From acb7814a563472df20c693256d3b614f344cadfe Mon Sep 17 00:00:00 2001
From: qanly97 <maqianli20@h-partners.com>
Date: Thu, 6 Nov 2025 16:16:53 +0800
Subject: [PATCH 1/7] =?UTF-8?q?=E9=87=8D=E5=91=BD=E5=90=8D=20faiss=20->=20?=
 =?UTF-8?q?knowherefaiss?=
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

---
 CMakeLists.txt                                |   2 +-
 benchmark/hdf5/benchmark_binary.cpp           |   2 +-
 benchmark/hdf5/benchmark_binary_range.cpp     |   2 +-
 benchmark/hdf5/benchmark_float.cpp            |   2 +-
 benchmark/hdf5/benchmark_float_bitset.cpp     |   2 +-
 benchmark/hdf5/benchmark_float_range.cpp      |   2 +-
 .../hdf5/benchmark_float_range_bitset.cpp     |   2 +-
 cmake/libs/libascend.cmake                    |  31 +
 cmake/libs/libfaiss.cmake                     |  78 +--
 include/knowhere/bitsetview_idselector.h      |  10 +-
 include/knowhere/comp/index_param.h           |   4 +
 include/knowhere/dataset.h                    |  17 +
 include/knowhere/expected.h                   |   1 +
 src/common/ascend/ascend_exception.h          |  60 ++
 src/common/ascend/ascend_utils.cc             |  80 +++
 src/common/ascend/ascend_utils.h              |  50 ++
 src/common/comp/brute_force.cc                | 175 +++--
 src/common/comp/knowhere_config.cc            |  58 +-
 src/common/metric.h                           |  24 +-
 src/common/utils.cc                           |  24 +-
 src/index/ascend/ascendflat.cc                | 451 +++++++++++++
 src/index/ascend/ascendflat_config.h          |  23 +
 src/index/ascend/flatint8.cc                  | 456 +++++++++++++
 src/index/ascend/flatint8_config.h            |  23 +
 .../data_view_dense_index.h                   |  68 +-
 .../data_view_index_config.h                  |   2 +-
 .../index_node_with_data_view_refiner.h       |   4 +-
 .../data_view_dense_index/refine_computer.h   | 114 ++--
 src/index/flat/flat.cc                        | 104 +--
 src/index/gpu/flat_gpu/flat_gpu.cc            |  26 +-
 src/index/gpu/gpu_res_mgr.h                   |  10 +-
 src/index/gpu/ivf_gpu/ivf_gpu.cc              |  82 +--
 src/index/hnsw/faiss_hnsw.cc                  | 346 +++++-----
 src/index/hnsw/impl/DummyVisitor.h            |   4 +-
 src/index/hnsw/impl/FederVisitor.h            |   4 +-
 src/index/hnsw/impl/IndexBruteForceWrapper.cc |  86 +--
 src/index/hnsw/impl/IndexBruteForceWrapper.h  |  16 +-
 .../hnsw/impl/IndexConditionalWrapper.cc      |  34 +-
 src/index/hnsw/impl/IndexConditionalWrapper.h |  10 +-
 src/index/hnsw/impl/IndexHNSWWrapper.cc       | 128 ++--
 src/index/hnsw/impl/IndexHNSWWrapper.h        |  20 +-
 src/index/hnsw/impl/IndexWrapperCosine.cc     |  12 +-
 src/index/hnsw/impl/IndexWrapperCosine.h      |  12 +-
 src/index/index_factory.cc                    |   2 +-
 src/index/ivf/ivf.cc                          | 412 ++++++------
 src/index/ivf/ivf_config.h                    |   4 +-
 src/index/ivf/ivfrbq_wrapper.cc               |  92 +--
 src/index/ivf/ivfrbq_wrapper.h                |  60 +-
 src/index/minhash/minhash_lsh.h               |  18 +-
 src/index/minhash/minhash_util.cc             |  26 +-
 src/index/minhash/minhash_util.h              |   8 +-
 src/index/refine/refine_utils.cc              |  54 +-
 src/index/refine/refine_utils.h               |  12 +-
 src/io/memory_io.h                            |   6 +-
 src/simd/distances_avx.cc                     |   6 +-
 src/simd/distances_avx.h                      |   4 +-
 src/simd/distances_avx512.cc                  |   6 +-
 src/simd/distances_avx512.h                   |   4 +-
 src/simd/distances_avx512icx.cc               |   4 +-
 src/simd/distances_avx512icx.h                |   4 +-
 src/simd/distances_neon.cc                    |   4 +-
 src/simd/distances_neon.h                     |   4 +-
 src/simd/distances_powerpc.cc                 |   4 +-
 src/simd/distances_powerpc.h                  |   4 +-
 src/simd/distances_ref.cc                     |   4 +-
 src/simd/distances_ref.h                      |   4 +-
 src/simd/distances_rvv.cc                     |   4 +-
 src/simd/distances_rvv.h                      |   4 +-
 src/simd/distances_sse.cc                     |   6 +-
 src/simd/distances_sse.h                      |   4 +-
 src/simd/distances_sve.cc                     |   6 +-
 src/simd/distances_sve.h                      |   4 +-
 src/simd/hook.cc                              |   8 +-
 src/simd/hook.h                               |   4 +-
 src/simd/instruction_set.h                    |   4 +-
 tests/faiss/CMakeLists.txt                    |  66 +-
 tests/ut/test_bruteforce.cc                   |   6 +-
 tests/ut/test_cluster.cc                      |   2 +-
 tests/ut/test_data_view_index.cc              |   8 +-
 tests/ut/test_distances.cc                    |  16 +-
 tests/ut/test_get_vector.cc                   |   2 +-
 tests/ut/test_index_node.cc                   |   2 +-
 tests/ut/test_iterator.cc                     |   4 +-
 tests/ut/test_ivfflat_cc.cc                   |   8 +-
 tests/ut/test_range_util.cc                   |   4 +-
 tests/ut/test_search.cc                       |  12 +-
 tests/ut/test_simd.cc                         | 322 +++++-----
 tests/ut/test_type.cc                         |   8 +-
 thirdparty/DiskANN/src/distance.cpp           |  24 +-
 thirdparty/faiss/.circleci/config.yml         |   2 +-
 .../.github/actions/build_cmake/action.yml    |  12 +-
 .../.github/workflows/update-doxygen.yml      |   2 +-
 thirdparty/faiss/.gitignore                   |  18 +-
 thirdparty/faiss/INSTALL.md                   |   6 +-
 thirdparty/faiss/benchs/bench_6bit_codec.cpp  |  10 +-
 .../benchs/bench_cppcontrib_sa_decode.cpp     | 162 ++---
 .../faiss/benchs/bench_hamming_computer.cpp   |  46 +-
 .../faiss/benchs/bench_heap_replace.cpp       |  10 +-
 .../faiss/benchs/bench_hnsw_knowhere.cpp      |  48 +-
 .../faiss/benchs/bench_ivf_selector.cpp       |  64 +-
 thirdparty/faiss/c_api/AutoTune_c.cpp         |   8 +-
 thirdparty/faiss/c_api/CMakeLists.txt         |   2 +-
 thirdparty/faiss/c_api/Clustering_c.cpp       |  14 +-
 thirdparty/faiss/c_api/IndexFlat_c.cpp        |  20 +-
 thirdparty/faiss/c_api/IndexIVFFlat_c.cpp     |   8 +-
 thirdparty/faiss/c_api/IndexIVF_c.cpp         |  10 +-
 thirdparty/faiss/c_api/IndexLSH_c.cpp         |   6 +-
 .../faiss/c_api/IndexPreTransform_c.cpp       |  10 +-
 thirdparty/faiss/c_api/IndexReplicas_c.cpp    |   6 +-
 .../faiss/c_api/IndexScalarQuantizer_c.cpp    |  20 +-
 thirdparty/faiss/c_api/IndexShards_c.cpp      |   6 +-
 thirdparty/faiss/c_api/Index_c.cpp            |  30 +-
 thirdparty/faiss/c_api/MetaIndexes_c.cpp      |   8 +-
 thirdparty/faiss/c_api/VectorTransform_c.cpp  |  30 +-
 thirdparty/faiss/c_api/clone_index_c.cpp      |  10 +-
 thirdparty/faiss/c_api/clone_index_c.h        |   4 +-
 thirdparty/faiss/c_api/error_impl.cpp         |   2 +-
 thirdparty/faiss/c_api/gpu/DeviceUtils_c.cpp  |  10 +-
 thirdparty/faiss/c_api/gpu/GpuAutoTune_c.cpp  |  28 +-
 .../faiss/c_api/gpu/GpuClonerOptions_c.cpp    |   8 +-
 thirdparty/faiss/c_api/gpu/GpuIndex_c.cpp     |   4 +-
 thirdparty/faiss/c_api/gpu/GpuResources_c.cpp |   6 +-
 .../c_api/gpu/StandardGpuResources_c.cpp      |   4 +-
 thirdparty/faiss/c_api/gpu/macros_impl.h      |   8 +-
 .../faiss/c_api/impl/AuxIndexStructures_c.cpp |  18 +-
 thirdparty/faiss/c_api/index_factory_c.cpp    |  10 +-
 thirdparty/faiss/c_api/index_io_c.cpp         |  12 +-
 thirdparty/faiss/c_api/index_io_c.h           |   8 +-
 thirdparty/faiss/c_api/macros_impl.h          |  24 +-
 thirdparty/faiss/c_api/utils/distances_c.cpp  |  34 +-
 .../faiss/conda/faiss-gpu-raft/build-pkg.sh   |   2 +-
 .../faiss/conda/faiss-gpu-raft/meta.yaml      |   8 +-
 thirdparty/faiss/conda/faiss-gpu/build-pkg.sh |   2 +-
 thirdparty/faiss/conda/faiss-gpu/meta.yaml    |   8 +-
 .../faiss/conda/faiss/build-pkg-arm64.sh      |   2 +-
 thirdparty/faiss/conda/faiss/build-pkg-osx.sh |   2 +-
 thirdparty/faiss/conda/faiss/build-pkg.bat    |   2 +-
 thirdparty/faiss/conda/faiss/build-pkg.sh     |   2 +-
 thirdparty/faiss/demos/demo_imi_flat.cpp      |  18 +-
 thirdparty/faiss/demos/demo_imi_pq.cpp        |  26 +-
 .../faiss/demos/demo_ivfpq_indexing.cpp       |  12 +-
 thirdparty/faiss/demos/demo_nndescent.cpp     |  12 +-
 .../faiss/demos/demo_residual_quantizer.cpp   |  56 +-
 thirdparty/faiss/demos/demo_sift1M.cpp        |  22 +-
 .../faiss/demos/demo_weighted_kmeans.cpp      |  22 +-
 .../rocksdb_ivf/RocksDBInvertedLists.cpp      |   4 +-
 .../demos/rocksdb_ivf/RocksDBInvertedLists.h  |  16 +-
 .../demos/rocksdb_ivf/demo_rocksdb_ivf.cpp    |  12 +-
 .../faiss/{faiss => knowherefaiss}/.flake8    |   0
 .../{faiss => knowherefaiss}/AutoTune.cpp     |  52 +-
 .../faiss/{faiss => knowherefaiss}/AutoTune.h |   8 +-
 .../{faiss => knowherefaiss}/CMakeLists.txt   |   8 +-
 .../{faiss => knowherefaiss}/Clustering.cpp   |  24 +-
 .../{faiss => knowherefaiss}/Clustering.h     |   8 +-
 .../{faiss => knowherefaiss}/FaissHook.cpp    |  14 +-
 .../{faiss => knowherefaiss}/FaissHook.h      |   8 +-
 .../faiss/{faiss => knowherefaiss}/IVFlib.cpp |  62 +-
 .../faiss/{faiss => knowherefaiss}/IVFlib.h   |   6 +-
 .../faiss/{faiss => knowherefaiss}/Index.cpp  |  16 +-
 .../faiss/{faiss => knowherefaiss}/Index.h    |   8 +-
 .../{faiss => knowherefaiss}/Index2Layer.cpp  |  22 +-
 .../{faiss => knowherefaiss}/Index2Layer.h    |  12 +-
 .../IndexAdditiveQuantizer.cpp                |  18 +-
 .../IndexAdditiveQuantizer.h                  |  16 +-
 .../IndexAdditiveQuantizerFastScan.cpp        |  20 +-
 .../IndexAdditiveQuantizerFastScan.h          |  14 +-
 .../{faiss => knowherefaiss}/IndexBinary.cpp  |   8 +-
 .../{faiss => knowherefaiss}/IndexBinary.h    |   6 +-
 .../IndexBinaryFlat.cpp                       |  20 +-
 .../IndexBinaryFlat.h                         |  10 +-
 .../IndexBinaryFromFloat.cpp                  |  10 +-
 .../IndexBinaryFromFloat.h                    |   6 +-
 .../IndexBinaryHNSW.cpp                       |  22 +-
 .../IndexBinaryHNSW.h                         |  10 +-
 .../IndexBinaryHash.cpp                       |  16 +-
 .../IndexBinaryHash.h                         |  12 +-
 .../IndexBinaryIVF.cpp                        |  22 +-
 .../{faiss => knowherefaiss}/IndexBinaryIVF.h |  12 +-
 .../{faiss => knowherefaiss}/IndexCosine.cpp  |  20 +-
 .../{faiss => knowherefaiss}/IndexCosine.h    |  14 +-
 .../IndexFastScan.cpp                         |  30 +-
 .../{faiss => knowherefaiss}/IndexFastScan.h  |   8 +-
 .../{faiss => knowherefaiss}/IndexFlat.cpp    |  26 +-
 .../{faiss => knowherefaiss}/IndexFlat.h      |   6 +-
 .../IndexFlatCodes.cpp                        |  16 +-
 .../{faiss => knowherefaiss}/IndexFlatCodes.h |  10 +-
 .../IndexFlatElkan.cpp                        |   8 +-
 .../{faiss => knowherefaiss}/IndexFlatElkan.h |   4 +-
 .../{faiss => knowherefaiss}/IndexHNSW.cpp    |  28 +-
 .../{faiss => knowherefaiss}/IndexHNSW.h      |  14 +-
 .../{faiss => knowherefaiss}/IndexIDMap.cpp   |  14 +-
 .../{faiss => knowherefaiss}/IndexIDMap.h     |  10 +-
 .../{faiss => knowherefaiss}/IndexIVF.cpp     |  20 +-
 .../faiss/{faiss => knowherefaiss}/IndexIVF.h |  18 +-
 .../IndexIVFAdditiveQuantizer.cpp             |  20 +-
 .../IndexIVFAdditiveQuantizer.h               |  16 +-
 .../IndexIVFAdditiveQuantizerFastScan.cpp     |  26 +-
 .../IndexIVFAdditiveQuantizerFastScan.h       |  14 +-
 .../IndexIVFFastScan.cpp                      |  28 +-
 .../IndexIVFFastScan.h                        |   8 +-
 .../{faiss => knowherefaiss}/IndexIVFFlat.cpp |  24 +-
 .../{faiss => knowherefaiss}/IndexIVFFlat.h   |   6 +-
 .../IndexIVFIndependentQuantizer.cpp          |  12 +-
 .../IndexIVFIndependentQuantizer.h            |   8 +-
 .../{faiss => knowherefaiss}/IndexIVFPQ.cpp   |  30 +-
 .../{faiss => knowherefaiss}/IndexIVFPQ.h     |  12 +-
 .../IndexIVFPQFastScan.cpp                    |  24 +-
 .../IndexIVFPQFastScan.h                      |  12 +-
 .../{faiss => knowherefaiss}/IndexIVFPQR.cpp  |  16 +-
 .../{faiss => knowherefaiss}/IndexIVFPQR.h    |   6 +-
 .../IndexIVFRaBitQ.cpp                        |  12 +-
 .../{faiss => knowherefaiss}/IndexIVFRaBitQ.h |  10 +-
 .../IndexIVFScalarQuantizerCC.cpp             |   6 +-
 .../IndexIVFScalarQuantizerCC.h               |   6 +-
 .../IndexIVFSpectralHash.cpp                  |  20 +-
 .../IndexIVFSpectralHash.h                    |   6 +-
 .../{faiss => knowherefaiss}/IndexLSH.cpp     |  16 +-
 .../faiss/{faiss => knowherefaiss}/IndexLSH.h |   8 +-
 .../{faiss => knowherefaiss}/IndexLattice.cpp |  12 +-
 .../{faiss => knowherefaiss}/IndexLattice.h   |   8 +-
 .../IndexNNDescent.cpp                        |  18 +-
 .../{faiss => knowherefaiss}/IndexNNDescent.h |  10 +-
 .../{faiss => knowherefaiss}/IndexNSG.cpp     |  18 +-
 .../faiss/{faiss => knowherefaiss}/IndexNSG.h |  16 +-
 .../{faiss => knowherefaiss}/IndexPQ.cpp      |  14 +-
 .../faiss/{faiss => knowherefaiss}/IndexPQ.h  |  12 +-
 .../IndexPQFastScan.cpp                       |  12 +-
 .../IndexPQFastScan.h                         |  12 +-
 .../IndexPreTransform.cpp                     |  12 +-
 .../IndexPreTransform.h                       |   8 +-
 .../{faiss => knowherefaiss}/IndexRaBitQ.cpp  |  10 +-
 .../{faiss => knowherefaiss}/IndexRaBitQ.h    |   8 +-
 .../{faiss => knowherefaiss}/IndexRefine.cpp  |  20 +-
 .../{faiss => knowherefaiss}/IndexRefine.h    |   6 +-
 .../IndexReplicas.cpp                         |  14 +-
 .../{faiss => knowherefaiss}/IndexReplicas.h  |  18 +-
 .../IndexRowwiseMinMax.cpp                    |  12 +-
 .../IndexRowwiseMinMax.h                      |   8 +-
 .../{faiss => knowherefaiss}/IndexScaNN.cpp   |  32 +-
 .../{faiss => knowherefaiss}/IndexScaNN.h     |   8 +-
 .../IndexScalarQuantizer.cpp                  |  16 +-
 .../IndexScalarQuantizer.h                    |  12 +-
 .../{faiss => knowherefaiss}/IndexShards.cpp  |  12 +-
 .../{faiss => knowherefaiss}/IndexShards.h    |  10 +-
 .../IndexShardsIVF.cpp                        |  14 +-
 .../{faiss => knowherefaiss}/IndexShardsIVF.h |   8 +-
 .../{faiss => knowherefaiss}/MatrixStats.cpp  |   8 +-
 .../{faiss => knowherefaiss}/MatrixStats.h    |   4 +-
 .../{faiss => knowherefaiss}/MetaIndexes.cpp  |  20 +-
 .../{faiss => knowherefaiss}/MetaIndexes.h    |  12 +-
 .../{faiss => knowherefaiss}/MetricType.h     |   8 +-
 .../VectorTransform.cpp                       |  16 +-
 .../VectorTransform.h                         |   6 +-
 .../{faiss => knowherefaiss}/clone_index.cpp  |  80 +--
 .../{faiss => knowherefaiss}/clone_index.h    |   4 +-
 .../cppcontrib/SaDecodeKernels.h              |  32 +-
 .../cppcontrib/detail/CoarseBitType.h         |   4 +-
 .../cppcontrib/detail/UintReader.h            |   6 +-
 .../knowhere/IndexBruteForceWrapper.cpp       |  20 +-
 .../knowhere/IndexBruteForceWrapper.h         |   6 +-
 .../cppcontrib/knowhere/IndexHNSWWrapper.cpp  |  20 +-
 .../cppcontrib/knowhere/IndexHNSWWrapper.h    |   6 +-
 .../cppcontrib/knowhere/IndexWrapper.cpp      |   4 +-
 .../cppcontrib/knowhere/IndexWrapper.h        |   4 +-
 .../cppcontrib/knowhere/impl/Bruteforce.h     |   8 +-
 .../knowhere/impl/CountSizeIOWriter.h         |   4 +-
 .../cppcontrib/knowhere/impl/HnswSearcher.h   |  72 +--
 .../cppcontrib/knowhere/impl/Neighbor.h       |   2 +-
 .../cppcontrib/knowhere/utils/Bitset.h        |   2 +-
 .../cppcontrib/sa_decode/Level2-avx2-inl.h    |   6 +-
 .../cppcontrib/sa_decode/Level2-inl.h         |   8 +-
 .../cppcontrib/sa_decode/Level2-neon-inl.h    |   6 +-
 .../cppcontrib/sa_decode/MinMax-inl.h         |   4 +-
 .../cppcontrib/sa_decode/MinMaxFP16-inl.h     | 102 +--
 .../cppcontrib/sa_decode/PQ-avx2-inl.h        |   6 +-
 .../cppcontrib/sa_decode/PQ-inl.h             |   4 +-
 .../cppcontrib/sa_decode/PQ-neon-inl.h        |   6 +-
 .../gpu/CMakeLists.txt                        |   2 +-
 .../gpu/GpuAutoTune.cpp                       |  28 +-
 .../gpu/GpuAutoTune.h                         |  14 +-
 .../gpu/GpuCloner.cpp                         |  90 +--
 .../{faiss => knowherefaiss}/gpu/GpuCloner.h  |  32 +-
 .../gpu/GpuClonerOptions.cpp                  |   6 +-
 .../gpu/GpuClonerOptions.h                    |   6 +-
 .../gpu/GpuDistance.cu                        |  24 +-
 .../gpu/GpuDistance.h                         |  12 +-
 .../gpu/GpuFaissAssert.h                      |   2 +-
 .../gpu/GpuIcmEncoder.cu                      |  12 +-
 .../gpu/GpuIcmEncoder.h                       |   6 +-
 .../{faiss => knowherefaiss}/gpu/GpuIndex.cu  |  22 +-
 .../{faiss => knowherefaiss}/gpu/GpuIndex.h   |  16 +-
 .../gpu/GpuIndexBinaryFlat.cu                 |  32 +-
 .../gpu/GpuIndexBinaryFlat.h                  |  28 +-
 .../gpu/GpuIndexFlat.cu                       |  58 +-
 .../gpu/GpuIndexFlat.h                        |  56 +-
 .../gpu/GpuIndexIVF.cu                        |  60 +-
 .../gpu/GpuIndexIVF.h                         |  22 +-
 .../gpu/GpuIndexIVFFlat.cu                    |  32 +-
 .../gpu/GpuIndexIVFFlat.h                     |  20 +-
 .../gpu/GpuIndexIVFPQ.cu                      |  34 +-
 .../gpu/GpuIndexIVFPQ.h                       |  20 +-
 .../gpu/GpuIndexIVFScalarQuantizer.cu         |  30 +-
 .../gpu/GpuIndexIVFScalarQuantizer.h          |  24 +-
 .../gpu/GpuIndexThreadSafe.cu                 |  16 +-
 .../gpu/GpuIndicesOptions.h                   |   4 +-
 .../gpu/GpuResources.cpp                      |   8 +-
 .../gpu/GpuResources.h                        |   6 +-
 .../gpu/StandardGpuResources.cpp              |  12 +-
 .../gpu/StandardGpuResources.h                |  10 +-
 .../gpu/impl/BinaryDistance.cu                |  12 +-
 .../gpu/impl/BinaryDistance.cuh               |   6 +-
 .../gpu/impl/BinaryFlatIndex.cu               |  12 +-
 .../gpu/impl/BinaryFlatIndex.cuh              |   8 +-
 .../gpu/impl/BroadcastSum.cu                  |  14 +-
 .../gpu/impl/BroadcastSum.cuh                 |   6 +-
 .../gpu/impl/Distance.cu                      |  30 +-
 .../gpu/impl/Distance.cuh                     |  58 +-
 .../gpu/impl/DistanceUtils.cuh                |   6 +-
 .../gpu/impl/FlatIndex.cu                     |  26 +-
 .../gpu/impl/FlatIndex.cuh                    |  16 +-
 .../gpu/impl/GeneralDistance.cuh              |  22 +-
 .../gpu/impl/GpuScalarQuantizer.cuh           |  18 +-
 .../gpu/impl/IVFAppend.cu                     |  24 +-
 .../gpu/impl/IVFAppend.cuh                    |  10 +-
 .../gpu/impl/IVFBase.cu                       |  26 +-
 .../gpu/impl/IVFBase.cuh                      |  20 +-
 .../gpu/impl/IVFFlat.cu                       |  38 +-
 .../gpu/impl/IVFFlat.cuh                      |  12 +-
 .../gpu/impl/IVFFlatScan.cu                   |  38 +-
 .../gpu/impl/IVFFlatScan.cuh                  |  14 +-
 .../gpu/impl/IVFInterleaved.cu                |  10 +-
 .../gpu/impl/IVFInterleaved.cuh               |  42 +-
 .../gpu/impl/IVFPQ.cu                         |  46 +-
 .../gpu/impl/IVFPQ.cuh                        |  14 +-
 .../gpu/impl/IVFUtils.cu                      |  14 +-
 .../gpu/impl/IVFUtils.cuh                     |  10 +-
 .../gpu/impl/IVFUtilsSelect1.cu               |  18 +-
 .../gpu/impl/IVFUtilsSelect2.cu               |  18 +-
 .../gpu/impl/IcmEncoder.cu                    |  26 +-
 .../gpu/impl/IcmEncoder.cuh                   |   8 +-
 .../gpu/impl/InterleavedCodes.cpp             |  10 +-
 .../gpu/impl/InterleavedCodes.h               |   4 +-
 .../gpu/impl/L2Norm.cu                        |  24 +-
 .../gpu/impl/L2Norm.cuh                       |   6 +-
 .../gpu/impl/L2Select.cu                      |  28 +-
 .../gpu/impl/L2Select.cuh                     |   6 +-
 .../gpu/impl/PQCodeDistances-inl.cuh          |  28 +-
 .../gpu/impl/PQCodeDistances.cuh              |  10 +-
 .../gpu/impl/PQCodeLoad.cuh                   |   6 +-
 .../impl/PQScanMultiPassNoPrecomputed-inl.cuh |  36 +-
 .../gpu/impl/PQScanMultiPassNoPrecomputed.cuh |  16 +-
 .../gpu/impl/PQScanMultiPassPrecomputed.cu    |  28 +-
 .../gpu/impl/PQScanMultiPassPrecomputed.cuh   |  12 +-
 .../gpu/impl/RemapIndices.cpp                 |   8 +-
 .../gpu/impl/RemapIndices.h                   |   6 +-
 .../gpu/impl/VectorResidual.cu                |  16 +-
 .../gpu/impl/VectorResidual.cuh               |   6 +-
 .../gpu/impl/scan/IVFInterleaved1.cu          |   6 +-
 .../gpu/impl/scan/IVFInterleaved1024.cu       |   6 +-
 .../gpu/impl/scan/IVFInterleaved128.cu        |   6 +-
 .../gpu/impl/scan/IVFInterleaved2048.cu       |   6 +-
 .../gpu/impl/scan/IVFInterleaved256.cu        |   6 +-
 .../gpu/impl/scan/IVFInterleaved32.cu         |   6 +-
 .../gpu/impl/scan/IVFInterleaved512.cu        |   6 +-
 .../gpu/impl/scan/IVFInterleaved64.cu         |   6 +-
 .../gpu/impl/scan/IVFInterleavedImpl.cuh      |  12 +-
 .../gpu/perf/IndexWrapper-inl.h               |  16 +-
 .../gpu/perf/IndexWrapper.h                   |  16 +-
 .../gpu/perf/PerfBinaryFlat.cu                |  38 +-
 .../gpu/perf/PerfClustering.cpp               |  38 +-
 .../gpu/perf/PerfFlat.cu                      |  46 +-
 .../gpu/perf/PerfIVFFlat.cu                   |  50 +-
 .../gpu/perf/PerfIVFPQ.cu                     |  50 +-
 .../gpu/perf/PerfIVFPQAdd.cpp                 |  36 +-
 .../gpu/perf/PerfSelect.cu                    |  20 +-
 .../gpu/perf/WriteIndex.cpp                   |  34 +-
 .../{faiss => knowherefaiss}/gpu/perf/slow.py |   0
 .../gpu/test/CMakeLists.txt                   |   0
 .../gpu/test/TestCodePacking.cpp              |  14 +-
 .../gpu/test/TestGpuDistance.cu               |  56 +-
 .../gpu/test/TestGpuIndexBinaryFlat.cpp       |  48 +-
 .../gpu/test/TestGpuIndexFlat.cpp             | 120 ++--
 .../gpu/test/TestGpuIndexIVFFlat.cpp          | 228 +++----
 .../gpu/test/TestGpuIndexIVFPQ.cpp            | 254 ++++----
 .../test/TestGpuIndexIVFScalarQuantizer.cpp   |  72 +--
 .../gpu/test/TestGpuMemoryException.cpp       |  32 +-
 .../gpu/test/TestGpuSelect.cu                 |  62 +-
 .../gpu/test/TestUtils.cpp                    |  38 +-
 .../gpu/test/TestUtils.h                      |  28 +-
 .../gpu/test/demo_ivfpq_indexing_gpu.cpp      |  20 +-
 .../gpu/test/test_contrib.py                  |   0
 .../gpu/test/test_gpu_basics.py               |   0
 .../gpu/test/test_gpu_index.py                |   0
 .../gpu/test/test_gpu_index_ivfsq.py          |   0
 .../gpu/test/torch_test_contrib_gpu.py        |   0
 .../gpu/utils/BlockSelectFloat.cu             |   8 +-
 .../gpu/utils/BlockSelectImpl.cuh             |   4 +-
 .../gpu/utils/BlockSelectKernel.cuh           |   6 +-
 .../gpu/utils/Comparators.cuh                 |   6 +-
 .../gpu/utils/ConversionOperators.cuh         |  10 +-
 .../gpu/utils/CopyUtils.cuh                   |   8 +-
 .../gpu/utils/DeviceDefs.cuh                  |   4 +-
 .../gpu/utils/DeviceTensor-inl.cuh            |   4 +-
 .../gpu/utils/DeviceTensor.cuh                |  10 +-
 .../gpu/utils/DeviceUtils.cu                  |  10 +-
 .../gpu/utils/DeviceUtils.h                   |   6 +-
 .../gpu/utils/DeviceVector.cuh                |  12 +-
 .../gpu/utils/Float16.cuh                     |   8 +-
 .../gpu/utils/HostTensor-inl.cuh              |   4 +-
 .../gpu/utils/HostTensor.cuh                  |   8 +-
 .../gpu/utils/Limits.cuh                      |   6 +-
 .../gpu/utils/LoadStoreOperators.cuh          |   6 +-
 .../gpu/utils/MathOperators.cuh               |   8 +-
 .../gpu/utils/MatrixMult-inl.cuh              |  12 +-
 .../gpu/utils/MatrixMult.cuh                  |  14 +-
 .../gpu/utils/MergeNetworkBlock.cuh           |  18 +-
 .../gpu/utils/MergeNetworkUtils.cuh           |   4 +-
 .../gpu/utils/MergeNetworkWarp.cuh            |  14 +-
 .../gpu/utils/NoTypeTensor.cuh                |   8 +-
 .../gpu/utils/Pair.cuh                        |   8 +-
 .../gpu/utils/PtxUtils.cuh                    |   4 +-
 .../gpu/utils/ReductionOperators.cuh          |  10 +-
 .../gpu/utils/Reductions.cuh                  |  14 +-
 .../gpu/utils/Select.cuh                      |  22 +-
 .../gpu/utils/StackDeviceMemory.cpp           |  12 +-
 .../gpu/utils/StackDeviceMemory.h             |   6 +-
 .../gpu/utils/StaticUtils.h                   |   4 +-
 .../gpu/utils/Tensor-inl.cuh                  |   8 +-
 .../gpu/utils/Tensor.cuh                      |   6 +-
 .../gpu/utils/ThrustAllocator.cuh             |   6 +-
 .../gpu/utils/Timer.cpp                       |  10 +-
 .../gpu/utils/Timer.h                         |   4 +-
 .../gpu/utils/Transpose.cuh                   |  12 +-
 .../gpu/utils/WarpPackedBits.cuh              |   8 +-
 .../gpu/utils/WarpSelectFloat.cu              |   8 +-
 .../gpu/utils/WarpSelectKernel.cuh            |   6 +-
 .../gpu/utils/WarpShuffles.cuh                |   6 +-
 .../utils/blockselect/BlockSelectFloat1.cu    |   6 +-
 .../utils/blockselect/BlockSelectFloat128.cu  |   6 +-
 .../utils/blockselect/BlockSelectFloat256.cu  |   6 +-
 .../utils/blockselect/BlockSelectFloat32.cu   |   6 +-
 .../utils/blockselect/BlockSelectFloat64.cu   |   6 +-
 .../blockselect/BlockSelectFloatF1024.cu      |   6 +-
 .../blockselect/BlockSelectFloatF2048.cu      |   8 +-
 .../utils/blockselect/BlockSelectFloatF512.cu |   6 +-
 .../blockselect/BlockSelectFloatT1024.cu      |   6 +-
 .../blockselect/BlockSelectFloatT2048.cu      |   8 +-
 .../utils/blockselect/BlockSelectFloatT512.cu |   6 +-
 .../gpu/utils/blockselect/BlockSelectImpl.cuh |   4 +-
 .../gpu/utils/warpselect/WarpSelectFloat1.cu  |   6 +-
 .../utils/warpselect/WarpSelectFloat128.cu    |   6 +-
 .../utils/warpselect/WarpSelectFloat256.cu    |   6 +-
 .../gpu/utils/warpselect/WarpSelectFloat32.cu |   6 +-
 .../gpu/utils/warpselect/WarpSelectFloat64.cu |   6 +-
 .../utils/warpselect/WarpSelectFloatF1024.cu  |   6 +-
 .../utils/warpselect/WarpSelectFloatF2048.cu  |   8 +-
 .../utils/warpselect/WarpSelectFloatF512.cu   |   6 +-
 .../utils/warpselect/WarpSelectFloatT1024.cu  |   6 +-
 .../utils/warpselect/WarpSelectFloatT2048.cu  |   8 +-
 .../utils/warpselect/WarpSelectFloatT512.cu   |   6 +-
 .../gpu/utils/warpselect/WarpSelectImpl.cuh   |   4 +-
 .../impl/AdditiveQuantizer.cpp                |  24 +-
 .../impl/AdditiveQuantizer.h                  |  10 +-
 .../impl/AuxIndexStructures.cpp               |  12 +-
 .../impl/AuxIndexStructures.h                 |   8 +-
 .../impl/CodePacker.cpp                       |   6 +-
 .../impl/CodePacker.h                         |   6 +-
 .../impl/DistanceComputer.h                   |   6 +-
 .../impl/FaissAssert.h                        |   8 +-
 .../impl/FaissException.cpp                   |   6 +-
 .../impl/FaissException.h                     |   4 +-
 .../{faiss => knowherefaiss}/impl/HNSW.cpp    |  30 +-
 .../{faiss => knowherefaiss}/impl/HNSW.h      |  20 +-
 .../impl/IDSelector.cpp                       |   8 +-
 .../impl/IDSelector.h                         |   6 +-
 .../impl/LocalSearchQuantizer.cpp             |  22 +-
 .../impl/LocalSearchQuantizer.h               |  10 +-
 .../impl/LookupTableScaler.h                  |   6 +-
 .../impl/NNDescent.cpp                        |  10 +-
 .../{faiss => knowherefaiss}/impl/NNDescent.h |  14 +-
 .../{faiss => knowherefaiss}/impl/NSG.cpp     |   8 +-
 .../faiss/{faiss => knowherefaiss}/impl/NSG.h |  14 +-
 .../impl/PolysemousTraining.cpp               |  16 +-
 .../impl/PolysemousTraining.h                 |   6 +-
 .../impl/ProductAdditiveQuantizer.cpp         |  18 +-
 .../impl/ProductAdditiveQuantizer.h           |  12 +-
 .../impl/ProductQuantizer-inl.h               |   4 +-
 .../impl/ProductQuantizer.cpp                 |  28 +-
 .../impl/ProductQuantizer.h                   |  14 +-
 .../{faiss => knowherefaiss}/impl/Quantizer.h |   4 +-
 .../{faiss => knowherefaiss}/impl/RHNSW.cpp   |  12 +-
 .../{faiss => knowherefaiss}/impl/RHNSW.h     |  20 +-
 .../impl/RaBitQuantizer.cpp                   |  14 +-
 .../impl/RaBitQuantizer.h                     |  10 +-
 .../impl/ResidualQuantizer.cpp                |  20 +-
 .../impl/ResidualQuantizer.h                  |  10 +-
 .../impl/ResultHandler.h                      |  18 +-
 .../impl/ScalarQuantizer.cpp                  |  24 +-
 .../impl/ScalarQuantizer.h                    |  10 +-
 .../impl/ScalarQuantizerCodec.h               |  18 +-
 .../impl/ScalarQuantizerCodec_avx.h           |  10 +-
 .../impl/ScalarQuantizerCodec_avx512.h        |  10 +-
 .../impl/ScalarQuantizerCodec_neon.h          |  10 +-
 .../impl/ScalarQuantizerDC.cpp                |   8 +-
 .../impl/ScalarQuantizerDC.h                  |   8 +-
 .../impl/ScalarQuantizerDC_avx.cpp            |   8 +-
 .../impl/ScalarQuantizerDC_avx.h              |   8 +-
 .../impl/ScalarQuantizerDC_avx512.cpp         |   8 +-
 .../impl/ScalarQuantizerDC_avx512.h           |   8 +-
 .../impl/ScalarQuantizerDC_neon.cpp           |   8 +-
 .../impl/ScalarQuantizerDC_neon.h             |   8 +-
 .../impl/ScalarQuantizerOp.cpp                |  10 +-
 .../impl/ScalarQuantizerOp.h                  |   6 +-
 .../impl/ScalarQuantizerScanner.h             |   8 +-
 .../impl/ThreadedIndex-inl.h                  |   6 +-
 .../impl/ThreadedIndex.h                      |  14 +-
 .../impl/code_distance/code_distance-avx2.h   |   8 +-
 .../impl/code_distance/code_distance-avx512.h |   8 +-
 .../code_distance/code_distance-generic.h     |   4 +-
 .../impl/code_distance/code_distance.h        |  14 +-
 .../impl/index_read.cpp                       | 102 +--
 .../impl/index_write.cpp                      |  98 +--
 .../{faiss => knowherefaiss}/impl/io.cpp      |   8 +-
 .../faiss/{faiss => knowherefaiss}/impl/io.h  |   4 +-
 .../{faiss => knowherefaiss}/impl/io_macros.h |   2 +-
 .../impl/kmeans1d.cpp                         |  10 +-
 .../{faiss => knowherefaiss}/impl/kmeans1d.h  |   6 +-
 .../impl/lattice_Zn.cpp                       |  10 +-
 .../impl/lattice_Zn.h                         |   4 +-
 .../impl/mapped_io.cpp                        |   8 +-
 .../{faiss => knowherefaiss}/impl/mapped_io.h |   8 +-
 .../impl/maybe_owned_vector.h                 |   8 +-
 .../impl/platform_macros.h                    |   0
 .../impl/pq4_fast_scan.cpp                    |  10 +-
 .../impl/pq4_fast_scan.h                      |   6 +-
 .../impl/pq4_fast_scan_search_1.cpp           |  12 +-
 .../impl/pq4_fast_scan_search_qbs.cpp         |  14 +-
 .../impl/residual_quantizer_encode_steps.cpp  |  22 +-
 .../impl/residual_quantizer_encode_steps.h    |   8 +-
 .../impl/simd_result_handlers.h               |  20 +-
 .../impl/zerocopy_io.cpp                      |   6 +-
 .../impl/zerocopy_io.h                        |   8 +-
 .../index_factory.cpp                         |  80 +--
 .../{faiss => knowherefaiss}/index_factory.h  |   8 +-
 .../faiss/{faiss => knowherefaiss}/index_io.h |   6 +-
 .../invlists/BlockInvertedLists.cpp           |  16 +-
 .../invlists/BlockInvertedLists.h             |  12 +-
 .../invlists/DirectMap.cpp                    |  14 +-
 .../invlists/DirectMap.h                      |  10 +-
 .../invlists/InvertedLists.cpp                |  18 +-
 .../invlists/InvertedLists.h                  |  10 +-
 .../invlists/InvertedListsIOHook.cpp          |  16 +-
 .../invlists/InvertedListsIOHook.h            |   8 +-
 .../invlists/OnDiskInvertedLists.cpp          |  14 +-
 .../invlists/OnDiskInvertedLists.h            |  10 +-
 .../python/CMakeLists.txt                     |  16 +-
 .../python/__init__.py                        |   0
 .../{faiss => knowherefaiss}/python/loader.py |   0
 .../python/python_callbacks.cpp               |   4 +-
 .../python/python_callbacks.h                 |   8 +-
 .../{faiss => knowherefaiss}/python/setup.py  |  30 +-
 .../python/swigfaiss.swig                     | 598 +++++++++---------
 .../utils/AlignedTable.h                      |   6 +-
 .../{faiss => knowherefaiss}/utils/Heap.cpp   |   8 +-
 .../{faiss => knowherefaiss}/utils/Heap.h     |   6 +-
 .../utils/WorkerThread.cpp                    |   8 +-
 .../utils/WorkerThread.h                      |   4 +-
 .../utils/approx_topk/approx_topk.h           |   8 +-
 .../utils/approx_topk/avx2-inl.h              |   8 +-
 .../utils/approx_topk/generic.h               |   8 +-
 .../utils/approx_topk/mode.h                  |   0
 .../approx_topk_hamming/approx_topk_hamming.h |  12 +-
 .../{faiss => knowherefaiss}/utils/bf16.h     |   4 +-
 .../utils/binary_distances.cpp                |  46 +-
 .../utils/binary_distances.h                  |  10 +-
 .../utils/bit_table.cpp                       |   2 +-
 .../utils/data_backup_file.cpp                |   6 +-
 .../utils/data_backup_file.h                  |   6 +-
 .../utils/distances.cpp                       |  20 +-
 .../utils/distances.h                         |   8 +-
 .../utils/distances_fused/avx512.cpp          |   6 +-
 .../utils/distances_fused/avx512.h            |  10 +-
 .../utils/distances_fused/distances_fused.cpp |  12 +-
 .../utils/distances_fused/distances_fused.h   |   8 +-
 .../utils/distances_fused/simdlib_based.cpp   |   8 +-
 .../utils/distances_fused/simdlib_based.h     |  10 +-
 .../utils/distances_if.h                      |   8 +-
 .../utils/distances_simd.cpp                  |  12 +-
 .../utils/distances_typed.cpp                 | 104 +--
 .../utils/distances_typed.h                   |   6 +-
 .../utils/extra_distances-inl.h               |  10 +-
 .../utils/extra_distances.cpp                 |  16 +-
 .../utils/extra_distances.h                   |  10 +-
 .../{faiss => knowherefaiss}/utils/fp16-arm.h |   4 +-
 .../utils/fp16-fp16c.h                        |   4 +-
 .../{faiss => knowherefaiss}/utils/fp16-inl.h |   4 +-
 .../{faiss => knowherefaiss}/utils/fp16.h     |   8 +-
 .../utils/hamming-inl.h                       |   6 +-
 .../utils/hamming.cpp                         |  54 +-
 .../{faiss => knowherefaiss}/utils/hamming.h  |  14 +-
 .../utils/hamming_distance/avx2-inl.h         |   6 +-
 .../utils/hamming_distance/common.h           |   6 +-
 .../utils/hamming_distance/generic-inl.h      |   6 +-
 .../utils/hamming_distance/hamdis-inl.h       |  12 +-
 .../utils/hamming_distance/neon-inl.h         |  10 +-
 .../utils/jaccard-inl.h                       |   8 +-
 .../utils/ordered_key_value.h                 |   4 +-
 .../utils/partitioning.cpp                    |  16 +-
 .../utils/partitioning.h                      |   6 +-
 .../utils/partitioning_avx2.cpp               |  16 +-
 .../{faiss => knowherefaiss}/utils/prefetch.h |   0
 .../utils/quantize_lut.cpp                    |   8 +-
 .../utils/quantize_lut.h                      |   4 +-
 .../{faiss => knowherefaiss}/utils/random.cpp |   6 +-
 .../{faiss => knowherefaiss}/utils/random.h   |   4 +-
 .../{faiss => knowherefaiss}/utils/simdlib.h  |  12 +-
 .../utils/simdlib_avx2.h                      |   6 +-
 .../utils/simdlib_avx512.h                    |   8 +-
 .../utils/simdlib_emulated.h                  |   4 +-
 .../utils/simdlib_neon.h                      |   6 +-
 .../utils/simdlib_ppc64.h                     |   4 +-
 .../utils/sorting.cpp                         |  10 +-
 .../{faiss => knowherefaiss}/utils/sorting.h  |   6 +-
 .../utils/structure-inl.h                     |   4 +-
 .../utils/transpose/transpose-avx2-inl.h      |   4 +-
 .../{faiss => knowherefaiss}/utils/utils.cpp  |  14 +-
 .../{faiss => knowherefaiss}/utils/utils.h    |   8 +-
 thirdparty/faiss/tests/test_RCQ_cropping.cpp  |  32 +-
 thirdparty/faiss/tests/test_approx_topk.cpp   |  12 +-
 thirdparty/faiss/tests/test_binary_flat.cpp   |  10 +-
 thirdparty/faiss/tests/test_callback.cpp      |  22 +-
 thirdparty/faiss/tests/test_code_distance.cpp |  16 +-
 .../tests/test_common_ivf_empty_index.cpp     |  46 +-
 .../faiss/tests/test_cppcontrib_sa_decode.cpp | 188 +++---
 .../tests/test_cppcontrib_uintreader.cpp      |  14 +-
 .../faiss/tests/test_dealloc_invlists.cpp     |  12 +-
 .../tests/test_disable_pq_sdc_tables.cpp      |  30 +-
 thirdparty/faiss/tests/test_distances_if.cpp  |  12 +-
 .../faiss/tests/test_distances_simd.cpp       |  12 +-
 thirdparty/faiss/tests/test_fastscan_perf.cpp |  16 +-
 thirdparty/faiss/tests/test_heap.cpp          |   4 +-
 thirdparty/faiss/tests/test_hnsw.cpp          |  16 +-
 thirdparty/faiss/tests/test_ivf_index.cpp     |  50 +-
 thirdparty/faiss/tests/test_ivfpq_codec.cpp   |  16 +-
 .../faiss/tests/test_ivfpq_indexing.cpp       |  16 +-
 thirdparty/faiss/tests/test_lowlevel_ivf.cpp  |  20 +-
 thirdparty/faiss/tests/test_mem_leak.cpp      |  10 +-
 thirdparty/faiss/tests/test_merge.cpp         |  68 +-
 thirdparty/faiss/tests/test_omp_threads.cpp   |   4 +-
 thirdparty/faiss/tests/test_ondisk_ivf.cpp    |  44 +-
 .../faiss/tests/test_pairs_decoding.cpp       |  24 +-
 .../faiss/tests/test_params_override.cpp      |  20 +-
 thirdparty/faiss/tests/test_partitioning.cpp  |   6 +-
 thirdparty/faiss/tests/test_pq_encoding.cpp   |  26 +-
 thirdparty/faiss/tests/test_simdlib.cpp       |   4 +-
 thirdparty/faiss/tests/test_sliding_ivf.cpp   |  14 +-
 .../faiss/tests/test_threaded_index.cpp       |  32 +-
 .../faiss/tests/test_transfer_invlists.cpp    |  22 +-
 thirdparty/faiss/tests/test_util.h            |   2 +-
 thirdparty/faiss/tutorial/cpp/1-Flat.cpp      |   6 +-
 thirdparty/faiss/tutorial/cpp/2-IVFFlat.cpp   |  10 +-
 thirdparty/faiss/tutorial/cpp/3-IVFPQ.cpp     |  10 +-
 thirdparty/faiss/tutorial/cpp/4-GPU.cpp       |  14 +-
 .../faiss/tutorial/cpp/5-Multiple-GPUs.cpp    |  24 +-
 thirdparty/faiss/tutorial/cpp/6-HNSW.cpp      |   6 +-
 .../faiss/tutorial/cpp/7-PQFastScan.cpp       |   6 +-
 .../faiss/tutorial/cpp/8-PQFastScanRefine.cpp |  14 +-
 .../faiss/tutorial/cpp/9-RefineComparison.cpp |  22 +-
 thirdparty/hnswlib/hnswlib/space_cosine.h     |   8 +-
 thirdparty/hnswlib/hnswlib/space_hamming.h    |   4 +-
 thirdparty/hnswlib/hnswlib/space_ip.h         |   8 +-
 thirdparty/hnswlib/hnswlib/space_jaccard.h    |   4 +-
 thirdparty/hnswlib/hnswlib/space_l2.h         |  14 +-
 673 files changed, 7574 insertions(+), 6313 deletions(-)
 create mode 100644 cmake/libs/libascend.cmake
 create mode 100644 src/common/ascend/ascend_exception.h
 create mode 100644 src/common/ascend/ascend_utils.cc
 create mode 100644 src/common/ascend/ascend_utils.h
 create mode 100644 src/index/ascend/ascendflat.cc
 create mode 100644 src/index/ascend/ascendflat_config.h
 create mode 100644 src/index/ascend/flatint8.cc
 create mode 100644 src/index/ascend/flatint8_config.h
 rename thirdparty/faiss/{faiss => knowherefaiss}/.flake8 (100%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/AutoTune.cpp (95%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/AutoTune.h (97%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/CMakeLists.txt (98%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/Clustering.cpp (98%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/Clustering.h (98%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/FaissHook.cpp (83%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/FaissHook.h (86%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/IVFlib.cpp (90%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/IVFlib.h (98%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/Index.cpp (93%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/Index.h (98%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/Index2Layer.cpp (95%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/Index2Layer.h (89%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/IndexAdditiveQuantizer.cpp (98%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/IndexAdditiveQuantizer.h (95%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/IndexAdditiveQuantizerFastScan.cpp (95%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/IndexAdditiveQuantizerFastScan.h (95%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/IndexBinary.cpp (95%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/IndexBinary.h (98%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/IndexBinaryFlat.cpp (92%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/IndexBinaryFlat.h (90%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/IndexBinaryFromFloat.cpp (91%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/IndexBinaryFromFloat.h (92%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/IndexBinaryHNSW.cpp (94%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/IndexBinaryHNSW.h (87%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/IndexBinaryHash.cpp (97%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/IndexBinaryHash.h (92%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/IndexBinaryIVF.cpp (98%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/IndexBinaryIVF.h (97%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/IndexCosine.cpp (96%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/IndexCosine.h (95%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/IndexFastScan.cpp (96%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/IndexFastScan.h (96%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/IndexFlat.cpp (97%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/IndexFlat.h (97%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/IndexFlatCodes.cpp (90%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/IndexFlatCodes.h (90%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/IndexFlatElkan.cpp (94%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/IndexFlatElkan.h (97%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/IndexHNSW.cpp (97%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/IndexHNSW.h (95%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/IndexIDMap.cpp (96%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/IndexIDMap.h (95%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/IndexIVF.cpp (99%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/IndexIVF.h (98%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/IndexIVFAdditiveQuantizer.cpp (96%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/IndexIVFAdditiveQuantizer.h (94%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/IndexIVFAdditiveQuantizerFastScan.cpp (96%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/IndexIVFAdditiveQuantizerFastScan.h (93%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/IndexIVFFastScan.cpp (98%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/IndexIVFFastScan.h (98%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/IndexIVFFlat.cpp (98%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/IndexIVFFlat.h (97%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/IndexIVFIndependentQuantizer.cpp (95%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/IndexIVFIndependentQuantizer.h (90%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/IndexIVFPQ.cpp (98%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/IndexIVFPQ.h (96%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/IndexIVFPQFastScan.cpp (94%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/IndexIVFPQFastScan.h (92%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/IndexIVFPQR.cpp (95%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/IndexIVFPQR.h (95%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/IndexIVFRaBitQ.cpp (97%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/IndexIVFRaBitQ.h (90%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/IndexIVFScalarQuantizerCC.cpp (97%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/IndexIVFScalarQuantizerCC.h (92%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/IndexIVFSpectralHash.cpp (96%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/IndexIVFSpectralHash.h (96%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/IndexLSH.cpp (94%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/IndexLSH.h (93%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/IndexLattice.cpp (93%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/IndexLattice.h (91%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/IndexNNDescent.cpp (93%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/IndexNNDescent.h (90%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/IndexNSG.cpp (96%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/IndexNSG.h (89%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/IndexPQ.cpp (99%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/IndexPQ.h (95%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/IndexPQFastScan.cpp (87%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/IndexPQFastScan.h (87%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/IndexPreTransform.cpp (97%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/IndexPreTransform.h (95%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/IndexRaBitQ.cpp (95%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/IndexRaBitQ.h (91%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/IndexRefine.cpp (96%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/IndexRefine.h (96%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/IndexReplicas.cpp (94%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/IndexReplicas.h (87%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/IndexRowwiseMinMax.cpp (98%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/IndexRowwiseMinMax.h (95%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/IndexScaNN.cpp (91%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/IndexScaNN.h (91%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/IndexScalarQuantizer.cpp (96%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/IndexScalarQuantizer.h (92%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/IndexShards.cpp (96%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/IndexShards.h (95%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/IndexShardsIVF.cpp (96%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/IndexShardsIVF.h (88%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/MatrixStats.cpp (98%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/MatrixStats.h (96%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/MetaIndexes.cpp (94%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/MetaIndexes.h (89%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/MetricType.h (94%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/VectorTransform.cpp (99%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/VectorTransform.h (99%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/clone_index.cpp (89%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/clone_index.h (94%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/cppcontrib/SaDecodeKernels.h (91%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/cppcontrib/detail/CoarseBitType.h (90%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/cppcontrib/detail/UintReader.h (99%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/cppcontrib/knowhere/IndexBruteForceWrapper.cpp (93%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/cppcontrib/knowhere/IndexBruteForceWrapper.h (91%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/cppcontrib/knowhere/IndexHNSWWrapper.cpp (95%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/cppcontrib/knowhere/IndexHNSWWrapper.h (93%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/cppcontrib/knowhere/IndexWrapper.cpp (95%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/cppcontrib/knowhere/IndexWrapper.h (96%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/cppcontrib/knowhere/impl/Bruteforce.h (94%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/cppcontrib/knowhere/impl/CountSizeIOWriter.h (94%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/cppcontrib/knowhere/impl/HnswSearcher.h (90%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/cppcontrib/knowhere/impl/Neighbor.h (99%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/cppcontrib/knowhere/utils/Bitset.h (99%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/cppcontrib/sa_decode/Level2-avx2-inl.h (99%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/cppcontrib/sa_decode/Level2-inl.h (99%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/cppcontrib/sa_decode/Level2-neon-inl.h (99%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/cppcontrib/sa_decode/MinMax-inl.h (99%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/cppcontrib/sa_decode/MinMaxFP16-inl.h (79%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/cppcontrib/sa_decode/PQ-avx2-inl.h (99%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/cppcontrib/sa_decode/PQ-inl.h (99%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/cppcontrib/sa_decode/PQ-neon-inl.h (99%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/CMakeLists.txt (98%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/GpuAutoTune.cpp (77%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/GpuAutoTune.h (63%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/GpuCloner.cpp (85%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/GpuCloner.h (74%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/GpuClonerOptions.cpp (86%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/GpuClonerOptions.h (92%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/GpuDistance.cu (94%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/GpuDistance.h (95%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/GpuFaissAssert.h (93%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/GpuIcmEncoder.cu (93%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/GpuIcmEncoder.h (92%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/GpuIndex.cu (97%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/GpuIndex.h (94%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/GpuIndexBinaryFlat.cu (91%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/GpuIndexBinaryFlat.h (76%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/GpuIndexFlat.cu (89%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/GpuIndexFlat.h (81%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/GpuIndexIVF.cu (83%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/GpuIndexIVF.h (84%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/GpuIndexIVFFlat.cu (92%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/GpuIndexIVFFlat.h (88%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/GpuIndexIVFPQ.cu (94%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/GpuIndexIVFPQ.h (92%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/GpuIndexIVFScalarQuantizer.cu (93%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/GpuIndexIVFScalarQuantizer.h (86%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/GpuIndexThreadSafe.cu (96%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/GpuIndicesOptions.h (94%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/GpuResources.cpp (96%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/GpuResources.h (98%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/StandardGpuResources.cpp (98%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/StandardGpuResources.h (97%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/impl/BinaryDistance.cu (97%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/impl/BinaryDistance.cuh (84%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/impl/BinaryFlatIndex.cu (88%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/impl/BinaryFlatIndex.cuh (90%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/impl/BroadcastSum.cu (97%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/impl/BroadcastSum.cuh (92%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/impl/Distance.cu (96%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/impl/Distance.cuh (86%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/impl/DistanceUtils.cuh (98%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/impl/FlatIndex.cu (94%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/impl/FlatIndex.cuh (91%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/impl/GeneralDistance.cuh (96%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/impl/GpuScalarQuantizer.cuh (98%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/impl/IVFAppend.cu (97%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/impl/IVFAppend.cuh (92%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/impl/IVFBase.cu (97%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/impl/IVFBase.cuh (95%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/impl/IVFFlat.cu (90%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/impl/IVFFlat.cuh (91%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/impl/IVFFlatScan.cu (95%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/impl/IVFFlatScan.cuh (76%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/impl/IVFInterleaved.cu (97%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/impl/IVFInterleaved.cuh (95%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/impl/IVFPQ.cu (95%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/impl/IVFPQ.cuh (95%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/impl/IVFUtils.cu (89%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/impl/IVFUtils.cuh (95%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/impl/IVFUtilsSelect1.cu (94%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/impl/IVFUtilsSelect2.cu (94%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/impl/IcmEncoder.cu (95%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/impl/IcmEncoder.cuh (92%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/impl/InterleavedCodes.cpp (98%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/impl/InterleavedCodes.h (96%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/impl/L2Norm.cu (95%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/impl/L2Norm.cuh (85%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/impl/L2Select.cu (94%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/impl/L2Select.cuh (83%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/impl/PQCodeDistances-inl.cuh (97%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/impl/PQCodeDistances.cuh (81%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/impl/PQCodeLoad.cuh (99%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/impl/PQScanMultiPassNoPrecomputed-inl.cuh (97%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/impl/PQScanMultiPassNoPrecomputed.cuh (78%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/impl/PQScanMultiPassPrecomputed.cu (97%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/impl/PQScanMultiPassPrecomputed.cuh (83%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/impl/RemapIndices.cpp (88%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/impl/RemapIndices.h (86%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/impl/VectorResidual.cu (92%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/impl/VectorResidual.cuh (91%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/impl/scan/IVFInterleaved1.cu (67%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/impl/scan/IVFInterleaved1024.cu (67%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/impl/scan/IVFInterleaved128.cu (67%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/impl/scan/IVFInterleaved2048.cu (72%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/impl/scan/IVFInterleaved256.cu (67%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/impl/scan/IVFInterleaved32.cu (67%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/impl/scan/IVFInterleaved512.cu (67%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/impl/scan/IVFInterleaved64.cu (67%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/impl/scan/IVFInterleavedImpl.cuh (92%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/perf/IndexWrapper-inl.h (75%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/perf/IndexWrapper.h (67%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/perf/PerfBinaryFlat.cu (72%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/perf/PerfClustering.cpp (73%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/perf/PerfFlat.cu (73%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/perf/PerfIVFFlat.cu (71%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/perf/PerfIVFPQ.cu (72%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/perf/PerfIVFPQAdd.cpp (82%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/perf/PerfSelect.cu (79%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/perf/WriteIndex.cpp (76%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/perf/slow.py (100%)
 mode change 100755 => 100644
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/test/CMakeLists.txt (100%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/test/TestCodePacking.cpp (97%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/test/TestGpuDistance.cu (70%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/test/TestGpuIndexBinaryFlat.cpp (64%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/test/TestGpuIndexFlat.cpp (68%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/test/TestGpuIndexIVFFlat.cpp (61%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/test/TestGpuIndexIVFPQ.cpp (69%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/test/TestGpuIndexIVFScalarQuantizer.cpp (71%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/test/TestGpuMemoryException.cpp (70%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/test/TestGpuSelect.cu (74%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/test/TestUtils.cpp (90%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/test/TestUtils.h (83%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/test/demo_ivfpq_indexing_gpu.cpp (87%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/test/test_contrib.py (100%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/test/test_gpu_basics.py (100%)
 mode change 100755 => 100644
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/test/test_gpu_index.py (100%)
 mode change 100755 => 100644
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/test/test_gpu_index_ivfsq.py (100%)
 mode change 100755 => 100644
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/test/torch_test_contrib_gpu.py (100%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/utils/BlockSelectFloat.cu (96%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/utils/BlockSelectImpl.cuh (98%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/utils/BlockSelectKernel.cuh (98%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/utils/Comparators.cuh (89%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/utils/ConversionOperators.cuh (94%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/utils/CopyUtils.cuh (95%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/utils/DeviceDefs.cuh (95%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/utils/DeviceTensor-inl.cuh (99%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/utils/DeviceTensor.cuh (93%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/utils/DeviceUtils.cu (96%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/utils/DeviceUtils.h (98%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/utils/DeviceVector.cuh (96%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/utils/Float16.cuh (89%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/utils/HostTensor-inl.cuh (99%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/utils/HostTensor.cuh (94%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/utils/Limits.cuh (94%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/utils/LoadStoreOperators.cuh (96%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/utils/MathOperators.cuh (98%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/utils/MatrixMult-inl.cuh (97%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/utils/MatrixMult.cuh (79%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/utils/MergeNetworkBlock.cuh (96%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/utils/MergeNetworkUtils.cuh (89%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/utils/MergeNetworkWarp.cuh (98%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/utils/NoTypeTensor.cuh (95%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/utils/Pair.cuh (91%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/utils/PtxUtils.cuh (97%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/utils/ReductionOperators.cuh (88%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/utils/Reductions.cuh (91%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/utils/Select.cuh (97%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/utils/StackDeviceMemory.cpp (95%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/utils/StackDeviceMemory.h (96%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/utils/StaticUtils.h (97%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/utils/Tensor-inl.cuh (99%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/utils/Tensor.cuh (99%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/utils/ThrustAllocator.cuh (95%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/utils/Timer.cpp (86%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/utils/Timer.h (95%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/utils/Transpose.cuh (96%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/utils/WarpPackedBits.cuh (98%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/utils/WarpSelectFloat.cu (93%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/utils/WarpSelectKernel.cuh (94%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/utils/WarpShuffles.cuh (96%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/utils/blockselect/BlockSelectFloat1.cu (71%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/utils/blockselect/BlockSelectFloat128.cu (71%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/utils/blockselect/BlockSelectFloat256.cu (71%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/utils/blockselect/BlockSelectFloat32.cu (71%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/utils/blockselect/BlockSelectFloat64.cu (71%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/utils/blockselect/BlockSelectFloatF1024.cu (67%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/utils/blockselect/BlockSelectFloatF2048.cu (64%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/utils/blockselect/BlockSelectFloatF512.cu (67%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/utils/blockselect/BlockSelectFloatT1024.cu (67%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/utils/blockselect/BlockSelectFloatT2048.cu (64%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/utils/blockselect/BlockSelectFloatT512.cu (67%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/utils/blockselect/BlockSelectImpl.cuh (98%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/utils/warpselect/WarpSelectFloat1.cu (71%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/utils/warpselect/WarpSelectFloat128.cu (71%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/utils/warpselect/WarpSelectFloat256.cu (71%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/utils/warpselect/WarpSelectFloat32.cu (71%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/utils/warpselect/WarpSelectFloat64.cu (71%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/utils/warpselect/WarpSelectFloatF1024.cu (67%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/utils/warpselect/WarpSelectFloatF2048.cu (64%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/utils/warpselect/WarpSelectFloatF512.cu (67%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/utils/warpselect/WarpSelectFloatT1024.cu (67%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/utils/warpselect/WarpSelectFloatT2048.cu (64%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/utils/warpselect/WarpSelectFloatT512.cu (67%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/gpu/utils/warpselect/WarpSelectImpl.cuh (96%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/impl/AdditiveQuantizer.cpp (97%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/impl/AdditiveQuantizer.h (97%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/impl/AuxIndexStructures.cpp (96%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/impl/AuxIndexStructures.h (97%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/impl/CodePacker.cpp (94%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/impl/CodePacker.h (96%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/impl/DistanceComputer.h (97%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/impl/FaissAssert.h (94%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/impl/FaissException.cpp (96%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/impl/FaissException.h (96%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/impl/HNSW.cpp (97%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/impl/HNSW.h (94%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/impl/IDSelector.cpp (95%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/impl/IDSelector.h (98%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/impl/LocalSearchQuantizer.cpp (97%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/impl/LocalSearchQuantizer.h (97%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/impl/LookupTableScaler.h (95%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/impl/NNDescent.cpp (98%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/impl/NNDescent.h (93%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/impl/NSG.cpp (99%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/impl/NSG.h (95%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/impl/PolysemousTraining.cpp (98%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/impl/PolysemousTraining.h (97%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/impl/ProductAdditiveQuantizer.cpp (96%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/impl/ProductAdditiveQuantizer.h (94%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/impl/ProductQuantizer-inl.h (97%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/impl/ProductQuantizer.cpp (97%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/impl/ProductQuantizer.h (96%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/impl/Quantizer.h (95%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/impl/RHNSW.cpp (98%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/impl/RHNSW.h (95%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/impl/RaBitQuantizer.cpp (98%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/impl/RaBitQuantizer.h (93%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/impl/ResidualQuantizer.cpp (97%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/impl/ResidualQuantizer.h (96%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/impl/ResultHandler.h (98%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/impl/ScalarQuantizer.cpp (91%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/impl/ScalarQuantizer.h (95%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/impl/ScalarQuantizerCodec.h (98%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/impl/ScalarQuantizerCodec_avx.h (99%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/impl/ScalarQuantizerCodec_avx512.h (99%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/impl/ScalarQuantizerCodec_neon.h (99%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/impl/ScalarQuantizerDC.cpp (89%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/impl/ScalarQuantizerDC.h (85%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/impl/ScalarQuantizerDC_avx.cpp (92%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/impl/ScalarQuantizerDC_avx.h (85%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/impl/ScalarQuantizerDC_avx512.cpp (93%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/impl/ScalarQuantizerDC_avx512.h (85%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/impl/ScalarQuantizerDC_neon.cpp (92%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/impl/ScalarQuantizerDC_neon.h (85%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/impl/ScalarQuantizerOp.cpp (96%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/impl/ScalarQuantizerOp.h (84%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/impl/ScalarQuantizerScanner.h (98%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/impl/ThreadedIndex-inl.h (98%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/impl/ThreadedIndex.h (90%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/impl/code_distance/code_distance-avx2.h (98%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/impl/code_distance/code_distance-avx512.h (97%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/impl/code_distance/code_distance-generic.h (97%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/impl/code_distance/code_distance.h (92%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/impl/index_read.cpp (96%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/impl/index_write.cpp (95%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/impl/io.cpp (98%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/impl/io.h (98%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/impl/io_macros.h (98%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/impl/kmeans1d.cpp (97%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/impl/kmeans1d.h (93%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/impl/lattice_Zn.cpp (98%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/impl/lattice_Zn.h (98%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/impl/mapped_io.cpp (98%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/impl/mapped_io.h (90%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/impl/maybe_owned_vector.h (98%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/impl/platform_macros.h (100%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/impl/pq4_fast_scan.cpp (97%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/impl/pq4_fast_scan.h (98%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/impl/pq4_fast_scan_search_1.cpp (96%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/impl/pq4_fast_scan_search_qbs.cpp (97%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/impl/residual_quantizer_encode_steps.cpp (98%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/impl/residual_quantizer_encode_steps.h (97%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/impl/simd_result_handlers.h (98%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/impl/zerocopy_io.cpp (93%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/impl/zerocopy_io.h (80%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/index_factory.cpp (95%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/index_factory.h (83%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/index_io.h (97%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/invlists/BlockInvertedLists.cpp (93%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/invlists/BlockInvertedLists.h (91%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/invlists/DirectMap.cpp (97%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/invlists/DirectMap.h (95%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/invlists/InvertedLists.cpp (99%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/invlists/InvertedLists.h (99%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/invlists/InvertedListsIOHook.cpp (87%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/invlists/InvertedListsIOHook.h (93%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/invlists/OnDiskInvertedLists.cpp (98%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/invlists/OnDiskInvertedLists.h (96%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/python/CMakeLists.txt (95%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/python/__init__.py (100%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/python/loader.py (100%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/python/python_callbacks.cpp (96%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/python/python_callbacks.h (86%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/python/setup.py (69%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/python/swigfaiss.swig (57%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/utils/AlignedTable.h (97%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/utils/Heap.cpp (98%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/utils/Heap.h (99%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/utils/WorkerThread.cpp (94%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/utils/WorkerThread.h (96%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/utils/approx_topk/approx_topk.h (93%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/utils/approx_topk/avx2-inl.h (98%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/utils/approx_topk/generic.h (97%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/utils/approx_topk/mode.h (100%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/utils/approx_topk_hamming/approx_topk_hamming.h (98%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/utils/bf16.h (91%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/utils/binary_distances.cpp (94%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/utils/binary_distances.h (95%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/utils/bit_table.cpp (99%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/utils/data_backup_file.cpp (96%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/utils/data_backup_file.h (90%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/utils/distances.cpp (99%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/utils/distances.h (99%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/utils/distances_fused/avx512.cpp (99%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/utils/distances_fused/avx512.h (80%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/utils/distances_fused/distances_fused.cpp (75%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/utils/distances_fused/distances_fused.h (89%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/utils/distances_fused/simdlib_based.cpp (98%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/utils/distances_fused/simdlib_based.h (77%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/utils/distances_if.h (99%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/utils/distances_simd.cpp (95%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/utils/distances_typed.cpp (89%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/utils/distances_typed.h (97%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/utils/extra_distances-inl.h (96%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/utils/extra_distances.cpp (95%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/utils/extra_distances.h (87%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/utils/fp16-arm.h (92%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/utils/fp16-fp16c.h (91%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/utils/fp16-inl.h (98%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/utils/fp16.h (61%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/utils/hamming-inl.h (96%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/utils/hamming.cpp (93%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/utils/hamming.h (96%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/utils/hamming_distance/avx2-inl.h (99%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/utils/hamming_distance/common.h (94%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/utils/hamming_distance/generic-inl.h (99%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/utils/hamming_distance/hamdis-inl.h (89%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/utils/hamming_distance/neon-inl.h (98%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/utils/jaccard-inl.h (99%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/utils/ordered_key_value.h (97%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/utils/partitioning.cpp (98%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/utils/partitioning.h (95%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/utils/partitioning_avx2.cpp (96%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/utils/prefetch.h (100%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/utils/quantize_lut.cpp (98%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/utils/quantize_lut.h (97%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/utils/random.cpp (98%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/utils/random.h (97%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/utils/simdlib.h (71%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/utils/simdlib_avx2.h (99%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/utils/simdlib_avx512.h (98%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/utils/simdlib_emulated.h (99%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/utils/simdlib_neon.h (99%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/utils/simdlib_ppc64.h (99%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/utils/sorting.cpp (99%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/utils/sorting.h (96%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/utils/structure-inl.h (99%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/utils/transpose/transpose-avx2-inl.h (99%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/utils/utils.cpp (98%)
 rename thirdparty/faiss/{faiss => knowherefaiss}/utils/utils.h (98%)

diff --git a/CMakeLists.txt b/CMakeLists.txt
index b3652425..ca7cb909 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -179,7 +179,7 @@ include_directories(src)
 include_directories(include)
 
 list(APPEND KNOWHERE_LINKER_LIBS Boost::boost)
-list(APPEND KNOWHERE_LINKER_LIBS faiss)
+list(APPEND KNOWHERE_LINKER_LIBS knowherefaiss)
 list(APPEND KNOWHERE_LINKER_LIBS glog::glog)
 list(APPEND KNOWHERE_LINKER_LIBS nlohmann_json::nlohmann_json)
 list(APPEND KNOWHERE_LINKER_LIBS prometheus-cpp::core prometheus-cpp::push)
diff --git a/benchmark/hdf5/benchmark_binary.cpp b/benchmark/hdf5/benchmark_binary.cpp
index bdbeeaef..f61ece80 100644
--- a/benchmark/hdf5/benchmark_binary.cpp
+++ b/benchmark/hdf5/benchmark_binary.cpp
@@ -107,7 +107,7 @@ class Benchmark_binary : public Benchmark_knowhere, public ::testing::Test {
         knowhere::KnowhereConfig::SetSimdType(knowhere::KnowhereConfig::SimdType::AVX2);
         knowhere::KnowhereConfig::SetBuildThreadPoolSize(default_build_thread_num);
         knowhere::KnowhereConfig::SetSearchThreadPoolSize(default_search_thread_num);
-        printf("faiss::distance_compute_blas_threshold: %ld\n", knowhere::KnowhereConfig::GetBlasThreshold());
+        printf("knowherefaiss::distance_compute_blas_threshold: %ld\n", knowhere::KnowhereConfig::GetBlasThreshold());
     }
 
     void
diff --git a/benchmark/hdf5/benchmark_binary_range.cpp b/benchmark/hdf5/benchmark_binary_range.cpp
index 390f3e11..f6cc4a79 100644
--- a/benchmark/hdf5/benchmark_binary_range.cpp
+++ b/benchmark/hdf5/benchmark_binary_range.cpp
@@ -117,7 +117,7 @@ class Benchmark_binary_range : public Benchmark_knowhere, public ::testing::Test
         knowhere::KnowhereConfig::SetSimdType(knowhere::KnowhereConfig::SimdType::AVX2);
         knowhere::KnowhereConfig::SetBuildThreadPoolSize(default_build_thread_num);
         knowhere::KnowhereConfig::SetSearchThreadPoolSize(default_search_thread_num);
-        printf("faiss::distance_compute_blas_threshold: %ld\n", knowhere::KnowhereConfig::GetBlasThreshold());
+        printf("knowherefaiss::distance_compute_blas_threshold: %ld\n", knowhere::KnowhereConfig::GetBlasThreshold());
     }
 
     void
diff --git a/benchmark/hdf5/benchmark_float.cpp b/benchmark/hdf5/benchmark_float.cpp
index fe91c9fd..b74bdbd9 100644
--- a/benchmark/hdf5/benchmark_float.cpp
+++ b/benchmark/hdf5/benchmark_float.cpp
@@ -277,7 +277,7 @@ class Benchmark_float : public Benchmark_knowhere, public ::testing::Test {
         knowhere::KnowhereConfig::SetSimdType(knowhere::KnowhereConfig::SimdType::AVX2);
         knowhere::KnowhereConfig::SetBuildThreadPoolSize(default_build_thread_num);
         knowhere::KnowhereConfig::SetSearchThreadPoolSize(default_search_thread_num);
-        printf("faiss::distance_compute_blas_threshold: %ld\n", knowhere::KnowhereConfig::GetBlasThreshold());
+        printf("knowherefaiss::distance_compute_blas_threshold: %ld\n", knowhere::KnowhereConfig::GetBlasThreshold());
 
 #ifdef KNOWHERE_WITH_CUVS
         knowhere::KnowhereConfig::SetRaftMemPool();
diff --git a/benchmark/hdf5/benchmark_float_bitset.cpp b/benchmark/hdf5/benchmark_float_bitset.cpp
index a0b551fd..ba33c89e 100644
--- a/benchmark/hdf5/benchmark_float_bitset.cpp
+++ b/benchmark/hdf5/benchmark_float_bitset.cpp
@@ -141,7 +141,7 @@ class Benchmark_float_bitset : public Benchmark_knowhere, public ::testing::Test
         knowhere::KnowhereConfig::SetSimdType(knowhere::KnowhereConfig::SimdType::AVX2);
         knowhere::KnowhereConfig::SetBuildThreadPoolSize(default_build_thread_num);
         knowhere::KnowhereConfig::SetSearchThreadPoolSize(default_search_thread_num);
-        printf("faiss::distance_compute_blas_threshold: %ld\n", knowhere::KnowhereConfig::GetBlasThreshold());
+        printf("knowherefaiss::distance_compute_blas_threshold: %ld\n", knowhere::KnowhereConfig::GetBlasThreshold());
 
         create_golden_index(cfg_);
     }
diff --git a/benchmark/hdf5/benchmark_float_range.cpp b/benchmark/hdf5/benchmark_float_range.cpp
index f6fe808b..e9ca2d45 100644
--- a/benchmark/hdf5/benchmark_float_range.cpp
+++ b/benchmark/hdf5/benchmark_float_range.cpp
@@ -159,7 +159,7 @@ class Benchmark_float_range : public Benchmark_knowhere, public ::testing::Test
         knowhere::KnowhereConfig::SetSimdType(knowhere::KnowhereConfig::SimdType::AVX2);
         knowhere::KnowhereConfig::SetBuildThreadPoolSize(default_build_thread_num);
         knowhere::KnowhereConfig::SetSearchThreadPoolSize(default_search_thread_num);
-        printf("faiss::distance_compute_blas_threshold: %ld\n", knowhere::KnowhereConfig::GetBlasThreshold());
+        printf("knowherefaiss::distance_compute_blas_threshold: %ld\n", knowhere::KnowhereConfig::GetBlasThreshold());
     }
 
     void
diff --git a/benchmark/hdf5/benchmark_float_range_bitset.cpp b/benchmark/hdf5/benchmark_float_range_bitset.cpp
index a39c711a..8acfad0e 100644
--- a/benchmark/hdf5/benchmark_float_range_bitset.cpp
+++ b/benchmark/hdf5/benchmark_float_range_bitset.cpp
@@ -145,7 +145,7 @@ class Benchmark_float_range_bitset : public Benchmark_knowhere, public ::testing
         knowhere::KnowhereConfig::SetSimdType(knowhere::KnowhereConfig::SimdType::AVX2);
         knowhere::KnowhereConfig::SetBuildThreadPoolSize(default_build_thread_num);
         knowhere::KnowhereConfig::SetSearchThreadPoolSize(default_search_thread_num);
-        printf("faiss::distance_compute_blas_threshold: %ld\n", knowhere::KnowhereConfig::GetBlasThreshold());
+        printf("knowherefaiss::distance_compute_blas_threshold: %ld\n", knowhere::KnowhereConfig::GetBlasThreshold());
 
         create_golden_index(cfg_);
     }
diff --git a/cmake/libs/libascend.cmake b/cmake/libs/libascend.cmake
new file mode 100644
index 00000000..2862189f
--- /dev/null
+++ b/cmake/libs/libascend.cmake
@@ -0,0 +1,31 @@
+if(DEFINED ENV{ASCEND_DEPEND_FAISS_DIR})
+    message("ASCEND_DEPEND_FAISS_DIR: $ENV{ASCEND_DEPEND_FAISS_DIR}")
+else()
+    message(FATAL_ERROR "NOT DEFINED ASCEND_DEPEND_FAISS_DIR VARIABLES")
+endif()
+
+if(DEFINED ENV{MX_INDEX_HOME})
+    message("MX_INDEX_HOME: $ENV{MX_INDEX_HOME}")
+else()
+    message(FATAL_ERROR "NOT DEFINED MX_INDEX_HOME VARIABLES")
+endif()
+
+SET(ASCEND_HOME              /usr/local/Ascend          CACHE STRING   "")
+IF (NOT DEFINED ASCEND_TOOLKIT_PATH)
+    SET(ASCEND_TOOLKIT_PATH /usr/local/Ascend/ascend-toolkit/latest)
+ENDIF()
+
+include_directories(
+    $ENV{ASCEND_DEPEND_FAISS_DIR}/include/
+    ${ASCEND_TOOLKIT_PATH}/include
+    ${ASCEND_HOME}/driver/include/dvpp
+    $ENV{MX_INDEX_HOME}/mxIndex/include/
+)
+
+link_directories(
+    $ENV{ASCEND_DEPEND_FAISS_DIR}/lib/
+    ${ASCEND_TOOLKIT_PATH}/lib64
+    $ENV{MX_INDEX_HOME}/mxIndex/host/lib/
+)
+
+set(ASCEND_LIBS faiss ascendcl c_sec ock_hmm ascendsearch ascendfaiss)
diff --git a/cmake/libs/libfaiss.cmake b/cmake/libs/libfaiss.cmake
index 98dbef4a..481d93a7 100644
--- a/cmake/libs/libfaiss.cmake
+++ b/cmake/libs/libfaiss.cmake
@@ -1,29 +1,29 @@
 include(CheckCXXCompilerFlag)
 
 knowhere_file_glob(
-  GLOB FAISS_SRCS thirdparty/faiss/faiss/*.cpp
-  thirdparty/faiss/faiss/impl/*.cpp thirdparty/faiss/faiss/invlists/*.cpp
-  thirdparty/faiss/faiss/utils/*.cpp
-  thirdparty/faiss/faiss/cppcontrib/knowhere/*.cpp)
+  GLOB FAISS_SRCS thirdparty/faiss/knowherefaiss/*.cpp
+  thirdparty/faiss/knowherefaiss/impl/*.cpp thirdparty/faiss/faiss/invlists/*.cpp
+  thirdparty/faiss/knowherefaiss/utils/*.cpp
+  thirdparty/faiss/knowherefaiss/cppcontrib/knowhere/*.cpp)
 
 knowhere_file_glob(GLOB FAISS_AVX512_SRCS
-                   thirdparty/faiss/faiss/impl/*avx512.cpp)
+                   thirdparty/faiss/knowherefaiss/impl/*avx512.cpp)
 
 knowhere_file_glob(
   GLOB
   FAISS_AVX2_SRCS
-  thirdparty/faiss/faiss/impl/*avx.cpp
-  thirdparty/faiss/faiss/impl/pq4_fast_scan_search_1.cpp
-  thirdparty/faiss/faiss/impl/pq4_fast_scan_search_qbs.cpp
-  thirdparty/faiss/faiss/utils/partitioning_avx2.cpp
-  thirdparty/faiss/faiss/IndexPQFastScan.cpp
-  thirdparty/faiss/faiss/IndexIVFFastScan.cpp
-  thirdparty/faiss/faiss/IndexIVFPQFastScan.cpp)
+  thirdparty/faiss/knowherefaiss/impl/*avx.cpp
+  thirdparty/faiss/knowherefaiss/impl/pq4_fast_scan_search_1.cpp
+  thirdparty/faiss/knowherefaiss/impl/pq4_fast_scan_search_qbs.cpp
+  thirdparty/faiss/knowherefaiss/utils/partitioning_avx2.cpp
+  thirdparty/faiss/knowherefaiss/IndexPQFastScan.cpp
+  thirdparty/faiss/knowherefaiss/IndexIVFFastScan.cpp
+  thirdparty/faiss/knowherefaiss/IndexIVFPQFastScan.cpp)
 
 list(REMOVE_ITEM FAISS_SRCS ${FAISS_AVX512_SRCS})
 
 # disable RHNSW
-knowhere_file_glob(GLOB FAISS_RHNSW_SRCS thirdparty/faiss/faiss/impl/RHNSW.cpp)
+knowhere_file_glob(GLOB FAISS_RHNSW_SRCS thirdparty/faiss/knowherefaiss/impl/RHNSW.cpp)
 list(REMOVE_ITEM FAISS_SRCS ${FAISS_RHNSW_SRCS})
 
 if(__X86_64)
@@ -168,7 +168,7 @@ include_directories(${xxHash_INCLUDE_DIRS})
 if(__X86_64)
   list(REMOVE_ITEM FAISS_SRCS ${FAISS_AVX2_SRCS})
 
-  knowhere_file_glob(GLOB FAISS_NEON_SRCS thirdparty/faiss/faiss/impl/*neon.cpp)
+  knowhere_file_glob(GLOB FAISS_NEON_SRCS thirdparty/faiss/knowherefaiss/impl/*neon.cpp)
   list(REMOVE_ITEM FAISS_SRCS ${FAISS_NEON_SRCS})
 
   add_library(faiss_avx2 OBJECT ${FAISS_AVX2_SRCS})
@@ -188,11 +188,11 @@ if(__X86_64)
             -mavx512vl
             -mpopcnt>)
 
-  add_library(faiss STATIC ${FAISS_SRCS})
+  add_library(knowherefaiss STATIC ${FAISS_SRCS})
 
-  add_dependencies(faiss faiss_avx2 faiss_avx512 knowhere_utils)
+  add_dependencies(knowherefaiss faiss_avx2 faiss_avx512 knowhere_utils)
   target_compile_options(
-    faiss
+    knowherefaiss
     PRIVATE $<$<COMPILE_LANGUAGE:CXX>:
             -msse4.2
             -mpopcnt
@@ -203,19 +203,19 @@ if(__X86_64)
             -Wno-unused-function
             -Wno-strict-aliasing>)
   target_link_libraries(
-    faiss PUBLIC OpenMP::OpenMP_CXX ${BLAS_LIBRARIES} ${LAPACK_LIBRARIES}
+    knowherefaiss PUBLIC OpenMP::OpenMP_CXX ${BLAS_LIBRARIES} ${LAPACK_LIBRARIES}
                  faiss_avx2 faiss_avx512 knowhere_utils)
-  target_compile_definitions(faiss PRIVATE FINTEGER=int)
+  target_compile_definitions(knowherefaiss PRIVATE FINTEGER=int)
 endif()
 
 if(__AARCH64)
-  knowhere_file_glob(GLOB FAISS_AVX_SRCS thirdparty/faiss/faiss/impl/*avx.cpp)
+  knowhere_file_glob(GLOB FAISS_AVX_SRCS thirdparty/faiss/knowherefaiss/impl/*avx.cpp)
   list(REMOVE_ITEM FAISS_SRCS ${FAISS_AVX_SRCS})
 
-  add_library(faiss STATIC ${FAISS_SRCS})
+  add_library(knowherefaiss STATIC ${FAISS_SRCS})
 
   target_compile_options(
-    faiss
+    knowherefaiss
     PRIVATE $<$<COMPILE_LANGUAGE:CXX>:
             -Wno-sign-compare
             -Wno-unused-variable
@@ -224,23 +224,23 @@ if(__AARCH64)
             -Wno-unused-function
             -Wno-strict-aliasing>)
 
-  add_dependencies(faiss knowhere_utils)
-  target_link_libraries(faiss PUBLIC OpenMP::OpenMP_CXX ${BLAS_LIBRARIES} ${LAPACK_LIBRARIES}
+  add_dependencies(knowherefaiss knowhere_utils)
+  target_link_libraries(knowherefaiss PUBLIC OpenMP::OpenMP_CXX ${BLAS_LIBRARIES} ${LAPACK_LIBRARIES}
                                      knowhere_utils)
-  target_compile_definitions(faiss PRIVATE FINTEGER=int)
+  target_compile_definitions(knowherefaiss PRIVATE FINTEGER=int)
 endif()
 
 if(__RISCV64)
-  knowhere_file_glob(GLOB FAISS_AVX_SRCS thirdparty/faiss/faiss/impl/*avx.cpp)
+  knowhere_file_glob(GLOB FAISS_AVX_SRCS thirdparty/faiss/knowherefaiss/impl/*avx.cpp)
   list(REMOVE_ITEM FAISS_SRCS ${FAISS_AVX_SRCS})
 
-  knowhere_file_glob(GLOB FAISS_NEON_SRCS thirdparty/faiss/faiss/impl/*neon.cpp)
+  knowhere_file_glob(GLOB FAISS_NEON_SRCS thirdparty/faiss/knowherefaiss/impl/*neon.cpp)
   list(REMOVE_ITEM FAISS_SRCS ${FAISS_NEON_SRCS})
 
-  add_library(faiss STATIC ${FAISS_SRCS})
+  add_library(knowherefaiss STATIC ${FAISS_SRCS})
 
   target_compile_options(
-    faiss
+    knowherefaiss
     PRIVATE $<$<COMPILE_LANGUAGE:CXX>:
             -march=rv64gcv
             -mabi=lp64d
@@ -251,23 +251,23 @@ if(__RISCV64)
             -Wno-unused-function
             -Wno-strict-aliasing>)
 
-  add_dependencies(faiss knowhere_utils)
-  target_link_libraries(faiss PUBLIC OpenMP::OpenMP_CXX ${BLAS_LIBRARIES}
+  add_dependencies(knowherefaiss knowhere_utils)
+  target_link_libraries(knowherefaiss PUBLIC OpenMP::OpenMP_CXX ${BLAS_LIBRARIES}
                                      ${LAPACK_LIBRARIES} knowhere_utils)
-  target_compile_definitions(faiss PRIVATE FINTEGER=int)
+  target_compile_definitions(knowherefaiss PRIVATE FINTEGER=int)
 endif()
 
 if(__PPC64)
-  knowhere_file_glob(GLOB FAISS_AVX_SRCS thirdparty/faiss/faiss/impl/*avx.cpp)
+  knowhere_file_glob(GLOB FAISS_AVX_SRCS thirdparty/faiss/knowherefaiss/impl/*avx.cpp)
   list(REMOVE_ITEM FAISS_SRCS ${FAISS_AVX_SRCS})
 
-  knowhere_file_glob(GLOB FAISS_NEON_SRCS thirdparty/faiss/faiss/impl/*neon.cpp)
+  knowhere_file_glob(GLOB FAISS_NEON_SRCS thirdparty/faiss/knowherefaiss/impl/*neon.cpp)
   list(REMOVE_ITEM FAISS_SRCS ${FAISS_NEON_SRCS})
 
-  add_library(faiss STATIC ${FAISS_SRCS})
+  add_library(knowherefaiss STATIC ${FAISS_SRCS})
 
   target_compile_options(
-    faiss
+    knowherefaiss
     PRIVATE $<$<COMPILE_LANGUAGE:CXX>:
             -mcpu=native
             -mvsx
@@ -278,8 +278,8 @@ if(__PPC64)
             -Wno-unused-function
             -Wno-strict-aliasing>)
 
-  add_dependencies(faiss knowhere_utils)
-  target_link_libraries(faiss PUBLIC OpenMP::OpenMP_CXX ${BLAS_LIBRARIES} ${LAPACK_LIBRARIES}
+  add_dependencies(knowherefaiss knowhere_utils)
+  target_link_libraries(knowherefaiss PUBLIC OpenMP::OpenMP_CXX ${BLAS_LIBRARIES} ${LAPACK_LIBRARIES}
                                       knowhere_utils)
-  target_compile_definitions(faiss PRIVATE FINTEGER=int)
+  target_compile_definitions(knowherefaiss PRIVATE FINTEGER=int)
 endif()
diff --git a/include/knowhere/bitsetview_idselector.h b/include/knowhere/bitsetview_idselector.h
index 49531e0e..dbac4991 100644
--- a/include/knowhere/bitsetview_idselector.h
+++ b/include/knowhere/bitsetview_idselector.h
@@ -11,13 +11,13 @@
 
 #pragma once
 
-#include <faiss/impl/IDSelector.h>
+#include <knowherefaiss/impl/IDSelector.h>
 
 #include "knowhere/bitsetview.h"
 
 namespace knowhere {
 
-struct BitsetViewIDSelector final : faiss::IDSelector {
+struct BitsetViewIDSelector final : knowherefaiss::IDSelector {
     const BitsetView bitset_view;
     const size_t id_offset;
 
@@ -26,13 +26,13 @@ struct BitsetViewIDSelector final : faiss::IDSelector {
     }
 
     inline bool
-    is_member(faiss::idx_t id) const override final {
+    is_member(knowherefaiss::idx_t id) const override final {
         // it is by design that bitset_view.empty() is not tested here
         return (!bitset_view.test(id + id_offset));
     }
 };
 
-struct BitsetViewWithMappingIDSelector final : faiss::IDSelector {
+struct BitsetViewWithMappingIDSelector final : knowherefaiss::IDSelector {
     const BitsetView bitset_view;
     const uint32_t* out_id_mapping;
     const size_t id_offset;
@@ -43,7 +43,7 @@ struct BitsetViewWithMappingIDSelector final : faiss::IDSelector {
     }
 
     inline bool
-    is_member(faiss::idx_t id) const override final {
+    is_member(knowherefaiss::idx_t id) const override final {
         // it is by design that out_id_mapping == nullptr is not tested here
         return (!bitset_view.test(out_id_mapping[id + id_offset]));
     }
diff --git a/include/knowhere/comp/index_param.h b/include/knowhere/comp/index_param.h
index efde10af..4b67a832 100644
--- a/include/knowhere/comp/index_param.h
+++ b/include/knowhere/comp/index_param.h
@@ -62,6 +62,9 @@ constexpr const char* INDEX_SPARSE_INVERTED_INDEX = "SPARSE_INVERTED_INDEX";
 constexpr const char* INDEX_SPARSE_WAND = "SPARSE_WAND";
 constexpr const char* INDEX_SPARSE_INVERTED_INDEX_CC = "SPARSE_INVERTED_INDEX_CC";
 constexpr const char* INDEX_SPARSE_WAND_CC = "SPARSE_WAND_CC";
+
+constexpr const char* INDEX_ASCEND_FLAT_INT8 = "ASCEND_FLAT_INT8";
+constexpr const char* INDEX_ASCEND_FLAT = "ASCEND_FLAT";
 }  // namespace IndexEnum
 
 namespace ClusterEnum {
@@ -104,6 +107,7 @@ constexpr const char* MATERIALIZED_VIEW_OPT_FIELDS_PATH = "opt_fields_path";
 constexpr const char* MAX_EMPTY_RESULT_BUCKETS = "max_empty_result_buckets";
 constexpr const char* BM25_K1 = "bm25_k1";
 constexpr const char* BM25_B = "bm25_b";
+constexpr const char* ASCEND_INDEX_TYPE = "ascend_index_type";
 // average document length
 constexpr const char* BM25_AVGDL = "bm25_avgdl";
 constexpr const char* DIM_MAX_SCORE_RATIO = "dim_max_score_ratio";
diff --git a/include/knowhere/dataset.h b/include/knowhere/dataset.h
index 6bc6e61c..3704713b 100644
--- a/include/knowhere/dataset.h
+++ b/include/knowhere/dataset.h
@@ -160,6 +160,12 @@ class DataSet : public std::enable_shared_from_this<const DataSet> {
         this->data_[meta::JSON_ID_SET] = Var(std::in_place_index<5>, idset);
     }
 
+    void
+    SetAscendIndexType(const std::string& type) {
+        std::unique_lock lock(mutex_);
+        this->data_[meta::ASCEND_INDEX_TYPE] = Var(std::in_place_index<5>, type);
+    }
+
     const float*
     GetDistance() const {
         std::shared_lock lock(mutex_);
@@ -248,6 +254,17 @@ class DataSet : public std::enable_shared_from_this<const DataSet> {
         return "";
     }
 
+    std::string
+    GetAscendIndexType() const {
+        std::shared_lock lock(mutex_);
+        auto it = this->data_.find(meta::ASCEND_INDEX_TYPE);
+        if (it != this->data_.end()) {
+            std::string res = *std::get_if<5>(&it->second);
+            return res;
+        }
+        return "";
+    }
+
     void
     SetIsOwner(bool is_owner) {
         std::unique_lock lock(mutex_);
diff --git a/include/knowhere/expected.h b/include/knowhere/expected.h
index 9cd5aa3c..5c553c44 100644
--- a/include/knowhere/expected.h
+++ b/include/knowhere/expected.h
@@ -50,6 +50,7 @@ enum class Status {
     invalid_serialized_index_type = 28,
     sparse_inner_error = 29,
     brute_force_inner_error = 30,
+    ascend_inner_error = 31,
 };
 
 inline std::string
diff --git a/src/common/ascend/ascend_exception.h b/src/common/ascend/ascend_exception.h
new file mode 100644
index 00000000..c19dbc83
--- /dev/null
+++ b/src/common/ascend/ascend_exception.h
@@ -0,0 +1,60 @@
+#ifndef KNOWHERE_ASCEND_EXCEPTION
+#define KNOWHERE_ASCEND_EXCEPTION
+
+#include <exception>
+#include <string>
+#include <sstream>
+#include <securec.h>
+
+namespace knowhere {
+namespace ascend {
+class AscendException : public std::exception {
+public:
+    explicit AscendException(const std::string& msg): msg(msg) {}
+
+    AscendException(const std::string& msg,
+                    const char* funcName,
+                    const char* file,
+                    int line)
+    {
+        const int msgLen = 1024;
+        const int scaleSize = 2;
+        int size = msgLen;
+        this->msg.resize(size, '\0');
+        while (snprintf_s(&this->msg[0], this->msg.size(), this->msg.size(), "Error in %s at %s:%d: %s",
+            funcName, file, line, msg.c_str()) < 0) {
+            size = size * scaleSize;
+            this->msg.resize(size, '\0');
+        }
+    }
+
+    ~AscendException() = default;
+
+    const char* what() const noexcept override
+    {
+        return msg.c_str();
+    }
+
+private:
+    std::string msg;
+};
+} // namespace ascend
+}
+
+#define KNOWHERE_ASCEND_THROW_MSG(MSG)                                                                \
+    do {                                                                                          \
+        throw knowhere::ascend::AscendException(MSG, __PRETTY_FUNCTION__, __FILE__, __LINE__);        \
+    } while (false)
+
+#define KNOWHERE_ASCEND_THROW_FMT(FMT, ...)                                                           \
+    do {                                                                                          \
+        int size = 1024;                                                                          \
+        std::string __s(size, '\0');                                                              \
+        while (snprintf_s(&__s[0], __s.size(), __s.size(), FMT, __VA_ARGS__) < 0) {               \
+            size = size * 2;                                                                      \
+            __s.resize(size, '\0');                                                               \
+        }                                                                                         \
+        throw knowhere::ascend::AscendException(__s, __PRETTY_FUNCTION__, __FILE__, __LINE__);        \
+    } while (false)
+
+#endif
\ No newline at end of file
diff --git a/src/common/ascend/ascend_utils.cc b/src/common/ascend/ascend_utils.cc
new file mode 100644
index 00000000..e0c9c512
--- /dev/null
+++ b/src/common/ascend/ascend_utils.cc
@@ -0,0 +1,80 @@
+#include "acl/acl.h"
+#include "ascend_utils.h"
+
+namespace knowhere {
+namespace ascend {
+int
+ascend_device_manager::random_choose() const {
+    srand(time(NULL));
+    int device_id = rand() % memory_load_.size();
+    LOG_KNOWHERE_INFO_ << "random_choose device: " << device_id;
+    return device_id;
+}
+
+int
+ascend_device_manager::choose_with_load(size_t load) {
+    std::lock_guard<std::mutex> lock(mtx_);
+
+    auto it = std::min_element(memory_load_.begin(), memory_load_.end());
+    *it += load;
+    int device_id = std::distance(memory_load_.begin(), it);
+    LOG_KNOWHERE_INFO_ << "min choose_with_load device: " << device_id << ", load:" << load;
+    return device_id;
+}
+
+void
+ascend_device_manager::release_load(int device_id, size_t load) {
+    if (size_t(device_id) < memory_load_.size()) {
+        std::lock_guard<std::mutex> lock(mtx_);
+        memory_load_[device_id] -= load;
+        LOG_KNOWHERE_INFO_ << "release_load device: " << device_id << ", load:" << load;
+    } else {
+        LOG_KNOWHERE_WARNING_ << "please check device id " << device_id;
+    }
+}
+
+ascend_device_manager::ascend_device_manager() {}
+
+void ascend_device_manager::init() {
+    std::lock_guard<std::mutex> lock(mtx_);
+    if (inited_.load()) {
+        return;
+    }
+
+    uint32_t device_counts;
+    auto ret = aclrtGetDeviceCount(&device_counts);
+    if (ret != ACL_SUCCESS) {
+        LOG_KNOWHERE_FATAL_ << "failed to get Ascend Device count!";
+        KNOWHERE_ASCEND_THROW_MSG("failed to get Ascend Device count!");
+    }
+    memory_load_.resize(device_counts);
+    std::fill(memory_load_.begin(), memory_load_.end(), 0);
+
+    device_mutex_ptres.resize(device_counts);
+    for (uint32_t dev = 0; dev < device_counts; dev++) {
+        device_mutex_ptres[dev] = new std::mutex();
+    }
+
+    inited_.store(true);
+}
+
+std::mutex* ascend_device_manager::get_dev_mutex_ptr(int32_t device_id) {
+    if (device_id < 0 || static_cast<size_t>(device_id + 1) > device_mutex_ptres.size()) {
+        LOG_KNOWHERE_ERROR_ << "bad device_id:" << device_id;
+        KNOWHERE_ASCEND_THROW_FMT("device_id:%i is out of available devices!", device_id);
+    }
+
+    return device_mutex_ptres[device_id];
+}
+
+ascend_device_manager&
+ascend_device_manager::instance() {
+    static ascend_device_manager mgr;
+    if (!mgr.inited_.load()) {
+        mgr.init();
+    }
+    return mgr;
+}
+
+} // namespace ascend
+}
\ No newline at end of file
diff --git a/src/common/ascend/ascend_utils.h b/src/common/ascend/ascend_utils.h
new file mode 100644
index 00000000..a7b5cfb6
--- /dev/null
+++ b/src/common/ascend/ascend_utils.h
@@ -0,0 +1,50 @@
+#ifndef KNOWHERE_ASCEND_UTILS
+#define KNOWHERE_ASCEND_UTILS
+
+#include <mutex>
+#include <thread>
+#include <unordered_map>
+#include <cstdlib>
+#include <vector>
+#include <algorithm>
+#include <atomic>
+
+#include "ascend_exception.h"
+#include "knowhere/expected.h"
+#include "knowhere/log.h"
+
+namespace knowhere {
+namespace ascend {
+class ascend_device_manager {
+public:
+    static ascend_device_manager& instance();
+    int random_choose() const;
+    int choose_with_load(size_t load);
+    void release_load(int32_t device_id, size_t load);
+    std::mutex* get_dev_mutex_ptr(int32_t device_id);
+
+private:
+    ascend_device_manager();
+    void init();
+    std::vector<size_t> memory_load_;
+    mutable std::mutex mtx_;
+    std::atomic<bool> inited_{false};
+    std::vector<std::mutex*> device_mutex_ptres;
+};
+} // namespace ascend
+}
+
+#define RANDOM_CHOOSE_ASCEND_DEVICE_WITH_ASSIGN(x)                             \
+    do {                                                                \
+        x = knowhere::ascend::ascend_device_manager::instance().random_choose(); \
+    } while (0)
+#define MIN_LOAD_CHOOSE_ASCEND_DEVICE_WITH_ASSIGN(x, load)                            \
+    do {                                                                       \
+        x = knowhere::ascend::ascend_device_manager::instance().choose_with_load(load); \
+    } while (0)
+#define RELEASE_ASCEND_DEVICE(x, load)                                           \
+    do {                                                                  \
+        knowhere::ascend::ascend_device_manager::instance().release_load(x, load); \
+    } while (0)
+
+#endif
\ No newline at end of file
diff --git a/src/common/comp/brute_force.cc b/src/common/comp/brute_force.cc
index c3d13984..7acc67a5 100644
--- a/src/common/comp/brute_force.cc
+++ b/src/common/comp/brute_force.cc
@@ -12,12 +12,13 @@
 #include "knowhere/comp/brute_force.h"
 
 #include <vector>
+#include <sys/time.h>
 
 #include "common/metric.h"
-#include "faiss/MetricType.h"
-#include "faiss/utils/binary_distances.h"
-#include "faiss/utils/distances.h"
-#include "faiss/utils/distances_typed.h"
+#include "knowherefaiss/MetricType.h"
+#include "knowherefaiss/utils/binary_distances.h"
+#include "knowherefaiss/utils/distances.h"
+#include "knowherefaiss/utils/distances_typed.h"
 #include "index/minhash/minhash_util.h"
 #include "knowhere/bitsetview_idselector.h"
 #include "knowhere/comp/thread_pool.h"
@@ -36,6 +37,70 @@
 
 namespace knowhere {
 
+static double GetMillisecs() {
+    struct timeval tv;
+    gettimeofday(&tv, nullptr);
+    const double sec2msec = 1e3;
+    const double usec2msec = 1e-3;
+    return tv.tv_sec * sec2msec + tv.tv_usec * usec2msec;
+}
+
+static void Quantization(const float *in, int64_t dim, int8_t *out) {
+    const int scale = 255;
+    for (int64_t i = 0; i < dim; i++) {
+        float tmpF = round(in[i] * scale);
+        out[i] = std::min<int8_t>(127, std::max<int8_t>(-127, tmpF));
+    }
+}
+
+template <typename C>
+static void ReComputeTopKResult(int topk, int64_t dim, const float* xb, const float* cur_query,
+                                int64_t* cur_labels, float* cur_distances, C &&cmp) {
+    // topk
+    std::shared_ptr<int8_t> xb_quan(new int8_t[topk * dim], std::default_delete<int8_t[]>());
+    // query
+    std::shared_ptr<int8_t> q_quan(new int8_t[dim], std::default_delete<int8_t[]>());
+    for (int j = 0; j < topk; j++) {
+        const float *base = static_cast<const float*>(xb) + cur_labels[j] * dim;
+        Quantization(base, dim, xb_quan.get() + j * dim);
+    }
+    Quantization(cur_query, dim, q_quan.get());
+
+    // query
+    int32_t q_sum = 0.0;
+    for (int64_t j = 0; j < dim; j++) {
+        q_sum += static_cast<int32_t>(q_quan.get()[j]) * static_cast<int32_t>(q_quan.get()[j]);
+    }
+    float q_norm = std::sqrt(static_cast<float>(q_sum));
+
+    std::vector<std::pair<float, int64_t>> id_and_dist(topk);
+    for (int j = 0; j < topk; j++) {
+        // xb
+        int32_t xb_sum = 0;
+        int32_t cross_mul = 0;
+        for (int64_t l = 0; l < dim; l++) {
+            int8_t *base = xb_quan.get() + j * dim + l;
+            xb_sum += static_cast<int32_t>(*base) * static_cast<int32_t>(*base);
+            cross_mul += static_cast<int32_t>(*base) * static_cast<int32_t>(q_quan.get()[l]);
+        }
+        float xb_norm = std::sqrt(static_cast<float>(xb_sum));
+        cur_distances[j] = static_cast<float>(cross_mul) / (xb_norm * q_norm);
+
+        id_and_dist[j] = {cur_distances[j], cur_labels[j]};
+    }
+
+    // topk
+    std::sort(id_and_dist.begin(), id_and_dist.end(),
+        [&cmp] (const std::pair<float, int64_t> &p1, const std::pair<float, int64_t> &p2) {
+            return cmp(p1.first, p2.first);
+        });
+
+    for (int j = 0; j < topk; j++) {
+        cur_distances[j] = id_and_dist[j].first;
+        cur_labels[j] = id_and_dist[j].second;
+    }
+}
+
 /* knowhere wrapper API to call faiss brute force search for all metric types */
 /* If the ids of base_dataset does not start from 0, the BF functions will filter based on the real ids and return the
  * real ids.*/
@@ -71,11 +136,11 @@ GetVecNorms(const DataSetPtr& base) {
     using NormComputer = float (*)(const DataType*, size_t);
     NormComputer norm_computer;
     if constexpr (std::is_same_v<DataType, knowhere::fp32>) {
-        norm_computer = faiss::fvec_norm_L2sqr;
+        norm_computer = knowherefaiss::fvec_norm_L2sqr;
     } else if constexpr (std::is_same_v<DataType, knowhere::fp16>) {
-        norm_computer = faiss::fp16_vec_norm_L2sqr;
+        norm_computer = knowherefaiss::fp16_vec_norm_L2sqr;
     } else if constexpr (std::is_same_v<DataType, knowhere::bf16>) {
-        norm_computer = faiss::bf16_vec_norm_L2sqr;
+        norm_computer = knowherefaiss::bf16_vec_norm_L2sqr;
     } else {
         return nullptr;
     }
@@ -166,14 +231,14 @@ BruteForce::SearchWithBuf(const DataSetPtr base_dataset, const DataSetPtr query_
     if (result.error() != Status::success) {
         return result.error();
     }
-    faiss::MetricType faiss_metric_type = result.value();
+    knowherefaiss::MetricType faiss_metric_type = result.value();
     bool is_cosine = IsMetricType(metric_str, metric::COSINE);
 
     int topk = cfg.k.value();
     auto labels = ids;
     auto distances = dis;
     // some check for minhash metric
-    if (faiss_metric_type == faiss::METRIC_MinHash_Jaccard) {
+    if (faiss_metric_type == knowherefaiss::METRIC_MinHash_Jaccard) {
         auto labels = ids;
         auto distances = dis;
         size_t mh_vec_size_in_bytes = dim / 8;
@@ -214,15 +279,15 @@ BruteForce::SearchWithBuf(const DataSetPtr base_dataset, const DataSetPtr query_
                 auto cur_distances = distances + topk * index;
 
                 BitsetViewIDSelector bw_idselector(bitset, xb_id_offset);
-                faiss::IDSelector* id_selector = (bitset.empty()) ? nullptr : &bw_idselector;
+                knowherefaiss::IDSelector* id_selector = (bitset.empty()) ? nullptr : &bw_idselector;
                 switch (faiss_metric_type) {
-                    case faiss::METRIC_L2: {
+                    case knowherefaiss::METRIC_L2: {
                         [[maybe_unused]] auto cur_query = (const DataType*)xq + dim * index;
                         if constexpr (std::is_same_v<DataType, knowhere::fp32>) {
-                            faiss::knn_L2sqr(cur_query, (const float*)xb, dim, 1, nb, topk, cur_distances, cur_labels,
+                            knowherefaiss::knn_L2sqr(cur_query, (const float*)xb, dim, 1, nb, topk, cur_distances, cur_labels,
                                              nullptr, id_selector);
                         } else if constexpr (KnowhereLowPrecisionTypeCheck<DataType>::value) {
-                            faiss::knn_L2sqr_typed(cur_query, (const DataType*)xb, dim, 1, nb, topk, cur_distances,
+                            knowherefaiss::knn_L2sqr_typed(cur_query, (const DataType*)xb, dim, 1, nb, topk, cur_distances,
                                                    cur_labels, nullptr, id_selector);
                         } else {
                             LOG_KNOWHERE_ERROR_ << "Metric L2 not supported for current vector type";
@@ -230,16 +295,16 @@ BruteForce::SearchWithBuf(const DataSetPtr base_dataset, const DataSetPtr query_
                         }
                         break;
                     }
-                    case faiss::METRIC_INNER_PRODUCT: {
+                    case knowherefaiss::METRIC_INNER_PRODUCT: {
                         [[maybe_unused]] auto cur_query = (const DataType*)xq + dim * index;
                         if (is_cosine) {
                             if constexpr (std::is_same_v<DataType, knowhere::fp32>) {
                                 auto copied_query = CopyAndNormalizeVecs(cur_query, 1, dim);
-                                faiss::knn_cosine(copied_query.get(), (const float*)xb, norms.get(), dim, 1, nb, topk,
+                                knowherefaiss::knn_cosine(copied_query.get(), (const float*)xb, norms.get(), dim, 1, nb, topk,
                                                   cur_distances, cur_labels, id_selector);
                             } else if constexpr (KnowhereLowPrecisionTypeCheck<DataType>::value) {
                                 // normalize query vector may cause precision loss, so div query norms in apply function
-                                faiss::knn_cosine_typed(cur_query, (const DataType*)xb, norms.get(), dim, 1, nb, topk,
+                                knowherefaiss::knn_cosine_typed(cur_query, (const DataType*)xb, norms.get(), dim, 1, nb, topk,
                                                         cur_distances, cur_labels, id_selector);
                             } else {
                                 LOG_KNOWHERE_ERROR_ << "Metric COSINE not supported for current vector type";
@@ -247,10 +312,10 @@ BruteForce::SearchWithBuf(const DataSetPtr base_dataset, const DataSetPtr query_
                             }
                         } else {
                             if constexpr (std::is_same_v<DataType, knowhere::fp32>) {
-                                faiss::knn_inner_product(cur_query, (const float*)xb, dim, 1, nb, topk, cur_distances,
+                                knowherefaiss::knn_inner_product(cur_query, (const float*)xb, dim, 1, nb, topk, cur_distances,
                                                          cur_labels, id_selector);
                             } else if constexpr (KnowhereLowPrecisionTypeCheck<DataType>::value) {
-                                faiss::knn_inner_product_typed(cur_query, (const DataType*)xb, dim, 1, nb, topk,
+                                knowherefaiss::knn_inner_product_typed(cur_query, (const DataType*)xb, dim, 1, nb, topk,
                                                                cur_distances, cur_labels, id_selector);
                             } else {
                                 LOG_KNOWHERE_ERROR_ << "Metric IP not supported for current vector type";
@@ -259,26 +324,26 @@ BruteForce::SearchWithBuf(const DataSetPtr base_dataset, const DataSetPtr query_
                         }
                         break;
                     }
-                    case faiss::METRIC_Jaccard: {
+                    case knowherefaiss::METRIC_Jaccard: {
                         auto cur_query = (const uint8_t*)xq + (dim / 8) * index;
-                        faiss::float_maxheap_array_t res = {size_t(1), size_t(topk), cur_labels, cur_distances};
-                        binary_knn_hc(faiss::METRIC_Jaccard, &res, cur_query, (const uint8_t*)xb, nb, dim / 8,
+                        knowherefaiss::float_maxheap_array_t res = {size_t(1), size_t(topk), cur_labels, cur_distances};
+                        binary_knn_hc(knowherefaiss::METRIC_Jaccard, &res, cur_query, (const uint8_t*)xb, nb, dim / 8,
                                       id_selector);
                         break;
                     }
-                    case faiss::METRIC_Hamming: {
+                    case knowherefaiss::METRIC_Hamming: {
                         auto cur_query = (const uint8_t*)xq + (dim / 8) * index;
                         std::vector<int32_t> int_distances(topk);
-                        faiss::int_maxheap_array_t res = {size_t(1), size_t(topk), cur_labels, int_distances.data()};
-                        binary_knn_hc(faiss::METRIC_Hamming, &res, (const uint8_t*)cur_query, (const uint8_t*)xb, nb,
+                        knowherefaiss::int_maxheap_array_t res = {size_t(1), size_t(topk), cur_labels, int_distances.data()};
+                        binary_knn_hc(knowherefaiss::METRIC_Hamming, &res, (const uint8_t*)cur_query, (const uint8_t*)xb, nb,
                                       dim / 8, id_selector);
                         for (int i = 0; i < topk; ++i) {
                             cur_distances[i] = int_distances[i];
                         }
                         break;
                     }
-                    case faiss::METRIC_Substructure:
-                    case faiss::METRIC_Superstructure: {
+                    case knowherefaiss::METRIC_Substructure:
+                    case knowherefaiss::METRIC_Superstructure: {
                         // only matched ids will be chosen, not to use heap
                         auto cur_query = (const uint8_t*)xq + (dim / 8) * index;
                         binary_knn_mc(faiss_metric_type, cur_query, (const uint8_t*)xb, 1, nb, topk, dim / 8,
@@ -357,7 +422,7 @@ BruteForce::RangeSearch(const DataSetPtr base_dataset, const DataSetPtr query_da
     std::string metric_str = cfg.metric_type.value();
     const bool is_bm25 = IsMetricType(metric_str, metric::BM25);
 
-    faiss::MetricType faiss_metric_type;
+    knowherefaiss::MetricType faiss_metric_type;
     sparse::DocValueComputer<float> sparse_computer;
     if constexpr (!std::is_same_v<DataType, knowhere::sparse::SparseRow<float>>) {
         auto result = Str2FaissMetricType(metric_str);
@@ -426,18 +491,18 @@ BruteForce::RangeSearch(const DataSetPtr base_dataset, const DataSetPtr query_da
             } else {
                 // else not sparse:
                 ThreadPool::ScopedSearchOmpSetter setter(1);
-                faiss::RangeSearchResult res(1);
+                knowherefaiss::RangeSearchResult res(1);
 
                 BitsetViewIDSelector bw_idselector(bitset, xb_id_offset);
-                faiss::IDSelector* id_selector = (bitset.empty()) ? nullptr : &bw_idselector;
+                knowherefaiss::IDSelector* id_selector = (bitset.empty()) ? nullptr : &bw_idselector;
                 switch (faiss_metric_type) {
-                    case faiss::METRIC_L2: {
+                    case knowherefaiss::METRIC_L2: {
                         [[maybe_unused]] auto cur_query = (const DataType*)xq + dim * index;
                         if constexpr (std::is_same_v<DataType, knowhere::fp32>) {
-                            faiss::range_search_L2sqr(cur_query, (const float*)xb, dim, 1, nb, radius, &res,
+                            knowherefaiss::range_search_L2sqr(cur_query, (const float*)xb, dim, 1, nb, radius, &res,
                                                       id_selector);
                         } else if constexpr (KnowhereLowPrecisionTypeCheck<DataType>::value) {
-                            faiss::range_search_L2sqr_typed(cur_query, (const DataType*)xb, dim, 1, nb, radius, &res,
+                            knowherefaiss::range_search_L2sqr_typed(cur_query, (const DataType*)xb, dim, 1, nb, radius, &res,
                                                             id_selector);
                         } else {
                             LOG_KNOWHERE_ERROR_ << "Metric L2 not supported for current vector type";
@@ -445,16 +510,16 @@ BruteForce::RangeSearch(const DataSetPtr base_dataset, const DataSetPtr query_da
                         }
                         break;
                     }
-                    case faiss::METRIC_INNER_PRODUCT: {
+                    case knowherefaiss::METRIC_INNER_PRODUCT: {
                         [[maybe_unused]] auto cur_query = (const DataType*)xq + dim * index;
                         if (is_cosine) {
                             if constexpr (std::is_same_v<DataType, knowhere::fp32>) {
                                 auto copied_query = CopyAndNormalizeVecs(cur_query, 1, dim);
-                                faiss::range_search_cosine(copied_query.get(), (const float*)xb, norms.get(), dim, 1,
+                                knowherefaiss::range_search_cosine(copied_query.get(), (const float*)xb, norms.get(), dim, 1,
                                                            nb, radius, &res, id_selector);
                             } else if constexpr (KnowhereLowPrecisionTypeCheck<DataType>::value) {
                                 // normalize query vector may cause precision loss, so div query norms in apply function
-                                faiss::range_search_cosine_typed(cur_query, (const DataType*)xb, norms.get(), dim, 1,
+                                knowherefaiss::range_search_cosine_typed(cur_query, (const DataType*)xb, norms.get(), dim, 1,
                                                                  nb, radius, &res, id_selector);
                             } else {
                                 LOG_KNOWHERE_ERROR_ << "Metric COSINE not supported for current vector type";
@@ -462,10 +527,10 @@ BruteForce::RangeSearch(const DataSetPtr base_dataset, const DataSetPtr query_da
                             }
                         } else {
                             if constexpr (std::is_same_v<DataType, knowhere::fp32>) {
-                                faiss::range_search_inner_product(cur_query, (const DataType*)xb, dim, 1, nb, radius,
+                                knowherefaiss::range_search_inner_product(cur_query, (const DataType*)xb, dim, 1, nb, radius,
                                                                   &res, id_selector);
                             } else if constexpr (KnowhereLowPrecisionTypeCheck<DataType>::value) {
-                                faiss::range_search_inner_product_typed(cur_query, (const DataType*)xb, dim, 1, nb,
+                                knowherefaiss::range_search_inner_product_typed(cur_query, (const DataType*)xb, dim, 1, nb,
                                                                         radius, &res, id_selector);
                             } else {
                                 LOG_KNOWHERE_ERROR_ << "Metric IP not supported for current vector type";
@@ -474,17 +539,17 @@ BruteForce::RangeSearch(const DataSetPtr base_dataset, const DataSetPtr query_da
                         }
                         break;
                     }
-                    case faiss::METRIC_Jaccard: {
+                    case knowherefaiss::METRIC_Jaccard: {
                         auto cur_query = (const uint8_t*)xq + (dim / 8) * index;
-                        faiss::binary_range_search<faiss::CMin<float, int64_t>, float>(
-                            faiss::METRIC_Jaccard, cur_query, (const uint8_t*)xb, 1, nb, radius, dim / 8, &res,
+                        knowherefaiss::binary_range_search<knowherefaiss::CMin<float, int64_t>, float>(
+                            knowherefaiss::METRIC_Jaccard, cur_query, (const uint8_t*)xb, 1, nb, radius, dim / 8, &res,
                             id_selector);
                         break;
                     }
-                    case faiss::METRIC_Hamming: {
+                    case knowherefaiss::METRIC_Hamming: {
                         auto cur_query = (const uint8_t*)xq + (dim / 8) * index;
-                        faiss::binary_range_search<faiss::CMin<int, int64_t>, int>(
-                            faiss::METRIC_Hamming, cur_query, (const uint8_t*)xb, 1, nb, (int)radius, dim / 8, &res,
+                        knowherefaiss::binary_range_search<knowherefaiss::CMin<int, int64_t>, int>(
+                            knowherefaiss::METRIC_Hamming, cur_query, (const uint8_t*)xb, 1, nb, (int)radius, dim / 8, &res,
                             id_selector);
                         break;
                     }
@@ -502,7 +567,7 @@ BruteForce::RangeSearch(const DataSetPtr base_dataset, const DataSetPtr query_da
                 }
                 if (cfg.range_filter.value() != defaultRangeFilter) {
                     FilterRangeSearchResultForOneNq(result_dist_array[index], result_id_array[index],
-                                                    faiss_metric_type == faiss::METRIC_INNER_PRODUCT, radius,
+                                                    faiss_metric_type == knowherefaiss::METRIC_INNER_PRODUCT, radius,
                                                     range_filter);
                 }
                 return Status::success;
@@ -690,9 +755,9 @@ BruteForce::AnnIterator(const DataSetPtr base_dataset, const DataSetPtr query_da
     }
     // LCOV_EXCL_STOP
 #endif
-    faiss::MetricType faiss_metric_type = result.value();
+    knowherefaiss::MetricType faiss_metric_type = result.value();
     bool is_cosine = IsMetricType(metric_str, metric::COSINE);
-    auto larger_is_closer = faiss::is_similarity_metric(faiss_metric_type) || is_cosine;
+    auto larger_is_closer = knowherefaiss::is_similarity_metric(faiss_metric_type) || is_cosine;
     auto vec = std::vector<IndexNode::IteratorPtr>(nq, nullptr);
     std::shared_ptr<float[]> norms = GetVecNorms<DataType>(base_dataset);
 
@@ -704,18 +769,18 @@ BruteForce::AnnIterator(const DataSetPtr base_dataset, const DataSetPtr query_da
                 auto xq = query_dataset->GetTensor();
                 auto xb_id_offset = base_dataset->GetTensorBeginId();
                 BitsetViewIDSelector bw_idselector(bitset, xb_id_offset);
-                [[maybe_unused]] faiss::IDSelector* id_selector = (bitset.empty()) ? nullptr : &bw_idselector;
+                [[maybe_unused]] knowherefaiss::IDSelector* id_selector = (bitset.empty()) ? nullptr : &bw_idselector;
                 auto max_dis =
                     larger_is_closer ? std::numeric_limits<float>::lowest() : std::numeric_limits<float>::max();
                 std::vector<DistId> distances_ids(nb, {-1, max_dis});
                 [[maybe_unused]] auto cur_query = (const DataType*)xq + dim * i;
                 switch (faiss_metric_type) {
-                    case faiss::METRIC_L2: {
+                    case knowherefaiss::METRIC_L2: {
                         if constexpr (std::is_same_v<DataType, knowhere::fp32>) {
-                            faiss::all_L2sqr(cur_query, (const float*)xb, dim, 1, nb, distances_ids, nullptr,
+                            knowherefaiss::all_L2sqr(cur_query, (const float*)xb, dim, 1, nb, distances_ids, nullptr,
                                              id_selector);
                         } else if constexpr (KnowhereLowPrecisionTypeCheck<DataType>::value) {
-                            faiss::all_L2sqr_typed(cur_query, (const DataType*)xb, dim, 1, nb, distances_ids, nullptr,
+                            knowherefaiss::all_L2sqr_typed(cur_query, (const DataType*)xb, dim, 1, nb, distances_ids, nullptr,
                                                    id_selector);
                         } else {
                             std::string err_msg = "Metric L2 not supported for current vector type";
@@ -724,15 +789,15 @@ BruteForce::AnnIterator(const DataSetPtr base_dataset, const DataSetPtr query_da
                         }
                         break;
                     }
-                    case faiss::METRIC_INNER_PRODUCT: {
+                    case knowherefaiss::METRIC_INNER_PRODUCT: {
                         if (is_cosine) {
                             if constexpr (std::is_same_v<DataType, knowhere::fp32>) {
                                 auto copied_query = CopyAndNormalizeVecs(cur_query, 1, dim);
-                                faiss::all_cosine(copied_query.get(), (const float*)xb, norms.get(), dim, 1, nb,
+                                knowherefaiss::all_cosine(copied_query.get(), (const float*)xb, norms.get(), dim, 1, nb,
                                                   distances_ids, id_selector);
                             } else if constexpr (KnowhereLowPrecisionTypeCheck<DataType>::value) {
                                 // normalize query vector may cause precision loss, so div query norms in apply function
-                                faiss::all_cosine_typed(cur_query, (const DataType*)xb, norms.get(), dim, 1, nb,
+                                knowherefaiss::all_cosine_typed(cur_query, (const DataType*)xb, norms.get(), dim, 1, nb,
                                                         distances_ids, id_selector);
                             } else {
                                 std::string err_msg = "Metric COSINE not supported for current vector type";
@@ -741,10 +806,10 @@ BruteForce::AnnIterator(const DataSetPtr base_dataset, const DataSetPtr query_da
                             }
                         } else {
                             if constexpr (std::is_same_v<DataType, knowhere::fp32>) {
-                                faiss::all_inner_product(cur_query, (const float*)xb, dim, 1, nb, distances_ids,
+                                knowherefaiss::all_inner_product(cur_query, (const float*)xb, dim, 1, nb, distances_ids,
                                                          id_selector);
                             } else if constexpr (KnowhereLowPrecisionTypeCheck<DataType>::value) {
-                                faiss::all_inner_product_typed(cur_query, (const DataType*)xb, dim, 1, nb,
+                                knowherefaiss::all_inner_product_typed(cur_query, (const DataType*)xb, dim, 1, nb,
                                                                distances_ids, id_selector);
                             } else {
                                 std::string err_msg = "Metric IP not supported for current vector type";
diff --git a/src/common/comp/knowhere_config.cc b/src/common/comp/knowhere_config.cc
index 2c295a58..554aad75 100644
--- a/src/common/comp/knowhere_config.cc
+++ b/src/common/comp/knowhere_config.cc
@@ -16,8 +16,8 @@
 #ifdef KNOWHERE_WITH_DISKANN
 #include "diskann/aio_context_pool.h"
 #endif
-#include "faiss/Clustering.h"
-#include "faiss/utils/distances.h"
+#include "knowherefaiss/Clustering.h"
+#include "knowherefaiss/utils/distances.h"
 #include "knowhere/comp/thread_pool.h"
 #include "knowhere/log.h"
 #ifdef KNOWHERE_WITH_GPU
@@ -58,34 +58,34 @@ std::string
 KnowhereConfig::SetSimdType(const SimdType simd_type) {
 #ifdef __x86_64__
     if (simd_type == SimdType::AUTO) {
-        faiss::use_avx512 = true;
-        faiss::use_avx2 = true;
-        faiss::use_sse4_2 = true;
+        knowherefaiss::use_avx512 = true;
+        knowherefaiss::use_avx2 = true;
+        knowherefaiss::use_sse4_2 = true;
         LOG_KNOWHERE_INFO_ << "FAISS expect simdType::AUTO";
     } else if (simd_type == SimdType::AVX512) {
-        faiss::use_avx512 = true;
-        faiss::use_avx2 = true;
-        faiss::use_sse4_2 = true;
+        knowherefaiss::use_avx512 = true;
+        knowherefaiss::use_avx2 = true;
+        knowherefaiss::use_sse4_2 = true;
         LOG_KNOWHERE_INFO_ << "FAISS expect simdType::AVX512";
     } else if (simd_type == SimdType::AVX2) {
-        faiss::use_avx512 = false;
-        faiss::use_avx2 = true;
-        faiss::use_sse4_2 = true;
+        knowherefaiss::use_avx512 = false;
+        knowherefaiss::use_avx2 = true;
+        knowherefaiss::use_sse4_2 = true;
         LOG_KNOWHERE_INFO_ << "FAISS expect simdType::AVX2";
     } else if (simd_type == SimdType::SSE4_2) {
-        faiss::use_avx512 = false;
-        faiss::use_avx2 = false;
-        faiss::use_sse4_2 = true;
+        knowherefaiss::use_avx512 = false;
+        knowherefaiss::use_avx2 = false;
+        knowherefaiss::use_sse4_2 = true;
         LOG_KNOWHERE_INFO_ << "FAISS expect simdType::SSE4_2";
     } else if (simd_type == SimdType::GENERIC) {
-        faiss::use_avx512 = false;
-        faiss::use_avx2 = false;
-        faiss::use_sse4_2 = false;
+        knowherefaiss::use_avx512 = false;
+        knowherefaiss::use_avx2 = false;
+        knowherefaiss::use_sse4_2 = false;
         LOG_KNOWHERE_INFO_ << "FAISS expect simdType::GENERIC";
     }
 #endif
     std::string simd_str;
-    faiss::fvec_hook(simd_str);
+    knowherefaiss::fvec_hook(simd_str);
     LOG_KNOWHERE_INFO_ << "FAISS hook " << simd_str;
     return simd_str;
 }
@@ -93,47 +93,47 @@ KnowhereConfig::SetSimdType(const SimdType simd_type) {
 void
 KnowhereConfig::EnablePatchForComputeFP32AsBF16() {
     LOG_KNOWHERE_INFO_ << "Enable patch for compute fp32 as bf16";
-    faiss::enable_patch_for_fp32_bf16();
+    knowherefaiss::enable_patch_for_fp32_bf16();
 }
 
 void
 KnowhereConfig::DisablePatchForComputeFP32AsBF16() {
     LOG_KNOWHERE_INFO_ << "Disable patch for compute fp32 as bf16";
-    faiss::disable_patch_for_fp32_bf16();
+    knowherefaiss::disable_patch_for_fp32_bf16();
 }
 
 void
 KnowhereConfig::SetBlasThreshold(const int64_t use_blas_threshold) {
-    LOG_KNOWHERE_INFO_ << "Set faiss::distance_compute_blas_threshold to " << use_blas_threshold;
-    faiss::distance_compute_blas_threshold = static_cast<int>(use_blas_threshold);
+    LOG_KNOWHERE_INFO_ << "Set knowherefaiss::distance_compute_blas_threshold to " << use_blas_threshold;
+    knowherefaiss::distance_compute_blas_threshold = static_cast<int>(use_blas_threshold);
 }
 
 int64_t
 KnowhereConfig::GetBlasThreshold() {
-    return faiss::distance_compute_blas_threshold;
+    return knowherefaiss::distance_compute_blas_threshold;
 }
 
 void
 KnowhereConfig::SetEarlyStopThreshold(const double early_stop_threshold) {
-    LOG_KNOWHERE_INFO_ << "Set faiss::early_stop_threshold to " << early_stop_threshold;
-    faiss::early_stop_threshold = early_stop_threshold;
+    LOG_KNOWHERE_INFO_ << "Set knowherefaiss::early_stop_threshold to " << early_stop_threshold;
+    knowherefaiss::early_stop_threshold = early_stop_threshold;
 }
 
 double
 KnowhereConfig::GetEarlyStopThreshold() {
-    return faiss::early_stop_threshold;
+    return knowherefaiss::early_stop_threshold;
 }
 
 void
 KnowhereConfig::SetClusteringType(const ClusteringType clustering_type) {
-    LOG_KNOWHERE_INFO_ << "Set faiss::clustering_type to " << clustering_type;
+    LOG_KNOWHERE_INFO_ << "Set knowherefaiss::clustering_type to " << clustering_type;
     switch (clustering_type) {
         case ClusteringType::K_MEANS:
         default:
-            faiss::clustering_type = faiss::ClusteringType::K_MEANS;
+            knowherefaiss::clustering_type = knowherefaiss::ClusteringType::K_MEANS;
             break;
         case ClusteringType::K_MEANS_PLUS_PLUS:
-            faiss::clustering_type = faiss::ClusteringType::K_MEANS_PLUS_PLUS;
+            knowherefaiss::clustering_type = knowherefaiss::ClusteringType::K_MEANS_PLUS_PLUS;
             break;
     }
 }
diff --git a/src/common/metric.h b/src/common/metric.h
index 791c4aeb..8b7b95a5 100644
--- a/src/common/metric.h
+++ b/src/common/metric.h
@@ -16,30 +16,30 @@
 #include <string>
 #include <unordered_map>
 
-#include "faiss/MetricType.h"
+#include "knowherefaiss/MetricType.h"
 #include "fmt/format.h"
 #include "knowhere/comp/index_param.h"
 #include "knowhere/expected.h"
 
 namespace knowhere {
 
-inline expected<faiss::MetricType>
+inline expected<knowherefaiss::MetricType>
 Str2FaissMetricType(std::string metric) {
-    static const std::unordered_map<std::string, faiss::MetricType> metric_map = {
-        {metric::L2, faiss::MetricType::METRIC_L2},
-        {metric::IP, faiss::MetricType::METRIC_INNER_PRODUCT},
-        {metric::COSINE, faiss::MetricType::METRIC_INNER_PRODUCT},
-        {metric::HAMMING, faiss::MetricType::METRIC_Hamming},
-        {metric::JACCARD, faiss::MetricType::METRIC_Jaccard},
-        {metric::SUBSTRUCTURE, faiss::MetricType::METRIC_Substructure},
-        {metric::SUPERSTRUCTURE, faiss::MetricType::METRIC_Superstructure},
-        {metric::MHJACCARD, faiss::MetricType::METRIC_MinHash_Jaccard},
+    static const std::unordered_map<std::string, knowherefaiss::MetricType> metric_map = {
+        {metric::L2, knowherefaiss::MetricType::METRIC_L2},
+        {metric::IP, knowherefaiss::MetricType::METRIC_INNER_PRODUCT},
+        {metric::COSINE, knowherefaiss::MetricType::METRIC_INNER_PRODUCT},
+        {metric::HAMMING, knowherefaiss::MetricType::METRIC_Hamming},
+        {metric::JACCARD, knowherefaiss::MetricType::METRIC_Jaccard},
+        {metric::SUBSTRUCTURE, knowherefaiss::MetricType::METRIC_Substructure},
+        {metric::SUPERSTRUCTURE, knowherefaiss::MetricType::METRIC_Superstructure},
+        {metric::MHJACCARD, knowherefaiss::MetricType::METRIC_MinHash_Jaccard},
     };
 
     std::transform(metric.begin(), metric.end(), metric.begin(), toupper);
     auto it = metric_map.find(metric);
     if (it == metric_map.end()) {
-        return expected<faiss::MetricType>::Err(Status::invalid_metric_type,
+        return expected<knowherefaiss::MetricType>::Err(Status::invalid_metric_type,
                                                 fmt::format("unsupported metric type {}", metric));
     }
     return it->second;
diff --git a/src/common/utils.cc b/src/common/utils.cc
index 995c35b6..a26fd5da 100644
--- a/src/common/utils.cc
+++ b/src/common/utils.cc
@@ -15,9 +15,9 @@
 #include <cmath>
 #include <cstdint>
 
-#include "faiss/IndexIVFFlat.h"
-#include "faiss/impl/FaissException.h"
-#include "faiss/index_io.h"
+#include "knowherefaiss/IndexIVFFlat.h"
+#include "knowherefaiss/impl/FaissException.h"
+#include "knowherefaiss/index_io.h"
 #include "io/memory_io.h"
 #include "knowhere/log.h"
 #include "simd/hook.h"
@@ -30,11 +30,11 @@ float
 GetL2Norm(const DataType* x, int32_t d) {
     float norm_l2_sqr = 0.0;
     if constexpr (std::is_same_v<DataType, fp32>) {
-        norm_l2_sqr = faiss::fvec_norm_L2sqr(x, d);
+        norm_l2_sqr = knowherefaiss::fvec_norm_L2sqr(x, d);
     } else if constexpr (std::is_same_v<DataType, fp16>) {
-        norm_l2_sqr = faiss::fp16_vec_norm_L2sqr(x, d);
+        norm_l2_sqr = knowherefaiss::fp16_vec_norm_L2sqr(x, d);
     } else if constexpr (std::is_same_v<DataType, bf16>) {
-        norm_l2_sqr = faiss::bf16_vec_norm_L2sqr(x, d);
+        norm_l2_sqr = knowherefaiss::bf16_vec_norm_L2sqr(x, d);
     } else {
         KNOWHERE_THROW_MSG("Unknown Datatype");
     }
@@ -62,11 +62,11 @@ float
 NormalizeVec(DataType* x, int32_t d) {
     float norm_l2_sqr = 0.0;
     if constexpr (std::is_same_v<DataType, fp32>) {
-        norm_l2_sqr = faiss::fvec_norm_L2sqr(x, d);
+        norm_l2_sqr = knowherefaiss::fvec_norm_L2sqr(x, d);
     } else if constexpr (std::is_same_v<DataType, fp16>) {
-        norm_l2_sqr = faiss::fp16_vec_norm_L2sqr(x, d);
+        norm_l2_sqr = knowherefaiss::fp16_vec_norm_L2sqr(x, d);
     } else if constexpr (std::is_same_v<DataType, bf16>) {
-        norm_l2_sqr = faiss::bf16_vec_norm_L2sqr(x, d);
+        norm_l2_sqr = knowherefaiss::bf16_vec_norm_L2sqr(x, d);
     } else {
         KNOWHERE_THROW_MSG("Unknown Datatype");
     }
@@ -143,8 +143,8 @@ ConvertIVFFlat(const BinarySet& binset, const MetricType metric_type, const uint
 
     try {
         // only read IVF_FLAT index header
-        std::unique_ptr<faiss::IndexIVFFlat> ivfl;
-        ivfl.reset(static_cast<faiss::IndexIVFFlat*>(faiss::read_index_nm(&reader)));
+        std::unique_ptr<knowherefaiss::IndexIVFFlat> ivfl;
+        ivfl.reset(static_cast<knowherefaiss::IndexIVFFlat*>(knowherefaiss::read_index_nm(&reader)));
 
         // is_cosine is not defined in IVF_FLAT_NM, so mark it from config
         ivfl->is_cosine = IsMetricType(metric_type, knowhere::metric::COSINE);
@@ -153,7 +153,7 @@ ConvertIVFFlat(const BinarySet& binset, const MetricType metric_type, const uint
 
         // over-write IVF_FLAT_NM binary with native IVF_FLAT binary
         MemoryIOWriter writer;
-        faiss::write_index(ivfl.get(), &writer);
+        knowherefaiss::write_index(ivfl.get(), &writer);
         std::shared_ptr<uint8_t[]> data(writer.data());
         binary->data = data;
         binary->size = writer.tellg();
diff --git a/src/index/ascend/ascendflat.cc b/src/index/ascend/ascendflat.cc
new file mode 100644
index 00000000..b32a2e70
--- /dev/null
+++ b/src/index/ascend/ascendflat.cc
@@ -0,0 +1,451 @@
+// Copyright (C) 2019-2023 Zilliz. All rights reserved.
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance
+// with the License. You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software distributed under the License
+// is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+// or implied. See the License for the specific language governing permissions and limitations under the License.
+
+#include <cmath>
+#include <mutex>
+#include <thread>
+#include <unordered_map>
+#include <sys/time.h>
+
+#include <faiss/ascend/AscendIndexFlat.h>
+#include <faiss/ascend/AscendCloner.h>
+#include <faiss/ascend/AscendClonerOptions.h>
+#include <faiss/impl/io.h>
+#include <faiss/index_io.h>
+#include <faiss/MetricType.h>
+
+#include "common/ascend/ascend_utils.h"
+#include "index/ascend/ascendflat_config.h"
+#include "knowhere/comp/thread_pool.h"
+#include "knowhere/factory.h"
+
+namespace knowhere {
+namespace {
+using knowhere::ascend::ascend_device_manager;
+std::mutex mtx;
+size_t magic_num = 2;
+
+struct MyMemoryIOWriter : public faiss::IOWriter {
+    uint8_t* data_ = nullptr;
+    size_t total = 0;
+    size_t rp = 0;
+
+    size_t
+    operator()(const void* ptr, size_t size, size_t nitems) override {
+        auto total_need = size * nitems + rp;
+
+        if (data_ == nullptr) {
+            total = total_need * magic_num;
+            rp = size * nitems;
+            data_ = new uint8_t[total];
+            memcpy(data_, ptr, rp);
+            return nitems;
+        }
+
+        if (total_need > total) {
+            total = total_need * magic_num;
+            auto new_data = new uint8_t[total];
+            memcpy(new_data, data_, rp);
+            delete[] data_;
+            data_ = new_data;
+
+            memcpy((data_ + rp), ptr, size * nitems);
+            rp = total_need;
+        } else {
+            memcpy((data_ + rp), ptr, size * nitems);
+            rp = total_need;
+        }
+
+        return nitems;
+    }
+
+    template <typename T>
+    size_t
+    write(T* ptr, size_t size, size_t nitems = 1) {
+#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
+        for (size_t i = 0; i < nitems; ++i) {
+            *(ptr + i) = getSwappedBytes(*(ptr + i));
+        }
+
+#endif
+        return operator()((const void*)ptr, size, nitems);
+    }
+};
+
+struct MyMemoryIOReader : public faiss::IOReader {
+    uint8_t* data_;
+    size_t rp = 0;
+    size_t total = 0;
+
+    size_t
+    operator()(void* ptr, size_t size, size_t nitems) override {
+        if (rp >= total) {
+            return 0;
+        }
+        size_t nremain = (total - rp) / size;
+        if (nremain < nitems) {
+            nitems = nremain;
+        }
+        memcpy(ptr, (data_ + rp), size * nitems);
+        rp += size * nitems;
+        return nitems;
+    }
+
+    template <typename T>
+    size_t
+    read(T* ptr, size_t size, size_t nitems = 1) {
+        auto res = operator()((void*)ptr, size, nitems);
+#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
+        for (size_t i = 0; i < nitems; ++i) {
+            *(ptr + i) = getSwappedBytes(*(ptr + i));
+        }
+#endif
+
+        return res;
+    }
+};
+
+double GetMillisecs() {
+    struct timeval tv;
+    gettimeofday(&tv, nullptr);
+    const double sec2msec = 1e3;
+    const double usec2msec = 1e-3;
+    return tv.tv_sec * sec2msec + tv.tv_usec * usec2msec;
+}
+
+Status
+Str2FaissMetricType(std::string metric, faiss::MetricType &metric_type) {
+    static const std::unordered_map<std::string, faiss::MetricType> metric_map = {
+        {metric::L2, faiss::MetricType::METRIC_L2},
+        {metric::IP, faiss::MetricType::METRIC_INNER_PRODUCT},
+    };
+
+    std::transform(metric.begin(), metric.end(), metric.begin(), toupper);
+    auto it = metric_map.find(metric);
+    if (it == metric_map.end()) {
+        return Status::invalid_metric_type;
+    }
+    metric_type = it->second;
+    return Status::success;
+}
+}
+
+class AscnedFlatIndexNode : public IndexNode {
+ public:
+    AscnedFlatIndexNode(const int32_t version, const Object&) : index_(nullptr) {
+        LOG_KNOWHERE_INFO_ << "ascend AscnedFlatIndexNode construct:"
+            << std::this_thread::get_id() << " this:" << int64_t(this);
+        pool_ = ThreadPool::GetGlobalSearchThreadPool();
+    }
+
+    Status
+    Build(const DataSet& dataset, const Config& cfg) override {
+        LOG_KNOWHERE_INFO_ << "ascend AscnedFlatIndexNode Build:"
+            << std::this_thread::get_id() << " this:" << int64_t(this);
+        auto err = Train(dataset, cfg);
+        if (err != Status::success) {
+            return err;
+        }
+        return Add(dataset, cfg);
+    }
+
+    Status
+    Train(const DataSet& dataset, const Config& cfg) override {
+        const AscendFlatConfig& f_cfg = static_cast<const AscendFlatConfig&>(cfg);
+        faiss::MetricType metric;
+        auto err = Str2FaissMetricType(f_cfg.metric_type.value(), metric);
+        if (err != Status::success) {
+            LOG_KNOWHERE_ERROR_ << "please check metric type, " << f_cfg.metric_type.value();
+            return err;
+        }
+        LOG_KNOWHERE_INFO_ << "ascend AscnedFlatIndexNode Train:"
+            << std::this_thread::get_id() << " this:" << int64_t(this)
+            << " dim: " << dataset.GetDim() << " metric type: " << f_cfg.metric_type.value();
+
+        try {
+            int32_t device_id = 0;
+            RANDOM_CHOOSE_ASCEND_DEVICE_WITH_ASSIGN(device_id);
+            std::vector<int> devices{ device_id }; // ascend index
+            int64_t resource_size = 1 * static_cast<int64_t>(1024 * 1024 * 1024);
+            faiss::ascend::AscendIndexFlatConfig conf(devices, resource_size);
+
+            std::lock_guard<std::mutex> lk(*(ascend_device_manager::instance().get_dev_mutex_ptr(device_id)));
+            LOG_KNOWHERE_INFO_ << "ascend AscnedFlatIndexNode Train on device:"
+                << device_id << ", thread-" << std::this_thread::get_id() << " this:" << int64_t(this);
+            index_ = std::make_unique<faiss::ascend::AscendIndexFlat>(
+                static_cast<int>(dataset.GetDim()), metric, conf);
+        } catch (const std::exception& e) {
+            LOG_KNOWHERE_ERROR_ << "error create ascend index, " << e.what();
+            return Status::ascend_inner_error;
+        }
+
+        return Status::success;
+    }
+
+    Status
+    Add(const DataSet& dataset, const Config& cfg) override {
+        auto x = dataset.GetTensor();
+        auto n = dataset.GetRows();
+        LOG_KNOWHERE_INFO_ << "ascend AscnedFlatIndexNode Add:"
+            << std::this_thread::get_id() << " this:" << int64_t(this) << " n:" << n;
+
+        try {
+            std::shared_ptr<float> codes(new float[n * static_cast<int64_t>(index_->d)],
+                std::default_delete<float[]>());
+            Quantization(static_cast<const float*>(x), n, static_cast<int64_t>(index_->d), codes.get());
+            int32_t device_id = index_->getDeviceList()[0];
+            std::lock_guard<std::mutex> lk(*(ascend_device_manager::instance().get_dev_mutex_ptr(device_id)));
+            index_->add(n, codes.get());
+        } catch (const std::exception& e) {
+            LOG_KNOWHERE_ERROR_ << "error add data, " << e.what();
+            return Status::ascend_inner_error;
+        }
+
+        LOG_KNOWHERE_INFO_ << "ascend AscnedFlatIndexNode Add finished:"
+            << std::this_thread::get_id() << " this:" << int64_t(this) << " n:" << n;
+        return Status::success;
+    }
+
+    expected<DataSetPtr>
+    Search(const DataSet& dataset, const Config& cfg, const BitsetView& bitset) const override {
+        if (index_ == nullptr) {
+            LOG_KNOWHERE_ERROR_ << "search on empty index";
+            expected<DataSetPtr>::Err(Status::empty_index, "index not loaded");
+        }
+
+        DataSetPtr results = std::make_shared<DataSet>();
+        const AscendFlatConfig& f_cfg = static_cast<const AscendFlatConfig&>(cfg);
+        auto k = f_cfg.k.value();
+        auto nq = dataset.GetRows();
+        auto x = dataset.GetTensor();
+
+        auto len = k * nq;
+        int64_t* ids = nullptr;
+        float* distances = nullptr;
+
+        try {
+            std::shared_ptr<float> codes(new float[nq * static_cast<int64_t>(index_->d)],
+                std::default_delete<float[]>());
+            Quantization(static_cast<const float*>(x), nq, static_cast<int64_t>(index_->d), codes.get());
+
+            ids = new int64_t[len];
+            distances = new float[len];
+
+            int32_t device_id = index_->getDeviceList()[0];
+            if (bitset.empty() || (bitset.count() == 0)) {
+                std::lock_guard<std::mutex> lk(*(ascend_device_manager::instance().get_dev_mutex_ptr(device_id)));
+                LOG_KNOWHERE_INFO_ << "ascend AscnedFlatIndexNode Search:"
+                    << std::this_thread::get_id() << " this:" << int64_t(this)
+                    << " nq:" << nq << " k:" << k << " ntotal:" << index_->ntotal;
+                double t1 = GetMillisecs();
+                index_->search(nq, codes.get(), k, distances, ids);
+                double t2 = GetMillisecs();
+                LOG_KNOWHERE_INFO_ << "ascend AscnedFlatIndexNode Search finished:" << t2 - t1;
+            } else {
+                // trans bitset to ascend mask
+                size_t byte_size = bitset.byte_size();
+                std::shared_ptr<uint8_t> masks(new uint8_t[byte_size * static_cast<size_t>(nq)],
+                    std::default_delete<uint8_t[]>());
+                Bitset2Mask(bitset, nq, masks.get());
+                std::lock_guard<std::mutex> lk(*(ascend_device_manager::instance().get_dev_mutex_ptr(device_id)));
+                LOG_KNOWHERE_INFO_ << "ascend AscnedFlatIndexNode Search with mask:"
+                    << std::this_thread::get_id() << " this:" << int64_t(this)
+                    << " nq:" << nq << " k:" << k << " ntotal:" << index_->ntotal;
+                double t1 = GetMillisecs();
+                index_->search_with_masks(nq, codes.get(), k, distances, ids, masks.get());
+                double t2 = GetMillisecs();
+                LOG_KNOWHERE_INFO_ << "ascend AscnedFlatIndexNode Search with mask finished:" << t2 - t1;
+            }
+        } catch (const std::exception& e) {
+            std::unique_ptr<int64_t[]> auto_delete_ids(ids);
+            std::unique_ptr<float[]> auto_delete_dis(distances);
+            LOG_KNOWHERE_ERROR_ << "error inner ascend, " << e.what();
+            return expected<DataSetPtr>::Err(Status::ascend_inner_error, e.what());
+        }
+
+        return GenResultDataSet(nq, k, ids, distances);
+    }
+
+    expected<DataSetPtr>
+    RangeSearch(const DataSet& dataset, const Config& cfg, const BitsetView& bitset) const override {
+        LOG_KNOWHERE_ERROR_ << "ascend AscnedFlatIndexNode RangeSearch not implemented";
+        return expected<DataSetPtr>::Err(Status::not_implemented, "RangeSearch not implemented");
+    }
+
+    expected<DataSetPtr>
+    GetVectorByIds(const DataSet& dataset) const override {
+        LOG_KNOWHERE_ERROR_ << "ascend AscnedFlatIndexNode GetVectorByIds not implemented";
+        return expected<DataSetPtr>::Err(Status::not_implemented, "GetVectorByIds not implemented");
+    }
+
+    bool
+    HasRawData(const std::string& metric_type) const override {
+        LOG_KNOWHERE_ERROR_ << "ascend AscnedFlatIndexNode HasRawData not implemented";
+        return false;
+    }
+
+    expected<DataSetPtr>
+    GetIndexMeta(const Config& cfg) const override {
+        LOG_KNOWHERE_ERROR_ << "ascend AscnedFlatIndexNode GetIndexMeta not implemented";
+        return expected<DataSetPtr>::Err(Status::not_implemented, "GetIndexMeta not implemented");
+    }
+
+    Status
+    Serialize(BinarySet& binset) const override {   
+        LOG_KNOWHERE_INFO_ << "ascend AscnedFlatIndexNode Serialize:"
+            << std::this_thread::get_id() << " this:" << int64_t(this);
+
+        if (index_ == nullptr) {
+            LOG_KNOWHERE_ERROR_ << "index_ not initilized";
+            expected<DataSetPtr>::Err(Status::empty_index, "index not loaded");
+        }
+
+        try {
+            MyMemoryIOWriter writer;
+            int32_t device_id = index_->getDeviceList()[0];
+            std::lock_guard<std::mutex> lk(*(ascend_device_manager::instance().get_dev_mutex_ptr(device_id)));
+            std::unique_ptr<faiss::Index> cpu_index(faiss::ascend::index_ascend_to_cpu(index_.get()));
+            faiss::write_index(cpu_index.get(), &writer);
+            std::shared_ptr<uint8_t[]> data(writer.data_);
+            binset.Append(Type(), data, writer.rp);
+        } catch (const std::exception& e) {
+            LOG_KNOWHERE_ERROR_ << "error inner ascend, " << e.what();
+            return Status::ascend_inner_error;
+        }
+        LOG_KNOWHERE_INFO_ << "ascend AscnedFlatIndexNode Serialize finished:"
+            << std::this_thread::get_id() << " this:" << int64_t(this) << " ntotal:" << index_->ntotal;
+        return Status::success;
+    }
+
+    Status
+    Deserialize(const BinarySet& binset, const Config& config) override {
+        std::string name = Type();
+        auto binary = binset.GetByName(name);
+        MyMemoryIOReader reader;
+        reader.total = binary->size;
+        reader.data_ = binary->data.get();
+
+        try {
+            std::unique_ptr<faiss::Index> cpu_index(faiss::read_index(&reader));
+            int32_t device_id = 0;
+            MIN_LOAD_CHOOSE_ASCEND_DEVICE_WITH_ASSIGN(device_id, binary->size);
+            std::vector<int> devices{ device_id };
+            faiss::ascend::AscendClonerOptions option; // TODO: resourceSize
+            option.resourceSize = 2 * static_cast<int64_t>(1024 * 1024 * 1024);
+            std::lock_guard<std::mutex> lk(*(ascend_device_manager::instance().get_dev_mutex_ptr(device_id)));
+            LOG_KNOWHERE_INFO_ << "ascend AscnedFlatIndexNode Deserialize on device:"
+                << device_id << ", thread-" << std::this_thread::get_id() << " this:" << int64_t(this);
+            auto ascend_index = dynamic_cast<faiss::ascend::AscendIndexFlat *>(
+                faiss::ascend::index_cpu_to_ascend(devices, cpu_index.get(), &option));
+            if (ascend_index == nullptr) {
+                LOG_KNOWHERE_ERROR_ << "error inner ascend, index_cpu_to_ascend failed";
+                return Status::ascend_inner_error;
+            }
+            index_.reset(ascend_index);
+            this->load_ = binary->size;
+        } catch (const std::exception& e) {
+            LOG_KNOWHERE_ERROR_ << "error inner ascend, " << e.what();
+            return Status::ascend_inner_error;
+        }
+        LOG_KNOWHERE_INFO_ << "ascend AscnedFlatIndexNode Deserialize finished:"
+            << std::this_thread::get_id() << " this:" << int64_t(this) << " ntotal:" << index_->ntotal;
+        return Status::success;
+    }
+
+    Status
+    DeserializeFromFile(const std::string& filename, const Config& config) override {
+        LOG_KNOWHERE_ERROR_ << "ascend AscnedFlatIndexNode DeserializeFromFile not implemented";
+        return Status::not_implemented;
+    }
+
+    std::unique_ptr<BaseConfig>
+    CreateConfig() const override {
+        return std::make_unique<AscendFlatConfig>();
+    }
+
+    int64_t
+    Dim() const override {
+        return static_cast<int64_t>(index_->d);
+    }
+
+    int64_t
+    Size() const override {
+        return index_->ntotal * static_cast<int64_t>(index_->d) * static_cast<int64_t>(sizeof(float));
+    }
+
+    int64_t
+    Count() const override {
+        return index_->ntotal;
+    }
+
+    std::string
+    Type() const override {
+        return knowhere::IndexEnum::INDEX_ASCEND_FLAT;
+    }
+
+    ~AscnedFlatIndexNode() override {
+        LOG_KNOWHERE_INFO_ << "ascend AscnedFlatIndexNode Deconstruct:"
+            << std::this_thread::get_id() << " this:" << int64_t(this) << " ntotal:" << index_->ntotal;
+        try {
+            int32_t device_id = index_->getDeviceList()[0];
+            std::lock_guard<std::mutex> lk(*(ascend_device_manager::instance().get_dev_mutex_ptr(device_id)));
+            RELEASE_ASCEND_DEVICE(device_id, this->load_);
+        } catch (const std::exception& e) {
+            LOG_KNOWHERE_WARNING_ << "error inner ascend, " << e.what();
+        }
+    }
+
+ private:
+    void Quantization(const float *in, int64_t nq, int64_t dim, float *out) const {
+        std::vector<folly::Future<folly::Unit>> futs;
+        futs.reserve(nq);
+        for (int64_t i = 0; i < nq; i++) {
+            futs.push_back(pool_->push([&, index = i] {
+                for (int64_t j = 0; j < dim; j++) {
+                    int64_t offset = index * dim + j;
+                    out[offset] = in[offset];
+                }
+            }));
+        }
+        for (auto& fut : futs) {
+            fut.wait();
+        }
+    }
+
+    void Bitset2Mask(const BitsetView& bitset, int64_t nq, uint8_t *mask) const {
+        size_t byte_size = bitset.byte_size();
+        const uint8_t *bits = bitset.data();
+
+        std::vector<folly::Future<folly::Unit>> futs;
+        futs.reserve(nq);
+        for (size_t i = 0; i < size_t(nq); i++) {
+            futs.push_back(pool_->push([&, index = i] {
+                for (size_t j = 0; j < byte_size; j++) {
+                    mask[index * byte_size + j] = ~(bits[j]);
+                }
+            }));
+        }
+        for (auto& fut : futs) {
+            fut.wait();
+        }
+    }
+
+ private:
+    std::unique_ptr<faiss::ascend::AscendIndexFlat> index_;
+    std::shared_ptr<ThreadPool> pool_;
+    size_t load_ = 0;
+};
+
+KNOWHERE_REGISTER_GLOBAL(ASCEND_FLAT, [](const int32_t& version, const Object& object) { 
+    return Index<AscnedFlatIndexNode>::Create(version, object);
+});
+
+}  // namespace knowhere
diff --git a/src/index/ascend/ascendflat_config.h b/src/index/ascend/ascendflat_config.h
new file mode 100644
index 00000000..ab411037
--- /dev/null
+++ b/src/index/ascend/ascendflat_config.h
@@ -0,0 +1,23 @@
+// Copyright (C) 2019-2023 Zilliz. All rights reserved.
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance
+// with the License. You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software distributed under the License
+// is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+// or implied. See the License for the specific language governing permissions and limitations under the License.
+
+#ifndef ASCEND_FLAT_CONFIG_H
+#define ASCEND_FLAT_CONFIG_H
+
+#include "knowhere/config.h"
+
+namespace knowhere {
+
+class AscendFlatConfig : public BaseConfig {};
+
+}  // namespace knowhere
+
+#endif /* ASCEND_FLAT_CONFIG_H */
diff --git a/src/index/ascend/flatint8.cc b/src/index/ascend/flatint8.cc
new file mode 100644
index 00000000..c5239435
--- /dev/null
+++ b/src/index/ascend/flatint8.cc
@@ -0,0 +1,456 @@
+// Copyright (C) 2019-2023 Zilliz. All rights reserved.
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance
+// with the License. You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software distributed under the License
+// is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+// or implied. See the License for the specific language governing permissions and limitations under the License.
+
+#include <cmath>
+#include <mutex>
+#include <thread>
+#include <unordered_map>
+#include <sys/time.h>
+
+#include <faiss/ascend/AscendIndexInt8Flat.h>
+#include <faiss/ascend/AscendCloner.h>
+#include <faiss/ascend/AscendClonerOptions.h>
+#include <faiss/impl/io.h>
+#include <faiss/index_io.h>
+#include <faiss/MetricType.h>
+
+#include "common/ascend/ascend_utils.h"
+#include "index/ascend/flatint8_config.h"
+#include "knowhere/comp/thread_pool.h"
+#include "knowhere/factory.h"
+
+namespace knowhere {
+namespace {
+using knowhere::ascend::ascend_device_manager;
+std::mutex mtx;
+size_t magic_num = 2;
+const std::string ascend_index_type = "ASCEND_FLAT_INT8";
+struct MyMemoryIOWriter : public faiss::IOWriter {
+    uint8_t* data_ = nullptr;
+    size_t total = 0;
+    size_t rp = 0;
+
+    size_t
+    operator()(const void* ptr, size_t size, size_t nitems) override {
+        auto total_need = size * nitems + rp;
+
+        if (data_ == nullptr) {
+            total = total_need * magic_num;
+            rp = size * nitems;
+            data_ = new uint8_t[total];
+            memcpy(data_, ptr, rp);
+            return nitems;
+        }
+
+        if (total_need > total) {
+            total = total_need * magic_num;
+            auto new_data = new uint8_t[total];
+            memcpy(new_data, data_, rp);
+            delete[] data_;
+            data_ = new_data;
+
+            memcpy((data_ + rp), ptr, size * nitems);
+            rp = total_need;
+        } else {
+            memcpy((data_ + rp), ptr, size * nitems);
+            rp = total_need;
+        }
+
+        return nitems;
+    }
+
+    template <typename T>
+    size_t
+    write(T* ptr, size_t size, size_t nitems = 1) {
+#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
+        for (size_t i = 0; i < nitems; ++i) {
+            *(ptr + i) = getSwappedBytes(*(ptr + i));
+        }
+
+#endif
+        return operator()((const void*)ptr, size, nitems);
+    }
+};
+
+struct MyMemoryIOReader : public faiss::IOReader {
+    uint8_t* data_;
+    size_t rp = 0;
+    size_t total = 0;
+
+    size_t
+    operator()(void* ptr, size_t size, size_t nitems) override {
+        if (rp >= total) {
+            return 0;
+        }
+        size_t nremain = (total - rp) / size;
+        if (nremain < nitems) {
+            nitems = nremain;
+        }
+        memcpy(ptr, (data_ + rp), size * nitems);
+        rp += size * nitems;
+        return nitems;
+    }
+
+    template <typename T>
+    size_t
+    read(T* ptr, size_t size, size_t nitems = 1) {
+        auto res = operator()((void*)ptr, size, nitems);
+#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__
+        for (size_t i = 0; i < nitems; ++i) {
+            *(ptr + i) = getSwappedBytes(*(ptr + i));
+        }
+#endif
+
+        return res;
+    }
+};
+
+double GetMillisecs() {
+    struct timeval tv;
+    gettimeofday(&tv, nullptr);
+    const double sec2msec = 1e3;
+    const double usec2msec = 1e-3;
+    return tv.tv_sec * sec2msec + tv.tv_usec * usec2msec;
+}
+
+Status
+Str2FaissMetricType(std::string metric, faiss::MetricType &metric_type) {
+    static const std::unordered_map<std::string, faiss::MetricType> metric_map = {
+        {metric::L2, faiss::MetricType::METRIC_L2},
+        {metric::IP, faiss::MetricType::METRIC_INNER_PRODUCT},
+    };
+
+    std::transform(metric.begin(), metric.end(), metric.begin(), toupper);
+    auto it = metric_map.find(metric);
+    if (it == metric_map.end()) {
+        return Status::invalid_metric_type;
+    }
+    metric_type = it->second;
+    return Status::success;
+}
+}
+
+class FlatInt8IndexNode : public IndexNode {
+ public:
+    FlatInt8IndexNode(const int32_t version, const Object&) : index_(nullptr) {
+        LOG_KNOWHERE_INFO_ << "ascend FlatInt8IndexNode construct:"
+            << std::this_thread::get_id() << " this:" << int64_t(this);
+        pool_ = ThreadPool::GetGlobalSearchThreadPool();
+    }
+
+    Status
+    Build(const DataSet& dataset, const Config& cfg) override {
+        LOG_KNOWHERE_INFO_ << "ascend FlatInt8IndexNode Build:"
+            << std::this_thread::get_id() << " this:" << int64_t(this);
+        auto err = Train(dataset, cfg);
+        if (err != Status::success) {
+            return err;
+        }
+        return Add(dataset, cfg);
+    }
+
+    Status
+    Train(const DataSet& dataset, const Config& cfg) override {
+        const FlatInt8Config& f_cfg = static_cast<const FlatInt8Config&>(cfg);
+        DataSet& newdataset = const_cast<DataSet&>(dataset);
+        newdataset.SetAscendIndexType(ascend_index_type);
+        faiss::MetricType metric;
+        auto err = Str2FaissMetricType(f_cfg.metric_type.value(), metric);
+        if (err != Status::success) {
+            LOG_KNOWHERE_ERROR_ << "please check metric type, " << f_cfg.metric_type.value();
+            return err;
+        }
+        LOG_KNOWHERE_INFO_ << "ascend FlatInt8IndexNode Train:"
+            << std::this_thread::get_id() << " this:" << int64_t(this)
+            << " dim: " << newdataset.GetDim() << " metric type: " << f_cfg.metric_type.value();
+
+        try {
+            int32_t device_id = 0;
+            RANDOM_CHOOSE_ASCEND_DEVICE_WITH_ASSIGN(device_id);
+            std::vector<int> devices{ device_id }; // ascend index
+            int64_t resource_size = 1 * static_cast<int64_t>(1024 * 1024 * 1024);
+            faiss::ascend::AscendIndexInt8FlatConfig conf(devices, resource_size);
+
+            std::lock_guard<std::mutex> lk(*(ascend_device_manager::instance().get_dev_mutex_ptr(device_id)));
+            LOG_KNOWHERE_INFO_ << "ascend FlatInt8IndexNode Train on device:"
+                << device_id << ", thread-" << std::this_thread::get_id() << " this:" << int64_t(this);
+            index_ = std::make_unique<faiss::ascend::AscendIndexInt8Flat>(
+                static_cast<int>(newdataset.GetDim()), metric, conf);
+        } catch (const std::exception& e) {
+            LOG_KNOWHERE_ERROR_ << "error create ascend index, " << e.what();
+            return Status::ascend_inner_error;
+        }
+
+        return Status::success;
+    }
+
+    Status
+    Add(const DataSet& dataset, const Config& cfg) override {
+        auto x = dataset.GetTensor();
+        auto n = dataset.GetRows();
+        LOG_KNOWHERE_INFO_ << "ascend FlatInt8IndexNode Add:"
+            << std::this_thread::get_id() << " this:" << int64_t(this) << " n:" << n;
+
+        try {
+            std::shared_ptr<int8_t> codes(new int8_t[n * static_cast<int64_t>(index_->getDim())],
+                std::default_delete<int8_t[]>());
+            Quantization(static_cast<const float*>(x), n, static_cast<int64_t>(index_->getDim()), codes.get());
+            int32_t device_id = index_->getDeviceList()[0];
+            std::lock_guard<std::mutex> lk(*(ascend_device_manager::instance().get_dev_mutex_ptr(device_id)));
+            index_->add(n, codes.get());
+        } catch (const std::exception& e) {
+            LOG_KNOWHERE_ERROR_ << "error add data, " << e.what();
+            return Status::ascend_inner_error;
+        }
+
+        LOG_KNOWHERE_INFO_ << "ascend FlatInt8IndexNode Add finished:"
+            << std::this_thread::get_id() << " this:" << int64_t(this) << " n:" << n;
+        return Status::success;
+    }
+
+    expected<DataSetPtr>
+    Search(const DataSet& dataset, const Config& cfg, const BitsetView& bitset) const override {
+        if (index_ == nullptr) {
+            LOG_KNOWHERE_ERROR_ << "search on empty index";
+            expected<DataSetPtr>::Err(Status::empty_index, "index not loaded");
+        }
+
+        DataSetPtr results = std::make_shared<DataSet>();
+        const FlatInt8Config& f_cfg = static_cast<const FlatInt8Config&>(cfg);
+        auto k = f_cfg.k.value();
+        auto nq = dataset.GetRows();
+        auto x = dataset.GetTensor();
+
+        auto len = k * nq;
+        int64_t* ids = nullptr;
+        float* distances = nullptr;
+
+        try {
+            std::shared_ptr<int8_t> codes(new int8_t[nq * static_cast<int64_t>(index_->getDim())],
+                std::default_delete<int8_t[]>());
+            Quantization(static_cast<const float*>(x), nq, static_cast<int64_t>(index_->getDim()), codes.get());
+            ids = new int64_t[len];
+            distances = new float[len];
+
+            int32_t device_id = index_->getDeviceList()[0];
+            if (bitset.empty() || (bitset.count() == 0)) {
+                std::lock_guard<std::mutex> lk(*(ascend_device_manager::instance().get_dev_mutex_ptr(device_id)));
+                LOG_KNOWHERE_INFO_ << "ascend FlatInt8IndexNode Search:"
+                    << std::this_thread::get_id() << " this:" << int64_t(this)
+                    << " nq:" << nq << " k:" << k << " ntotal:" << index_->getNTotal();
+                double t1 = GetMillisecs();
+                index_->search(nq, codes.get(), k, distances, ids);
+                double t2 = GetMillisecs();
+                LOG_KNOWHERE_INFO_ << "ascend FlatInt8IndexNode Search finished:" << t2 - t1;
+            } else {
+                // trans bitset to ascend mask
+                size_t byte_size = bitset.byte_size();
+                std::shared_ptr<uint8_t> masks(new uint8_t[byte_size * static_cast<size_t>(nq)],
+                    std::default_delete<uint8_t[]>());
+                Bitset2Mask(bitset, nq, masks.get());
+                std::lock_guard<std::mutex> lk(*(ascend_device_manager::instance().get_dev_mutex_ptr(device_id)));
+                LOG_KNOWHERE_INFO_ << "ascend FlatInt8IndexNode Search with mask:"
+                    << std::this_thread::get_id() << " this:" << int64_t(this)
+                    << " nq:" << nq << " k:" << k << " ntotal:" << index_->getNTotal();
+                double t1 = GetMillisecs();
+                index_->search_with_masks(nq, codes.get(), k, distances, ids, masks.get());
+                double t2 = GetMillisecs();
+                LOG_KNOWHERE_INFO_ << "ascend FlatInt8IndexNode Search finished:" << t2 - t1;
+            }
+        } catch (const std::exception& e) {
+            std::unique_ptr<int64_t[]> auto_delete_ids(ids);
+            std::unique_ptr<float[]> auto_delete_dis(distances);
+            LOG_KNOWHERE_ERROR_ << "error inner ascend, " << e.what();
+            return expected<DataSetPtr>::Err(Status::ascend_inner_error, e.what());
+        }
+
+        return GenResultDataSet(nq, k, ids, distances);
+    }
+
+    expected<DataSetPtr>
+    RangeSearch(const DataSet& dataset, const Config& cfg, const BitsetView& bitset) const override {
+        LOG_KNOWHERE_ERROR_ << "ascend FlatInt8IndexNode RangeSearch not implemented";
+        return expected<DataSetPtr>::Err(Status::not_implemented, "RangeSearch not implemented");
+    }
+
+    expected<DataSetPtr>
+    GetVectorByIds(const DataSet& dataset) const override {
+        LOG_KNOWHERE_ERROR_ << "ascend FlatInt8IndexNode GetVectorByIds not implemented";
+        return expected<DataSetPtr>::Err(Status::not_implemented, "GetVectorByIds not implemented");
+    }
+
+    bool
+    HasRawData(const std::string& metric_type) const override {
+        LOG_KNOWHERE_ERROR_ << "ascend FlatInt8IndexNode HasRawData not implemented";
+        return false;
+    }
+
+    expected<DataSetPtr>
+    GetIndexMeta(const Config& cfg) const override {
+        LOG_KNOWHERE_ERROR_ << "ascend FlatInt8IndexNode GetIndexMeta not implemented";
+        return expected<DataSetPtr>::Err(Status::not_implemented, "GetIndexMeta not implemented");
+    }
+
+    Status
+    Serialize(BinarySet& binset) const override {   
+        LOG_KNOWHERE_INFO_ << "ascend FlatInt8IndexNode Serialize:"
+            << std::this_thread::get_id() << " this:" << int64_t(this);
+
+        if (index_ == nullptr) {
+            LOG_KNOWHERE_ERROR_ << "index_ not initilized";
+            expected<DataSetPtr>::Err(Status::empty_index, "index not loaded");
+        }
+
+        try {
+            MyMemoryIOWriter writer;
+            int32_t device_id = index_->getDeviceList()[0];
+            std::lock_guard<std::mutex> lk(*(ascend_device_manager::instance().get_dev_mutex_ptr(device_id)));
+            std::unique_ptr<faiss::Index> cpu_index(faiss::ascend::index_int8_ascend_to_cpu(index_.get()));
+            faiss::write_index(cpu_index.get(), &writer);
+            std::shared_ptr<uint8_t[]> data(writer.data_);
+            binset.Append(Type(), data, writer.rp);
+        } catch (const std::exception& e) {
+            LOG_KNOWHERE_ERROR_ << "error inner ascend, " << e.what();
+            return Status::ascend_inner_error;
+        }
+        LOG_KNOWHERE_INFO_ << "ascend FlatInt8IndexNode Serialize finished:"
+            << std::this_thread::get_id() << " this:" << int64_t(this) << " ntotal:" << index_->getNTotal();
+        return Status::success;
+    }
+
+    Status
+    Deserialize(const BinarySet& binset, const Config& config) override {
+        std::string name = Type();
+        auto binary = binset.GetByName(name);
+        MyMemoryIOReader reader;
+        reader.total = binary->size;
+        reader.data_ = binary->data.get();
+
+        try {
+            std::unique_ptr<faiss::Index> cpu_index(faiss::read_index(&reader));
+            int32_t device_id = 0;
+            MIN_LOAD_CHOOSE_ASCEND_DEVICE_WITH_ASSIGN(device_id, binary->size);
+            std::vector<int> devices{ device_id };
+            faiss::ascend::AscendClonerOptions option; // TODO: resourceSize
+            option.resourceSize = 2 * static_cast<int64_t>(1024 * 1024 * 1024);
+            std::lock_guard<std::mutex> lk(*(ascend_device_manager::instance().get_dev_mutex_ptr(device_id)));
+            LOG_KNOWHERE_INFO_ << "ascend FlatInt8IndexNode Deserialize on device:"
+                << device_id << ", thread-" << std::this_thread::get_id() << " this:" << int64_t(this);
+            auto ascend_index = dynamic_cast<faiss::ascend::AscendIndexInt8Flat *>(
+                faiss::ascend::index_int8_cpu_to_ascend(devices, cpu_index.get(), &option));
+            if (ascend_index == nullptr) {
+                LOG_KNOWHERE_ERROR_ << "error inner ascend, index_int8_cpu_to_ascend failed";
+                return Status::ascend_inner_error;
+            }
+            index_.reset(ascend_index);
+            this->load_ = binary->size;
+        } catch (const std::exception& e) {
+            LOG_KNOWHERE_ERROR_ << "error inner ascend, " << e.what();
+            return Status::ascend_inner_error;
+        }
+        LOG_KNOWHERE_INFO_ << "ascend FlatInt8IndexNode Deserialize finished:"
+            << std::this_thread::get_id() << " this:" << int64_t(this) << " ntotal:" << index_->getNTotal();
+        return Status::success;
+    }
+
+    Status
+    DeserializeFromFile(const std::string& filename, const Config& config) override {
+        LOG_KNOWHERE_ERROR_ << "ascend FlatInt8IndexNode DeserializeFromFile not implemented";
+        return Status::not_implemented;
+    }
+
+    std::unique_ptr<BaseConfig>
+    CreateConfig() const override {
+        return std::make_unique<FlatInt8Config>();
+    }
+
+    int64_t
+    Dim() const override {
+        return static_cast<int64_t>(index_->getDim());
+    }
+
+    int64_t
+    Size() const override {
+        return index_->getNTotal() * static_cast<int64_t>(index_->getDim()) * static_cast<int64_t>(sizeof(int8_t));
+    }
+
+    int64_t
+    Count() const override {
+        return index_->getNTotal();
+    }
+
+    std::string
+    Type() const override {
+        return knowhere::IndexEnum::INDEX_ASCEND_FLAT_INT8;
+    }
+
+    ~FlatInt8IndexNode() override {
+        std::lock_guard<std::mutex> lk(mtx);
+        LOG_KNOWHERE_INFO_ << "ascend FlatInt8IndexNode Deconstruct:"
+            << std::this_thread::get_id() << " this:" << int64_t(this) << " ntotal:" << index_->getNTotal();
+        try {
+            int32_t device_id = index_->getDeviceList()[0];
+            std::lock_guard<std::mutex> lk(*(ascend_device_manager::instance().get_dev_mutex_ptr(device_id)));
+            RELEASE_ASCEND_DEVICE(device_id, this->load_);
+        } catch (const std::exception& e) {
+            LOG_KNOWHERE_WARNING_ << "error inner ascend, " << e.what();
+        }
+    }
+
+ private:
+    void Quantization(const float *in, int64_t nq, int64_t dim, int8_t *out) const {
+        const int scale = 255;
+        std::vector<folly::Future<folly::Unit>> futs;
+        futs.reserve(nq);
+        for (int64_t i = 0; i < nq; i++) {
+            futs.push_back(pool_->push([&, index = i] {
+                for (int64_t j = 0; j < dim; j++) {
+                    int64_t offset = index * dim + j;
+                    float tmp = round(in[offset] * scale);
+                    out[offset] = std::min<int8_t>(127, std::max<int8_t>(-127, tmp));
+                }
+            }));
+        }
+        for (auto& fut : futs) {
+            fut.wait();
+        }
+    }
+
+    void Bitset2Mask(const BitsetView& bitset, int64_t nq, uint8_t *mask) const {
+        size_t byte_size = bitset.byte_size();
+        const uint8_t *bits = bitset.data();
+
+        std::vector<folly::Future<folly::Unit>> futs;
+        futs.reserve(nq);
+        for (size_t i = 0; i < size_t(nq); i++) {
+            futs.push_back(pool_->push([&, index = i] {
+                for (size_t j = 0; j < byte_size; j++) {
+                    mask[index * byte_size + j] = ~(bits[j]);
+                }
+            }));
+        }
+        for (auto& fut : futs) {
+            fut.wait();
+        }
+    }
+
+ private:
+    std::unique_ptr<faiss::ascend::AscendIndexInt8Flat> index_;
+    std::shared_ptr<ThreadPool> pool_;
+    size_t load_ = 0;
+};
+
+KNOWHERE_REGISTER_GLOBAL(ASCEND_FLAT_INT8,
+                         [](const int32_t& version, const Object& object) { 
+    return Index<FlatInt8IndexNode>::Create(version, object);
+});
+
+}  // namespace knowhere
diff --git a/src/index/ascend/flatint8_config.h b/src/index/ascend/flatint8_config.h
new file mode 100644
index 00000000..8d5671be
--- /dev/null
+++ b/src/index/ascend/flatint8_config.h
@@ -0,0 +1,23 @@
+// Copyright (C) 2019-2023 Zilliz. All rights reserved.
+//
+// Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance
+// with the License. You may obtain a copy of the License at
+//
+// http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software distributed under the License
+// is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
+// or implied. See the License for the specific language governing permissions and limitations under the License.
+
+#ifndef FLAT_INT8_CONFIG_H
+#define FLAT_INT8_CONFIG_H
+
+#include "knowhere/config.h"
+
+namespace knowhere {
+
+class FlatInt8Config : public BaseConfig {};
+
+}  // namespace knowhere
+
+#endif /* FLAT_INT8_CONFIG_H */
diff --git a/src/index/data_view_dense_index/data_view_dense_index.h b/src/index/data_view_dense_index/data_view_dense_index.h
index d7360de6..3690e9f4 100644
--- a/src/index/data_view_dense_index/data_view_dense_index.h
+++ b/src/index/data_view_dense_index/data_view_dense_index.h
@@ -22,9 +22,9 @@
 #include <mutex>
 #include <shared_mutex>
 
-#include "faiss/impl/AuxIndexStructures.h"
-#include "faiss/impl/ResultHandler.h"
-#include "faiss/utils/distances_if.h"
+#include "knowherefaiss/impl/AuxIndexStructures.h"
+#include "knowherefaiss/impl/ResultHandler.h"
+#include "knowherefaiss/utils/distances_if.h"
 #include "index/data_view_dense_index/refine_computer.h"
 #include "knowhere/bitsetview_idselector.h"
 #include "knowhere/comp/thread_pool.h"
@@ -32,8 +32,8 @@
 #include "knowhere/operands.h"
 #include "knowhere/range_util.h"
 namespace knowhere {
-using CMAX = faiss::CMax<float, idx_t>;
-using CMIN = faiss::CMin<float, idx_t>;
+using CMAX = knowherefaiss::CMax<float, idx_t>;
+using CMIN = knowherefaiss::CMin<float, idx_t>;
 struct RangeSearchResult;
 /*
 DataViewIndexBase is is an index base class.
@@ -191,7 +191,7 @@ class DataViewIndexFlat : public DataViewIndexBase {
                             })
                             .getTry();
             if (task.hasException()) {
-                std::runtime_error(std::string("faiss internal error," + task.exception().what()));
+                std::runtime_error(std::string("knowherefaiss internal error," + task.exception().what()));
             }
         }
         return;
@@ -217,7 +217,7 @@ class DataViewIndexFlat : public DataViewIndexBase {
                             })
                             .getTry();
             if (task.hasException()) {
-                std::runtime_error(std::string("faiss internal error," + task.exception().what()));
+                std::runtime_error(std::string("knowherefaiss internal error," + task.exception().what()));
             }
         }
         if (is_cosine_) {
@@ -288,7 +288,7 @@ class DataViewIndexFlat : public DataViewIndexBase {
  protected:
     template <class SingleResultHandler, class SelectorHelper>
     void
-    exhaustive_search_in_one_query_impl(const std::unique_ptr<faiss::DistanceComputer>& computer, size_t ny,
+    exhaustive_search_in_one_query_impl(const std::unique_ptr<knowherefaiss::DistanceComputer>& computer, size_t ny,
                                         SingleResultHandler& resi, const SelectorHelper& selector) const;
 
  protected:
@@ -298,7 +298,7 @@ class DataViewIndexFlat : public DataViewIndexBase {
 
 template <class SingleResultHandler, class SelectorHelper>
 void
-DataViewIndexFlat::exhaustive_search_in_one_query_impl(const std::unique_ptr<faiss::DistanceComputer>& computer,
+DataViewIndexFlat::exhaustive_search_in_one_query_impl(const std::unique_ptr<knowherefaiss::DistanceComputer>& computer,
                                                        size_t ny, SingleResultHandler& resi,
                                                        const SelectorHelper& selector) const {
     auto filter = [&selector](const size_t j) { return selector.is_member(j); };
@@ -309,10 +309,10 @@ DataViewIndexFlat::exhaustive_search_in_one_query_impl(const std::unique_ptr<fai
             dis = dis / (norms_[j]);
             resi.add_result(dis, j);
         };
-        faiss::distance_compute_if(ny, computer.get(), filter, apply);
+        knowherefaiss::distance_compute_if(ny, computer.get(), filter, apply);
     } else {
         auto apply = [&resi](const float dis, const idx_t j) { resi.add_result(dis, j); };
-        faiss::distance_compute_if(ny, computer.get(), filter, apply);
+        knowherefaiss::distance_compute_if(ny, computer.get(), filter, apply);
     }
 }
 
@@ -323,19 +323,19 @@ DataViewIndexFlat::Search(const idx_t n, const void* __restrict x, const idx_t k
     const auto& search_pool = ThreadPool::GetGlobalSearchThreadPool();
     std::vector<folly::Future<folly::Unit>> futs;
     futs.reserve(n);
-    if (k < faiss::distance_compute_min_k_reservoir) {
+    if (k < knowherefaiss::distance_compute_min_k_reservoir) {
         if (metric_type_ == metric::L2) {
-            faiss::HeapBlockResultHandler<CMAX> res(n, distances, labels, k);
+            knowherefaiss::HeapBlockResultHandler<CMAX> res(n, distances, labels, k);
             for (auto i = 0; i < n; i++) {
                 futs.emplace_back(search_pool->push([&] {
                     ThreadPool::ScopedSearchOmpSetter setter(1);
-                    faiss::HeapBlockResultHandler<CMAX>::SingleResultHandler resi(res);
+                    knowherefaiss::HeapBlockResultHandler<CMAX>::SingleResultHandler resi(res);
                     auto computer = SelectDataViewComputer(view_data_, data_type_, metric_type_, d_, is_cosine_,
                                                            use_quant ? quant_data_ : nullptr);
                     computer->set_query((const float*)((const char*)x + code_size_ * i));
                     resi.begin(i);
                     if (bitset.empty()) {
-                        exhaustive_search_in_one_query_impl(computer, n, resi, faiss::IDSelectorAll());
+                        exhaustive_search_in_one_query_impl(computer, n, resi, knowherefaiss::IDSelectorAll());
                     } else {
                         exhaustive_search_in_one_query_impl(computer, n, resi, BitsetViewIDSelector(bitset));
                     }
@@ -344,17 +344,17 @@ DataViewIndexFlat::Search(const idx_t n, const void* __restrict x, const idx_t k
             }
             WaitAllSuccess(futs);
         } else {
-            faiss::HeapBlockResultHandler<CMIN> res(n, distances, labels, k);
+            knowherefaiss::HeapBlockResultHandler<CMIN> res(n, distances, labels, k);
             for (auto i = 0; i < n; i++) {
                 futs.emplace_back(search_pool->push([&] {
                     ThreadPool::ScopedSearchOmpSetter setter(1);
-                    faiss::HeapBlockResultHandler<CMIN>::SingleResultHandler resi(res);
+                    knowherefaiss::HeapBlockResultHandler<CMIN>::SingleResultHandler resi(res);
                     auto computer = SelectDataViewComputer(view_data_, data_type_, metric_type_, d_, is_cosine_,
                                                            use_quant ? quant_data_ : nullptr);
                     computer->set_query((const float*)((const char*)x + code_size_ * i));
                     resi.begin(i);
                     if (bitset.empty()) {
-                        exhaustive_search_in_one_query_impl(computer, n, resi, faiss::IDSelectorAll());
+                        exhaustive_search_in_one_query_impl(computer, n, resi, knowherefaiss::IDSelectorAll());
                     } else {
                         exhaustive_search_in_one_query_impl(computer, n, resi, BitsetViewIDSelector(bitset));
                     }
@@ -365,18 +365,18 @@ DataViewIndexFlat::Search(const idx_t n, const void* __restrict x, const idx_t k
         }
     } else {
         if (metric_type_ == metric::L2) {
-            faiss::ReservoirBlockResultHandler<CMAX> res(n, distances, labels, k);
+            knowherefaiss::ReservoirBlockResultHandler<CMAX> res(n, distances, labels, k);
 
             for (auto i = 0; i < n; i++) {
                 futs.emplace_back(search_pool->push([&] {
                     ThreadPool::ScopedSearchOmpSetter setter(1);
-                    faiss::ReservoirBlockResultHandler<CMAX>::SingleResultHandler resi(res);
+                    knowherefaiss::ReservoirBlockResultHandler<CMAX>::SingleResultHandler resi(res);
                     auto computer = SelectDataViewComputer(view_data_, data_type_, metric_type_, d_, is_cosine_,
                                                            use_quant ? quant_data_ : nullptr);
                     computer->set_query((const float*)((const char*)x + code_size_ * i));
                     resi.begin(i);
                     if (bitset.empty()) {
-                        exhaustive_search_in_one_query_impl(computer, n, resi, faiss::IDSelectorAll());
+                        exhaustive_search_in_one_query_impl(computer, n, resi, knowherefaiss::IDSelectorAll());
                     } else {
                         exhaustive_search_in_one_query_impl(computer, n, resi, BitsetViewIDSelector(bitset));
                     }
@@ -385,17 +385,17 @@ DataViewIndexFlat::Search(const idx_t n, const void* __restrict x, const idx_t k
             }
             WaitAllSuccess(futs);
         } else {
-            faiss::ReservoirBlockResultHandler<CMIN> res(n, distances, labels, k);
+            knowherefaiss::ReservoirBlockResultHandler<CMIN> res(n, distances, labels, k);
             for (auto i = 0; i < n; i++) {
                 futs.emplace_back(search_pool->push([&] {
                     ThreadPool::ScopedSearchOmpSetter setter(1);
-                    faiss::ReservoirBlockResultHandler<CMIN>::SingleResultHandler resi(res);
+                    knowherefaiss::ReservoirBlockResultHandler<CMIN>::SingleResultHandler resi(res);
                     auto computer = SelectDataViewComputer(view_data_, data_type_, metric_type_, d_, is_cosine_,
                                                            use_quant ? quant_data_ : nullptr);
                     computer->set_query((const float*)((const char*)x + code_size_ * i));
                     resi.begin(i);
                     if (bitset.empty()) {
-                        exhaustive_search_in_one_query_impl(computer, n, resi, faiss::IDSelectorAll());
+                        exhaustive_search_in_one_query_impl(computer, n, resi, knowherefaiss::IDSelectorAll());
                     } else {
                         exhaustive_search_in_one_query_impl(computer, n, resi, BitsetViewIDSelector(bitset));
                     }
@@ -438,10 +438,10 @@ DataViewIndexFlat::SearchWithIds(const idx_t n, const void* __restrict x, const
                 }
             }
             if (metric_type_ == metric::L2) {
-                faiss::reorder_2_heaps<CMAX>(1, k, out_ids + i * k, out_dist + i * k, base_n, base_ids,
+                knowherefaiss::reorder_2_heaps<CMAX>(1, k, out_ids + i * k, out_dist + i * k, base_n, base_ids,
                                              base_dist.get());
             } else {
-                faiss::reorder_2_heaps<CMIN>(1, k, out_ids + i * k, out_dist + i * k, base_n, base_ids,
+                knowherefaiss::reorder_2_heaps<CMIN>(1, k, out_ids + i * k, out_dist + i * k, base_n, base_ids,
                                              base_dist.get());
             }
         }));
@@ -474,13 +474,13 @@ DataViewIndexFlat::RangeSearch(const idx_t n, const void* __restrict x, const fl
                 ThreadPool::ScopedSearchOmpSetter setter(1);
                 auto computer = SelectDataViewComputer(view_data_, data_type_, metric_type_, d_, is_cosine_,
                                                        use_quant ? quant_data_ : nullptr);
-                faiss::RangeSearchResult res(1);
-                faiss::RangeSearchBlockResultHandler<CMAX> resh(&res, radius);
-                faiss::RangeSearchBlockResultHandler<CMAX>::SingleResultHandler reshi(resh);
+                knowherefaiss::RangeSearchResult res(1);
+                knowherefaiss::RangeSearchBlockResultHandler<CMAX> resh(&res, radius);
+                knowherefaiss::RangeSearchBlockResultHandler<CMAX>::SingleResultHandler reshi(resh);
                 computer->set_query(((const float*)x + code_size_ * i));
                 reshi.begin(i);
                 if (bitset.empty()) {
-                    exhaustive_search_in_one_query_impl(computer, n, reshi, faiss::IDSelectorAll());
+                    exhaustive_search_in_one_query_impl(computer, n, reshi, knowherefaiss::IDSelectorAll());
                 } else {
                     exhaustive_search_in_one_query_impl(computer, n, reshi, BitsetViewIDSelector(bitset));
                 }
@@ -505,13 +505,13 @@ DataViewIndexFlat::RangeSearch(const idx_t n, const void* __restrict x, const fl
                 ThreadPool::ScopedSearchOmpSetter setter(1);
                 auto computer = SelectDataViewComputer(view_data_, data_type_, metric_type_, d_, is_cosine_,
                                                        use_quant ? quant_data_ : nullptr);
-                faiss::RangeSearchResult res(1);
-                faiss::RangeSearchBlockResultHandler<CMIN> resh(&res, radius);
-                faiss::RangeSearchBlockResultHandler<CMIN>::SingleResultHandler reshi(resh);
+                knowherefaiss::RangeSearchResult res(1);
+                knowherefaiss::RangeSearchBlockResultHandler<CMIN> resh(&res, radius);
+                knowherefaiss::RangeSearchBlockResultHandler<CMIN>::SingleResultHandler reshi(resh);
                 computer->set_query(((const float*)x + code_size_ * i));
                 reshi.begin(i);
                 if (bitset.empty()) {
-                    exhaustive_search_in_one_query_impl(computer, n, reshi, faiss::IDSelectorAll());
+                    exhaustive_search_in_one_query_impl(computer, n, reshi, knowherefaiss::IDSelectorAll());
                 } else {
                     exhaustive_search_in_one_query_impl(computer, n, reshi, BitsetViewIDSelector(bitset));
                 }
diff --git a/src/index/data_view_dense_index/data_view_index_config.h b/src/index/data_view_dense_index/data_view_index_config.h
index b45c3894..2d59ca6f 100644
--- a/src/index/data_view_dense_index/data_view_index_config.h
+++ b/src/index/data_view_dense_index/data_view_index_config.h
@@ -37,7 +37,7 @@ class ScannWithDataViewRefinerConfig : public ScannConfig {
     }
     Status
     CheckAndAdjust(PARAM_TYPE param_type, std::string* err_msg) override {
-        if (!faiss::support_pq_fast_scan) {
+        if (!knowherefaiss::support_pq_fast_scan) {
             LOG_KNOWHERE_ERROR_ << "SCANN index is not supported on the current CPU model, avx2 support is "
                                    "needed for x86 arch.";
             return Status::invalid_instruction_set;
diff --git a/src/index/data_view_dense_index/index_node_with_data_view_refiner.h b/src/index/data_view_dense_index/index_node_with_data_view_refiner.h
index 71cccaf6..c346ab92 100644
--- a/src/index/data_view_dense_index/index_node_with_data_view_refiner.h
+++ b/src/index/data_view_dense_index/index_node_with_data_view_refiner.h
@@ -13,7 +13,7 @@
 #include <atomic>
 #include <random>
 
-#include "faiss/utils/random.h"
+#include "knowherefaiss/utils/random.h"
 #include "index/data_view_dense_index/data_view_dense_index.h"
 #include "index/data_view_dense_index/data_view_index_config.h"
 #include "knowhere/comp/rw_lock.h"
@@ -263,7 +263,7 @@ class IndexNodeWithDataViewRefiner : public IndexNode {
         std::shared_ptr<DataViewIndexFlat> refine_offset_index_ = nullptr;
         std::unique_ptr<DataType[]> copied_query_ = nullptr;
         IndexNode::IteratorPtr base_workspace_ = nullptr;
-        std::unique_ptr<faiss::DistanceComputer> refine_computer_ = nullptr;
+        std::unique_ptr<knowherefaiss::DistanceComputer> refine_computer_ = nullptr;
     };
     bool is_cosine_;
     ViewDataOp view_data_op_;
diff --git a/src/index/data_view_dense_index/refine_computer.h b/src/index/data_view_dense_index/refine_computer.h
index a03e171e..ae1d8e8e 100644
--- a/src/index/data_view_dense_index/refine_computer.h
+++ b/src/index/data_view_dense_index/refine_computer.h
@@ -12,9 +12,9 @@
 // knowhere-specific indices
 #pragma once
 
-#include "faiss/impl/DistanceComputer.h"
-#include "faiss/impl/ScalarQuantizer.h"
-#include "faiss/invlists/InvertedLists.h"
+#include "knowherefaiss/impl/DistanceComputer.h"
+#include "knowherefaiss/impl/ScalarQuantizer.h"
+#include "knowherefaiss/invlists/InvertedLists.h"
 #include "knowhere/comp/index_param.h"
 #include "knowhere/object.h"
 #include "knowhere/operands.h"
@@ -22,7 +22,7 @@
 #include "simd/hook.h"
 
 namespace knowhere {
-using idx_t = faiss::idx_t;
+using idx_t = knowherefaiss::idx_t;
 namespace {
 inline bool
 convert_data(const void* in_data, float* out_data, const DataFormatEnum data_type, const size_t n, const size_t dim) {
@@ -55,27 +55,27 @@ struct QuantRefine {
     QuantRefine(size_t d, DataFormatEnum data_type, RefineType refine_type, MetricType metric)
         : origin_data_type(data_type), refine_type(refine_type) {
         if (metric == metric::IP) {
-            metric_type = faiss::MetricType::METRIC_INNER_PRODUCT;
+            metric_type = knowherefaiss::MetricType::METRIC_INNER_PRODUCT;
         } else if (metric == metric::L2) {
-            metric_type = faiss::MetricType::METRIC_L2;
+            metric_type = knowherefaiss::MetricType::METRIC_L2;
         } else {
             throw std::runtime_error("QuantRefine only support metric L2 and IP.");
         }
         switch (refine_type) {
             case RefineType::UINT8_QUANT:
-                quantizer = new faiss::ScalarQuantizer(d, faiss::ScalarQuantizer::QuantizerType::QT_8bit);
+                quantizer = new knowherefaiss::ScalarQuantizer(d, knowherefaiss::ScalarQuantizer::QuantizerType::QT_8bit);
                 break;
             case RefineType::BFLOAT16_QUANT:
-                quantizer = new faiss::ScalarQuantizer(d, faiss::ScalarQuantizer::QuantizerType::QT_bf16);
+                quantizer = new knowherefaiss::ScalarQuantizer(d, knowherefaiss::ScalarQuantizer::QuantizerType::QT_bf16);
                 break;
             case RefineType::FLOAT16_QUANT:
-                quantizer = new faiss::ScalarQuantizer(d, faiss::ScalarQuantizer::QuantizerType::QT_fp16);
+                quantizer = new knowherefaiss::ScalarQuantizer(d, knowherefaiss::ScalarQuantizer::QuantizerType::QT_fp16);
                 break;
             default:
                 throw std::runtime_error("Fail to generate quant for refiner if refine_type == RefineType::DATA_VIEW");
                 break;
         }
-        storage = new faiss::ConcurrentArrayInvertedLists(list_num, quantizer->code_size, segment_size, false);
+        storage = new knowherefaiss::ConcurrentArrayInvertedLists(list_num, quantizer->code_size, segment_size, false);
     }
     void
     Train(const void* train_data, const size_t n) {
@@ -110,13 +110,13 @@ struct QuantRefine {
     GetCode(size_t id) {
         return storage->get_codes(key, id);
     }
-    faiss::MetricType
+    knowherefaiss::MetricType
     GetMetric() {
         return metric_type;
     }
-    std::unique_ptr<faiss::ScalarQuantizer::SQDistanceComputer>
+    std::unique_ptr<knowherefaiss::ScalarQuantizer::SQDistanceComputer>
     GetQuantComputer() {
-        return std::unique_ptr<faiss::ScalarQuantizer::SQDistanceComputer>(
+        return std::unique_ptr<knowherefaiss::ScalarQuantizer::SQDistanceComputer>(
             quantizer->get_distance_computer(metric_type));
     }
     DataFormatEnum
@@ -137,19 +137,19 @@ struct QuantRefine {
     static constexpr size_t key = 0;
     static constexpr size_t list_num = 1;
     static constexpr size_t segment_size = 48;
-    faiss::ScalarQuantizer* quantizer = nullptr;
-    faiss::InvertedLists* storage = nullptr;
-    faiss::MetricType metric_type;
+    knowherefaiss::ScalarQuantizer* quantizer = nullptr;
+    knowherefaiss::InvertedLists* storage = nullptr;
+    knowherefaiss::MetricType metric_type;
     DataFormatEnum origin_data_type;
     RefineType refine_type;
 };
 
 // refine computer only use in single thread
 template <bool NeedNormalize = false>
-struct QuantDataDistanceComputer : faiss::DistanceComputer {
+struct QuantDataDistanceComputer : knowherefaiss::DistanceComputer {
     std::vector<float> query_buf;
     std::shared_ptr<QuantRefine> quant_data;
-    std::unique_ptr<faiss::ScalarQuantizer::SQDistanceComputer> qc;
+    std::unique_ptr<knowherefaiss::ScalarQuantizer::SQDistanceComputer> qc;
     float q_norm;
     size_t dim;
 
@@ -218,7 +218,7 @@ struct QuantDataDistanceComputer : faiss::DistanceComputer {
 };
 
 template <typename DataType, typename Distance1, typename Distance4, bool NeedNormalize = false>
-struct DataViewDistanceComputer : faiss::DistanceComputer {
+struct DataViewDistanceComputer : knowherefaiss::DistanceComputer {
     ViewDataOp view_data;
     size_t dim;
     const DataType* q;
@@ -292,70 +292,70 @@ struct DataViewDistanceComputer : faiss::DistanceComputer {
     }
 };
 
-static std::unique_ptr<faiss::DistanceComputer>
+static std::unique_ptr<knowherefaiss::DistanceComputer>
 SelectDataViewComputer(const ViewDataOp& view_data, const DataFormatEnum& data_type, const knowhere::MetricType& metric,
                        const size_t dim, bool is_cosine, const std::shared_ptr<QuantRefine> quant = nullptr) {
     if (quant) {
         if (is_cosine) {
-            return std::unique_ptr<faiss::DistanceComputer>(new QuantDataDistanceComputer<true>(quant, dim));
+            return std::unique_ptr<knowherefaiss::DistanceComputer>(new QuantDataDistanceComputer<true>(quant, dim));
         } else {
-            return std::unique_ptr<faiss::DistanceComputer>(new QuantDataDistanceComputer<false>(quant, dim));
+            return std::unique_ptr<knowherefaiss::DistanceComputer>(new QuantDataDistanceComputer<false>(quant, dim));
         }
     } else if (data_type == DataFormatEnum::fp16) {
         if (metric == metric::IP) {
             if (is_cosine) {
-                return std::unique_ptr<faiss::DistanceComputer>(
-                    new DataViewDistanceComputer<fp16, decltype(faiss::fp16_vec_inner_product),
-                                                 decltype(faiss::fp16_vec_inner_product_batch_4), true>(
-                        view_data, dim, faiss::fp16_vec_inner_product, faiss::fp16_vec_inner_product_batch_4));
+                return std::unique_ptr<knowherefaiss::DistanceComputer>(
+                    new DataViewDistanceComputer<fp16, decltype(knowherefaiss::fp16_vec_inner_product),
+                                                 decltype(knowherefaiss::fp16_vec_inner_product_batch_4), true>(
+                        view_data, dim, knowherefaiss::fp16_vec_inner_product, knowherefaiss::fp16_vec_inner_product_batch_4));
             } else {
-                return std::unique_ptr<faiss::DistanceComputer>(
-                    new DataViewDistanceComputer<fp16, decltype(faiss::fp16_vec_inner_product),
-                                                 decltype(faiss::fp16_vec_inner_product_batch_4), false>(
-                        view_data, dim, faiss::fp16_vec_inner_product, faiss::fp16_vec_inner_product_batch_4));
+                return std::unique_ptr<knowherefaiss::DistanceComputer>(
+                    new DataViewDistanceComputer<fp16, decltype(knowherefaiss::fp16_vec_inner_product),
+                                                 decltype(knowherefaiss::fp16_vec_inner_product_batch_4), false>(
+                        view_data, dim, knowherefaiss::fp16_vec_inner_product, knowherefaiss::fp16_vec_inner_product_batch_4));
             }
         } else {
-            return std::unique_ptr<faiss::DistanceComputer>(
-                new DataViewDistanceComputer<fp16, decltype(faiss::fp16_vec_L2sqr),
-                                             decltype(faiss::fp16_vec_L2sqr_batch_4)>(
-                    view_data, dim, faiss::fp16_vec_L2sqr, faiss::fp16_vec_L2sqr_batch_4));
+            return std::unique_ptr<knowherefaiss::DistanceComputer>(
+                new DataViewDistanceComputer<fp16, decltype(knowherefaiss::fp16_vec_L2sqr),
+                                             decltype(knowherefaiss::fp16_vec_L2sqr_batch_4)>(
+                    view_data, dim, knowherefaiss::fp16_vec_L2sqr, knowherefaiss::fp16_vec_L2sqr_batch_4));
         }
     } else if (data_type == DataFormatEnum::bf16) {
         if (metric == metric::IP) {
             if (is_cosine) {
-                return std::unique_ptr<faiss::DistanceComputer>(
-                    new DataViewDistanceComputer<bf16, decltype(faiss::bf16_vec_inner_product),
-                                                 decltype(faiss::bf16_vec_inner_product_batch_4), true>(
-                        view_data, dim, faiss::bf16_vec_inner_product, faiss::bf16_vec_inner_product_batch_4));
+                return std::unique_ptr<knowherefaiss::DistanceComputer>(
+                    new DataViewDistanceComputer<bf16, decltype(knowherefaiss::bf16_vec_inner_product),
+                                                 decltype(knowherefaiss::bf16_vec_inner_product_batch_4), true>(
+                        view_data, dim, knowherefaiss::bf16_vec_inner_product, knowherefaiss::bf16_vec_inner_product_batch_4));
             } else {
-                return std::unique_ptr<faiss::DistanceComputer>(
-                    new DataViewDistanceComputer<bf16, decltype(faiss::bf16_vec_inner_product),
-                                                 decltype(faiss::bf16_vec_inner_product_batch_4), false>(
-                        view_data, dim, faiss::bf16_vec_inner_product, faiss::bf16_vec_inner_product_batch_4));
+                return std::unique_ptr<knowherefaiss::DistanceComputer>(
+                    new DataViewDistanceComputer<bf16, decltype(knowherefaiss::bf16_vec_inner_product),
+                                                 decltype(knowherefaiss::bf16_vec_inner_product_batch_4), false>(
+                        view_data, dim, knowherefaiss::bf16_vec_inner_product, knowherefaiss::bf16_vec_inner_product_batch_4));
             }
         } else {
-            return std::unique_ptr<faiss::DistanceComputer>(
-                new DataViewDistanceComputer<bf16, decltype(faiss::bf16_vec_L2sqr),
-                                             decltype(faiss::bf16_vec_L2sqr_batch_4)>(
-                    view_data, dim, faiss::bf16_vec_L2sqr, faiss::bf16_vec_L2sqr_batch_4));
+            return std::unique_ptr<knowherefaiss::DistanceComputer>(
+                new DataViewDistanceComputer<bf16, decltype(knowherefaiss::bf16_vec_L2sqr),
+                                             decltype(knowherefaiss::bf16_vec_L2sqr_batch_4)>(
+                    view_data, dim, knowherefaiss::bf16_vec_L2sqr, knowherefaiss::bf16_vec_L2sqr_batch_4));
         }
     } else if (data_type == DataFormatEnum::fp32) {
         if (metric == metric::IP) {
             if (is_cosine) {
-                return std::unique_ptr<faiss::DistanceComputer>(
-                    new DataViewDistanceComputer<fp32, decltype(faiss::fvec_inner_product),
-                                                 decltype(faiss::fvec_inner_product_batch_4), true>(
-                        view_data, dim, faiss::fvec_inner_product, faiss::fvec_inner_product_batch_4));
+                return std::unique_ptr<knowherefaiss::DistanceComputer>(
+                    new DataViewDistanceComputer<fp32, decltype(knowherefaiss::fvec_inner_product),
+                                                 decltype(knowherefaiss::fvec_inner_product_batch_4), true>(
+                        view_data, dim, knowherefaiss::fvec_inner_product, knowherefaiss::fvec_inner_product_batch_4));
             } else {
-                return std::unique_ptr<faiss::DistanceComputer>(
-                    new DataViewDistanceComputer<fp32, decltype(faiss::fvec_inner_product),
-                                                 decltype(faiss::fvec_inner_product_batch_4), false>(
-                        view_data, dim, faiss::fvec_inner_product, faiss::fvec_inner_product_batch_4));
+                return std::unique_ptr<knowherefaiss::DistanceComputer>(
+                    new DataViewDistanceComputer<fp32, decltype(knowherefaiss::fvec_inner_product),
+                                                 decltype(knowherefaiss::fvec_inner_product_batch_4), false>(
+                        view_data, dim, knowherefaiss::fvec_inner_product, knowherefaiss::fvec_inner_product_batch_4));
             }
         } else {
-            return std::unique_ptr<faiss::DistanceComputer>(
-                new DataViewDistanceComputer<fp32, decltype(faiss::fvec_L2sqr), decltype(faiss::fvec_L2sqr_batch_4)>(
-                    view_data, dim, faiss::fvec_L2sqr, faiss::fvec_L2sqr_batch_4));
+            return std::unique_ptr<knowherefaiss::DistanceComputer>(
+                new DataViewDistanceComputer<fp32, decltype(knowherefaiss::fvec_L2sqr), decltype(knowherefaiss::fvec_L2sqr_batch_4)>(
+                    view_data, dim, knowherefaiss::fvec_L2sqr, knowherefaiss::fvec_L2sqr_batch_4));
         }
     } else {
         return nullptr;
diff --git a/src/index/flat/flat.cc b/src/index/flat/flat.cc
index 59a8c66e..356298a2 100644
--- a/src/index/flat/flat.cc
+++ b/src/index/flat/flat.cc
@@ -10,10 +10,10 @@
 // or implied. See the License for the specific language governing permissions and limitations under the License.
 
 #include "common/metric.h"
-#include "faiss/IndexBinaryFlat.h"
-#include "faiss/IndexFlat.h"
-#include "faiss/impl/AuxIndexStructures.h"
-#include "faiss/index_io.h"
+#include "knowherefaiss/IndexBinaryFlat.h"
+#include "knowherefaiss/IndexFlat.h"
+#include "knowherefaiss/impl/AuxIndexStructures.h"
+#include "knowherefaiss/index_io.h"
 #include "index/flat/flat_config.h"
 #include "io/memory_io.h"
 #include "knowhere/bitsetview_idselector.h"
@@ -32,7 +32,7 @@ class FlatIndexNode : public IndexNode {
  public:
     FlatIndexNode(const int32_t version, const Object& object) : IndexNode(version), index_(nullptr) {
         static_assert(
-            std::is_same<IndexType, faiss::IndexFlat>::value || std::is_same<IndexType, faiss::IndexBinaryFlat>::value,
+            std::is_same<IndexType, knowherefaiss::IndexFlat>::value || std::is_same<IndexType, knowherefaiss::IndexBinaryFlat>::value,
             "not support");
         static_assert(std::is_same_v<DataType, fp32> || std::is_same_v<DataType, bin1>,
                       "FlatIndexNode only support float/binary");
@@ -48,12 +48,12 @@ class FlatIndexNode : public IndexNode {
             LOG_KNOWHERE_ERROR_ << "unsupported metric type: " << f_cfg.metric_type.value();
             return metric.error();
         }
-        if constexpr (std::is_same<faiss::IndexBinaryFlat, IndexType>::value) {
-            index_ = std::make_unique<faiss::IndexBinaryFlat>(dataset->GetDim(), metric.value());
+        if constexpr (std::is_same<knowherefaiss::IndexBinaryFlat, IndexType>::value) {
+            index_ = std::make_unique<knowherefaiss::IndexBinaryFlat>(dataset->GetDim(), metric.value());
         }
-        if constexpr (std::is_same<faiss::IndexFlat, IndexType>::value) {
+        if constexpr (std::is_same<knowherefaiss::IndexFlat, IndexType>::value) {
             bool is_cosine = IsMetricType(f_cfg.metric_type.value(), knowhere::metric::COSINE);
-            index_ = std::make_unique<faiss::IndexFlat>(dataset->GetDim(), metric.value(), is_cosine);
+            index_ = std::make_unique<knowherefaiss::IndexFlat>(dataset->GetDim(), metric.value(), is_cosine);
         }
         return Status::success;
     }
@@ -97,9 +97,9 @@ class FlatIndexNode : public IndexNode {
                     auto cur_dis = distances + k * index;
 
                     BitsetViewIDSelector bw_idselector(bitset);
-                    faiss::IDSelector* id_selector = (bitset.empty()) ? nullptr : &bw_idselector;
+                    knowherefaiss::IDSelector* id_selector = (bitset.empty()) ? nullptr : &bw_idselector;
 
-                    if constexpr (std::is_same<IndexType, faiss::IndexFlat>::value) {
+                    if constexpr (std::is_same<IndexType, knowherefaiss::IndexFlat>::value) {
                         auto cur_query = (const DataType*)x + dim * index;
                         std::unique_ptr<DataType[]> copied_query = nullptr;
                         if (is_cosine) {
@@ -107,21 +107,21 @@ class FlatIndexNode : public IndexNode {
                             cur_query = copied_query.get();
                         }
 
-                        faiss::SearchParameters search_params;
+                        knowherefaiss::SearchParameters search_params;
                         search_params.sel = id_selector;
 
                         index_->search(1, cur_query, k, cur_dis, cur_ids, &search_params);
                     }
-                    if constexpr (std::is_same<IndexType, faiss::IndexBinaryFlat>::value) {
+                    if constexpr (std::is_same<IndexType, knowherefaiss::IndexBinaryFlat>::value) {
                         auto cur_i_dis = reinterpret_cast<int32_t*>(cur_dis);
 
-                        faiss::SearchParameters search_params;
+                        knowherefaiss::SearchParameters search_params;
                         search_params.sel = id_selector;
 
                         index_->search(1, (const uint8_t*)x + index * ((dim + 7) / 8), k, cur_i_dis, cur_ids,
                                        &search_params);
 
-                        if (index_->metric_type == faiss::METRIC_Hamming) {
+                        if (index_->metric_type == knowherefaiss::METRIC_Hamming) {
                             for (int64_t j = 0; j < k; j++) {
                                 cur_dis[j] = static_cast<float>(cur_i_dis[j]);
                             }
@@ -134,7 +134,7 @@ class FlatIndexNode : public IndexNode {
         } catch (const std::exception& e) {
             std::unique_ptr<int64_t[]> auto_delete_ids(ids);
             std::unique_ptr<float[]> auto_delete_dis(distances);
-            LOG_KNOWHERE_WARNING_ << "error inner faiss: " << e.what();
+            LOG_KNOWHERE_WARNING_ << "error inner knowherefaiss: " << e.what();
             return expected<DataSetPtr>::Err(Status::faiss_inner_error, e.what());
         }
         return GenResultDataSet(nq, k, ids, distances);
@@ -156,7 +156,7 @@ class FlatIndexNode : public IndexNode {
 
         float radius = f_cfg.radius.value();
         float range_filter = f_cfg.range_filter.value();
-        bool is_ip = (index_->metric_type == faiss::METRIC_INNER_PRODUCT);
+        bool is_ip = (index_->metric_type == knowherefaiss::METRIC_INNER_PRODUCT);
 
         RangeSearchResult range_search_result;
 
@@ -169,12 +169,12 @@ class FlatIndexNode : public IndexNode {
             for (int i = 0; i < nq; ++i) {
                 futs.emplace_back(search_pool_->push([&, index = i] {
                     ThreadPool::ScopedSearchOmpSetter setter(1);
-                    faiss::RangeSearchResult res(1);
+                    knowherefaiss::RangeSearchResult res(1);
 
                     BitsetViewIDSelector bw_idselector(bitset);
-                    faiss::IDSelector* id_selector = (bitset.empty()) ? nullptr : &bw_idselector;
+                    knowherefaiss::IDSelector* id_selector = (bitset.empty()) ? nullptr : &bw_idselector;
 
-                    if constexpr (std::is_same<IndexType, faiss::IndexFlat>::value) {
+                    if constexpr (std::is_same<IndexType, knowherefaiss::IndexFlat>::value) {
                         auto cur_query = (const DataType*)xq + dim * index;
                         std::unique_ptr<DataType[]> copied_query = nullptr;
                         if (is_cosine) {
@@ -182,13 +182,13 @@ class FlatIndexNode : public IndexNode {
                             cur_query = copied_query.get();
                         }
 
-                        faiss::SearchParameters search_params;
+                        knowherefaiss::SearchParameters search_params;
                         search_params.sel = id_selector;
 
                         index_->range_search(1, cur_query, radius, &res, &search_params);
                     }
-                    if constexpr (std::is_same<IndexType, faiss::IndexBinaryFlat>::value) {
-                        faiss::SearchParameters search_params;
+                    if constexpr (std::is_same<IndexType, knowherefaiss::IndexBinaryFlat>::value) {
+                        knowherefaiss::SearchParameters search_params;
                         search_params.sel = id_selector;
 
                         index_->range_search(1, (const uint8_t*)xq + index * ((dim + 7) / 8), radius, &res,
@@ -212,7 +212,7 @@ class FlatIndexNode : public IndexNode {
             range_search_result =
                 GetRangeSearchResult(result_dist_array, result_id_array, is_ip, nq, radius, range_filter);
         } catch (const std::exception& e) {
-            LOG_KNOWHERE_WARNING_ << "error inner faiss: " << e.what();
+            LOG_KNOWHERE_WARNING_ << "error inner knowherefaiss: " << e.what();
             return expected<DataSetPtr>::Err(Status::faiss_inner_error, e.what());
         }
 
@@ -224,7 +224,7 @@ class FlatIndexNode : public IndexNode {
         auto dim = Dim();
         auto rows = dataset->GetRows();
         auto ids = dataset->GetIds();
-        if constexpr (std::is_same<IndexType, faiss::IndexFlat>::value) {
+        if constexpr (std::is_same<IndexType, knowherefaiss::IndexFlat>::value) {
             DataType* data = nullptr;
             try {
                 data = new DataType[rows * dim];
@@ -234,11 +234,11 @@ class FlatIndexNode : public IndexNode {
                 return GenResultDataSet(rows, dim, data);
             } catch (const std::exception& e) {
                 std::unique_ptr<DataType[]> auto_del(data);
-                LOG_KNOWHERE_WARNING_ << "faiss inner error: " << e.what();
+                LOG_KNOWHERE_WARNING_ << "knowherefaiss inner error: " << e.what();
                 return expected<DataSetPtr>::Err(Status::faiss_inner_error, e.what());
             }
         }
-        if constexpr (std::is_same<IndexType, faiss::IndexBinaryFlat>::value) {
+        if constexpr (std::is_same<IndexType, knowherefaiss::IndexBinaryFlat>::value) {
             uint8_t* data = nullptr;
             try {
                 data = new uint8_t[rows * ((dim + 7) / 8)];
@@ -248,7 +248,7 @@ class FlatIndexNode : public IndexNode {
                 return GenResultDataSet(rows, dim, data);
             } catch (const std::exception& e) {
                 std::unique_ptr<uint8_t[]> auto_del(data);
-                LOG_KNOWHERE_WARNING_ << "error inner faiss: " << e.what();
+                LOG_KNOWHERE_WARNING_ << "error inner knowherefaiss: " << e.what();
                 return expected<DataSetPtr>::Err(Status::faiss_inner_error, e.what());
             }
         }
@@ -256,7 +256,7 @@ class FlatIndexNode : public IndexNode {
 
     static bool
     StaticHasRawData(const knowhere::BaseConfig& config, const IndexVersion& version) {
-        if constexpr (std::is_same<IndexType, faiss::IndexFlat>::value) {
+        if constexpr (std::is_same<IndexType, knowherefaiss::IndexFlat>::value) {
             const FlatConfig& f_cfg = static_cast<const FlatConfig&>(config);
             if (knowhere::Version(version) <= Version::GetMinimalVersion()) {
                 return !IsMetricType(f_cfg.metric_type.value(), metric::COSINE);
@@ -265,21 +265,21 @@ class FlatIndexNode : public IndexNode {
             }
         }
 
-        if constexpr (std::is_same<IndexType, faiss::IndexBinaryFlat>::value) {
+        if constexpr (std::is_same<IndexType, knowherefaiss::IndexBinaryFlat>::value) {
             return true;
         }
     }
 
     bool
     HasRawData(const std::string& metric_type) const override {
-        if constexpr (std::is_same<IndexType, faiss::IndexFlat>::value) {
+        if constexpr (std::is_same<IndexType, knowherefaiss::IndexFlat>::value) {
             if (this->version_ <= Version::GetMinimalVersion()) {
                 return !IsMetricType(metric_type, metric::COSINE);
             } else {
                 return true;
             }
         }
-        if constexpr (std::is_same<IndexType, faiss::IndexBinaryFlat>::value) {
+        if constexpr (std::is_same<IndexType, knowherefaiss::IndexBinaryFlat>::value) {
             return true;
         }
     }
@@ -297,17 +297,17 @@ class FlatIndexNode : public IndexNode {
         }
         try {
             MemoryIOWriter writer;
-            if constexpr (std::is_same<IndexType, faiss::IndexFlat>::value) {
-                faiss::write_index(index_.get(), &writer);
+            if constexpr (std::is_same<IndexType, knowherefaiss::IndexFlat>::value) {
+                knowherefaiss::write_index(index_.get(), &writer);
             }
-            if constexpr (std::is_same<IndexType, faiss::IndexBinaryFlat>::value) {
-                faiss::write_index_binary(index_.get(), &writer);
+            if constexpr (std::is_same<IndexType, knowherefaiss::IndexBinaryFlat>::value) {
+                knowherefaiss::write_index_binary(index_.get(), &writer);
             }
             std::shared_ptr<uint8_t[]> data(writer.data());
             binset.Append(Type(), data, writer.tellg());
             return Status::success;
         } catch (const std::exception& e) {
-            LOG_KNOWHERE_WARNING_ << "error inner faiss: " << e.what();
+            LOG_KNOWHERE_WARNING_ << "error inner knowherefaiss: " << e.what();
             return Status::faiss_inner_error;
         }
     }
@@ -324,12 +324,12 @@ class FlatIndexNode : public IndexNode {
         }
 
         MemoryIOReader reader(binary->data.get(), binary->size);
-        if constexpr (std::is_same<IndexType, faiss::IndexFlat>::value) {
-            faiss::Index* index = faiss::read_index(&reader);
+        if constexpr (std::is_same<IndexType, knowherefaiss::IndexFlat>::value) {
+            knowherefaiss::Index* index = knowherefaiss::read_index(&reader);
             index_.reset(static_cast<IndexType*>(index));
         }
-        if constexpr (std::is_same<IndexType, faiss::IndexBinaryFlat>::value) {
-            faiss::IndexBinary* index = faiss::read_index_binary(&reader);
+        if constexpr (std::is_same<IndexType, knowherefaiss::IndexBinaryFlat>::value) {
+            knowherefaiss::IndexBinary* index = knowherefaiss::read_index_binary(&reader);
             index_.reset(static_cast<IndexType*>(index));
         }
         return Status::success;
@@ -341,15 +341,15 @@ class FlatIndexNode : public IndexNode {
 
         int io_flags = 0;
         if (flat_cfg.enable_mmap.value()) {
-            io_flags |= faiss::IO_FLAG_MMAP_IFC;
+            io_flags |= knowherefaiss::IO_FLAG_MMAP_IFC;
         }
 
-        if constexpr (std::is_same<IndexType, faiss::IndexFlat>::value) {
-            faiss::Index* index = faiss::read_index(filename.data(), io_flags);
+        if constexpr (std::is_same<IndexType, knowherefaiss::IndexFlat>::value) {
+            knowherefaiss::Index* index = knowherefaiss::read_index(filename.data(), io_flags);
             index_.reset(static_cast<IndexType*>(index));
         }
-        if constexpr (std::is_same<IndexType, faiss::IndexBinaryFlat>::value) {
-            faiss::IndexBinary* index = faiss::read_index_binary(filename.data(), io_flags);
+        if constexpr (std::is_same<IndexType, knowherefaiss::IndexBinaryFlat>::value) {
+            knowherefaiss::IndexBinary* index = knowherefaiss::read_index_binary(filename.data(), io_flags);
             index_.reset(static_cast<IndexType*>(index));
         }
         return Status::success;
@@ -382,10 +382,10 @@ class FlatIndexNode : public IndexNode {
 
     std::string
     Type() const override {
-        if constexpr (std::is_same<IndexType, faiss::IndexFlat>::value) {
+        if constexpr (std::is_same<IndexType, knowherefaiss::IndexFlat>::value) {
             return knowhere::IndexEnum::INDEX_FAISS_IDMAP;
         }
-        if constexpr (std::is_same<IndexType, faiss::IndexBinaryFlat>::value) {
+        if constexpr (std::is_same<IndexType, knowherefaiss::IndexBinaryFlat>::value) {
             return knowhere::IndexEnum::INDEX_FAISS_BIN_IDMAP;
         }
     }
@@ -398,18 +398,18 @@ class FlatIndexNode : public IndexNode {
 KNOWHERE_MOCK_REGISTER_DENSE_FLOAT_ALL_GLOBAL(FLAT, FlatIndexNode,
                                               knowhere::feature::NO_TRAIN | knowhere::feature::KNN |
                                                   knowhere::feature::MMAP,
-                                              faiss::IndexFlat);
+                                              knowherefaiss::IndexFlat);
 
 KNOWHERE_MOCK_REGISTER_DENSE_INT_GLOBAL(FLAT, FlatIndexNode,
                                         knowhere::feature::NO_TRAIN | knowhere::feature::KNN | knowhere::feature::MMAP,
-                                        faiss::IndexFlat);
+                                        knowherefaiss::IndexFlat);
 
 KNOWHERE_SIMPLE_REGISTER_DENSE_BIN_GLOBAL(BINFLAT, FlatIndexNode,
                                           knowhere::feature::NO_TRAIN | knowhere::feature::KNN |
                                               knowhere::feature::MMAP,
-                                          faiss::IndexBinaryFlat);
+                                          knowherefaiss::IndexBinaryFlat);
 KNOWHERE_SIMPLE_REGISTER_DENSE_BIN_GLOBAL(BIN_FLAT, FlatIndexNode,
                                           knowhere::feature::NO_TRAIN | knowhere::feature::KNN |
                                               knowhere::feature::MMAP,
-                                          faiss::IndexBinaryFlat);
+                                          knowherefaiss::IndexBinaryFlat);
 }  // namespace knowhere
diff --git a/src/index/gpu/flat_gpu/flat_gpu.cc b/src/index/gpu/flat_gpu/flat_gpu.cc
index 07f35ee6..ec672cab 100644
--- a/src/index/gpu/flat_gpu/flat_gpu.cc
+++ b/src/index/gpu/flat_gpu/flat_gpu.cc
@@ -10,9 +10,9 @@
 // or implied. See the License for the specific language governing permissions and limitations under the License.
 
 #include "common/metric.h"
-#include "faiss/IndexFlat.h"
-#include "faiss/gpu/GpuCloner.h"
-#include "faiss/index_io.h"
+#include "knowherefaiss/IndexFlat.h"
+#include "knowherefaiss/gpu/GpuCloner.h"
+#include "knowherefaiss/index_io.h"
 #include "index/flat_gpu/flat_gpu_config.h"
 #include "index/gpu/gpu_res_mgr.h"
 #include "io/memory_io.h"
@@ -35,7 +35,7 @@ class GpuFlatIndexNode : public IndexNode {
             LOG_KNOWHERE_WARNING_ << "metric type error, " << f_cfg.metric_type;
             return metric.error();
         }
-        index_ = std::make_unique<faiss::IndexFlat>(dataset->GetDim(), metric.value());
+        index_ = std::make_unique<knowherefaiss::IndexFlat>(dataset->GetDim(), metric.value());
         return Status::success;
     }
 
@@ -47,7 +47,7 @@ class GpuFlatIndexNode : public IndexNode {
             index_->add(n, (const float*)x);
             // need not copy index from CPU to GPU for IDMAP
         } catch (const std::exception& e) {
-            LOG_KNOWHERE_WARNING_ << "faiss inner error, " << e.what();
+            LOG_KNOWHERE_WARNING_ << "knowherefaiss inner error, " << e.what();
             return Status::faiss_inner_error;
         }
         return Status::success;
@@ -75,7 +75,7 @@ class GpuFlatIndexNode : public IndexNode {
         } catch (const std::exception& e) {
             std::unique_ptr<int64_t[]> auto_delete_ids(ids);
             std::unique_ptr<float[]> auto_delete_dis(dis);
-            LOG_KNOWHERE_WARNING_ << "faiss inner error, " << e.what();
+            LOG_KNOWHERE_WARNING_ << "knowherefaiss inner error, " << e.what();
             return expected<DataSetPtr>::Err(Status::faiss_inner_error, e.what());
         }
 
@@ -101,7 +101,7 @@ class GpuFlatIndexNode : public IndexNode {
             }
             return GenResultDataSet(xq);
         } catch (const std::exception& e) {
-            LOG_KNOWHERE_WARNING_ << "faiss inner error: " << e.what();
+            LOG_KNOWHERE_WARNING_ << "knowherefaiss inner error: " << e.what();
             return expected<DataSetPtr>::Err(Status::faiss_inner_error, e.what());
         }
     }
@@ -120,11 +120,11 @@ class GpuFlatIndexNode : public IndexNode {
         try {
             MemoryIOWriter writer;
             // Serialize() is called after Add(), at this time index_ is CPU index actually
-            faiss::write_index(index_.get(), &writer);
+            knowherefaiss::write_index(index_.get(), &writer);
             std::shared_ptr<uint8_t[]> data(writer.data());
             binset.Append(Type(), data, writer.tellg());
         } catch (const std::exception& e) {
-            LOG_KNOWHERE_WARNING_ << "faiss inner error, " << e.what();
+            LOG_KNOWHERE_WARNING_ << "knowherefaiss inner error, " << e.what();
             return Status::faiss_inner_error;
         }
         return Status::success;
@@ -139,15 +139,15 @@ class GpuFlatIndexNode : public IndexNode {
         }
         MemoryIOReader reader(binary->data.get(), binary->size);
         try {
-            std::unique_ptr<faiss::Index> index(faiss::read_index(&reader));
+            std::unique_ptr<knowherefaiss::Index> index(knowherefaiss::read_index(&reader));
 
             auto gpu_res = GPUResMgr::GetInstance().GetRes();
             ResScope rs(gpu_res, true);
-            auto gpu_index = faiss::gpu::index_cpu_to_gpu(gpu_res->faiss_res_.get(), gpu_res->gpu_id_, index.get());
+            auto gpu_index = knowherefaiss::gpu::index_cpu_to_gpu(gpu_res->faiss_res_.get(), gpu_res->gpu_id_, index.get());
             index_.reset(gpu_index);
             res_ = gpu_res;
         } catch (const std::exception& e) {
-            LOG_KNOWHERE_WARNING_ << "faiss inner error, " << e.what();
+            LOG_KNOWHERE_WARNING_ << "knowherefaiss inner error, " << e.what();
             return Status::faiss_inner_error;
         }
 
@@ -192,7 +192,7 @@ class GpuFlatIndexNode : public IndexNode {
 
  private:
     mutable ResWPtr res_;
-    std::unique_ptr<faiss::Index> index_;
+    std::unique_ptr<knowherefaiss::Index> index_;
 };
 // GPU_FAISS_FLAT is deprecated
 }  // namespace knowhere
diff --git a/src/index/gpu/gpu_res_mgr.h b/src/index/gpu/gpu_res_mgr.h
index 15348563..c7bcdd99 100644
--- a/src/index/gpu/gpu_res_mgr.h
+++ b/src/index/gpu/gpu_res_mgr.h
@@ -11,7 +11,7 @@
 
 #pragma once
 
-#include <faiss/gpu/StandardGpuResources.h>
+#include <knowherefaiss/gpu/StandardGpuResources.h>
 #ifdef KNOWHERE_WITH_CUVS
 #include <rmm/cuda_device.hpp>
 #include <rmm/mr/device/device_memory_resource.hpp>
@@ -32,12 +32,12 @@ namespace knowhere {
 constexpr int64_t MB = 1LL << 20;
 
 struct Resource {
-    Resource(int64_t gpu_id, faiss::gpu::StandardGpuResources* r) : faiss_res_(r), gpu_id_(gpu_id) {
+    Resource(int64_t gpu_id, knowherefaiss::gpu::StandardGpuResources* r) : faiss_res_(r), gpu_id_(gpu_id) {
         static int64_t global_id = 0;
         id_ = global_id++;
     }
 
-    std::unique_ptr<faiss::gpu::StandardGpuResources> faiss_res_;
+    std::unique_ptr<knowherefaiss::gpu::StandardGpuResources> faiss_res_;
     int64_t id_;
     int64_t gpu_id_;
     std::mutex mutex_;
@@ -72,7 +72,7 @@ class GPUResMgr {
     void
     InitDevice(const int64_t gpu_id, const GPUParams& gpu_params) {
         // check gpu device validation
-        faiss::gpu::setCurrentDevice(gpu_id);
+        knowherefaiss::gpu::setCurrentDevice(gpu_id);
 
         gpu_id_ = gpu_id;
         gpu_params_.res_num_ = gpu_params.res_num_;
@@ -91,7 +91,7 @@ class GPUResMgr {
             std::lock_guard<std::mutex> lock(init_mutex_);
             if (!init_) {
                 for (int64_t i = 0; i < gpu_params_.res_num_; ++i) {
-                    auto gpu_res = new faiss::gpu::StandardGpuResources();
+                    auto gpu_res = new knowherefaiss::gpu::StandardGpuResources();
                     auto res = std::make_shared<Resource>(gpu_id_, gpu_res);
 
                     cudaStream_t s;
diff --git a/src/index/gpu/ivf_gpu/ivf_gpu.cc b/src/index/gpu/ivf_gpu/ivf_gpu.cc
index 001f1c7f..886d4d81 100644
--- a/src/index/gpu/ivf_gpu/ivf_gpu.cc
+++ b/src/index/gpu/ivf_gpu/ivf_gpu.cc
@@ -10,17 +10,17 @@
 // or implied. See the License for the specific language governing permissions and limitations under the License.
 
 #include "common/metric.h"
-#include "faiss/IndexFlat.h"
-#include "faiss/IndexIVFFlat.h"
-#include "faiss/IndexIVFPQ.h"
-#include "faiss/IndexReplicas.h"
-#include "faiss/IndexScalarQuantizer.h"
-#include "faiss/gpu/GpuCloner.h"
-#include "faiss/gpu/GpuIndexIVF.h"
-#include "faiss/gpu/GpuIndexIVFFlat.h"
-#include "faiss/gpu/GpuIndexIVFPQ.h"
-#include "faiss/gpu/GpuIndexIVFScalarQuantizer.h"
-#include "faiss/index_io.h"
+#include "knowherefaiss/IndexFlat.h"
+#include "knowherefaiss/IndexIVFFlat.h"
+#include "knowherefaiss/IndexIVFPQ.h"
+#include "knowherefaiss/IndexReplicas.h"
+#include "knowherefaiss/IndexScalarQuantizer.h"
+#include "knowherefaiss/gpu/GpuCloner.h"
+#include "knowherefaiss/gpu/GpuIndexIVF.h"
+#include "knowherefaiss/gpu/GpuIndexIVFFlat.h"
+#include "knowherefaiss/gpu/GpuIndexIVFPQ.h"
+#include "knowherefaiss/gpu/GpuIndexIVFScalarQuantizer.h"
+#include "knowherefaiss/index_io.h"
 #include "index/gpu/gpu_res_mgr.h"
 #include "index/ivf_gpu/ivf_gpu_config.h"
 #include "io/memory_io.h"
@@ -34,15 +34,15 @@ template <typename T>
 struct KnowhereConfigType {};
 
 template <>
-struct KnowhereConfigType<faiss::IndexIVFFlat> {
+struct KnowhereConfigType<knowherefaiss::IndexIVFFlat> {
     typedef GpuIvfFlatConfig Type;
 };
 template <>
-struct KnowhereConfigType<faiss::IndexIVFPQ> {
+struct KnowhereConfigType<knowherefaiss::IndexIVFPQ> {
     typedef GpuIvfPqConfig Type;
 };
 template <>
-struct KnowhereConfigType<faiss::IndexIVFScalarQuantizer> {
+struct KnowhereConfigType<knowherefaiss::IndexIVFScalarQuantizer> {
     typedef GpuIvfSqConfig Type;
 };
 
@@ -50,8 +50,8 @@ template <typename T>
 class GpuIvfIndexNode : public IndexNode {
  public:
     GpuIvfIndexNode(const int32_t& version, const Object& object) : index_(nullptr) {
-        static_assert(std::is_same<T, faiss::IndexIVFFlat>::value || std::is_same<T, faiss::IndexIVFPQ>::value ||
-                      std::is_same<T, faiss::IndexIVFScalarQuantizer>::value);
+        static_assert(std::is_same<T, knowherefaiss::IndexIVFFlat>::value || std::is_same<T, knowherefaiss::IndexIVFPQ>::value ||
+                      std::is_same<T, knowherefaiss::IndexIVFScalarQuantizer>::value);
     }
 
     Status
@@ -72,35 +72,35 @@ class GpuIvfIndexNode : public IndexNode {
             return metric.error();
         }
 
-        std::unique_ptr<faiss::Index> index;
+        std::unique_ptr<knowherefaiss::Index> index;
         try {
             auto gpu_res = GPUResMgr::GetInstance().GetRes();
             ResScope rs(gpu_res, true);
 
-            if constexpr (std::is_same<T, faiss::IndexIVFFlat>::value) {
-                faiss::gpu::GpuIndexIVFFlatConfig f_cfg;
+            if constexpr (std::is_same<T, knowherefaiss::IndexIVFFlat>::value) {
+                knowherefaiss::gpu::GpuIndexIVFFlatConfig f_cfg;
                 f_cfg.device = static_cast<int32_t>(gpu_res->gpu_id_);
-                index = std::make_unique<faiss::gpu::GpuIndexIVFFlat>(gpu_res->faiss_res_.get(), dim, ivf_gpu_cfg.nlist,
+                index = std::make_unique<knowherefaiss::gpu::GpuIndexIVFFlat>(gpu_res->faiss_res_.get(), dim, ivf_gpu_cfg.nlist,
                                                                       metric.value(), f_cfg);
             }
-            if constexpr (std::is_same<T, faiss::IndexIVFPQ>::value) {
-                faiss::gpu::GpuIndexIVFPQConfig f_cfg;
+            if constexpr (std::is_same<T, knowherefaiss::IndexIVFPQ>::value) {
+                knowherefaiss::gpu::GpuIndexIVFPQConfig f_cfg;
                 f_cfg.device = static_cast<int32_t>(gpu_res->gpu_id_);
-                index = std::make_unique<faiss::gpu::GpuIndexIVFPQ>(gpu_res->faiss_res_.get(), dim, ivf_gpu_cfg.nlist,
+                index = std::make_unique<knowherefaiss::gpu::GpuIndexIVFPQ>(gpu_res->faiss_res_.get(), dim, ivf_gpu_cfg.nlist,
                                                                     ivf_gpu_cfg.m, ivf_gpu_cfg.nbits, metric.value(),
                                                                     f_cfg);
             }
-            if constexpr (std::is_same<T, faiss::IndexIVFScalarQuantizer>::value) {
-                faiss::gpu::GpuIndexIVFScalarQuantizerConfig f_cfg;
+            if constexpr (std::is_same<T, knowherefaiss::IndexIVFScalarQuantizer>::value) {
+                knowherefaiss::gpu::GpuIndexIVFScalarQuantizerConfig f_cfg;
                 f_cfg.device = static_cast<int32_t>(gpu_res->gpu_id_);
-                index = std::make_unique<faiss::gpu::GpuIndexIVFScalarQuantizer>(
-                    gpu_res->faiss_res_.get(), dim, ivf_gpu_cfg.nlist, faiss::QuantizerType::QT_8bit, metric.value(),
+                index = std::make_unique<knowherefaiss::gpu::GpuIndexIVFScalarQuantizer>(
+                    gpu_res->faiss_res_.get(), dim, ivf_gpu_cfg.nlist, knowherefaiss::QuantizerType::QT_8bit, metric.value(),
                     true, f_cfg);
             }
             index->train(rows, reinterpret_cast<const float*>(tensor));
             res_ = gpu_res;
         } catch (std::exception& e) {
-            LOG_KNOWHERE_WARNING_ << "faiss inner error, " << e.what();
+            LOG_KNOWHERE_WARNING_ << "knowherefaiss inner error, " << e.what();
             return Status::faiss_inner_error;
         }
         index_ = std::move(index);
@@ -123,7 +123,7 @@ class GpuIvfIndexNode : public IndexNode {
             ResScope rs(res_, false);
             index_->add(rows, (const float*)tensor);
         } catch (std::exception& e) {
-            LOG_KNOWHERE_WARNING_ << "faiss inner error, " << e.what();
+            LOG_KNOWHERE_WARNING_ << "knowherefaiss inner error, " << e.what();
             return Status::faiss_inner_error;
         }
         return Status::success;
@@ -142,7 +142,7 @@ class GpuIvfIndexNode : public IndexNode {
         int64_t* ids = new (std::nothrow) int64_t[rows * k];
         try {
             ResScope rs(res_, false);
-            auto gpu_index = dynamic_cast<faiss::gpu::GpuIndexIVF*>(index_.get());
+            auto gpu_index = dynamic_cast<knowherefaiss::gpu::GpuIndexIVF*>(index_.get());
             for (int i = 0; i < rows; i += block_size) {
                 int64_t search_size = (rows - i > block_size) ? block_size : (rows - i);
                 gpu_index->search_thread_safe(search_size, reinterpret_cast<const float*>(tensor) + i * dim, k,
@@ -151,7 +151,7 @@ class GpuIvfIndexNode : public IndexNode {
         } catch (std::exception& e) {
             std::unique_ptr<float> auto_delete_dis(dis);
             std::unique_ptr<int64_t> auto_delete_ids(ids);
-            LOG_KNOWHERE_WARNING_ << "faiss inner error, " << e.what();
+            LOG_KNOWHERE_WARNING_ << "knowherefaiss inner error, " << e.what();
             return expected<DataSetPtr>::Err(Status::faiss_inner_error, e.what());
         }
 
@@ -187,14 +187,14 @@ class GpuIvfIndexNode : public IndexNode {
         try {
             MemoryIOWriter writer;
             {
-                faiss::Index* host_index = faiss::gpu::index_gpu_to_cpu(index_.get());
-                faiss::write_index(host_index, &writer);
+                knowherefaiss::Index* host_index = knowherefaiss::gpu::index_gpu_to_cpu(index_.get());
+                knowherefaiss::write_index(host_index, &writer);
                 delete host_index;
             }
             std::shared_ptr<uint8_t[]> data(writer.data());
             binset.Append(Type(), data, writer.tellg());
         } catch (std::exception& e) {
-            LOG_KNOWHERE_WARNING_ << "faiss inner error, " << e.what();
+            LOG_KNOWHERE_WARNING_ << "knowherefaiss inner error, " << e.what();
             return Status::faiss_inner_error;
         }
 
@@ -210,14 +210,14 @@ class GpuIvfIndexNode : public IndexNode {
         }
         MemoryIOReader reader(binary->data.get(), binary->size);
         try {
-            std::unique_ptr<faiss::Index> index(faiss::read_index(&reader));
+            std::unique_ptr<knowherefaiss::Index> index(knowherefaiss::read_index(&reader));
             auto gpu_res = GPUResMgr::GetInstance().GetRes();
             ResScope rs(gpu_res, true);
-            auto gpu_index = faiss::gpu::index_cpu_to_gpu(gpu_res->faiss_res_.get(), gpu_res->gpu_id_, index.get());
+            auto gpu_index = knowherefaiss::gpu::index_cpu_to_gpu(gpu_res->faiss_res_.get(), gpu_res->gpu_id_, index.get());
             index_.reset(gpu_index);
             res_ = gpu_res;
         } catch (std::exception& e) {
-            LOG_KNOWHERE_WARNING_ << "faiss inner error, " << e.what();
+            LOG_KNOWHERE_WARNING_ << "knowherefaiss inner error, " << e.what();
             return Status::faiss_inner_error;
         }
         return Status::success;
@@ -262,20 +262,20 @@ class GpuIvfIndexNode : public IndexNode {
 
     std::string
     Type() const override {
-        if constexpr (std::is_same<faiss::IndexIVFFlat, T>::value) {
+        if constexpr (std::is_same<knowherefaiss::IndexIVFFlat, T>::value) {
             return knowhere::IndexEnum::INDEX_FAISS_GPU_IVFFLAT;
         }
-        if constexpr (std::is_same<faiss::IndexIVFPQ, T>::value) {
+        if constexpr (std::is_same<knowherefaiss::IndexIVFPQ, T>::value) {
             return knowhere::IndexEnum::INDEX_FAISS_GPU_IVFPQ;
         }
-        if constexpr (std::is_same<faiss::IndexIVFScalarQuantizer, T>::value) {
+        if constexpr (std::is_same<knowherefaiss::IndexIVFScalarQuantizer, T>::value) {
             return knowhere::IndexEnum::INDEX_FAISS_GPU_IVFSQ8;
         }
     }
 
  private:
     mutable ResWPtr res_;
-    std::unique_ptr<faiss::Index> index_;
+    std::unique_ptr<knowherefaiss::Index> index_;
 };
 // GPU_FAISS_IVF_FLAT/GPU_FAISS_IVF_PQ/GPU_FAISS_IVF_SQ8 is deprecated
 }  // namespace knowhere
diff --git a/src/index/hnsw/faiss_hnsw.cc b/src/index/hnsw/faiss_hnsw.cc
index a27c9876..30933acd 100644
--- a/src/index/hnsw/faiss_hnsw.cc
+++ b/src/index/hnsw/faiss_hnsw.cc
@@ -9,10 +9,10 @@
 // is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 // or implied. See the License for the specific language governing permissions and limitations under the License.
 
-#include <faiss/cppcontrib/knowhere/impl/CountSizeIOWriter.h>
-#include <faiss/cppcontrib/knowhere/impl/HnswSearcher.h>
-#include <faiss/cppcontrib/knowhere/utils/Bitset.h>
-#include <faiss/utils/Heap.h>
+#include <knowherefaiss/cppcontrib/knowhere/impl/CountSizeIOWriter.h>
+#include <knowherefaiss/cppcontrib/knowhere/impl/HnswSearcher.h>
+#include <knowherefaiss/cppcontrib/knowhere/utils/Bitset.h>
+#include <knowherefaiss/utils/Heap.h>
 
 #include <cstddef>
 #include <cstdint>
@@ -25,13 +25,13 @@
 #include <string>
 
 #include "common/metric.h"
-#include "faiss/IndexBinaryHNSW.h"
-#include "faiss/IndexCosine.h"
-#include "faiss/IndexHNSW.h"
-#include "faiss/IndexRefine.h"
-#include "faiss/impl/ScalarQuantizer.h"
-#include "faiss/impl/mapped_io.h"
-#include "faiss/index_io.h"
+#include "knowherefaiss/IndexBinaryHNSW.h"
+#include "knowherefaiss/IndexCosine.h"
+#include "knowherefaiss/IndexHNSW.h"
+#include "knowherefaiss/IndexRefine.h"
+#include "knowherefaiss/impl/ScalarQuantizer.h"
+#include "knowherefaiss/impl/mapped_io.h"
+#include "knowherefaiss/index_io.h"
 #include "index/hnsw/faiss_hnsw_config.h"
 #include "index/hnsw/hnsw.h"
 #include "index/hnsw/impl/DummyVisitor.h"
@@ -98,7 +98,7 @@ class BaseFaissIndexNode : public IndexNode {
                 .getTry();
 
         if (!tryObj.hasValue()) {
-            LOG_KNOWHERE_WARNING_ << "faiss internal error: " << tryObj.exception().what();
+            LOG_KNOWHERE_WARNING_ << "knowherefaiss internal error: " << tryObj.exception().what();
             return Status::faiss_inner_error;
         }
 
@@ -125,7 +125,7 @@ class BaseFaissIndexNode : public IndexNode {
                 .getTry();
 
         if (!tryObj.hasValue()) {
-            LOG_KNOWHERE_WARNING_ << "faiss internal error: " << tryObj.exception().what();
+            LOG_KNOWHERE_WARNING_ << "knowherefaiss internal error: " << tryObj.exception().what();
             return Status::faiss_inner_error;
         }
 
@@ -183,21 +183,21 @@ class BaseFaissRegularIndexNode : public BaseFaissIndexNode {
             if (indexes.size() > 1) {
                 // this is a hack for compatibility, faiss index has 4-byte header to indicate index category
                 // create a new one to distinguish MV faiss hnsw from faiss hnsw
-                faiss::write_mv(&writer);
+                knowherefaiss::write_mv(&writer);
                 writeHeader(&writer);
                 for (const auto& index : indexes) {
-                    faiss::write_index(index.get(), &writer);
+                    knowherefaiss::write_index(index.get(), &writer);
                 }
 
                 std::shared_ptr<uint8_t[]> data(writer.data());
                 binset.Append(Type(), data, writer.tellg());
             } else {
-                faiss::write_index(indexes[0].get(), &writer);
+                knowherefaiss::write_index(indexes[0].get(), &writer);
                 std::shared_ptr<uint8_t[]> data(writer.data());
                 binset.Append(Type(), data, writer.tellg());
             }
         } catch (const std::exception& e) {
-            LOG_KNOWHERE_WARNING_ << "faiss inner error: " << e.what();
+            LOG_KNOWHERE_WARNING_ << "knowherefaiss inner error: " << e.what();
             return Status::faiss_inner_error;
         }
 
@@ -216,27 +216,27 @@ class BaseFaissRegularIndexNode : public BaseFaissIndexNode {
         try {
             // this is a hack for compatibility, faiss index has 4-byte header to indicate index category
             // create a new one to distinguish MV faiss hnsw from faiss hnsw
-            bool is_mv = faiss::read_is_mv(&reader);
+            bool is_mv = knowherefaiss::read_is_mv(&reader);
             if (is_mv) {
                 LOG_KNOWHERE_INFO_ << "start to load index by mv";
                 uint32_t v = readHeader(&reader);
                 indexes.resize(v);
                 LOG_KNOWHERE_INFO_ << "read " << v << " mvs";
                 for (auto i = 0; i < v; ++i) {
-                    auto read_index = std::unique_ptr<faiss::Index>(faiss::read_index(&reader));
+                    auto read_index = std::unique_ptr<knowherefaiss::Index>(knowherefaiss::read_index(&reader));
                     indexes[i].reset(read_index.release());
                 }
             } else {
                 reader.reset();
-                auto read_index = std::unique_ptr<faiss::Index>(faiss::read_index(&reader));
+                auto read_index = std::unique_ptr<knowherefaiss::Index>(knowherefaiss::read_index(&reader));
                 indexes[0].reset(read_index.release());
             }
         } catch (const std::exception& e) {
             if (is_faiss_fourcc_error(e.what())) {
-                LOG_KNOWHERE_WARNING_ << "faiss does not recognize the input index: " << e.what();
+                LOG_KNOWHERE_WARNING_ << "knowherefaiss does not recognize the input index: " << e.what();
                 return Status::invalid_serialized_index_type;
             } else {
-                LOG_KNOWHERE_WARNING_ << "faiss inner error: " << e.what();
+                LOG_KNOWHERE_WARNING_ << "knowherefaiss inner error: " << e.what();
                 return Status::faiss_inner_error;
             }
         }
@@ -250,44 +250,44 @@ class BaseFaissRegularIndexNode : public BaseFaissIndexNode {
 
         int io_flags = 0;
         if (cfg.enable_mmap.value()) {
-            io_flags |= faiss::IO_FLAG_MMAP_IFC;
+            io_flags |= knowherefaiss::IO_FLAG_MMAP_IFC;
         }
 
         try {
             // this is a hack for compatibility, faiss index has 4-byte header to indicate index category
             // create a new one to distinguish MV faiss hnsw from faiss hnsw
-            bool is_mv = faiss::read_is_mv(filename.data());
+            bool is_mv = knowherefaiss::read_is_mv(filename.data());
             if (is_mv) {
-                auto read_index = [&](faiss::IOReader* r) {
+                auto read_index = [&](knowherefaiss::IOReader* r) {
                     LOG_KNOWHERE_INFO_ << "start to load index by mv";
                     read_is_mv(r);
                     uint32_t v = readHeader(r);
                     LOG_KNOWHERE_INFO_ << "read " << v << " mvs";
                     indexes.resize(v);
                     for (auto i = 0; i < v; ++i) {
-                        auto read_index = std::unique_ptr<faiss::Index>(faiss::read_index(r, io_flags));
+                        auto read_index = std::unique_ptr<knowherefaiss::Index>(knowherefaiss::read_index(r, io_flags));
                         indexes[i].reset(read_index.release());
                     }
                 };
-                if ((io_flags & faiss::IO_FLAG_MMAP_IFC) == faiss::IO_FLAG_MMAP_IFC) {
+                if ((io_flags & knowherefaiss::IO_FLAG_MMAP_IFC) == knowherefaiss::IO_FLAG_MMAP_IFC) {
                     // enable mmap-supporting IOReader
-                    auto owner = std::make_shared<faiss::MmappedFileMappingOwner>(filename.data());
-                    faiss::MappedFileIOReader reader(owner);
+                    auto owner = std::make_shared<knowherefaiss::MmappedFileMappingOwner>(filename.data());
+                    knowherefaiss::MappedFileIOReader reader(owner);
                     read_index(&reader);
                 } else {
-                    faiss::FileIOReader reader(filename.data());
+                    knowherefaiss::FileIOReader reader(filename.data());
                     read_index(&reader);
                 }
             } else {
-                auto read_index = std::unique_ptr<faiss::Index>(faiss::read_index(filename.data(), io_flags));
+                auto read_index = std::unique_ptr<knowherefaiss::Index>(knowherefaiss::read_index(filename.data(), io_flags));
                 indexes[0].reset(read_index.release());
             }
         } catch (const std::exception& e) {
             if (is_faiss_fourcc_error(e.what())) {
-                LOG_KNOWHERE_WARNING_ << "faiss does not recognize the input index: " << e.what();
+                LOG_KNOWHERE_WARNING_ << "knowherefaiss does not recognize the input index: " << e.what();
                 return Status::invalid_serialized_index_type;
             } else {
-                LOG_KNOWHERE_WARNING_ << "faiss inner error: " << e.what();
+                LOG_KNOWHERE_WARNING_ << "knowherefaiss inner error: " << e.what();
                 return Status::faiss_inner_error;
             }
         }
@@ -326,9 +326,9 @@ class BaseFaissRegularIndexNode : public BaseFaissIndexNode {
         }
 
         // a temporary yet expensive workaround
-        faiss::cppcontrib::knowhere::CountSizeIOWriter writer;
+        knowherefaiss::cppcontrib::knowhere::CountSizeIOWriter writer;
         for (const auto& index : indexes) {
-            faiss::write_index(index.get(), &writer);
+            knowherefaiss::write_index(index.get(), &writer);
         }
 
         // todo
@@ -338,7 +338,7 @@ class BaseFaissRegularIndexNode : public BaseFaissIndexNode {
  protected:
     // it is std::shared_ptr, not std::unique_ptr, because it can be
     //    shared with FaissHnswIterator
-    std::vector<std::shared_ptr<faiss::Index>> indexes;
+    std::vector<std::shared_ptr<knowherefaiss::Index>> indexes;
     // each index's out ids(label), can be shared with FaissHnswIterator
     std::vector<std::shared_ptr<std::vector<uint32_t>>> labels;
 
@@ -372,32 +372,32 @@ class BaseFaissRegularIndexNode : public BaseFaissIndexNode {
     }
 
     void
-    writeHeader(faiss::IOWriter* f) const {
+    writeHeader(knowherefaiss::IOWriter* f) const {
         uint32_t version = 0;
-        faiss::write_value(version, f);
+        knowherefaiss::write_value(version, f);
         uint32_t size = indexes.size();
-        faiss::write_value(size, f);
+        knowherefaiss::write_value(size, f);
         uint32_t cluster_size = labels.size();
-        faiss::write_value(cluster_size, f);
+        knowherefaiss::write_value(cluster_size, f);
         for (const auto& label : labels) {
-            faiss::write_vector(*label, f);
+            knowherefaiss::write_vector(*label, f);
         }
-        faiss::write_vector(index_rows_sum, f);
-        faiss::write_vector(label_to_internal_offset, f);
+        knowherefaiss::write_vector(index_rows_sum, f);
+        knowherefaiss::write_vector(label_to_internal_offset, f);
     }
 
     uint32_t
-    readHeader(faiss::IOReader* f) {
-        [[maybe_unused]] uint32_t version = faiss::read_value(f);
-        uint32_t size = faiss::read_value(f);
-        uint32_t cluster_size = faiss::read_value(f);
+    readHeader(knowherefaiss::IOReader* f) {
+        [[maybe_unused]] uint32_t version = knowherefaiss::read_value(f);
+        uint32_t size = knowherefaiss::read_value(f);
+        uint32_t cluster_size = knowherefaiss::read_value(f);
         labels.resize(cluster_size);
         for (auto j = 0; j < cluster_size; ++j) {
             labels[j] = std::make_shared<std::vector<uint32_t>>();
-            faiss::read_vector(*labels[j], f);
+            knowherefaiss::read_vector(*labels[j], f);
         }
-        faiss::read_vector(index_rows_sum, f);
-        faiss::read_vector(label_to_internal_offset, f);
+        knowherefaiss::read_vector(index_rows_sum, f);
+        knowherefaiss::read_vector(label_to_internal_offset, f);
         return size;
     }
 
@@ -546,7 +546,7 @@ convert_ds_to_float(const DataSetPtr& src, DataFormatEnum data_format) {
 }
 
 Status
-add_to_index(faiss::Index* const __restrict index, const DataSetPtr& dataset, const DataFormatEnum data_format) {
+add_to_index(knowherefaiss::Index* const __restrict index, const DataSetPtr& dataset, const DataFormatEnum data_format) {
     const auto* data = dataset->GetTensor();
     const auto rows = dataset->GetRows();
     const auto dim = dataset->GetDim();
@@ -578,7 +578,7 @@ add_to_index(faiss::Index* const __restrict index, const DataSetPtr& dataset, co
 }
 
 Status
-add_partial_dataset_to_index(faiss::Index* const __restrict index, const DataSetPtr& dataset,
+add_partial_dataset_to_index(knowherefaiss::Index* const __restrict index, const DataSetPtr& dataset,
                              const DataFormatEnum data_format, const std::vector<uint32_t>& ids) {
     const auto* data = dataset->GetTensor();
 
@@ -615,7 +615,7 @@ add_partial_dataset_to_index(faiss::Index* const __restrict index, const DataSet
 //
 // returns nullopt if an input index does not contain raw bf16, fp16 or fp32 data
 std::optional<DataFormatEnum>
-get_index_data_format(const faiss::Index* index) {
+get_index_data_format(const knowherefaiss::Index* index) {
     // empty
     if (index == nullptr) {
         return std::nullopt;
@@ -623,20 +623,20 @@ get_index_data_format(const faiss::Index* index) {
 
     // is it flat?
     // note: IndexFlatCosine preserves the original data, no cosine norm is applied
-    auto index_flat = dynamic_cast<const faiss::IndexFlat*>(index);
+    auto index_flat = dynamic_cast<const knowherefaiss::IndexFlat*>(index);
     if (index_flat != nullptr) {
         return DataFormatEnum::fp32;
     }
 
     // is it sq?
     // note: IndexScalarQuantizerCosine preserves the original data, no cosine norm is appliesd
-    auto index_sq = dynamic_cast<const faiss::IndexScalarQuantizer*>(index);
+    auto index_sq = dynamic_cast<const knowherefaiss::IndexScalarQuantizer*>(index);
     if (index_sq != nullptr) {
-        if (index_sq->sq.qtype == faiss::ScalarQuantizer::QT_bf16) {
+        if (index_sq->sq.qtype == knowherefaiss::ScalarQuantizer::QT_bf16) {
             return DataFormatEnum::bf16;
-        } else if (index_sq->sq.qtype == faiss::ScalarQuantizer::QT_fp16) {
+        } else if (index_sq->sq.qtype == knowherefaiss::ScalarQuantizer::QT_fp16) {
             return DataFormatEnum::fp16;
-        } else if (index_sq->sq.qtype == faiss::ScalarQuantizer::QT_8bit_direct_signed) {
+        } else if (index_sq->sq.qtype == knowherefaiss::ScalarQuantizer::QT_8bit_direct_signed) {
             return DataFormatEnum::int8;
         } else {
             return std::nullopt;
@@ -648,10 +648,10 @@ get_index_data_format(const faiss::Index* index) {
 }
 
 // cloned from IndexHNSW.cpp
-faiss::DistanceComputer*
-storage_distance_computer(const faiss::Index* storage) {
-    if (faiss::is_similarity_metric(storage->metric_type)) {
-        return new faiss::NegativeDistanceComputer(storage->get_distance_computer());
+knowherefaiss::DistanceComputer*
+storage_distance_computer(const knowherefaiss::Index* storage) {
+    if (knowherefaiss::is_similarity_metric(storage->metric_type)) {
+        return new knowherefaiss::NegativeDistanceComputer(storage->get_distance_computer());
     } else {
         return storage->get_distance_computer();
     }
@@ -703,17 +703,17 @@ combine_partitions(const std::vector<std::vector<uint32_t>>& scalar_info, const
 struct FaissHnswIteratorWorkspace {
     // hnsw.
     // this pointer is not owned.
-    const faiss::HNSW* hnsw = nullptr;
+    const knowherefaiss::HNSW* hnsw = nullptr;
 
     // nodes that we've already visited
-    faiss::cppcontrib::knowhere::Bitset visited_nodes;
+    knowherefaiss::cppcontrib::knowhere::Bitset visited_nodes;
 
     // Computes distances.
     //   This needs to be wrapped with a sign change.
-    std::unique_ptr<faiss::DistanceComputer> qdis;
+    std::unique_ptr<knowherefaiss::DistanceComputer> qdis;
     // Computes refine distances (if refine is available).
     //   This DOES NOT need to be wrapped with a sign change
-    std::unique_ptr<faiss::DistanceComputer> qdis_refine;
+    std::unique_ptr<knowherefaiss::DistanceComputer> qdis_refine;
 
     // for filtering out nodes
     BitsetView bitset;
@@ -725,7 +725,7 @@ struct FaissHnswIteratorWorkspace {
     DummyVisitor graph_visitor;
 
     // faiss hnsw search params (such as ef)
-    faiss::SearchParametersHNSW search_params;
+    knowherefaiss::SearchParametersHNSW search_params;
 
     // the query
     std::unique_ptr<float[]> query;
@@ -739,13 +739,13 @@ struct FaissHnswIteratorWorkspace {
     std::vector<DistId> dists;
 
     // TODO test for memory usage of this heap and add a metric monitoring it.
-    faiss::cppcontrib::knowhere::IteratorMinHeap to_visit;
+    knowherefaiss::cppcontrib::knowhere::IteratorMinHeap to_visit;
 };
 
 // Contains an iterator logic
 class FaissHnswIterator : public IndexIterator {
  public:
-    FaissHnswIterator(const std::shared_ptr<faiss::Index>& index_in,
+    FaissHnswIterator(const std::shared_ptr<knowherefaiss::Index>& index_in,
                       const std::shared_ptr<std::vector<uint32_t>>& labels_in, std::unique_ptr<float[]>&& query_in,
                       const BitsetView& bitset_in, const int32_t ef_in, bool larger_is_closer,
                       const float refine_ratio = 0.5f, const std::vector<uint32_t>& label_to_internal_offset_in = {},
@@ -770,9 +770,9 @@ class FaissHnswIterator : public IndexIterator {
         //   to (-1) again after we're done.
 
         // TODO: upgrade to refine options && cosine
-        const faiss::IndexRefine* index_refine = dynamic_cast<const faiss::IndexRefine*>(index.get());
+        const knowherefaiss::IndexRefine* index_refine = dynamic_cast<const knowherefaiss::IndexRefine*>(index.get());
         if (index_refine != nullptr) {
-            const faiss::IndexHNSW* index_hnsw = dynamic_cast<const faiss::IndexHNSW*>(index_refine->base_index);
+            const knowherefaiss::IndexHNSW* index_hnsw = dynamic_cast<const knowherefaiss::IndexHNSW*>(index_refine->base_index);
             if (index_hnsw == nullptr) {
                 // todo: turn constructor into a factory method
                 throw;
@@ -781,7 +781,7 @@ class FaissHnswIterator : public IndexIterator {
             workspace.hnsw = &index_hnsw->hnsw;
 
             // wrap a sign, if needed
-            workspace.qdis = std::unique_ptr<faiss::DistanceComputer>(storage_distance_computer(index_hnsw));
+            workspace.qdis = std::unique_ptr<knowherefaiss::DistanceComputer>(storage_distance_computer(index_hnsw));
 
             if (refine_ratio != 0) {
                 // the refine is needed
@@ -790,28 +790,28 @@ class FaissHnswIterator : public IndexIterator {
                 // Basically, if out hnsw index's storage is HasInverseL2Norms, then
                 //   this is a cosine index. But because refine always keeps original
                 //   data, then we need to use a wrapper over a distance computer
-                const faiss::HasInverseL2Norms* has_l2_norms =
-                    dynamic_cast<const faiss::HasInverseL2Norms*>(index_hnsw->storage);
+                const knowherefaiss::HasInverseL2Norms* has_l2_norms =
+                    dynamic_cast<const knowherefaiss::HasInverseL2Norms*>(index_hnsw->storage);
                 if (has_l2_norms != nullptr) {
                     // add a cosine wrapper over it
                     // DO NOT WRAP A SIGN, by design
                     workspace.qdis_refine =
-                        std::unique_ptr<faiss::DistanceComputer>(new faiss::WithCosineNormDistanceComputer(
+                        std::unique_ptr<knowherefaiss::DistanceComputer>(new knowherefaiss::WithCosineNormDistanceComputer(
                             has_l2_norms->get_inverse_l2_norms(), index->d,
-                            std::unique_ptr<faiss::DistanceComputer>(
+                            std::unique_ptr<knowherefaiss::DistanceComputer>(
                                 index_refine->refine_index->get_distance_computer())));
                 } else {
                     // use it as is
                     // DO NOT WRAP A SIGN, by design
                     workspace.qdis_refine =
-                        std::unique_ptr<faiss::DistanceComputer>(index_refine->refine_index->get_distance_computer());
+                        std::unique_ptr<knowherefaiss::DistanceComputer>(index_refine->refine_index->get_distance_computer());
                 }
             } else {
                 // the refine is not needed
                 workspace.qdis_refine = nullptr;
             }
         } else {
-            const faiss::IndexHNSW* index_hnsw = dynamic_cast<const faiss::IndexHNSW*>(index.get());
+            const knowherefaiss::IndexHNSW* index_hnsw = dynamic_cast<const knowherefaiss::IndexHNSW*>(index.get());
             if (index_hnsw == nullptr) {
                 // todo: turn constructor into a factory method
                 throw;
@@ -820,7 +820,7 @@ class FaissHnswIterator : public IndexIterator {
             workspace.hnsw = &index_hnsw->hnsw;
 
             // wrap a sign, if needed
-            workspace.qdis = std::unique_ptr<faiss::DistanceComputer>(storage_distance_computer(index_hnsw));
+            workspace.qdis = std::unique_ptr<knowherefaiss::DistanceComputer>(storage_distance_computer(index_hnsw));
         }
 
         // set query
@@ -831,7 +831,7 @@ class FaissHnswIterator : public IndexIterator {
         }
 
         // set up a buffer that tracks visited points
-        workspace.visited_nodes = faiss::cppcontrib::knowhere::Bitset::create_cleared(index->ntotal);
+        workspace.visited_nodes = knowherefaiss::cppcontrib::knowhere::Bitset::create_cleared(index->ntotal);
 
         workspace.search_params.efSearch = ef_in;
         // no need to set this one, use bitsetview directly
@@ -853,8 +853,8 @@ class FaissHnswIterator : public IndexIterator {
     next_batch(std::function<void(const std::vector<DistId>&)> batch_handler, FilterT& filter) {
         //
         using searcher_type =
-            faiss::cppcontrib::knowhere::v2_hnsw_searcher<faiss::DistanceComputer, DummyVisitor,
-                                                          faiss::cppcontrib::knowhere::Bitset, FilterT>;
+            knowherefaiss::cppcontrib::knowhere::v2_hnsw_searcher<knowherefaiss::DistanceComputer, DummyVisitor,
+                                                          knowherefaiss::cppcontrib::knowhere::Bitset, FilterT>;
 
         using storage_idx_t = typename searcher_type::storage_idx_t;
         using idx_t = typename searcher_type::idx_t;
@@ -868,7 +868,7 @@ class FaissHnswIterator : public IndexIterator {
         // accumulate elements for a new batch?
         if (!workspace.initial_search_done) {
             // yes
-            faiss::HNSWStats stats;
+            knowherefaiss::HNSWStats stats;
 
             // is the graph empty?
             if (searcher.hnsw.entry_point != -1) {
@@ -879,7 +879,7 @@ class FaissHnswIterator : public IndexIterator {
                 float d_nearest = searcher.qdis(nearest);
 
                 // iterate through upper levels
-                faiss::HNSWStats bottom_levels_stats = searcher.greedy_search_top_levels(nearest, d_nearest);
+                knowherefaiss::HNSWStats bottom_levels_stats = searcher.greedy_search_top_levels(nearest, d_nearest);
 
                 // update stats
                 if (track_hnsw_stats) {
@@ -891,23 +891,23 @@ class FaissHnswIterator : public IndexIterator {
 
                 // initialize the container for candidates
                 const idx_t n_candidates = workspace.search_params.efSearch;
-                faiss::cppcontrib::knowhere::NeighborSetDoublePopList retset(n_candidates);
+                knowherefaiss::cppcontrib::knowhere::NeighborSetDoublePopList retset(n_candidates);
 
                 // initialize retset with a single 'nearest' point
                 {
                     if (!searcher.filter.is_member(nearest)) {
-                        retset.insert(faiss::cppcontrib::knowhere::Neighbor(
-                            nearest, d_nearest, faiss::cppcontrib::knowhere::Neighbor::kInvalid));
+                        retset.insert(knowherefaiss::cppcontrib::knowhere::Neighbor(
+                            nearest, d_nearest, knowherefaiss::cppcontrib::knowhere::Neighbor::kInvalid));
                     } else {
-                        retset.insert(faiss::cppcontrib::knowhere::Neighbor(
-                            nearest, d_nearest, faiss::cppcontrib::knowhere::Neighbor::kValid));
+                        retset.insert(knowherefaiss::cppcontrib::knowhere::Neighbor(
+                            nearest, d_nearest, knowherefaiss::cppcontrib::knowhere::Neighbor::kValid));
                     }
 
                     searcher.visited_nodes[nearest] = true;
                 }
 
                 // perform the search of the level 0.
-                faiss::HNSWStats local_stats =
+                knowherefaiss::HNSWStats local_stats =
                     searcher.search_on_a_level(retset, 0, &workspace.to_visit, workspace.accumulated_alpha);
                 if (track_hnsw_stats) {
                     stats.combine(local_stats);
@@ -929,7 +929,7 @@ class FaissHnswIterator : public IndexIterator {
             // TODO: currently each time iterator.Next() is called, we return 1 result but adds more than 1 results to
             // to_visit. Consider limit the size of visit by searching 1 step only after several Next() calls. Careful:
             // how does such strategy affect the correctness of the search?
-            faiss::cppcontrib::knowhere::IteratorMinHeap* to_visit_ptr = &workspace.to_visit;
+            knowherefaiss::cppcontrib::knowhere::IteratorMinHeap* to_visit_ptr = &workspace.to_visit;
 
             while (!to_visit_ptr->empty()) {
                 auto top = to_visit_ptr->top();
@@ -953,7 +953,7 @@ class FaissHnswIterator : public IndexIterator {
         //   because workspace.qdis() does so.
         // We need to ensure that we pass positive distances into batch_handler(),
         //   thus we need to negate the sign from workspace.qdis().
-        if (faiss::is_similarity_metric(index->metric_type)) {
+        if (knowherefaiss::is_similarity_metric(index->metric_type)) {
             for (auto& p : workspace.dists) {
                 p.val = -p.val;
             }
@@ -975,7 +975,7 @@ class FaissHnswIterator : public IndexIterator {
     void
     next_batch(std::function<void(const std::vector<DistId>&)> batch_handler) override {
         if (workspace.bitset.empty()) {
-            using filter_type = faiss::IDSelectorAll;
+            using filter_type = knowherefaiss::IDSelectorAll;
             filter_type sel;
 
             next_batch(batch_handler, sel);
@@ -1002,7 +1002,7 @@ class FaissHnswIterator : public IndexIterator {
     }
 
  private:
-    std::shared_ptr<faiss::Index> index;
+    std::shared_ptr<knowherefaiss::Index> index;
     std::shared_ptr<std::vector<uint32_t>> labels;
     const std::vector<uint32_t>& label_to_internal_offset;  // internal_offset = label_to_internal_offset[label_id];
     const uint32_t mv_base_offset;                          // mv_internal_offset = internal_offset - mv_base_offset;
@@ -1043,9 +1043,9 @@ class BaseFaissRegularIndexHNSWNode : public BaseFaissRegularIndexNode {
         }
 
         // an index that is used for reconstruction
-        std::vector<const faiss::Index*> indexes_to_reconstruct_from(indexes.size());
+        std::vector<const knowherefaiss::Index*> indexes_to_reconstruct_from(indexes.size());
         for (auto i = 0; i < indexes.size(); ++i) {
-            const faiss::Index* index_to_reconstruct_from = GetIndexToReconstructRawDataFrom(i);
+            const knowherefaiss::Index* index_to_reconstruct_from = GetIndexToReconstructRawDataFrom(i);
 
             // check whether raw data is available
             if (index_to_reconstruct_from == nullptr) {
@@ -1145,7 +1145,7 @@ class BaseFaissRegularIndexHNSWNode : public BaseFaissRegularIndexNode {
                 return expected<DataSetPtr>::Err(Status::invalid_args, "Unsupported data format");
             }
         } catch (const std::exception& e) {
-            LOG_KNOWHERE_WARNING_ << "faiss inner error: " << e.what();
+            LOG_KNOWHERE_WARNING_ << "knowherefaiss inner error: " << e.what();
             return expected<DataSetPtr>::Err(Status::faiss_inner_error, e.what());
         }
     }
@@ -1201,8 +1201,8 @@ class BaseFaissRegularIndexHNSWNode : public BaseFaissRegularIndexNode {
         }
 
         // set up a bf wrapper as fallback
-        std::unique_ptr<faiss::Index> bf_index_wrapper = nullptr;
-        faiss::Index* bf_index_wrapper_ptr = nullptr;
+        std::unique_ptr<knowherefaiss::Index> bf_index_wrapper = nullptr;
+        knowherefaiss::Index* bf_index_wrapper_ptr = nullptr;
         if (!whether_bf_search.value_or(false)) {
             std::tie(bf_index_wrapper, is_refined) =
                 create_conditional_hnsw_wrapper(indexes[index_id].get(), hnsw_cfg, true, whether_to_enable_refine);
@@ -1212,7 +1212,7 @@ class BaseFaissRegularIndexHNSWNode : public BaseFaissRegularIndexNode {
             bf_index_wrapper_ptr = bf_index_wrapper.get();
         }
 
-        faiss::Index* index_wrapper_ptr = index_wrapper.get();
+        knowherefaiss::Index* index_wrapper_ptr = index_wrapper.get();
 
         // set up faiss search parameters
         knowhere::SearchParametersHNSWWrapper hnsw_search_params;
@@ -1231,7 +1231,7 @@ class BaseFaissRegularIndexHNSWNode : public BaseFaissRegularIndexNode {
         BitsetViewIDSelector bw_idselector(bitset);
         BitsetViewWithMappingIDSelector bw_mapping_idselector(
             bitset, labels.empty() ? nullptr : labels[index_id].get()->data());
-        faiss::IDSelector* id_selector = nullptr;
+        knowherefaiss::IDSelector* id_selector = nullptr;
         if (!bitset.empty()) {
             if (labels.empty()) {
                 id_selector = &bw_idselector;
@@ -1242,7 +1242,7 @@ class BaseFaissRegularIndexHNSWNode : public BaseFaissRegularIndexNode {
         hnsw_search_params.sel = id_selector;
 
         // run
-        auto ids = std::make_unique<faiss::idx_t[]>(rows * k);
+        auto ids = std::make_unique<knowherefaiss::idx_t[]>(rows * k);
         auto distances = std::make_unique<float[]>(rows * k);
 
         try {
@@ -1268,7 +1268,7 @@ class BaseFaissRegularIndexHNSWNode : public BaseFaissRegularIndexNode {
                     }
 
                     // set up local results
-                    faiss::idx_t* const __restrict local_ids = ids.get() + k * idx;
+                    knowherefaiss::idx_t* const __restrict local_ids = ids.get() + k * idx;
                     float* const __restrict local_distances = distances.get() + k * idx;
 
                     // check if we need to perform a brute-force search bcz of the lack of results
@@ -1289,7 +1289,7 @@ class BaseFaissRegularIndexHNSWNode : public BaseFaissRegularIndexNode {
 
                     // perform the search
                     if (is_refined) {
-                        faiss::IndexRefineSearchParameters refine_params;
+                        knowherefaiss::IndexRefineSearchParameters refine_params;
                         refine_params.k_factor = hnsw_cfg.refine_k.value_or(1);
                         // a refine procedure itself does not need to care about filtering
                         refine_params.sel = nullptr;
@@ -1318,7 +1318,7 @@ class BaseFaissRegularIndexHNSWNode : public BaseFaissRegularIndexNode {
             // wait for the completion
             WaitAllSuccess(futs);
         } catch (const std::exception& e) {
-            LOG_KNOWHERE_WARNING_ << "faiss inner error: " << e.what();
+            LOG_KNOWHERE_WARNING_ << "knowherefaiss inner error: " << e.what();
             return expected<DataSetPtr>::Err(Status::faiss_inner_error, e.what());
         }
 
@@ -1364,7 +1364,7 @@ class BaseFaissRegularIndexHNSWNode : public BaseFaissRegularIndexNode {
             return expected<DataSetPtr>::Err(Status::invalid_args, "partition key value not correctly set");
         }
 
-        const bool is_similarity_metric = faiss::is_similarity_metric(indexes[index_id]->metric_type);
+        const bool is_similarity_metric = knowherefaiss::is_similarity_metric(indexes[index_id]->metric_type);
 
         const float radius = hnsw_cfg.radius.value();
         const float range_filter = hnsw_cfg.range_filter.value();
@@ -1395,7 +1395,7 @@ class BaseFaissRegularIndexHNSWNode : public BaseFaissRegularIndexNode {
             return expected<DataSetPtr>::Err(Status::invalid_args, "an input index seems to be unrelated to HNSW");
         }
 
-        faiss::Index* index_wrapper_ptr = index_wrapper.get();
+        knowherefaiss::Index* index_wrapper_ptr = index_wrapper.get();
 
         // set up faiss search parameters
         knowhere::SearchParametersHNSWWrapper hnsw_search_params;
@@ -1415,7 +1415,7 @@ class BaseFaissRegularIndexHNSWNode : public BaseFaissRegularIndexNode {
         BitsetViewIDSelector bw_idselector(bitset);
         BitsetViewWithMappingIDSelector bw_mapping_idselector(
             bitset, labels.empty() ? nullptr : labels[index_id].get()->data());
-        faiss::IDSelector* id_selector = nullptr;
+        knowherefaiss::IDSelector* id_selector = nullptr;
         if (!bitset.empty()) {
             if (labels.empty()) {
                 id_selector = &bw_idselector;
@@ -1455,11 +1455,11 @@ class BaseFaissRegularIndexHNSWNode : public BaseFaissRegularIndexNode {
                     }
 
                     // initialize a buffer
-                    faiss::RangeSearchResult res(1);
+                    knowherefaiss::RangeSearchResult res(1);
 
                     // perform the search
                     if (is_refined) {
-                        faiss::IndexRefineSearchParameters refine_params;
+                        knowherefaiss::IndexRefineSearchParameters refine_params;
                         refine_params.k_factor = hnsw_cfg.refine_k.value_or(1);
                         // a refine procedure itself does not need to care about filtering
                         refine_params.sel = nullptr;
@@ -1528,7 +1528,7 @@ class BaseFaissRegularIndexHNSWNode : public BaseFaissRegularIndexNode {
                 auto status = add_to_index(indexes[0].get(), dataset, data_format);
                 return status;
             } catch (const std::exception& e) {
-                LOG_KNOWHERE_WARNING_ << "faiss inner error: " << e.what();
+                LOG_KNOWHERE_WARNING_ << "knowherefaiss inner error: " << e.what();
                 return Status::faiss_inner_error;
             }
         }
@@ -1556,14 +1556,14 @@ class BaseFaissRegularIndexHNSWNode : public BaseFaissRegularIndexNode {
                 }
             }
         } catch (const std::exception& e) {
-            LOG_KNOWHERE_WARNING_ << "faiss inner error: " << e.what();
+            LOG_KNOWHERE_WARNING_ << "knowherefaiss inner error: " << e.what();
             return Status::faiss_inner_error;
         }
 
         return Status::success;
     }
 
-    const faiss::Index*
+    const knowherefaiss::Index*
     GetIndexToReconstructRawDataFrom(int i) const {
         if (indexes.size() <= i) {
             return nullptr;
@@ -1573,15 +1573,15 @@ class BaseFaissRegularIndexHNSWNode : public BaseFaissRegularIndexNode {
         }
 
         // an index that is used for reconstruction
-        const faiss::Index* index_to_reconstruct_from = nullptr;
+        const knowherefaiss::Index* index_to_reconstruct_from = nullptr;
 
         // check whether our index uses refine
-        auto index_refine = dynamic_cast<const faiss::IndexRefine*>(indexes[i].get());
+        auto index_refine = dynamic_cast<const knowherefaiss::IndexRefine*>(indexes[i].get());
         if (index_refine == nullptr) {
             // non-refined index
 
             // cast as IndexHNSW
-            auto index_hnsw = dynamic_cast<const faiss::IndexHNSW*>(indexes[i].get());
+            auto index_hnsw = dynamic_cast<const knowherefaiss::IndexHNSW*>(indexes[i].get());
             if (index_hnsw == nullptr) {
                 // this is unexpected, we expect IndexHNSW
                 return nullptr;
@@ -1711,7 +1711,7 @@ class BaseFaissRegularIndexHNSWNode : public BaseFaissRegularIndexNode {
                 }
 
                 const bool should_use_refine =
-                    (dynamic_cast<const faiss::IndexRefine*>(indexes[index_id].get()) != nullptr);
+                    (dynamic_cast<const knowherefaiss::IndexRefine*>(indexes[index_id].get()) != nullptr);
 
                 const float iterator_refine_ratio =
                     should_use_refine ? hnsw_cfg.iterator_refine_ratio.value_or(0.5) : 0;
@@ -1730,7 +1730,7 @@ class BaseFaissRegularIndexHNSWNode : public BaseFaissRegularIndexNode {
                 vec[i] = it;
             }
         } catch (const std::exception& e) {
-            LOG_KNOWHERE_WARNING_ << "faiss inner error: " << e.what();
+            LOG_KNOWHERE_WARNING_ << "knowherefaiss inner error: " << e.what();
             return expected<std::vector<IndexNode::IteratorPtr>>::Err(Status::faiss_inner_error, e.what());
         }
         return vec;
@@ -1781,36 +1781,36 @@ class BaseFaissRegularIndexHNSWFlatNode : public BaseFaissRegularIndexHNSWNode {
         // create an index
         const bool is_cosine = IsMetricType(hnsw_cfg.metric_type.value(), metric::COSINE);
 
-        std::unique_ptr<faiss::IndexHNSW> hnsw_index;
+        std::unique_ptr<knowherefaiss::IndexHNSW> hnsw_index;
         auto train_index = [&](const float* data, const int i, const int64_t rows) {
             if (is_cosine) {
                 if (data_format == DataFormatEnum::fp32) {
-                    hnsw_index = std::make_unique<faiss::IndexHNSWFlatCosine>(dim, hnsw_cfg.M.value());
+                    hnsw_index = std::make_unique<knowherefaiss::IndexHNSWFlatCosine>(dim, hnsw_cfg.M.value());
                 } else if (data_format == DataFormatEnum::fp16) {
-                    hnsw_index = std::make_unique<faiss::IndexHNSWSQCosine>(dim, faiss::ScalarQuantizer::QT_fp16,
+                    hnsw_index = std::make_unique<knowherefaiss::IndexHNSWSQCosine>(dim, knowherefaiss::ScalarQuantizer::QT_fp16,
                                                                             hnsw_cfg.M.value());
                 } else if (data_format == DataFormatEnum::bf16) {
-                    hnsw_index = std::make_unique<faiss::IndexHNSWSQCosine>(dim, faiss::ScalarQuantizer::QT_bf16,
+                    hnsw_index = std::make_unique<knowherefaiss::IndexHNSWSQCosine>(dim, knowherefaiss::ScalarQuantizer::QT_bf16,
                                                                             hnsw_cfg.M.value());
                 } else if (data_format == DataFormatEnum::int8) {
-                    hnsw_index = std::make_unique<faiss::IndexHNSWSQCosine>(
-                        dim, faiss::ScalarQuantizer::QT_8bit_direct_signed, hnsw_cfg.M.value());
+                    hnsw_index = std::make_unique<knowherefaiss::IndexHNSWSQCosine>(
+                        dim, knowherefaiss::ScalarQuantizer::QT_8bit_direct_signed, hnsw_cfg.M.value());
                 } else {
                     LOG_KNOWHERE_ERROR_ << "Unsupported metric type: " << hnsw_cfg.metric_type.value();
                     return Status::invalid_metric_type;
                 }
             } else {
                 if (data_format == DataFormatEnum::fp32) {
-                    hnsw_index = std::make_unique<faiss::IndexHNSWFlat>(dim, hnsw_cfg.M.value(), metric.value());
+                    hnsw_index = std::make_unique<knowherefaiss::IndexHNSWFlat>(dim, hnsw_cfg.M.value(), metric.value());
                 } else if (data_format == DataFormatEnum::fp16) {
-                    hnsw_index = std::make_unique<faiss::IndexHNSWSQ>(dim, faiss::ScalarQuantizer::QT_fp16,
+                    hnsw_index = std::make_unique<knowherefaiss::IndexHNSWSQ>(dim, knowherefaiss::ScalarQuantizer::QT_fp16,
                                                                       hnsw_cfg.M.value(), metric.value());
                 } else if (data_format == DataFormatEnum::bf16) {
-                    hnsw_index = std::make_unique<faiss::IndexHNSWSQ>(dim, faiss::ScalarQuantizer::QT_bf16,
+                    hnsw_index = std::make_unique<knowherefaiss::IndexHNSWSQ>(dim, knowherefaiss::ScalarQuantizer::QT_bf16,
                                                                       hnsw_cfg.M.value(), metric.value());
                 } else if (data_format == DataFormatEnum::int8) {
-                    hnsw_index = std::make_unique<faiss::IndexHNSWSQ>(
-                        dim, faiss::ScalarQuantizer::QT_8bit_direct_signed, hnsw_cfg.M.value(), metric.value());
+                    hnsw_index = std::make_unique<knowherefaiss::IndexHNSWSQ>(
+                        dim, knowherefaiss::ScalarQuantizer::QT_8bit_direct_signed, hnsw_cfg.M.value(), metric.value());
                 } else {
                     LOG_KNOWHERE_ERROR_ << "Unsupported metric type: " << hnsw_cfg.metric_type.value();
                     return Status::invalid_metric_type;
@@ -2112,15 +2112,15 @@ class BaseFaissRegularIndexHNSWSQNode : public BaseFaissRegularIndexHNSWNode {
         const bool is_cosine = IsMetricType(hnsw_cfg.metric_type.value(), metric::COSINE);
 
         // should refine be used?
-        std::unique_ptr<faiss::Index> final_index;
+        std::unique_ptr<knowherefaiss::Index> final_index;
 
         auto train_index = [&](const float* data, const int i, const int64_t rows) {
-            std::unique_ptr<faiss::IndexHNSW> hnsw_index;
+            std::unique_ptr<knowherefaiss::IndexHNSW> hnsw_index;
             if (is_cosine) {
-                hnsw_index = std::make_unique<faiss::IndexHNSWSQCosine>(dim, sq_type.value(), hnsw_cfg.M.value());
+                hnsw_index = std::make_unique<knowherefaiss::IndexHNSWSQCosine>(dim, sq_type.value(), hnsw_cfg.M.value());
             } else {
                 hnsw_index =
-                    std::make_unique<faiss::IndexHNSWSQ>(dim, sq_type.value(), hnsw_cfg.M.value(), metric.value());
+                    std::make_unique<knowherefaiss::IndexHNSWSQ>(dim, sq_type.value(), hnsw_cfg.M.value(), metric.value());
             }
 
             hnsw_index->hnsw.efConstruction = hnsw_cfg.efConstruction.value();
@@ -2225,7 +2225,7 @@ class BaseFaissRegularIndexHNSWPQNode : public BaseFaissRegularIndexHNSWNode {
     }
 
  protected:
-    std::vector<std::unique_ptr<faiss::IndexPQ>> tmp_index_pq;
+    std::vector<std::unique_ptr<knowherefaiss::IndexPQ>> tmp_index_pq;
 
     Status
     TrainInternal(const DataSetPtr dataset, const Config& cfg) override {
@@ -2257,26 +2257,26 @@ class BaseFaissRegularIndexHNSWPQNode : public BaseFaissRegularIndexHNSWNode {
         // HNSW + PQ index yields BAD recall somewhy.
         // Let's build HNSW+FLAT index, then replace FLAT with PQ
         auto train_index = [&](const float* data, const int i, const int64_t rows) {
-            std::unique_ptr<faiss::IndexHNSW> hnsw_index;
+            std::unique_ptr<knowherefaiss::IndexHNSW> hnsw_index;
             if (is_cosine) {
-                hnsw_index = std::make_unique<faiss::IndexHNSWFlatCosine>(dim, hnsw_cfg.M.value());
+                hnsw_index = std::make_unique<knowherefaiss::IndexHNSWFlatCosine>(dim, hnsw_cfg.M.value());
             } else {
-                hnsw_index = std::make_unique<faiss::IndexHNSWFlat>(dim, hnsw_cfg.M.value(), metric.value());
+                hnsw_index = std::make_unique<knowherefaiss::IndexHNSWFlat>(dim, hnsw_cfg.M.value(), metric.value());
             }
 
             hnsw_index->hnsw.efConstruction = hnsw_cfg.efConstruction.value();
 
             // pq
-            std::unique_ptr<faiss::IndexPQ> pq_index;
+            std::unique_ptr<knowherefaiss::IndexPQ> pq_index;
             if (is_cosine) {
-                pq_index = std::make_unique<faiss::IndexPQCosine>(dim, hnsw_cfg.m.value(), hnsw_cfg.nbits.value());
+                pq_index = std::make_unique<knowherefaiss::IndexPQCosine>(dim, hnsw_cfg.m.value(), hnsw_cfg.nbits.value());
             } else {
                 pq_index =
-                    std::make_unique<faiss::IndexPQ>(dim, hnsw_cfg.m.value(), hnsw_cfg.nbits.value(), metric.value());
+                    std::make_unique<knowherefaiss::IndexPQ>(dim, hnsw_cfg.m.value(), hnsw_cfg.nbits.value(), metric.value());
             }
 
             // should refine be used?
-            std::unique_ptr<faiss::Index> final_index;
+            std::unique_ptr<knowherefaiss::Index> final_index;
             if (hnsw_cfg.refine.value_or(false) && hnsw_cfg.refine_type.has_value()) {
                 // yes
                 const auto hnsw_d = hnsw_index->storage->d;
@@ -2359,28 +2359,28 @@ class BaseFaissRegularIndexHNSWPQNode : public BaseFaissRegularIndexHNSWNode {
             // throw away flat and replace it with pq
 
             // check if we have a refine available.
-            faiss::IndexHNSW* index_hnsw = nullptr;
+            knowherefaiss::IndexHNSW* index_hnsw = nullptr;
 
-            faiss::IndexRefine* const index_refine = dynamic_cast<faiss::IndexRefine*>(indexes[i].get());
+            knowherefaiss::IndexRefine* const index_refine = dynamic_cast<knowherefaiss::IndexRefine*>(indexes[i].get());
 
             if (index_refine != nullptr) {
-                index_hnsw = dynamic_cast<faiss::IndexHNSW*>(index_refine->base_index);
+                index_hnsw = dynamic_cast<knowherefaiss::IndexHNSW*>(index_refine->base_index);
             } else {
-                index_hnsw = dynamic_cast<faiss::IndexHNSW*>(indexes[i].get());
+                index_hnsw = dynamic_cast<knowherefaiss::IndexHNSW*>(indexes[i].get());
             }
 
             // recreate hnswpq
-            std::unique_ptr<faiss::IndexHNSW> index_hnsw_pq;
+            std::unique_ptr<knowherefaiss::IndexHNSW> index_hnsw_pq;
 
             if (index_hnsw->storage->is_cosine) {
-                index_hnsw_pq = std::make_unique<faiss::IndexHNSWPQCosine>();
+                index_hnsw_pq = std::make_unique<knowherefaiss::IndexHNSWPQCosine>();
             } else {
-                index_hnsw_pq = std::make_unique<faiss::IndexHNSWPQ>();
+                index_hnsw_pq = std::make_unique<knowherefaiss::IndexHNSWPQ>();
             }
 
             // C++ slicing.
-            // we can't use move, because faiss::IndexHNSW overrides a destructor.
-            static_cast<faiss::IndexHNSW&>(*index_hnsw_pq) = static_cast<faiss::IndexHNSW&>(*index_hnsw);
+            // we can't use move, because knowherefaiss::IndexHNSW overrides a destructor.
+            static_cast<knowherefaiss::IndexHNSW&>(*index_hnsw_pq) = static_cast<knowherefaiss::IndexHNSW&>(*index_hnsw);
 
             // clear out the storage
             delete index_hnsw->storage;
@@ -2455,7 +2455,7 @@ class BaseFaissRegularIndexHNSWPQNode : public BaseFaissRegularIndexHNSWNode {
             }
 
         } catch (const std::exception& e) {
-            LOG_KNOWHERE_WARNING_ << "faiss inner error: " << e.what();
+            LOG_KNOWHERE_WARNING_ << "knowherefaiss inner error: " << e.what();
             return Status::faiss_inner_error;
         }
 
@@ -2500,7 +2500,7 @@ class BaseFaissRegularIndexHNSWPRQNode : public BaseFaissRegularIndexHNSWNode {
     }
 
  protected:
-    std::vector<std::unique_ptr<faiss::IndexProductResidualQuantizer>> tmp_index_prq;
+    std::vector<std::unique_ptr<knowherefaiss::IndexProductResidualQuantizer>> tmp_index_prq;
 
     Status
     TrainInternal(const DataSetPtr dataset, const Config& cfg) override {
@@ -2532,33 +2532,33 @@ class BaseFaissRegularIndexHNSWPRQNode : public BaseFaissRegularIndexHNSWNode {
         // HNSW + PRQ index yields BAD recall somewhy.
         // Let's build HNSW+FLAT index, then replace FLAT with PRQ
         auto train_index = [&](const float* data, const int i, const int64_t rows) {
-            std::unique_ptr<faiss::IndexHNSW> hnsw_index;
+            std::unique_ptr<knowherefaiss::IndexHNSW> hnsw_index;
             if (is_cosine) {
-                hnsw_index = std::make_unique<faiss::IndexHNSWFlatCosine>(dim, hnsw_cfg.M.value());
+                hnsw_index = std::make_unique<knowherefaiss::IndexHNSWFlatCosine>(dim, hnsw_cfg.M.value());
             } else {
-                hnsw_index = std::make_unique<faiss::IndexHNSWFlat>(dim, hnsw_cfg.M.value(), metric.value());
+                hnsw_index = std::make_unique<knowherefaiss::IndexHNSWFlat>(dim, hnsw_cfg.M.value(), metric.value());
             }
 
             hnsw_index->hnsw.efConstruction = hnsw_cfg.efConstruction.value();
 
             // prq
-            faiss::AdditiveQuantizer::Search_type_t prq_search_type =
-                (metric.value() == faiss::MetricType::METRIC_INNER_PRODUCT)
-                    ? faiss::AdditiveQuantizer::Search_type_t::ST_LUT_nonorm
-                    : faiss::AdditiveQuantizer::Search_type_t::ST_norm_float;
+            knowherefaiss::AdditiveQuantizer::Search_type_t prq_search_type =
+                (metric.value() == knowherefaiss::MetricType::METRIC_INNER_PRODUCT)
+                    ? knowherefaiss::AdditiveQuantizer::Search_type_t::ST_LUT_nonorm
+                    : knowherefaiss::AdditiveQuantizer::Search_type_t::ST_norm_float;
 
-            std::unique_ptr<faiss::IndexProductResidualQuantizer> prq_index;
+            std::unique_ptr<knowherefaiss::IndexProductResidualQuantizer> prq_index;
             if (is_cosine) {
-                prq_index = std::make_unique<faiss::IndexProductResidualQuantizerCosine>(
+                prq_index = std::make_unique<knowherefaiss::IndexProductResidualQuantizerCosine>(
                     dim, hnsw_cfg.m.value(), hnsw_cfg.nrq.value(), hnsw_cfg.nbits.value(), prq_search_type);
             } else {
-                prq_index = std::make_unique<faiss::IndexProductResidualQuantizer>(
+                prq_index = std::make_unique<knowherefaiss::IndexProductResidualQuantizer>(
                     dim, hnsw_cfg.m.value(), hnsw_cfg.nrq.value(), hnsw_cfg.nbits.value(), metric.value(),
                     prq_search_type);
             }
 
             // should refine be used?
-            std::unique_ptr<faiss::Index> final_index;
+            std::unique_ptr<knowherefaiss::Index> final_index;
             if (hnsw_cfg.refine.value_or(false) && hnsw_cfg.refine_type.has_value()) {
                 // yes
                 const auto hnsw_d = hnsw_index->storage->d;
@@ -2641,28 +2641,28 @@ class BaseFaissRegularIndexHNSWPRQNode : public BaseFaissRegularIndexHNSWNode {
             // throw away flat and replace it with prq
 
             // check if we have a refine available.
-            faiss::IndexHNSW* index_hnsw = nullptr;
+            knowherefaiss::IndexHNSW* index_hnsw = nullptr;
 
-            faiss::IndexRefine* const index_refine = dynamic_cast<faiss::IndexRefine*>(indexes[i].get());
+            knowherefaiss::IndexRefine* const index_refine = dynamic_cast<knowherefaiss::IndexRefine*>(indexes[i].get());
 
             if (index_refine != nullptr) {
-                index_hnsw = dynamic_cast<faiss::IndexHNSW*>(index_refine->base_index);
+                index_hnsw = dynamic_cast<knowherefaiss::IndexHNSW*>(index_refine->base_index);
             } else {
-                index_hnsw = dynamic_cast<faiss::IndexHNSW*>(indexes[i].get());
+                index_hnsw = dynamic_cast<knowherefaiss::IndexHNSW*>(indexes[i].get());
             }
 
             // recreate hnswprq
-            std::unique_ptr<faiss::IndexHNSW> index_hnsw_prq;
+            std::unique_ptr<knowherefaiss::IndexHNSW> index_hnsw_prq;
 
             if (index_hnsw->storage->is_cosine) {
-                index_hnsw_prq = std::make_unique<faiss::IndexHNSWProductResidualQuantizerCosine>();
+                index_hnsw_prq = std::make_unique<knowherefaiss::IndexHNSWProductResidualQuantizerCosine>();
             } else {
-                index_hnsw_prq = std::make_unique<faiss::IndexHNSWProductResidualQuantizer>();
+                index_hnsw_prq = std::make_unique<knowherefaiss::IndexHNSWProductResidualQuantizer>();
             }
 
             // C++ slicing
-            // we can't use move, because faiss::IndexHNSW overrides a destructor.
-            static_cast<faiss::IndexHNSW&>(*index_hnsw_prq) = static_cast<faiss::IndexHNSW&>(*index_hnsw);
+            // we can't use move, because knowherefaiss::IndexHNSW overrides a destructor.
+            static_cast<knowherefaiss::IndexHNSW&>(*index_hnsw_prq) = static_cast<knowherefaiss::IndexHNSW&>(*index_hnsw);
 
             // clear out the storage
             delete index_hnsw->storage;
@@ -2738,7 +2738,7 @@ class BaseFaissRegularIndexHNSWPRQNode : public BaseFaissRegularIndexHNSWNode {
             }
 
         } catch (const std::exception& e) {
-            LOG_KNOWHERE_WARNING_ << "faiss inner error: " << e.what();
+            LOG_KNOWHERE_WARNING_ << "knowherefaiss inner error: " << e.what();
             return Status::faiss_inner_error;
         }
 
diff --git a/src/index/hnsw/impl/DummyVisitor.h b/src/index/hnsw/impl/DummyVisitor.h
index ea6d3642..caf82d7c 100644
--- a/src/index/hnsw/impl/DummyVisitor.h
+++ b/src/index/hnsw/impl/DummyVisitor.h
@@ -11,13 +11,13 @@
 
 #pragma once
 
-#include <faiss/impl/HNSW.h>
+#include <knowherefaiss/impl/HNSW.h>
 
 namespace knowhere {
 
 // a visitor that does nothing
 struct DummyVisitor {
-    using storage_idx_t = faiss::HNSW::storage_idx_t;
+    using storage_idx_t = knowherefaiss::HNSW::storage_idx_t;
 
     inline void
     visit_level(const int level) {
diff --git a/src/index/hnsw/impl/FederVisitor.h b/src/index/hnsw/impl/FederVisitor.h
index 02bba004..f58239d3 100644
--- a/src/index/hnsw/impl/FederVisitor.h
+++ b/src/index/hnsw/impl/FederVisitor.h
@@ -11,7 +11,7 @@
 
 #pragma once
 
-#include <faiss/impl/HNSW.h>
+#include <knowherefaiss/impl/HNSW.h>
 
 #include "knowhere/feder/HNSW.h"
 
@@ -19,7 +19,7 @@ namespace knowhere {
 
 // a default feder visitor
 struct FederVisitor {
-    using storage_idx_t = faiss::HNSW::storage_idx_t;
+    using storage_idx_t = knowherefaiss::HNSW::storage_idx_t;
 
     // a non-owning pointer
     knowhere::feder::hnsw::FederResult* feder = nullptr;
diff --git a/src/index/hnsw/impl/IndexBruteForceWrapper.cc b/src/index/hnsw/impl/IndexBruteForceWrapper.cc
index 44958c41..77e9f6c6 100644
--- a/src/index/hnsw/impl/IndexBruteForceWrapper.cc
+++ b/src/index/hnsw/impl/IndexBruteForceWrapper.cc
@@ -11,13 +11,13 @@
 
 #include "index/hnsw/impl/IndexBruteForceWrapper.h"
 
-#include <faiss/Index.h>
-#include <faiss/MetricType.h>
-#include <faiss/cppcontrib/knowhere/impl/Bruteforce.h>
-#include <faiss/impl/AuxIndexStructures.h>
-#include <faiss/impl/DistanceComputer.h>
-#include <faiss/impl/FaissAssert.h>
-#include <faiss/impl/ResultHandler.h>
+#include <knowherefaiss/Index.h>
+#include <knowherefaiss/MetricType.h>
+#include <knowherefaiss/cppcontrib/knowhere/impl/Bruteforce.h>
+#include <knowherefaiss/impl/AuxIndexStructures.h>
+#include <knowherefaiss/impl/DistanceComputer.h>
+#include <knowherefaiss/impl/FaissAssert.h>
+#include <knowherefaiss/impl/ResultHandler.h>
 
 #include <algorithm>
 #include <memory>
@@ -27,7 +27,7 @@
 
 namespace knowhere {
 
-using idx_t = faiss::idx_t;
+using idx_t = knowherefaiss::idx_t;
 
 // the following structure is a hack, because GCC cannot properly
 //   de-virtualize a plain BitsetViewIDSelector.
@@ -38,7 +38,7 @@ struct BitsetViewIDSelectorWrapper final {
     }
 
     [[nodiscard]] inline bool
-    is_member(faiss::idx_t id) const {
+    is_member(knowherefaiss::idx_t id) const {
         // it is by design that bitset_view.empty() is not tested here
         return (!bitset_view.test(id));
     }
@@ -53,24 +53,24 @@ struct BitsetViewWithMappingIDSelectorWrapper final {
     }
 
     [[nodiscard]] inline bool
-    is_member(faiss::idx_t id) const {
+    is_member(knowherefaiss::idx_t id) const {
         // it is by design that bitset_view.empty() and out_id_mapping == nullptr is not tested here
         return (!bitset_view.test(out_id_mapping[id]));
     }
 };
 
 //
-IndexBruteForceWrapper::IndexBruteForceWrapper(faiss::Index* underlying_index)
-    : faiss::cppcontrib::knowhere::IndexWrapper{underlying_index} {
+IndexBruteForceWrapper::IndexBruteForceWrapper(knowherefaiss::Index* underlying_index)
+    : knowherefaiss::cppcontrib::knowhere::IndexWrapper{underlying_index} {
 }
 
 void
-IndexBruteForceWrapper::search(faiss::idx_t n, const float* __restrict x, faiss::idx_t k, float* __restrict distances,
-                               faiss::idx_t* __restrict labels,
-                               const faiss::SearchParameters* __restrict params) const {
+IndexBruteForceWrapper::search(knowherefaiss::idx_t n, const float* __restrict x, knowherefaiss::idx_t k, float* __restrict distances,
+                               knowherefaiss::idx_t* __restrict labels,
+                               const knowherefaiss::SearchParameters* __restrict params) const {
     FAISS_THROW_IF_NOT(k > 0);
 
-    std::unique_ptr<faiss::DistanceComputer> dis(index->get_distance_computer());
+    std::unique_ptr<knowherefaiss::DistanceComputer> dis(index->get_distance_computer());
 
     // no parallelism by design
     for (idx_t i = 0; i < n; i++) {
@@ -82,10 +82,10 @@ IndexBruteForceWrapper::search(faiss::idx_t n, const float* __restrict x, faiss:
         float* const __restrict local_distances = distances + i * index->d;
 
         // set up a filter
-        faiss::IDSelector* sel = (params == nullptr) ? nullptr : params->sel;
+        knowherefaiss::IDSelector* sel = (params == nullptr) ? nullptr : params->sel;
 
         if (is_similarity_metric(index->metric_type)) {
-            using C = faiss::CMin<float, idx_t>;
+            using C = knowherefaiss::CMin<float, idx_t>;
 
             // try knowhere-specific filter
             if (const knowhere::BitsetViewWithMappingIDSelector* __restrict bw_idselector =
@@ -94,7 +94,7 @@ IndexBruteForceWrapper::search(faiss::idx_t n, const float* __restrict x, faiss:
                 BitsetViewWithMappingIDSelectorWrapper bw_idselector_w(bw_idselector->bitset_view,
                                                                        bw_idselector->out_id_mapping);
 
-                faiss::cppcontrib::knowhere::brute_force_search_impl<C, faiss::DistanceComputer,
+                knowherefaiss::cppcontrib::knowhere::brute_force_search_impl<C, knowherefaiss::DistanceComputer,
                                                                      BitsetViewWithMappingIDSelectorWrapper>(
                     index->ntotal, *dis, bw_idselector_w, k, local_distances, local_ids);
             } else if (const knowhere::BitsetViewIDSelector* __restrict bw_idselector =
@@ -102,16 +102,16 @@ IndexBruteForceWrapper::search(faiss::idx_t n, const float* __restrict x, faiss:
                        bw_idselector && !bw_idselector->bitset_view.empty()) {
                 BitsetViewIDSelectorWrapper bw_idselector_w(bw_idselector->bitset_view);
 
-                faiss::cppcontrib::knowhere::brute_force_search_impl<C, faiss::DistanceComputer,
+                knowherefaiss::cppcontrib::knowhere::brute_force_search_impl<C, knowherefaiss::DistanceComputer,
                                                                      BitsetViewIDSelectorWrapper>(
                     index->ntotal, *dis, bw_idselector_w, k, local_distances, local_ids);
             } else {
-                faiss::IDSelectorAll sel_all;
-                faiss::cppcontrib::knowhere::brute_force_search_impl<C, faiss::DistanceComputer, faiss::IDSelectorAll>(
+                knowherefaiss::IDSelectorAll sel_all;
+                knowherefaiss::cppcontrib::knowhere::brute_force_search_impl<C, knowherefaiss::DistanceComputer, knowherefaiss::IDSelectorAll>(
                     index->ntotal, *dis, sel_all, k, local_distances, local_ids);
             }
         } else {
-            using C = faiss::CMax<float, idx_t>;
+            using C = knowherefaiss::CMax<float, idx_t>;
 
             // try knowhere-specific filter
             if (const knowhere::BitsetViewWithMappingIDSelector* __restrict bw_idselector =
@@ -120,7 +120,7 @@ IndexBruteForceWrapper::search(faiss::idx_t n, const float* __restrict x, faiss:
                 BitsetViewWithMappingIDSelectorWrapper bw_idselector_w(bw_idselector->bitset_view,
                                                                        bw_idselector->out_id_mapping);
 
-                faiss::cppcontrib::knowhere::brute_force_search_impl<C, faiss::DistanceComputer,
+                knowherefaiss::cppcontrib::knowhere::brute_force_search_impl<C, knowherefaiss::DistanceComputer,
                                                                      BitsetViewWithMappingIDSelectorWrapper>(
                     index->ntotal, *dis, bw_idselector_w, k, local_distances, local_ids);
             } else if (const knowhere::BitsetViewIDSelector* __restrict bw_idselector =
@@ -128,12 +128,12 @@ IndexBruteForceWrapper::search(faiss::idx_t n, const float* __restrict x, faiss:
                        bw_idselector && !bw_idselector->bitset_view.empty()) {
                 BitsetViewIDSelectorWrapper bw_idselector_w(bw_idselector->bitset_view);
 
-                faiss::cppcontrib::knowhere::brute_force_search_impl<C, faiss::DistanceComputer,
+                knowherefaiss::cppcontrib::knowhere::brute_force_search_impl<C, knowherefaiss::DistanceComputer,
                                                                      BitsetViewIDSelectorWrapper>(
                     index->ntotal, *dis, bw_idselector_w, k, local_distances, local_ids);
             } else {
-                faiss::IDSelectorAll sel_all;
-                faiss::cppcontrib::knowhere::brute_force_search_impl<C, faiss::DistanceComputer, faiss::IDSelectorAll>(
+                knowherefaiss::IDSelectorAll sel_all;
+                knowherefaiss::cppcontrib::knowhere::brute_force_search_impl<C, knowherefaiss::DistanceComputer, knowherefaiss::IDSelectorAll>(
                     index->ntotal, *dis, sel_all, k, local_distances, local_ids);
             }
         }
@@ -141,14 +141,14 @@ IndexBruteForceWrapper::search(faiss::idx_t n, const float* __restrict x, faiss:
 }
 
 void
-IndexBruteForceWrapper::range_search(faiss::idx_t n, const float* x, float radius, faiss::RangeSearchResult* result,
-                                     const faiss::SearchParameters* params) const {
-    using RH_min = faiss::RangeSearchBlockResultHandler<faiss::CMax<float, int64_t>>;
-    using RH_max = faiss::RangeSearchBlockResultHandler<faiss::CMin<float, int64_t>>;
+IndexBruteForceWrapper::range_search(knowherefaiss::idx_t n, const float* x, float radius, knowherefaiss::RangeSearchResult* result,
+                                     const knowherefaiss::SearchParameters* params) const {
+    using RH_min = knowherefaiss::RangeSearchBlockResultHandler<knowherefaiss::CMax<float, int64_t>>;
+    using RH_max = knowherefaiss::RangeSearchBlockResultHandler<knowherefaiss::CMin<float, int64_t>>;
     RH_min bres_min(result, radius);
     RH_max bres_max(result, radius);
 
-    std::unique_ptr<faiss::DistanceComputer> dis(index->get_distance_computer());
+    std::unique_ptr<knowherefaiss::DistanceComputer> dis(index->get_distance_computer());
 
     // no parallelism by design
     for (idx_t i = 0; i < n; i++) {
@@ -156,7 +156,7 @@ IndexBruteForceWrapper::range_search(faiss::idx_t n, const float* x, float radiu
         dis->set_query(x + i * index->d);
 
         // set up a filter
-        faiss::IDSelector* __restrict sel = (params == nullptr) ? nullptr : params->sel;
+        knowherefaiss::IDSelector* __restrict sel = (params == nullptr) ? nullptr : params->sel;
 
         if (is_similarity_metric(index->metric_type)) {
             typename RH_max::SingleResultHandler res_max(bres_max);
@@ -164,14 +164,14 @@ IndexBruteForceWrapper::range_search(faiss::idx_t n, const float* x, float radiu
 
             if (sel == nullptr) {
                 // Compiler is expected to de-virtualize virtual method calls
-                faiss::IDSelectorAll sel_all;
+                knowherefaiss::IDSelectorAll sel_all;
 
-                faiss::cppcontrib::knowhere::brute_force_range_search_impl<
-                    typename RH_max::SingleResultHandler, faiss::DistanceComputer, faiss::IDSelectorAll>(
+                knowherefaiss::cppcontrib::knowhere::brute_force_range_search_impl<
+                    typename RH_max::SingleResultHandler, knowherefaiss::DistanceComputer, knowherefaiss::IDSelectorAll>(
                     index->ntotal, *dis, sel_all, res_max);
             } else {
-                faiss::cppcontrib::knowhere::brute_force_range_search_impl<typename RH_max::SingleResultHandler,
-                                                                           faiss::DistanceComputer, faiss::IDSelector>(
+                knowherefaiss::cppcontrib::knowhere::brute_force_range_search_impl<typename RH_max::SingleResultHandler,
+                                                                           knowherefaiss::DistanceComputer, knowherefaiss::IDSelector>(
                     index->ntotal, *dis, *sel, res_max);
             }
 
@@ -182,14 +182,14 @@ IndexBruteForceWrapper::range_search(faiss::idx_t n, const float* x, float radiu
 
             if (sel == nullptr) {
                 // Compiler is expected to de-virtualize virtual method calls
-                faiss::IDSelectorAll sel_all;
+                knowherefaiss::IDSelectorAll sel_all;
 
-                faiss::cppcontrib::knowhere::brute_force_range_search_impl<
-                    typename RH_min::SingleResultHandler, faiss::DistanceComputer, faiss::IDSelectorAll>(
+                knowherefaiss::cppcontrib::knowhere::brute_force_range_search_impl<
+                    typename RH_min::SingleResultHandler, knowherefaiss::DistanceComputer, knowherefaiss::IDSelectorAll>(
                     index->ntotal, *dis, sel_all, res_min);
             } else {
-                faiss::cppcontrib::knowhere::brute_force_range_search_impl<typename RH_min::SingleResultHandler,
-                                                                           faiss::DistanceComputer, faiss::IDSelector>(
+                knowherefaiss::cppcontrib::knowhere::brute_force_range_search_impl<typename RH_min::SingleResultHandler,
+                                                                           knowherefaiss::DistanceComputer, knowherefaiss::IDSelector>(
                     index->ntotal, *dis, *sel, res_min);
             }
 
diff --git a/src/index/hnsw/impl/IndexBruteForceWrapper.h b/src/index/hnsw/impl/IndexBruteForceWrapper.h
index afa4d2a3..9965ba9d 100644
--- a/src/index/hnsw/impl/IndexBruteForceWrapper.h
+++ b/src/index/hnsw/impl/IndexBruteForceWrapper.h
@@ -11,24 +11,24 @@
 
 #pragma once
 
-#include <faiss/Index.h>
-#include <faiss/cppcontrib/knowhere/IndexWrapper.h>
+#include <knowherefaiss/Index.h>
+#include <knowherefaiss/cppcontrib/knowhere/IndexWrapper.h>
 
 namespace knowhere {
 
 // override a search procedure to perform a brute-force search.
-struct IndexBruteForceWrapper : public faiss::cppcontrib::knowhere::IndexWrapper {
-    IndexBruteForceWrapper(faiss::Index* underlying_index);
+struct IndexBruteForceWrapper : public knowherefaiss::cppcontrib::knowhere::IndexWrapper {
+    IndexBruteForceWrapper(knowherefaiss::Index* underlying_index);
 
     /// entry point for search
     void
-    search(faiss::idx_t n, const float* x, faiss::idx_t k, float* distances, faiss::idx_t* labels,
-           const faiss::SearchParameters* params) const override;
+    search(knowherefaiss::idx_t n, const float* x, knowherefaiss::idx_t k, float* distances, knowherefaiss::idx_t* labels,
+           const knowherefaiss::SearchParameters* params) const override;
 
     /// entry point for range search
     void
-    range_search(faiss::idx_t n, const float* x, float radius, faiss::RangeSearchResult* result,
-                 const faiss::SearchParameters* params) const override;
+    range_search(knowherefaiss::idx_t n, const float* x, float radius, knowherefaiss::RangeSearchResult* result,
+                 const knowherefaiss::SearchParameters* params) const override;
 };
 
 }  // namespace knowhere
diff --git a/src/index/hnsw/impl/IndexConditionalWrapper.cc b/src/index/hnsw/impl/IndexConditionalWrapper.cc
index 69410cbd..fb82e2de 100644
--- a/src/index/hnsw/impl/IndexConditionalWrapper.cc
+++ b/src/index/hnsw/impl/IndexConditionalWrapper.cc
@@ -14,9 +14,9 @@
 #include <cstddef>
 #include <cstdint>
 
-#include "faiss/IndexCosine.h"
-#include "faiss/IndexHNSW.h"
-#include "faiss/IndexRefine.h"
+#include "knowherefaiss/IndexCosine.h"
+#include "knowherefaiss/IndexHNSW.h"
+#include "knowherefaiss/IndexRefine.h"
 #include "index/hnsw/impl/IndexBruteForceWrapper.h"
 #include "index/hnsw/impl/IndexHNSWWrapper.h"
 #include "index/hnsw/impl/IndexWrapperCosine.h"
@@ -32,7 +32,7 @@ namespace knowhere {
 // This may be applicable in case of very large topk values or
 //   extremely high filtering levels.
 std::optional<bool>
-WhetherPerformBruteForceSearch(const faiss::Index* index, const BaseConfig& cfg, const BitsetView& bitset) {
+WhetherPerformBruteForceSearch(const knowherefaiss::Index* index, const BaseConfig& cfg, const BitsetView& bitset) {
     // check if parameters have all we need
     if (!cfg.k.has_value() || index == nullptr) {
         return std::nullopt;
@@ -65,7 +65,7 @@ WhetherPerformBruteForceSearch(const faiss::Index* index, const BaseConfig& cfg,
 // This may be applicable in case of very large topk values or
 //   extremely high filtering levels.
 std::optional<bool>
-WhetherPerformBruteForceRangeSearch(const faiss::Index* index, const FaissHnswConfig& cfg, const BitsetView& bitset) {
+WhetherPerformBruteForceRangeSearch(const knowherefaiss::Index* index, const FaissHnswConfig& cfg, const BitsetView& bitset) {
     // check if parameters have all we need
     if (!cfg.ef.has_value() || index == nullptr) {
         return std::nullopt;
@@ -98,19 +98,19 @@ WhetherPerformBruteForceRangeSearch(const faiss::Index* index, const FaissHnswCo
 //
 // `whether_to_enable_refine` allows to enable the refine for the search if the
 //    index was trained with the refine.
-std::tuple<std::unique_ptr<faiss::Index>, bool>
-create_conditional_hnsw_wrapper(faiss::Index* index, const FaissHnswConfig& hnsw_cfg, const bool whether_bf_search,
+std::tuple<std::unique_ptr<knowherefaiss::Index>, bool>
+create_conditional_hnsw_wrapper(knowherefaiss::Index* index, const FaissHnswConfig& hnsw_cfg, const bool whether_bf_search,
                                 const bool whether_to_enable_refine) {
     const bool is_cosine = IsMetricType(hnsw_cfg.metric_type.value(), knowhere::metric::COSINE);
 
     // check if we have a refine available.
-    faiss::IndexRefine* const index_refine = dynamic_cast<faiss::IndexRefine*>(index);
+    knowherefaiss::IndexRefine* const index_refine = dynamic_cast<knowherefaiss::IndexRefine*>(index);
 
     if (index_refine != nullptr) {
         // yes, it is possible to refine results.
 
         // cast a base index to IndexHNSW-based index
-        faiss::IndexHNSW* const index_hnsw = dynamic_cast<faiss::IndexHNSW*>(index_refine->base_index);
+        knowherefaiss::IndexHNSW* const index_hnsw = dynamic_cast<knowherefaiss::IndexHNSW*>(index_refine->base_index);
 
         if (index_hnsw == nullptr) {
             // this is unexpected
@@ -119,7 +119,7 @@ create_conditional_hnsw_wrapper(faiss::Index* index, const FaissHnswConfig& hnsw
 
         // select a wrapper index, which is safe to delete without deleting
         //   an original index
-        std::unique_ptr<faiss::Index> base_wrapper;
+        std::unique_ptr<knowherefaiss::Index> base_wrapper;
 
         if (whether_bf_search) {
             // use brute-force wrapper
@@ -142,11 +142,11 @@ create_conditional_hnsw_wrapper(faiss::Index* index, const FaissHnswConfig& hnsw
                 std::unique_ptr<knowhere::IndexWrapperCosine> cosine_wrapper =
                     std::make_unique<knowhere::IndexWrapperCosine>(
                         index_refine->refine_index,
-                        dynamic_cast<faiss::HasInverseL2Norms*>(index_hnsw->storage)->get_inverse_l2_norms());
+                        dynamic_cast<knowherefaiss::HasInverseL2Norms*>(index_hnsw->storage)->get_inverse_l2_norms());
 
                 // create a temporary refine index
-                std::unique_ptr<faiss::IndexRefine> refine_wrapper =
-                    std::make_unique<faiss::IndexRefine>(base_wrapper.get(), cosine_wrapper.get());
+                std::unique_ptr<knowherefaiss::IndexRefine> refine_wrapper =
+                    std::make_unique<knowherefaiss::IndexRefine>(base_wrapper.get(), cosine_wrapper.get());
 
                 // transfer ownership
                 refine_wrapper->own_fields = true;
@@ -161,8 +161,8 @@ create_conditional_hnsw_wrapper(faiss::Index* index, const FaissHnswConfig& hnsw
                 // no, wrap base index only.
 
                 // create a temporary refine index
-                std::unique_ptr<faiss::IndexRefine> refine_wrapper =
-                    std::make_unique<faiss::IndexRefine>(base_wrapper.get(), index_refine->refine_index);
+                std::unique_ptr<knowherefaiss::IndexRefine> refine_wrapper =
+                    std::make_unique<knowherefaiss::IndexRefine>(base_wrapper.get(), index_refine->refine_index);
 
                 // transfer ownership
                 refine_wrapper->own_fields = true;
@@ -179,7 +179,7 @@ create_conditional_hnsw_wrapper(faiss::Index* index, const FaissHnswConfig& hnsw
         }
     } else {
         // cast to IndexHNSW-based index
-        faiss::IndexHNSW* const index_hnsw = dynamic_cast<faiss::IndexHNSW*>(index);
+        knowherefaiss::IndexHNSW* const index_hnsw = dynamic_cast<knowherefaiss::IndexHNSW*>(index);
 
         if (index_hnsw == nullptr) {
             // this is unexpected
@@ -187,7 +187,7 @@ create_conditional_hnsw_wrapper(faiss::Index* index, const FaissHnswConfig& hnsw
         }
 
         // select a wrapper index for search
-        std::unique_ptr<faiss::Index> base_wrapper;
+        std::unique_ptr<knowherefaiss::Index> base_wrapper;
 
         if (whether_bf_search) {
             // use brute-force wrapper
diff --git a/src/index/hnsw/impl/IndexConditionalWrapper.h b/src/index/hnsw/impl/IndexConditionalWrapper.h
index 84d86ee1..4ad18bb2 100644
--- a/src/index/hnsw/impl/IndexConditionalWrapper.h
+++ b/src/index/hnsw/impl/IndexConditionalWrapper.h
@@ -17,7 +17,7 @@
 #include <optional>
 #include <tuple>
 
-#include "faiss/Index.h"
+#include "knowherefaiss/Index.h"
 #include "index/hnsw/faiss_hnsw_config.h"
 #include "knowhere/bitsetview.h"
 
@@ -33,21 +33,21 @@ struct HnswSearchThresholds {
 // This may be applicable in case of very large topk values or
 //   extremely high filtering levels.
 std::optional<bool>
-WhetherPerformBruteForceSearch(const faiss::Index* index, const BaseConfig& cfg, const BitsetView& bitset);
+WhetherPerformBruteForceSearch(const knowherefaiss::Index* index, const BaseConfig& cfg, const BitsetView& bitset);
 
 // Decides whether a brute force should be used instead of a regular HNSW range search.
 // This may be applicable in case of very large topk values or
 //   extremely high filtering levels.
 std::optional<bool>
-WhetherPerformBruteForceRangeSearch(const faiss::Index* index, const FaissHnswConfig& cfg, const BitsetView& bitset);
+WhetherPerformBruteForceRangeSearch(const knowherefaiss::Index* index, const FaissHnswConfig& cfg, const BitsetView& bitset);
 
 // first return arg: returns nullptr in case of invalid index
 // second return arg: returns whether an index does the refine
 //
 // `whether_to_enable_refine` allows to enable the refine for the search if the
 //    index was trained with the refine.
-std::tuple<std::unique_ptr<faiss::Index>, bool>
-create_conditional_hnsw_wrapper(faiss::Index* index, const FaissHnswConfig& hnsw_cfg, const bool whether_bf_search,
+std::tuple<std::unique_ptr<knowherefaiss::Index>, bool>
+create_conditional_hnsw_wrapper(knowherefaiss::Index* index, const FaissHnswConfig& hnsw_cfg, const bool whether_bf_search,
                                 const bool whether_to_enable_refine);
 
 }  // namespace knowhere
diff --git a/src/index/hnsw/impl/IndexHNSWWrapper.cc b/src/index/hnsw/impl/IndexHNSWWrapper.cc
index cadbc639..f5ef1e2b 100644
--- a/src/index/hnsw/impl/IndexHNSWWrapper.cc
+++ b/src/index/hnsw/impl/IndexHNSWWrapper.cc
@@ -11,16 +11,16 @@
 
 #include "index/hnsw/impl/IndexHNSWWrapper.h"
 
-#include <faiss/IndexHNSW.h>
-#include <faiss/MetricType.h>
-#include <faiss/cppcontrib/knowhere/impl/Bruteforce.h>
-#include <faiss/cppcontrib/knowhere/impl/HnswSearcher.h>
-#include <faiss/cppcontrib/knowhere/utils/Bitset.h>
-#include <faiss/impl/AuxIndexStructures.h>
-#include <faiss/impl/DistanceComputer.h>
-#include <faiss/impl/FaissAssert.h>
-#include <faiss/impl/HNSW.h>
-#include <faiss/impl/ResultHandler.h>
+#include <knowherefaiss/IndexHNSW.h>
+#include <knowherefaiss/MetricType.h>
+#include <knowherefaiss/cppcontrib/knowhere/impl/Bruteforce.h>
+#include <knowherefaiss/cppcontrib/knowhere/impl/HnswSearcher.h>
+#include <knowherefaiss/cppcontrib/knowhere/utils/Bitset.h>
+#include <knowherefaiss/impl/AuxIndexStructures.h>
+#include <knowherefaiss/impl/DistanceComputer.h>
+#include <knowherefaiss/impl/FaissAssert.h>
+#include <knowherefaiss/impl/HNSW.h>
+#include <knowherefaiss/impl/ResultHandler.h>
 
 #include <algorithm>
 #include <cstddef>
@@ -45,10 +45,10 @@ namespace knowhere {
 namespace {
 
 // cloned from IndexHNSW.cpp
-faiss::DistanceComputer*
-storage_distance_computer(const faiss::Index* storage) {
-    if (faiss::is_similarity_metric(storage->metric_type)) {
-        return new faiss::NegativeDistanceComputer(storage->get_distance_computer());
+knowherefaiss::DistanceComputer*
+storage_distance_computer(const knowherefaiss::Index* storage) {
+    if (knowherefaiss::is_similarity_metric(storage->metric_type)) {
+        return new knowherefaiss::NegativeDistanceComputer(storage->get_distance_computer());
     } else {
         return storage->get_distance_computer();
     }
@@ -60,24 +60,24 @@ storage_distance_computer(const faiss::Index* storage) {
  * IndexHNSWWrapper implementation
  **************************************************************/
 
-using idx_t = faiss::idx_t;
+using idx_t = knowherefaiss::idx_t;
 
-IndexHNSWWrapper::IndexHNSWWrapper(faiss::IndexHNSW* underlying_index)
-    : faiss::cppcontrib::knowhere::IndexWrapper(underlying_index) {
+IndexHNSWWrapper::IndexHNSWWrapper(knowherefaiss::IndexHNSW* underlying_index)
+    : knowherefaiss::cppcontrib::knowhere::IndexWrapper(underlying_index) {
 }
 
 void
 IndexHNSWWrapper::search(idx_t n, const float* __restrict x, idx_t k, float* __restrict distances,
-                         idx_t* __restrict labels, const faiss::SearchParameters* __restrict params_in) const {
+                         idx_t* __restrict labels, const knowherefaiss::SearchParameters* __restrict params_in) const {
     FAISS_THROW_IF_NOT(k > 0);
 
-    const faiss::IndexHNSW* index_hnsw = dynamic_cast<const faiss::IndexHNSW*>(index);
+    const knowherefaiss::IndexHNSW* index_hnsw = dynamic_cast<const knowherefaiss::IndexHNSW*>(index);
     FAISS_THROW_IF_NOT(index_hnsw);
 
     FAISS_THROW_IF_NOT_MSG(index_hnsw->storage, "No storage index");
 
     // set up
-    using C = faiss::HNSW::C;
+    using C = knowherefaiss::HNSW::C;
 
     // check if the graph is empty
     if (index_hnsw->hnsw.entry_point == -1) {
@@ -91,7 +91,7 @@ IndexHNSWWrapper::search(idx_t n, const float* __restrict x, idx_t k, float* __r
 
     // check parameters
     const SearchParametersHNSWWrapper* params = nullptr;
-    const faiss::HNSW& hnsw = index_hnsw->hnsw;
+    const knowherefaiss::HNSW& hnsw = index_hnsw->hnsw;
 
     float kAlpha = 0.0f;
     if (params_in) {
@@ -102,7 +102,7 @@ IndexHNSWWrapper::search(idx_t n, const float* __restrict x, idx_t k, float* __r
     }
 
     // set up hnsw_stats
-    faiss::HNSWStats* __restrict const hnsw_stats = (params == nullptr) ? nullptr : params->hnsw_stats;
+    knowherefaiss::HNSWStats* __restrict const hnsw_stats = (params == nullptr) ? nullptr : params->hnsw_stats;
 
     //
     size_t n1 = 0;
@@ -111,11 +111,11 @@ IndexHNSWWrapper::search(idx_t n, const float* __restrict x, idx_t k, float* __r
     size_t nhops = 0;
 
     //
-    faiss::cppcontrib::knowhere::Bitset bitset_visited_nodes =
-        faiss::cppcontrib::knowhere::Bitset::create_uninitialized(index->ntotal);
+    knowherefaiss::cppcontrib::knowhere::Bitset bitset_visited_nodes =
+        knowherefaiss::cppcontrib::knowhere::Bitset::create_uninitialized(index->ntotal);
 
     // create a distance computer
-    std::unique_ptr<faiss::DistanceComputer> dis(storage_distance_computer(index_hnsw->storage));
+    std::unique_ptr<knowherefaiss::DistanceComputer> dis(storage_distance_computer(index_hnsw->storage));
 
     // no parallelism by design
     for (idx_t i = 0; i < n; i++) {
@@ -129,10 +129,10 @@ IndexHNSWWrapper::search(idx_t n, const float* __restrict x, idx_t k, float* __r
         knowhere::feder::hnsw::FederResult* feder = (params == nullptr) ? nullptr : params->feder;
 
         // future results
-        faiss::HNSWStats local_stats;
+        knowherefaiss::HNSWStats local_stats;
 
         // set up a filter
-        faiss::IDSelector* sel = (params == nullptr) ? nullptr : params->sel;
+        knowherefaiss::IDSelector* sel = (params == nullptr) ? nullptr : params->sel;
 
         // try knowhere-specific filter
         if (const knowhere::BitsetViewWithMappingIDSelector* __restrict bw_idselector =
@@ -145,8 +145,8 @@ IndexHNSWWrapper::search(idx_t n, const float* __restrict x, idx_t k, float* __r
                 DummyVisitor graph_visitor;
 
                 using searcher_type =
-                    faiss::cppcontrib::knowhere::v2_hnsw_searcher<faiss::DistanceComputer, DummyVisitor,
-                                                                  faiss::cppcontrib::knowhere::Bitset,
+                    knowherefaiss::cppcontrib::knowhere::v2_hnsw_searcher<knowherefaiss::DistanceComputer, DummyVisitor,
+                                                                  knowherefaiss::cppcontrib::knowhere::Bitset,
                                                                   knowhere::BitsetViewWithMappingIDSelector>;
 
                 searcher_type searcher{hnsw,           *(dis.get()), graph_visitor, bitset_visited_nodes,
@@ -158,8 +158,8 @@ IndexHNSWWrapper::search(idx_t n, const float* __restrict x, idx_t k, float* __r
                 FederVisitor graph_visitor(feder);
 
                 using searcher_type =
-                    faiss::cppcontrib::knowhere::v2_hnsw_searcher<faiss::DistanceComputer, FederVisitor,
-                                                                  faiss::cppcontrib::knowhere::Bitset,
+                    knowherefaiss::cppcontrib::knowhere::v2_hnsw_searcher<knowherefaiss::DistanceComputer, FederVisitor,
+                                                                  knowherefaiss::cppcontrib::knowhere::Bitset,
                                                                   knowhere::BitsetViewWithMappingIDSelector>;
 
                 searcher_type searcher{hnsw,           *(dis.get()), graph_visitor, bitset_visited_nodes,
@@ -178,8 +178,8 @@ IndexHNSWWrapper::search(idx_t n, const float* __restrict x, idx_t k, float* __r
                 DummyVisitor graph_visitor;
 
                 using searcher_type =
-                    faiss::cppcontrib::knowhere::v2_hnsw_searcher<faiss::DistanceComputer, DummyVisitor,
-                                                                  faiss::cppcontrib::knowhere::Bitset,
+                    knowherefaiss::cppcontrib::knowhere::v2_hnsw_searcher<knowherefaiss::DistanceComputer, DummyVisitor,
+                                                                  knowherefaiss::cppcontrib::knowhere::Bitset,
                                                                   knowhere::BitsetViewIDSelector>;
 
                 searcher_type searcher{hnsw,           *(dis.get()), graph_visitor, bitset_visited_nodes,
@@ -191,8 +191,8 @@ IndexHNSWWrapper::search(idx_t n, const float* __restrict x, idx_t k, float* __r
                 FederVisitor graph_visitor(feder);
 
                 using searcher_type =
-                    faiss::cppcontrib::knowhere::v2_hnsw_searcher<faiss::DistanceComputer, FederVisitor,
-                                                                  faiss::cppcontrib::knowhere::Bitset,
+                    knowherefaiss::cppcontrib::knowhere::v2_hnsw_searcher<knowherefaiss::DistanceComputer, FederVisitor,
+                                                                  knowherefaiss::cppcontrib::knowhere::Bitset,
                                                                   knowhere::BitsetViewIDSelector>;
 
                 searcher_type searcher{hnsw,           *(dis.get()), graph_visitor, bitset_visited_nodes,
@@ -202,15 +202,15 @@ IndexHNSWWrapper::search(idx_t n, const float* __restrict x, idx_t k, float* __r
             }
         } else {
             // no filter
-            faiss::IDSelectorAll sel_all;
+            knowherefaiss::IDSelectorAll sel_all;
 
             // feder templating is important, bcz it removes an unneeded 'CALL' instruction.
             if (feder == nullptr) {
                 // no feder
                 DummyVisitor graph_visitor;
 
-                using searcher_type = faiss::cppcontrib::knowhere::v2_hnsw_searcher<
-                    faiss::DistanceComputer, DummyVisitor, faiss::cppcontrib::knowhere::Bitset, faiss::IDSelectorAll>;
+                using searcher_type = knowherefaiss::cppcontrib::knowhere::v2_hnsw_searcher<
+                    knowherefaiss::DistanceComputer, DummyVisitor, knowherefaiss::cppcontrib::knowhere::Bitset, knowherefaiss::IDSelectorAll>;
 
                 searcher_type searcher{hnsw,    *(dis.get()), graph_visitor, bitset_visited_nodes,
                                        sel_all, kAlpha,       params};
@@ -220,8 +220,8 @@ IndexHNSWWrapper::search(idx_t n, const float* __restrict x, idx_t k, float* __r
                 // use feder
                 FederVisitor graph_visitor(feder);
 
-                using searcher_type = faiss::cppcontrib::knowhere::v2_hnsw_searcher<
-                    faiss::DistanceComputer, FederVisitor, faiss::cppcontrib::knowhere::Bitset, faiss::IDSelectorAll>;
+                using searcher_type = knowherefaiss::cppcontrib::knowhere::v2_hnsw_searcher<
+                    knowherefaiss::DistanceComputer, FederVisitor, knowherefaiss::cppcontrib::knowhere::Bitset, knowherefaiss::IDSelectorAll>;
 
                 searcher_type searcher{hnsw,    *(dis.get()), graph_visitor, bitset_visited_nodes,
                                        sel_all, kAlpha,       params};
@@ -260,9 +260,9 @@ IndexHNSWWrapper::search(idx_t n, const float* __restrict x, idx_t k, float* __r
 
 void
 IndexHNSWWrapper::range_search(idx_t n, const float* __restrict x, float radius_in,
-                               faiss::RangeSearchResult* __restrict result,
-                               const faiss::SearchParameters* __restrict params_in) const {
-    const faiss::IndexHNSW* index_hnsw = dynamic_cast<const faiss::IndexHNSW*>(index);
+                               knowherefaiss::RangeSearchResult* __restrict result,
+                               const knowherefaiss::SearchParameters* __restrict params_in) const {
+    const knowherefaiss::IndexHNSW* index_hnsw = dynamic_cast<const knowherefaiss::IndexHNSW*>(index);
     FAISS_THROW_IF_NOT(index_hnsw);
 
     FAISS_THROW_IF_NOT_MSG(index_hnsw->storage, "No storage index");
@@ -274,7 +274,7 @@ IndexHNSWWrapper::range_search(idx_t n, const float* __restrict x, float radius_
 
     // check parameters
     const SearchParametersHNSWWrapper* params = nullptr;
-    const faiss::HNSW& hnsw = index_hnsw->hnsw;
+    const knowherefaiss::HNSW& hnsw = index_hnsw->hnsw;
 
     float kAlpha = 0.0f;
     if (params_in) {
@@ -285,7 +285,7 @@ IndexHNSWWrapper::range_search(idx_t n, const float* __restrict x, float radius_
     }
 
     // set up hnsw_stats
-    faiss::HNSWStats* __restrict const hnsw_stats = (params == nullptr) ? nullptr : params->hnsw_stats;
+    knowherefaiss::HNSWStats* __restrict const hnsw_stats = (params == nullptr) ? nullptr : params->hnsw_stats;
 
     //
     size_t n1 = 0;
@@ -294,11 +294,11 @@ IndexHNSWWrapper::range_search(idx_t n, const float* __restrict x, float radius_
     size_t nhops = 0;
 
     //
-    faiss::cppcontrib::knowhere::Bitset bitset_visited_nodes =
-        faiss::cppcontrib::knowhere::Bitset::create_uninitialized(index->ntotal);
+    knowherefaiss::cppcontrib::knowhere::Bitset bitset_visited_nodes =
+        knowherefaiss::cppcontrib::knowhere::Bitset::create_uninitialized(index->ntotal);
 
     // create a distance computer
-    std::unique_ptr<faiss::DistanceComputer> dis(storage_distance_computer(index_hnsw->storage));
+    std::unique_ptr<knowherefaiss::DistanceComputer> dis(storage_distance_computer(index_hnsw->storage));
 
     // radius
     float radius = radius_in;
@@ -307,7 +307,7 @@ IndexHNSWWrapper::range_search(idx_t n, const float* __restrict x, float radius_
     }
 
     // initialize a ResultHandler
-    using RH_min = faiss::RangeSearchBlockResultHandler<faiss::CMax<float, int64_t>>;
+    using RH_min = knowherefaiss::RangeSearchBlockResultHandler<knowherefaiss::CMax<float, int64_t>>;
     RH_min bres_min(result, radius);
 
     // no parallelism by design
@@ -326,10 +326,10 @@ IndexHNSWWrapper::range_search(idx_t n, const float* __restrict x, float radius_
         knowhere::feder::hnsw::FederResult* feder = (params == nullptr) ? nullptr : params->feder;
 
         // future results
-        faiss::HNSWStats local_stats;
+        knowherefaiss::HNSWStats local_stats;
 
         // set up a filter
-        faiss::IDSelector* sel = (params == nullptr) ? nullptr : params->sel;
+        knowherefaiss::IDSelector* sel = (params == nullptr) ? nullptr : params->sel;
 
         // try knowhere-specific filter
         if (const knowhere::BitsetViewWithMappingIDSelector* __restrict bw_idselector =
@@ -343,8 +343,8 @@ IndexHNSWWrapper::range_search(idx_t n, const float* __restrict x, float radius_
                 DummyVisitor graph_visitor;
 
                 using searcher_type =
-                    faiss::cppcontrib::knowhere::v2_hnsw_searcher<faiss::DistanceComputer, DummyVisitor,
-                                                                  faiss::cppcontrib::knowhere::Bitset,
+                    knowherefaiss::cppcontrib::knowhere::v2_hnsw_searcher<knowherefaiss::DistanceComputer, DummyVisitor,
+                                                                  knowherefaiss::cppcontrib::knowhere::Bitset,
                                                                   knowhere::BitsetViewWithMappingIDSelector>;
 
                 searcher_type searcher{hnsw,           *(dis.get()), graph_visitor, bitset_visited_nodes,
@@ -356,8 +356,8 @@ IndexHNSWWrapper::range_search(idx_t n, const float* __restrict x, float radius_
                 FederVisitor graph_visitor(feder);
 
                 using searcher_type =
-                    faiss::cppcontrib::knowhere::v2_hnsw_searcher<faiss::DistanceComputer, FederVisitor,
-                                                                  faiss::cppcontrib::knowhere::Bitset,
+                    knowherefaiss::cppcontrib::knowhere::v2_hnsw_searcher<knowherefaiss::DistanceComputer, FederVisitor,
+                                                                  knowherefaiss::cppcontrib::knowhere::Bitset,
                                                                   knowhere::BitsetViewWithMappingIDSelector>;
 
                 searcher_type searcher{hnsw,           *(dis.get()), graph_visitor, bitset_visited_nodes,
@@ -376,8 +376,8 @@ IndexHNSWWrapper::range_search(idx_t n, const float* __restrict x, float radius_
                 DummyVisitor graph_visitor;
 
                 using searcher_type =
-                    faiss::cppcontrib::knowhere::v2_hnsw_searcher<faiss::DistanceComputer, DummyVisitor,
-                                                                  faiss::cppcontrib::knowhere::Bitset,
+                    knowherefaiss::cppcontrib::knowhere::v2_hnsw_searcher<knowherefaiss::DistanceComputer, DummyVisitor,
+                                                                  knowherefaiss::cppcontrib::knowhere::Bitset,
                                                                   knowhere::BitsetViewIDSelector>;
 
                 searcher_type searcher{hnsw,           *(dis.get()), graph_visitor, bitset_visited_nodes,
@@ -389,8 +389,8 @@ IndexHNSWWrapper::range_search(idx_t n, const float* __restrict x, float radius_
                 FederVisitor graph_visitor(feder);
 
                 using searcher_type =
-                    faiss::cppcontrib::knowhere::v2_hnsw_searcher<faiss::DistanceComputer, FederVisitor,
-                                                                  faiss::cppcontrib::knowhere::Bitset,
+                    knowherefaiss::cppcontrib::knowhere::v2_hnsw_searcher<knowherefaiss::DistanceComputer, FederVisitor,
+                                                                  knowherefaiss::cppcontrib::knowhere::Bitset,
                                                                   knowhere::BitsetViewIDSelector>;
 
                 searcher_type searcher{hnsw,           *(dis.get()), graph_visitor, bitset_visited_nodes,
@@ -400,15 +400,15 @@ IndexHNSWWrapper::range_search(idx_t n, const float* __restrict x, float radius_
             }
         } else {
             // no filter
-            faiss::IDSelectorAll sel_all;
+            knowherefaiss::IDSelectorAll sel_all;
 
             // feder templating is important, bcz it removes an unneeded 'CALL' instruction.
             if (feder == nullptr) {
                 // no feder
                 DummyVisitor graph_visitor;
 
-                using searcher_type = faiss::cppcontrib::knowhere::v2_hnsw_searcher<
-                    faiss::DistanceComputer, DummyVisitor, faiss::cppcontrib::knowhere::Bitset, faiss::IDSelectorAll>;
+                using searcher_type = knowherefaiss::cppcontrib::knowhere::v2_hnsw_searcher<
+                    knowherefaiss::DistanceComputer, DummyVisitor, knowherefaiss::cppcontrib::knowhere::Bitset, knowherefaiss::IDSelectorAll>;
 
                 searcher_type searcher{hnsw,    *(dis.get()), graph_visitor, bitset_visited_nodes,
                                        sel_all, kAlpha,       params};
@@ -418,8 +418,8 @@ IndexHNSWWrapper::range_search(idx_t n, const float* __restrict x, float radius_
                 // use feder
                 FederVisitor graph_visitor(feder);
 
-                using searcher_type = faiss::cppcontrib::knowhere::v2_hnsw_searcher<
-                    faiss::DistanceComputer, FederVisitor, faiss::cppcontrib::knowhere::Bitset, faiss::IDSelectorAll>;
+                using searcher_type = knowherefaiss::cppcontrib::knowhere::v2_hnsw_searcher<
+                    knowherefaiss::DistanceComputer, FederVisitor, knowherefaiss::cppcontrib::knowhere::Bitset, knowherefaiss::IDSelectorAll>;
 
                 searcher_type searcher{hnsw,    *(dis.get()), graph_visitor, bitset_visited_nodes,
                                        sel_all, kAlpha,       params};
diff --git a/src/index/hnsw/impl/IndexHNSWWrapper.h b/src/index/hnsw/impl/IndexHNSWWrapper.h
index 7b4348c8..00d3196e 100644
--- a/src/index/hnsw/impl/IndexHNSWWrapper.h
+++ b/src/index/hnsw/impl/IndexHNSWWrapper.h
@@ -11,8 +11,8 @@
 
 #pragma once
 
-#include <faiss/IndexHNSW.h>
-#include <faiss/cppcontrib/knowhere/IndexWrapper.h>
+#include <knowherefaiss/IndexHNSW.h>
+#include <knowherefaiss/cppcontrib/knowhere/IndexWrapper.h>
 
 #include <cstddef>
 #include <cstdint>
@@ -22,9 +22,9 @@
 namespace knowhere {
 
 // Custom parameters for IndexHNSW.
-struct SearchParametersHNSWWrapper : public faiss::SearchParametersHNSW {
+struct SearchParametersHNSWWrapper : public knowherefaiss::SearchParametersHNSW {
     // Stats will be updated if the object pointer is provided.
-    faiss::HNSWStats* hnsw_stats = nullptr;
+    knowherefaiss::HNSWStats* hnsw_stats = nullptr;
     // feder will be updated if the object pointer is provided.
     knowhere::feder::hnsw::FederResult* feder = nullptr;
     // filtering parameter
@@ -39,18 +39,18 @@ struct SearchParametersHNSWWrapper : public faiss::SearchParametersHNSW {
 //   work correctly for 2B+ samples. This can be easily changed, if needed.
 
 // override a search() procedure for IndexHNSW.
-struct IndexHNSWWrapper : public faiss::cppcontrib::knowhere::IndexWrapper {
-    IndexHNSWWrapper(faiss::IndexHNSW* underlying_index);
+struct IndexHNSWWrapper : public knowherefaiss::cppcontrib::knowhere::IndexWrapper {
+    IndexHNSWWrapper(knowherefaiss::IndexHNSW* underlying_index);
 
     /// entry point for search
     void
-    search(faiss::idx_t n, const float* x, faiss::idx_t k, float* distances, faiss::idx_t* labels,
-           const faiss::SearchParameters* params) const override;
+    search(knowherefaiss::idx_t n, const float* x, knowherefaiss::idx_t k, float* distances, knowherefaiss::idx_t* labels,
+           const knowherefaiss::SearchParameters* params) const override;
 
     /// entry point for range search
     void
-    range_search(faiss::idx_t n, const float* x, float radius, faiss::RangeSearchResult* result,
-                 const faiss::SearchParameters* params) const override;
+    range_search(knowherefaiss::idx_t n, const float* x, float radius, knowherefaiss::RangeSearchResult* result,
+                 const knowherefaiss::SearchParameters* params) const override;
 };
 
 }  // namespace knowhere
diff --git a/src/index/hnsw/impl/IndexWrapperCosine.cc b/src/index/hnsw/impl/IndexWrapperCosine.cc
index e022d102..c67a6fea 100644
--- a/src/index/hnsw/impl/IndexWrapperCosine.cc
+++ b/src/index/hnsw/impl/IndexWrapperCosine.cc
@@ -11,19 +11,19 @@
 
 #include "index/hnsw/impl/IndexWrapperCosine.h"
 
-#include <faiss/IndexCosine.h>
+#include <knowherefaiss/IndexCosine.h>
 
 namespace knowhere {
 
 // a wrapper that overrides a distance computer
-IndexWrapperCosine::IndexWrapperCosine(faiss::Index* index, const float* inverse_l2_norms_in)
-    : faiss::cppcontrib::knowhere::IndexWrapper(index), inverse_l2_norms{inverse_l2_norms_in} {
+IndexWrapperCosine::IndexWrapperCosine(knowherefaiss::Index* index, const float* inverse_l2_norms_in)
+    : knowherefaiss::cppcontrib::knowhere::IndexWrapper(index), inverse_l2_norms{inverse_l2_norms_in} {
 }
 
-faiss::DistanceComputer*
+knowherefaiss::DistanceComputer*
 IndexWrapperCosine::get_distance_computer() const {
-    return new faiss::WithCosineNormDistanceComputer(
-        inverse_l2_norms, index->d, std::unique_ptr<faiss::DistanceComputer>(index->get_distance_computer()));
+    return new knowherefaiss::WithCosineNormDistanceComputer(
+        inverse_l2_norms, index->d, std::unique_ptr<knowherefaiss::DistanceComputer>(index->get_distance_computer()));
 }
 
 }  // namespace knowhere
diff --git a/src/index/hnsw/impl/IndexWrapperCosine.h b/src/index/hnsw/impl/IndexWrapperCosine.h
index eb048876..bef2a9bc 100644
--- a/src/index/hnsw/impl/IndexWrapperCosine.h
+++ b/src/index/hnsw/impl/IndexWrapperCosine.h
@@ -11,21 +11,21 @@
 
 #pragma once
 
-#include <faiss/Index.h>
-#include <faiss/cppcontrib/knowhere/IndexWrapper.h>
-#include <faiss/impl/DistanceComputer.h>
+#include <knowherefaiss/Index.h>
+#include <knowherefaiss/cppcontrib/knowhere/IndexWrapper.h>
+#include <knowherefaiss/impl/DistanceComputer.h>
 
 namespace knowhere {
 
 // overrides a distance compute function
-struct IndexWrapperCosine : public faiss::cppcontrib::knowhere::IndexWrapper {
+struct IndexWrapperCosine : public knowherefaiss::cppcontrib::knowhere::IndexWrapper {
     // a non-owning pointer
     const float* inverse_l2_norms;
 
     // norms are external
-    IndexWrapperCosine(faiss::Index* index, const float* inverse_l2_norms_in);
+    IndexWrapperCosine(knowherefaiss::Index* index, const float* inverse_l2_norms_in);
 
-    faiss::DistanceComputer*
+    knowherefaiss::DistanceComputer*
     get_distance_computer() const override;
 };
 
diff --git a/src/index/index_factory.cc b/src/index/index_factory.cc
index b9508910..e266d721 100644
--- a/src/index/index_factory.cc
+++ b/src/index/index_factory.cc
@@ -60,7 +60,7 @@ IndexFactory::Create(const std::string& name, const int32_t& version, const Obje
         return expected<Index<IndexNode>>::Err(Status::cuda_runtime_error, "gpu not available");
     }
 #endif
-    if (name == knowhere::IndexEnum::INDEX_FAISS_SCANN && !faiss::support_pq_fast_scan) {
+    if (name == knowhere::IndexEnum::INDEX_FAISS_SCANN && !knowherefaiss::support_pq_fast_scan) {
         LOG_KNOWHERE_ERROR_ << "SCANN index is not supported on the current CPU model";
         return expected<Index<IndexNode>>::Err(Status::invalid_index_error,
                                                "SCANN index is not supported on the current CPU model");
diff --git a/src/index/ivf/ivf.cc b/src/index/ivf/ivf.cc
index 141cf98f..55f1d4b6 100644
--- a/src/index/ivf/ivf.cc
+++ b/src/index/ivf/ivf.cc
@@ -10,19 +10,19 @@
 // or implied. See the License for the specific language governing permissions and limitations under the License.
 
 #include "common/metric.h"
-#include "faiss/IndexBinaryFlat.h"
-#include "faiss/IndexBinaryIVF.h"
-#include "faiss/IndexFlat.h"
-#include "faiss/IndexFlatElkan.h"
-#include "faiss/IndexIVFFlat.h"
-#include "faiss/IndexIVFPQ.h"
-#include "faiss/IndexIVFPQFastScan.h"
-#include "faiss/IndexIVFRaBitQ.h"
-#include "faiss/IndexIVFScalarQuantizerCC.h"
-#include "faiss/IndexScaNN.h"
-#include "faiss/IndexScalarQuantizer.h"
-#include "faiss/VectorTransform.h"
-#include "faiss/index_io.h"
+#include "knowherefaiss/IndexBinaryFlat.h"
+#include "knowherefaiss/IndexBinaryIVF.h"
+#include "knowherefaiss/IndexFlat.h"
+#include "knowherefaiss/IndexFlatElkan.h"
+#include "knowherefaiss/IndexIVFFlat.h"
+#include "knowherefaiss/IndexIVFPQ.h"
+#include "knowherefaiss/IndexIVFPQFastScan.h"
+#include "knowherefaiss/IndexIVFRaBitQ.h"
+#include "knowherefaiss/IndexIVFScalarQuantizerCC.h"
+#include "knowherefaiss/IndexScaNN.h"
+#include "knowherefaiss/IndexScalarQuantizer.h"
+#include "knowherefaiss/VectorTransform.h"
+#include "knowherefaiss/index_io.h"
 #include "index/data_view_dense_index/index_node_with_data_view_refiner.h"
 #include "index/ivf/ivf_config.h"
 #include "index/ivf/ivfrbq_wrapper.h"
@@ -49,7 +49,7 @@ struct IndexDispatch {
 };
 
 template <>
-struct IndexDispatch<faiss::IndexIVFFlat> {
+struct IndexDispatch<knowherefaiss::IndexIVFFlat> {
     using Tag = IVFFlatTag;
 };
 
@@ -57,13 +57,13 @@ template <typename DataType, typename IndexType>
 class IvfIndexNode : public IndexNode {
  public:
     IvfIndexNode(const int32_t version, const Object& object) : IndexNode(version), index_(nullptr) {
-        static_assert(std::is_same<IndexType, faiss::IndexIVFFlat>::value ||
-                          std::is_same<IndexType, faiss::IndexIVFFlatCC>::value ||
-                          std::is_same<IndexType, faiss::IndexIVFPQ>::value ||
-                          std::is_same<IndexType, faiss::IndexIVFScalarQuantizer>::value ||
-                          std::is_same<IndexType, faiss::IndexBinaryIVF>::value ||
-                          std::is_same<IndexType, faiss::IndexScaNN>::value ||
-                          std::is_same<IndexType, faiss::IndexIVFScalarQuantizerCC>::value ||
+        static_assert(std::is_same<IndexType, knowherefaiss::IndexIVFFlat>::value ||
+                          std::is_same<IndexType, knowherefaiss::IndexIVFFlatCC>::value ||
+                          std::is_same<IndexType, knowherefaiss::IndexIVFPQ>::value ||
+                          std::is_same<IndexType, knowherefaiss::IndexIVFScalarQuantizer>::value ||
+                          std::is_same<IndexType, knowherefaiss::IndexBinaryIVF>::value ||
+                          std::is_same<IndexType, knowherefaiss::IndexScaNN>::value ||
+                          std::is_same<IndexType, knowherefaiss::IndexIVFScalarQuantizerCC>::value ||
                           std::is_same<IndexType, IndexIVFRaBitQWrapper>::value,
                       "not support");
         static_assert(std::is_same_v<DataType, fp32> || std::is_same_v<DataType, bin1>,
@@ -81,11 +81,11 @@ class IvfIndexNode : public IndexNode {
     RangeSearch(const DataSetPtr dataset, std::unique_ptr<Config> cfg, const BitsetView& bitset) const override;
     static constexpr bool
     is_ann_iterator_supported() {
-        return (std::is_same<faiss::IndexIVFFlatCC, IndexType>::value ||
-                std::is_same<faiss::IndexIVFFlat, IndexType>::value ||
-                std::is_same<faiss::IndexIVFScalarQuantizer, IndexType>::value ||
-                std::is_same<faiss::IndexIVFScalarQuantizerCC, IndexType>::value ||
-                std::is_same<faiss::IndexScaNN, IndexType>::value ||
+        return (std::is_same<knowherefaiss::IndexIVFFlatCC, IndexType>::value ||
+                std::is_same<knowherefaiss::IndexIVFFlat, IndexType>::value ||
+                std::is_same<knowherefaiss::IndexIVFScalarQuantizer, IndexType>::value ||
+                std::is_same<knowherefaiss::IndexIVFScalarQuantizerCC, IndexType>::value ||
+                std::is_same<knowherefaiss::IndexScaNN, IndexType>::value ||
                 std::is_same<IndexIVFRaBitQWrapper, IndexType>::value);
     }
     expected<std::vector<IndexNode::IteratorPtr>>
@@ -123,19 +123,19 @@ class IvfIndexNode : public IndexNode {
 
     static bool
     CommonHasRawData() {
-        if constexpr (std::is_same<faiss::IndexIVFFlat, IndexType>::value) {
+        if constexpr (std::is_same<knowherefaiss::IndexIVFFlat, IndexType>::value) {
             return true;
         }
-        if constexpr (std::is_same<faiss::IndexIVFFlatCC, IndexType>::value) {
+        if constexpr (std::is_same<knowherefaiss::IndexIVFFlatCC, IndexType>::value) {
             return true;
         }
-        if constexpr (std::is_same<faiss::IndexIVFPQ, IndexType>::value) {
+        if constexpr (std::is_same<knowherefaiss::IndexIVFPQ, IndexType>::value) {
             return false;
         }
-        if constexpr (std::is_same<faiss::IndexIVFScalarQuantizer, IndexType>::value) {
+        if constexpr (std::is_same<knowherefaiss::IndexIVFScalarQuantizer, IndexType>::value) {
             return false;
         }
-        if constexpr (std::is_same<faiss::IndexBinaryIVF, IndexType>::value) {
+        if constexpr (std::is_same<knowherefaiss::IndexBinaryIVF, IndexType>::value) {
             return true;
         }
         if constexpr (std::is_same<IndexIVFRaBitQWrapper, IndexType>::value) {
@@ -146,11 +146,11 @@ class IvfIndexNode : public IndexNode {
 
     static bool
     StaticHasRawData(const knowhere::BaseConfig& config, const IndexVersion& version) {
-        if constexpr (std::is_same<faiss::IndexScaNN, IndexType>::value) {
+        if constexpr (std::is_same<knowherefaiss::IndexScaNN, IndexType>::value) {
             const ScannConfig& scann_cfg = static_cast<const ScannConfig&>(config);
             return scann_cfg.with_raw_data.has_value() && scann_cfg.with_raw_data.value();
         }
-        if constexpr (std::is_same<faiss::IndexIVFScalarQuantizerCC, IndexType>::value) {
+        if constexpr (std::is_same<knowherefaiss::IndexIVFScalarQuantizerCC, IndexType>::value) {
             const IvfSqCcConfig& ivfsqcc_cfg = static_cast<const IvfSqCcConfig&>(config);
             return ivfsqcc_cfg.raw_data_store_prefix.has_value();
         }
@@ -162,10 +162,10 @@ class IvfIndexNode : public IndexNode {
         if (!index_) {
             return false;
         }
-        if constexpr (std::is_same<faiss::IndexScaNN, IndexType>::value) {
+        if constexpr (std::is_same<knowherefaiss::IndexScaNN, IndexType>::value) {
             return index_->with_raw_data();
         }
-        if constexpr (std::is_same<faiss::IndexIVFScalarQuantizerCC, IndexType>::value) {
+        if constexpr (std::is_same<knowherefaiss::IndexIVFScalarQuantizerCC, IndexType>::value) {
             return index_->with_raw_data();
         }
         return CommonHasRawData();
@@ -185,25 +185,25 @@ class IvfIndexNode : public IndexNode {
 
     static std::unique_ptr<BaseConfig>
     StaticCreateConfig() {
-        if constexpr (std::is_same<faiss::IndexIVFFlat, IndexType>::value) {
+        if constexpr (std::is_same<knowherefaiss::IndexIVFFlat, IndexType>::value) {
             return std::make_unique<IvfFlatConfig>();
         }
-        if constexpr (std::is_same<faiss::IndexIVFFlatCC, IndexType>::value) {
+        if constexpr (std::is_same<knowherefaiss::IndexIVFFlatCC, IndexType>::value) {
             return std::make_unique<IvfFlatCcConfig>();
         }
-        if constexpr (std::is_same<faiss::IndexIVFPQ, IndexType>::value) {
+        if constexpr (std::is_same<knowherefaiss::IndexIVFPQ, IndexType>::value) {
             return std::make_unique<IvfPqConfig>();
         }
-        if constexpr (std::is_same<faiss::IndexScaNN, IndexType>::value) {
+        if constexpr (std::is_same<knowherefaiss::IndexScaNN, IndexType>::value) {
             return std::make_unique<ScannConfig>();
         }
-        if constexpr (std::is_same<faiss::IndexIVFScalarQuantizer, IndexType>::value) {
+        if constexpr (std::is_same<knowherefaiss::IndexIVFScalarQuantizer, IndexType>::value) {
             return std::make_unique<IvfSqConfig>();
         }
-        if constexpr (std::is_same<faiss::IndexBinaryIVF, IndexType>::value) {
+        if constexpr (std::is_same<knowherefaiss::IndexBinaryIVF, IndexType>::value) {
             return std::make_unique<IvfBinConfig>();
         }
-        if constexpr (std::is_same<faiss::IndexIVFScalarQuantizerCC, IndexType>::value) {
+        if constexpr (std::is_same<knowherefaiss::IndexIVFScalarQuantizerCC, IndexType>::value) {
             return std::make_unique<IvfSqCcConfig>();
         }
         if constexpr (std::is_same<IndexIVFRaBitQWrapper, IndexType>::value) {
@@ -228,19 +228,19 @@ class IvfIndexNode : public IndexNode {
         if (!index_) {
             return 0;
         }
-        if constexpr (std::is_same<IndexType, faiss::IndexIVFFlat>::value) {
+        if constexpr (std::is_same<IndexType, knowherefaiss::IndexIVFFlat>::value) {
             auto nb = index_->invlists->compute_ntotal();
             auto nlist = index_->nlist;
             auto code_size = index_->code_size;
             return ((nb + nlist) * (code_size + sizeof(int64_t)));
         }
-        if constexpr (std::is_same<IndexType, faiss::IndexIVFFlatCC>::value) {
+        if constexpr (std::is_same<IndexType, knowherefaiss::IndexIVFFlatCC>::value) {
             auto nb = index_->invlists->compute_ntotal();
             auto nlist = index_->nlist;
             auto code_size = index_->code_size;
             return (nb * code_size + nb * sizeof(int64_t) + nlist * code_size);
         }
-        if constexpr (std::is_same<IndexType, faiss::IndexIVFPQ>::value) {
+        if constexpr (std::is_same<IndexType, knowherefaiss::IndexIVFPQ>::value) {
             auto nb = index_->invlists->compute_ntotal();
             auto code_size = index_->code_size;
             auto pq = index_->pq;
@@ -252,22 +252,22 @@ class IvfIndexNode : public IndexNode {
             auto precomputed_table = nlist * pq.M * pq.ksub * sizeof(float);
             return (capacity + centroid_table + precomputed_table);
         }
-        if constexpr (std::is_same<IndexType, faiss::IndexScaNN>::value) {
+        if constexpr (std::is_same<IndexType, knowherefaiss::IndexScaNN>::value) {
             return index_->size();
         }
-        if constexpr (std::is_same<IndexType, faiss::IndexIVFScalarQuantizer>::value) {
+        if constexpr (std::is_same<IndexType, knowherefaiss::IndexIVFScalarQuantizer>::value) {
             auto nb = index_->invlists->compute_ntotal();
             auto code_size = index_->code_size;
             auto nlist = index_->nlist;
             return (nb * code_size + nb * sizeof(int64_t) + 2 * code_size + nlist * code_size);
         }
-        if constexpr (std::is_same<IndexType, faiss::IndexBinaryIVF>::value) {
+        if constexpr (std::is_same<IndexType, knowherefaiss::IndexBinaryIVF>::value) {
             auto nb = index_->invlists->compute_ntotal();
             auto nlist = index_->nlist;
             auto code_size = index_->code_size;
             return (nb * code_size + nb * sizeof(int64_t) + nlist * code_size);
         }
-        if constexpr (std::is_same<IndexType, faiss::IndexIVFScalarQuantizerCC>::value) {
+        if constexpr (std::is_same<IndexType, knowherefaiss::IndexIVFScalarQuantizerCC>::value) {
             auto nb = index_->invlists->compute_ntotal();
             auto code_size = index_->code_size;
             auto nlist = index_->nlist;
@@ -286,25 +286,25 @@ class IvfIndexNode : public IndexNode {
     };
     std::string
     Type() const override {
-        if constexpr (std::is_same<IndexType, faiss::IndexIVFFlat>::value) {
+        if constexpr (std::is_same<IndexType, knowherefaiss::IndexIVFFlat>::value) {
             return knowhere::IndexEnum::INDEX_FAISS_IVFFLAT;
         }
-        if constexpr (std::is_same<IndexType, faiss::IndexIVFFlatCC>::value) {
+        if constexpr (std::is_same<IndexType, knowherefaiss::IndexIVFFlatCC>::value) {
             return knowhere::IndexEnum::INDEX_FAISS_IVFFLAT_CC;
         }
-        if constexpr (std::is_same<IndexType, faiss::IndexIVFPQ>::value) {
+        if constexpr (std::is_same<IndexType, knowherefaiss::IndexIVFPQ>::value) {
             return knowhere::IndexEnum::INDEX_FAISS_IVFPQ;
         }
-        if constexpr (std::is_same<IndexType, faiss::IndexScaNN>::value) {
+        if constexpr (std::is_same<IndexType, knowherefaiss::IndexScaNN>::value) {
             return knowhere::IndexEnum::INDEX_FAISS_SCANN;
         }
-        if constexpr (std::is_same<IndexType, faiss::IndexIVFScalarQuantizer>::value) {
+        if constexpr (std::is_same<IndexType, knowherefaiss::IndexIVFScalarQuantizer>::value) {
             return knowhere::IndexEnum::INDEX_FAISS_IVFSQ8;
         }
-        if constexpr (std::is_same<IndexType, faiss::IndexBinaryIVF>::value) {
+        if constexpr (std::is_same<IndexType, knowherefaiss::IndexBinaryIVF>::value) {
             return knowhere::IndexEnum::INDEX_FAISS_BIN_IVFFLAT;
         }
-        if constexpr (std::is_same<IndexType, faiss::IndexIVFScalarQuantizerCC>::value) {
+        if constexpr (std::is_same<IndexType, knowherefaiss::IndexIVFScalarQuantizerCC>::value) {
             return knowhere::IndexEnum::INDEX_FAISS_IVFSQ_CC;
         }
         if constexpr (std::is_same<IndexType, IndexIVFRaBitQWrapper>::value) {
@@ -331,10 +331,10 @@ class IvfIndexNode : public IndexNode {
 
     static constexpr bool
     IsQuantized() {
-        return std::is_same_v<IndexType, faiss::IndexIVFPQ> ||
-               std::is_same_v<IndexType, faiss::IndexIVFScalarQuantizer> ||
-               std::is_same_v<IndexType, faiss::IndexIVFScalarQuantizerCC> ||
-               std::is_same_v<IndexType, faiss::IndexScaNN> || std::is_same_v<IndexType, IndexIVFRaBitQWrapper>;
+        return std::is_same_v<IndexType, knowherefaiss::IndexIVFPQ> ||
+               std::is_same_v<IndexType, knowherefaiss::IndexIVFScalarQuantizer> ||
+               std::is_same_v<IndexType, knowherefaiss::IndexIVFScalarQuantizerCC> ||
+               std::is_same_v<IndexType, knowherefaiss::IndexScaNN> || std::is_same_v<IndexType, IndexIVFRaBitQWrapper>;
     }
 
  private:
@@ -371,7 +371,7 @@ class IvfIndexNode : public IndexNode {
 
         float
         raw_distance(int64_t id) override {
-            if constexpr (std::is_same_v<IndexType, faiss::IndexScaNN>) {
+            if constexpr (std::is_same_v<IndexType, knowherefaiss::IndexScaNN>) {
                 if (this->refine_) {
                     return workspace_->dis_refine->operator()(id);
                 } else {
@@ -383,10 +383,10 @@ class IvfIndexNode : public IndexNode {
 
      private:
         const IndexType* index_ = nullptr;
-        std::unique_ptr<faiss::IVFIteratorWorkspace> workspace_ = nullptr;
+        std::unique_ptr<knowherefaiss::IVFIteratorWorkspace> workspace_ = nullptr;
         std::unique_ptr<float[]> copied_query_ = nullptr;
         std::unique_ptr<BitsetViewIDSelector> bw_idselector_ = nullptr;
-        faiss::IVFSearchParameters ivf_search_params_;
+        knowherefaiss::IVFSearchParameters ivf_search_params_;
     };
 
     std::unique_ptr<IndexType> index_;
@@ -437,25 +437,25 @@ MatchNbits(int64_t size, int64_t nbits) {
 namespace {
 
 // turn IndexFlatElkan into IndexFlat
-std::unique_ptr<faiss::IndexFlat>
-to_index_flat(std::unique_ptr<faiss::IndexFlat>&& index) {
+std::unique_ptr<knowherefaiss::IndexFlat>
+to_index_flat(std::unique_ptr<knowherefaiss::IndexFlat>&& index) {
     // C++ slicing here
-    return std::make_unique<faiss::IndexFlat>(std::move(*index));
+    return std::make_unique<knowherefaiss::IndexFlat>(std::move(*index));
 }
 
-expected<faiss::ScalarQuantizer::QuantizerType>
+expected<knowherefaiss::ScalarQuantizer::QuantizerType>
 get_ivf_sq_quantizer_type(int code_size) {
     switch (code_size) {
         case 4:
-            return faiss::ScalarQuantizer::QuantizerType::QT_4bit;
+            return knowherefaiss::ScalarQuantizer::QuantizerType::QT_4bit;
         case 6:
-            return faiss::ScalarQuantizer::QuantizerType::QT_6bit;
+            return knowherefaiss::ScalarQuantizer::QuantizerType::QT_6bit;
         case 8:
-            return faiss::ScalarQuantizer::QuantizerType::QT_8bit;
+            return knowherefaiss::ScalarQuantizer::QuantizerType::QT_8bit;
         case 16:
-            return faiss::ScalarQuantizer::QuantizerType::QT_fp16;
+            return knowherefaiss::ScalarQuantizer::QuantizerType::QT_fp16;
         default:
-            return expected<faiss::ScalarQuantizer::QuantizerType>::Err(
+            return expected<knowherefaiss::ScalarQuantizer::QuantizerType>::Err(
                 Status::invalid_args, fmt::format("current code size {} not in (4, 6, 8, 16)", code_size));
     }
 }
@@ -472,7 +472,7 @@ IvfIndexNode<DataType, IndexType>::Train(const DataSetPtr dataset, std::shared_p
     if (tryObj.hasValue()) {
         return tryObj.value();
     }
-    LOG_KNOWHERE_WARNING_ << "faiss internal error: " << tryObj.exception().what();
+    LOG_KNOWHERE_WARNING_ << "knowherefaiss internal error: " << tryObj.exception().what();
     return Status::faiss_inner_error;
 }
 
@@ -490,8 +490,8 @@ IvfIndexNode<DataType, IndexType>::TrainInternal(const DataSetPtr dataset, std::
     bool is_cosine = IsMetricType(base_cfg.metric_type.value(), knowhere::metric::COSINE);
 
     // do normalize for COSINE metric type
-    if constexpr (std::is_same_v<faiss::IndexIVFPQ, IndexType> ||
-                  std::is_same_v<faiss::IndexIVFScalarQuantizer, IndexType> ||
+    if constexpr (std::is_same_v<knowherefaiss::IndexIVFPQ, IndexType> ||
+                  std::is_same_v<knowherefaiss::IndexIVFScalarQuantizer, IndexType> ||
                   std::is_same_v<IndexIVFRaBitQWrapper, IndexType>) {
         if (is_cosine) {
             NormalizeDataset<DataType>(dataset);
@@ -510,7 +510,7 @@ IvfIndexNode<DataType, IndexType>::TrainInternal(const DataSetPtr dataset, std::
 
     // faiss scann needs at least 16 rows since nbits=4
     constexpr int64_t SCANN_MIN_ROWS = 16;
-    if constexpr (std::is_same<faiss::IndexScaNN, IndexType>::value) {
+    if constexpr (std::is_same<knowherefaiss::IndexScaNN, IndexType>::value) {
         if (rows < SCANN_MIN_ROWS) {
             LOG_KNOWHERE_ERROR_ << rows << " rows is not enough, scann needs at least 16 rows to build index";
             return Status::faiss_inner_error;
@@ -520,17 +520,17 @@ IvfIndexNode<DataType, IndexType>::TrainInternal(const DataSetPtr dataset, std::
     std::unique_ptr<IndexType> index;
     // if cfg.use_elkan is used, then we'll use a temporary instance of
     //  IndexFlatElkan for the training.
-    if constexpr (std::is_same<faiss::IndexIVFFlat, IndexType>::value) {
+    if constexpr (std::is_same<knowherefaiss::IndexIVFFlat, IndexType>::value) {
         const IvfFlatConfig& ivf_flat_cfg = static_cast<const IvfFlatConfig&>(*cfg);
         auto nlist = MatchNlist(rows, ivf_flat_cfg.nlist.value());
 
         const bool use_elkan = ivf_flat_cfg.use_elkan.value_or(true);
 
         // create quantizer for the training
-        std::unique_ptr<faiss::IndexFlat> qzr =
-            std::make_unique<faiss::IndexFlatElkan>(dim, metric.value(), false, use_elkan);
+        std::unique_ptr<knowherefaiss::IndexFlat> qzr =
+            std::make_unique<knowherefaiss::IndexFlatElkan>(dim, metric.value(), false, use_elkan);
         // create index. Index does not own qzr
-        index = std::make_unique<faiss::IndexIVFFlat>(qzr.get(), dim, nlist, metric.value(), is_cosine);
+        index = std::make_unique<knowherefaiss::IndexIVFFlat>(qzr.get(), dim, nlist, metric.value(), is_cosine);
         // train
         index->train(rows, (const float*)data);
         // replace quantizer with a regular IndexFlat
@@ -539,17 +539,17 @@ IvfIndexNode<DataType, IndexType>::TrainInternal(const DataSetPtr dataset, std::
         index->quantizer = qzr.release();
         index->own_fields = true;
     }
-    if constexpr (std::is_same<faiss::IndexIVFFlatCC, IndexType>::value) {
+    if constexpr (std::is_same<knowherefaiss::IndexIVFFlatCC, IndexType>::value) {
         const IvfFlatCcConfig& ivf_flat_cc_cfg = static_cast<const IvfFlatCcConfig&>(*cfg);
         auto nlist = MatchNlist(rows, ivf_flat_cc_cfg.nlist.value());
 
         const bool use_elkan = ivf_flat_cc_cfg.use_elkan.value_or(true);
 
         // create quantizer for the training
-        std::unique_ptr<faiss::IndexFlat> qzr =
-            std::make_unique<faiss::IndexFlatElkan>(dim, metric.value(), false, use_elkan);
+        std::unique_ptr<knowherefaiss::IndexFlat> qzr =
+            std::make_unique<knowherefaiss::IndexFlatElkan>(dim, metric.value(), false, use_elkan);
         // create index. Index does not own qzr
-        index = std::make_unique<faiss::IndexIVFFlatCC>(qzr.get(), dim, nlist, ivf_flat_cc_cfg.ssize.value(),
+        index = std::make_unique<knowherefaiss::IndexIVFFlatCC>(qzr.get(), dim, nlist, ivf_flat_cc_cfg.ssize.value(),
                                                         metric.value(), is_cosine);
         // train
         index->train(rows, (const float*)data);
@@ -559,9 +559,9 @@ IvfIndexNode<DataType, IndexType>::TrainInternal(const DataSetPtr dataset, std::
         index->quantizer = qzr.release();
         index->own_fields = true;
         // ivfflat_cc has no serialize stage, make map at build stage
-        index->make_direct_map(true, faiss::DirectMap::ConcurrentArray);
+        index->make_direct_map(true, knowherefaiss::DirectMap::ConcurrentArray);
     }
-    if constexpr (std::is_same<faiss::IndexIVFPQ, IndexType>::value) {
+    if constexpr (std::is_same<knowherefaiss::IndexIVFPQ, IndexType>::value) {
         const IvfPqConfig& ivf_pq_cfg = static_cast<const IvfPqConfig&>(*cfg);
         auto nlist = MatchNlist(rows, ivf_pq_cfg.nlist.value());
         auto nbits = MatchNbits(rows, ivf_pq_cfg.nbits.value());
@@ -569,10 +569,10 @@ IvfIndexNode<DataType, IndexType>::TrainInternal(const DataSetPtr dataset, std::
         const bool use_elkan = ivf_pq_cfg.use_elkan.value_or(true);
 
         // create quantizer for the training
-        std::unique_ptr<faiss::IndexFlat> qzr =
-            std::make_unique<faiss::IndexFlatElkan>(dim, metric.value(), false, use_elkan);
+        std::unique_ptr<knowherefaiss::IndexFlat> qzr =
+            std::make_unique<knowherefaiss::IndexFlatElkan>(dim, metric.value(), false, use_elkan);
         // create index. Index does not own qzr
-        index = std::make_unique<faiss::IndexIVFPQ>(qzr.get(), dim, nlist, ivf_pq_cfg.m.value(), nbits, metric.value());
+        index = std::make_unique<knowherefaiss::IndexIVFPQ>(qzr.get(), dim, nlist, ivf_pq_cfg.m.value(), nbits, metric.value());
         // train
         index->train(rows, (const float*)data);
         // replace quantizer with a regular IndexFlat
@@ -581,7 +581,7 @@ IvfIndexNode<DataType, IndexType>::TrainInternal(const DataSetPtr dataset, std::
         index->quantizer = qzr.release();
         index->own_fields = true;
     }
-    if constexpr (std::is_same<faiss::IndexScaNN, IndexType>::value) {
+    if constexpr (std::is_same<knowherefaiss::IndexScaNN, IndexType>::value) {
         const ScannConfig& scann_cfg = static_cast<const ScannConfig&>(*cfg);
         auto nlist = MatchNlist(rows, scann_cfg.nlist.value());
         bool is_cosine = base_cfg.metric_type.value() == metric::COSINE;
@@ -589,17 +589,17 @@ IvfIndexNode<DataType, IndexType>::TrainInternal(const DataSetPtr dataset, std::
         const bool use_elkan = scann_cfg.use_elkan.value_or(true);
         const int sub_dim = scann_cfg.sub_dim.value_or(2);
         // create quantizer for the training
-        std::unique_ptr<faiss::IndexFlat> qzr =
-            std::make_unique<faiss::IndexFlatElkan>(dim, metric.value(), false, use_elkan);
+        std::unique_ptr<knowherefaiss::IndexFlat> qzr =
+            std::make_unique<knowherefaiss::IndexFlatElkan>(dim, metric.value(), false, use_elkan);
         // create base index. it does not own qzr
-        auto base_index = std::make_unique<faiss::IndexIVFPQFastScan>(
+        auto base_index = std::make_unique<knowherefaiss::IndexIVFPQFastScan>(
             qzr.get(), dim, nlist, (dim + sub_dim - 1) / sub_dim, 4, is_cosine, metric.value());
         // create scann index, which does not base_index by default,
         //    but owns the refine index by default omg
         if (scann_cfg.with_raw_data.value()) {
-            index = std::make_unique<faiss::IndexScaNN>(base_index.get(), (const float*)data);
+            index = std::make_unique<knowherefaiss::IndexScaNN>(base_index.get(), (const float*)data);
         } else {
-            index = std::make_unique<faiss::IndexScaNN>(base_index.get(), nullptr);
+            index = std::make_unique<knowherefaiss::IndexScaNN>(base_index.get(), nullptr);
         }
         // train
         index->train(rows, (const float*)data);
@@ -613,18 +613,18 @@ IvfIndexNode<DataType, IndexType>::TrainInternal(const DataSetPtr dataset, std::
         base_index.release();
         index->own_fields = true;
     }
-    if constexpr (std::is_same<faiss::IndexIVFScalarQuantizer, IndexType>::value) {
+    if constexpr (std::is_same<knowherefaiss::IndexIVFScalarQuantizer, IndexType>::value) {
         const IvfSqConfig& ivf_sq_cfg = static_cast<const IvfSqConfig&>(*cfg);
         auto nlist = MatchNlist(rows, ivf_sq_cfg.nlist.value());
 
         const bool use_elkan = ivf_sq_cfg.use_elkan.value_or(true);
 
         // create quantizer for the training
-        std::unique_ptr<faiss::IndexFlat> qzr =
-            std::make_unique<faiss::IndexFlatElkan>(dim, metric.value(), false, use_elkan);
+        std::unique_ptr<knowherefaiss::IndexFlat> qzr =
+            std::make_unique<knowherefaiss::IndexFlatElkan>(dim, metric.value(), false, use_elkan);
         // create index. Index does not own qzr
-        index = std::make_unique<faiss::IndexIVFScalarQuantizer>(
-            qzr.get(), dim, nlist, faiss::ScalarQuantizer::QuantizerType::QT_8bit, metric.value());
+        index = std::make_unique<knowherefaiss::IndexIVFScalarQuantizer>(
+            qzr.get(), dim, nlist, knowherefaiss::ScalarQuantizer::QuantizerType::QT_8bit, metric.value());
         // train
         index->train(rows, (const float*)data);
         // replace quantizer with a regular IndexFlat
@@ -633,21 +633,21 @@ IvfIndexNode<DataType, IndexType>::TrainInternal(const DataSetPtr dataset, std::
         index->quantizer = qzr.release();
         index->own_fields = true;
     }
-    if constexpr (std::is_same<faiss::IndexBinaryIVF, IndexType>::value) {
+    if constexpr (std::is_same<knowherefaiss::IndexBinaryIVF, IndexType>::value) {
         const IvfBinConfig& ivf_bin_cfg = static_cast<const IvfBinConfig&>(*cfg);
         auto nlist = MatchNlist(rows, ivf_bin_cfg.nlist.value());
 
         // create quantizer
-        auto qzr = std::make_unique<faiss::IndexBinaryFlat>(dim, metric.value());
+        auto qzr = std::make_unique<knowherefaiss::IndexBinaryFlat>(dim, metric.value());
         // create index. Index does not own qzr
-        index = std::make_unique<faiss::IndexBinaryIVF>(qzr.get(), dim, nlist, metric.value());
+        index = std::make_unique<knowherefaiss::IndexBinaryIVF>(qzr.get(), dim, nlist, metric.value());
         // train
         index->train(rows, (const uint8_t*)data);
         // transfer ownership of qzr to index
         qzr.release();
         index->own_fields = true;
     }
-    if constexpr (std::is_same<faiss::IndexIVFScalarQuantizerCC, IndexType>::value) {
+    if constexpr (std::is_same<knowherefaiss::IndexIVFScalarQuantizerCC, IndexType>::value) {
         const IvfSqCcConfig& ivf_sq_cc_cfg = static_cast<const IvfSqCcConfig&>(*cfg);
         auto nlist = MatchNlist(rows, ivf_sq_cc_cfg.nlist.value());
         auto ssize = ivf_sq_cc_cfg.ssize.value();
@@ -655,15 +655,15 @@ IvfIndexNode<DataType, IndexType>::TrainInternal(const DataSetPtr dataset, std::
         const bool use_elkan = ivf_sq_cc_cfg.use_elkan.value_or(true);
 
         // create quantizer for the training
-        std::unique_ptr<faiss::IndexFlat> qzr =
-            std::make_unique<faiss::IndexFlatElkan>(dim, metric.value(), false, use_elkan);
+        std::unique_ptr<knowherefaiss::IndexFlat> qzr =
+            std::make_unique<knowherefaiss::IndexFlatElkan>(dim, metric.value(), false, use_elkan);
         // create index. Index does not own qzr
         auto qzr_type = get_ivf_sq_quantizer_type(ivf_sq_cc_cfg.code_size.value());
         if (!qzr_type.has_value()) {
             LOG_KNOWHERE_ERROR_ << "fail to get ivf sq quantizer type, " << qzr_type.what();
             return qzr_type.error();
         }
-        index = std::make_unique<faiss::IndexIVFScalarQuantizerCC>(qzr.get(), dim, nlist, ssize, qzr_type.value(),
+        index = std::make_unique<knowherefaiss::IndexIVFScalarQuantizerCC>(qzr.get(), dim, nlist, ssize, qzr_type.value(),
                                                                    metric.value(), is_cosine, false,
                                                                    ivf_sq_cc_cfg.raw_data_store_prefix);
         // train
@@ -673,7 +673,7 @@ IvfIndexNode<DataType, IndexType>::TrainInternal(const DataSetPtr dataset, std::
         // transfer ownership of qzr to index
         index->quantizer = qzr.release();
         index->own_fields = true;
-        index->make_direct_map(true, faiss::DirectMap::ConcurrentArray);
+        index->make_direct_map(true, knowherefaiss::DirectMap::ConcurrentArray);
     }
     if constexpr (std::is_same<IndexIVFRaBitQWrapper, IndexType>::value) {
         const IvfRaBitQConfig& ivf_rabitq_cfg = static_cast<const IvfRaBitQConfig&>(*cfg);
@@ -717,7 +717,7 @@ IvfIndexNode<DataType, IndexType>::Add(const DataSetPtr dataset, std::shared_ptr
                           } else {
                               setter = std::make_unique<ThreadPool::ScopedBuildOmpSetter>();
                           }
-                          if constexpr (std::is_same<faiss::IndexBinaryIVF, IndexType>::value) {
+                          if constexpr (std::is_same<knowherefaiss::IndexBinaryIVF, IndexType>::value) {
                               index_->add(rows, (const uint8_t*)data);
                           } else {
                               index_->add(rows, (const float*)data);
@@ -725,7 +725,7 @@ IvfIndexNode<DataType, IndexType>::Add(const DataSetPtr dataset, std::shared_ptr
                       })
                       .getTry();
     if (tryObj.hasException()) {
-        LOG_KNOWHERE_WARNING_ << "faiss internal error: " << tryObj.exception().what();
+        LOG_KNOWHERE_WARNING_ << "knowherefaiss internal error: " << tryObj.exception().what();
         return Status::faiss_inner_error;
     }
     return Status::success;
@@ -766,33 +766,33 @@ IvfIndexNode<DataType, IndexType>::Search(const DataSetPtr dataset, std::unique_
                 std::unique_ptr<float[]> copied_query = nullptr;
 
                 BitsetViewIDSelector bw_idselector(bitset);
-                faiss::IDSelector* id_selector = (bitset.empty()) ? nullptr : &bw_idselector;
+                knowherefaiss::IDSelector* id_selector = (bitset.empty()) ? nullptr : &bw_idselector;
 
-                if constexpr (std::is_same<IndexType, faiss::IndexBinaryIVF>::value) {
+                if constexpr (std::is_same<IndexType, knowherefaiss::IndexBinaryIVF>::value) {
                     auto cur_data = (const uint8_t*)data + index * ((dim + 7) / 8);
 
                     int32_t* i_distances = reinterpret_cast<int32_t*>(distances.get());
 
-                    faiss::IVFSearchParameters ivf_search_params;
+                    knowherefaiss::IVFSearchParameters ivf_search_params;
                     ivf_search_params.nprobe = nprobe;
                     ivf_search_params.sel = id_selector;
                     index_->search(1, cur_data, k, i_distances + offset, ids.get() + offset, &ivf_search_params);
 
-                    if (index_->metric_type == faiss::METRIC_Hamming) {
+                    if (index_->metric_type == knowherefaiss::METRIC_Hamming) {
                         // this is an in-place conversion int32_t -> float
                         for (int64_t i = 0; i < k; i++) {
                             distances[i + offset] = static_cast<float>(i_distances[i + offset]);
                         }
                     }
-                } else if constexpr (std::is_same<IndexType, faiss::IndexIVFFlatCC>::value ||
-                                     std::is_same<IndexType, faiss::IndexIVFScalarQuantizerCC>::value) {
+                } else if constexpr (std::is_same<IndexType, knowherefaiss::IndexIVFFlatCC>::value ||
+                                     std::is_same<IndexType, knowherefaiss::IndexIVFScalarQuantizerCC>::value) {
                     auto cur_query = (const float*)data + index * dim;
                     if (is_cosine) {
                         copied_query = CopyAndNormalizeVecs(cur_query, 1, dim);
                         cur_query = copied_query.get();
                     }
 
-                    faiss::IVFSearchParameters ivf_search_params;
+                    knowherefaiss::IVFSearchParameters ivf_search_params;
 
                     ivf_search_params.sel = id_selector;
                     ivf_search_params.ensure_topk_full = ivf_cfg.ensure_topk_full.value();
@@ -807,7 +807,7 @@ IvfIndexNode<DataType, IndexType>::Search(const DataSetPtr dataset, std::unique_
                     }
 
                     index_->search(1, cur_query, k, distances.get() + offset, ids.get() + offset, &ivf_search_params);
-                } else if constexpr (std::is_same<IndexType, faiss::IndexScaNN>::value) {
+                } else if constexpr (std::is_same<IndexType, knowherefaiss::IndexScaNN>::value) {
                     auto cur_query = (const float*)data + index * dim;
                     const ScannConfig& scann_cfg = static_cast<const ScannConfig&>(*cfg);
                     if (is_cosine) {
@@ -816,12 +816,12 @@ IvfIndexNode<DataType, IndexType>::Search(const DataSetPtr dataset, std::unique_
                     }
 
                     // todo aguzhva: this is somewhat alogical. Refactor?
-                    faiss::IVFSearchParameters base_search_params;
+                    knowherefaiss::IVFSearchParameters base_search_params;
                     base_search_params.sel = id_selector;
                     base_search_params.nprobe = nprobe;
                     base_search_params.ensure_topk_full = scann_cfg.ensure_topk_full.value();
                     if (base_search_params.ensure_topk_full) {
-                        if (auto base_index_ptr = reinterpret_cast<faiss::IndexIVFPQFastScan*>(index_->base_index)) {
+                        if (auto base_index_ptr = reinterpret_cast<knowherefaiss::IndexIVFPQFastScan*>(index_->base_index)) {
                             auto nlist = base_index_ptr->nlist;
                             base_search_params.nprobe = nlist;
                             // use max_codes to early termination
@@ -835,7 +835,7 @@ IvfIndexNode<DataType, IndexType>::Search(const DataSetPtr dataset, std::unique_
                         base_search_params.max_codes = 0;
                     }
 
-                    faiss::IndexScaNNSearchParameters scann_search_params;
+                    knowherefaiss::IndexScaNNSearchParameters scann_search_params;
                     scann_search_params.base_index_params = &base_search_params;
                     scann_search_params.reorder_k = scann_cfg.reorder_k.value();
 
@@ -855,11 +855,11 @@ IvfIndexNode<DataType, IndexType>::Search(const DataSetPtr dataset, std::unique_
                     const bool whether_to_enable_refine = ivf_rabitq_cfg.refine_k.has_value();
                     if (const auto wrapper_index = dynamic_cast<const IndexIVFRaBitQWrapper*>(index_.get());
                         wrapper_index != nullptr) {
-                        const faiss::IndexRefine* refine_index = wrapper_index->get_refine_index();
+                        const knowherefaiss::IndexRefine* refine_index = wrapper_index->get_refine_index();
                         use_refine = (refine_index != nullptr);
                     }
 
-                    faiss::IVFRaBitQSearchParameters ivf_search_params;
+                    knowherefaiss::IVFRaBitQSearchParameters ivf_search_params;
                     ivf_search_params.nprobe = nprobe;
                     ivf_search_params.max_codes = 0;
                     ivf_search_params.sel = id_selector;
@@ -867,7 +867,7 @@ IvfIndexNode<DataType, IndexType>::Search(const DataSetPtr dataset, std::unique_
 
                     if (use_refine && whether_to_enable_refine) {
                         // yes, use refine
-                        faiss::IndexRefineSearchParameters refine_search_params;
+                        knowherefaiss::IndexRefineSearchParameters refine_search_params;
                         refine_search_params.sel = id_selector;
                         refine_search_params.k_factor = ivf_rabitq_cfg.refine_k.value_or(1);
                         refine_search_params.base_index_params = &ivf_search_params;
@@ -886,7 +886,7 @@ IvfIndexNode<DataType, IndexType>::Search(const DataSetPtr dataset, std::unique_
                         cur_query = copied_query.get();
                     }
 
-                    faiss::IVFSearchParameters ivf_search_params;
+                    knowherefaiss::IVFSearchParameters ivf_search_params;
                     ivf_search_params.nprobe = nprobe;
                     ivf_search_params.max_codes = 0;
                     ivf_search_params.sel = id_selector;
@@ -898,7 +898,7 @@ IvfIndexNode<DataType, IndexType>::Search(const DataSetPtr dataset, std::unique_
         // wait for the completion
         WaitAllSuccess(futs);
     } catch (const std::exception& e) {
-        LOG_KNOWHERE_WARNING_ << "faiss inner error: " << e.what();
+        LOG_KNOWHERE_WARNING_ << "knowherefaiss inner error: " << e.what();
         return expected<DataSetPtr>::Err(Status::faiss_inner_error, e.what());
     }
 
@@ -933,7 +933,7 @@ IvfIndexNode<DataType, IndexType>::RangeSearch(const DataSetPtr dataset, std::un
 
     float radius = ivf_cfg.radius.value();
     float range_filter = ivf_cfg.range_filter.value();
-    bool is_ip = (index_->metric_type == faiss::METRIC_INNER_PRODUCT);
+    bool is_ip = (index_->metric_type == knowherefaiss::METRIC_INNER_PRODUCT);
 
     RangeSearchResult range_search_result;
 
@@ -946,36 +946,36 @@ IvfIndexNode<DataType, IndexType>::RangeSearch(const DataSetPtr dataset, std::un
         for (int i = 0; i < nq; ++i) {
             futs.emplace_back(search_pool_->push([&, index = i] {
                 ThreadPool::ScopedSearchOmpSetter setter(1);
-                faiss::RangeSearchResult res(1);
+                knowherefaiss::RangeSearchResult res(1);
                 std::unique_ptr<float[]> copied_query = nullptr;
 
                 BitsetViewIDSelector bw_idselector(bitset);
-                faiss::IDSelector* id_selector = (bitset.empty()) ? nullptr : &bw_idselector;
+                knowherefaiss::IDSelector* id_selector = (bitset.empty()) ? nullptr : &bw_idselector;
 
-                if constexpr (std::is_same<IndexType, faiss::IndexBinaryIVF>::value) {
+                if constexpr (std::is_same<IndexType, knowherefaiss::IndexBinaryIVF>::value) {
                     auto cur_data = (const uint8_t*)xq + index * ((dim + 7) / 8);
 
-                    faiss::IVFSearchParameters ivf_search_params;
+                    knowherefaiss::IVFSearchParameters ivf_search_params;
                     ivf_search_params.nprobe = index_->nlist;
                     ivf_search_params.max_empty_result_buckets = ivf_cfg.max_empty_result_buckets.value();
                     ivf_search_params.sel = id_selector;
 
                     index_->range_search(1, cur_data, radius, &res, &ivf_search_params);
-                } else if constexpr (std::is_same<IndexType, faiss::IndexIVFFlat>::value) {
+                } else if constexpr (std::is_same<IndexType, knowherefaiss::IndexIVFFlat>::value) {
                     auto cur_query = (const float*)xq + index * dim;
                     if (is_cosine) {
                         copied_query = CopyAndNormalizeVecs(cur_query, 1, dim);
                         cur_query = copied_query.get();
                     }
 
-                    faiss::IVFSearchParameters ivf_search_params;
+                    knowherefaiss::IVFSearchParameters ivf_search_params;
                     ivf_search_params.nprobe = index_->nlist;
                     ivf_search_params.max_codes = 0;
                     ivf_search_params.max_empty_result_buckets = ivf_cfg.max_empty_result_buckets.value();
                     ivf_search_params.sel = id_selector;
 
                     index_->range_search(1, cur_query, radius, &res, &ivf_search_params);
-                } else if constexpr (std::is_same<IndexType, faiss::IndexScaNN>::value) {
+                } else if constexpr (std::is_same<IndexType, knowherefaiss::IndexScaNN>::value) {
                     auto cur_query = (const float*)xq + index * dim;
                     if (is_cosine) {
                         copied_query = CopyAndNormalizeVecs(cur_query, 1, dim);
@@ -983,7 +983,7 @@ IvfIndexNode<DataType, IndexType>::RangeSearch(const DataSetPtr dataset, std::un
                     }
 
                     // todo aguzhva: this is somewhat alogical. Refactor?
-                    faiss::IVFSearchParameters search_params;
+                    knowherefaiss::IVFSearchParameters search_params;
                     search_params.max_empty_result_buckets = ivf_cfg.max_empty_result_buckets.value();
                     search_params.sel = id_selector;
 
@@ -997,9 +997,9 @@ IvfIndexNode<DataType, IndexType>::RangeSearch(const DataSetPtr dataset, std::un
 
                     const IvfRaBitQConfig& ivf_rabitq_cfg = static_cast<const IvfRaBitQConfig&>(*cfg);
 
-                    const faiss::IndexIVFRaBitQ* uindex_ = index_->get_ivfrabitq_index();
+                    const knowherefaiss::IndexIVFRaBitQ* uindex_ = index_->get_ivfrabitq_index();
 
-                    faiss::IVFRaBitQSearchParameters ivf_search_params;
+                    knowherefaiss::IVFRaBitQSearchParameters ivf_search_params;
                     ivf_search_params.nprobe = uindex_->nlist;
                     ivf_search_params.max_codes = 0;
                     ivf_search_params.max_empty_result_buckets = ivf_cfg.max_empty_result_buckets.value();
@@ -1012,13 +1012,13 @@ IvfIndexNode<DataType, IndexType>::RangeSearch(const DataSetPtr dataset, std::un
                     const bool whether_to_enable_refine = ivf_rabitq_cfg.refine_k.has_value();
                     if (const auto wrapper_index = dynamic_cast<const IndexIVFRaBitQWrapper*>(index_.get());
                         wrapper_index != nullptr) {
-                        const faiss::IndexRefine* refine_index = wrapper_index->get_refine_index();
+                        const knowherefaiss::IndexRefine* refine_index = wrapper_index->get_refine_index();
                         use_refine = (refine_index != nullptr);
                     }
 
                     if (use_refine && whether_to_enable_refine) {
                         // yes, use refine
-                        faiss::IndexRefineSearchParameters refine_search_params;
+                        knowherefaiss::IndexRefineSearchParameters refine_search_params;
                         refine_search_params.sel = id_selector;
                         refine_search_params.k_factor = ivf_rabitq_cfg.refine_k.value_or(1);
                         refine_search_params.base_index_params = &ivf_search_params;
@@ -1034,7 +1034,7 @@ IvfIndexNode<DataType, IndexType>::RangeSearch(const DataSetPtr dataset, std::un
                         cur_query = copied_query.get();
                     }
 
-                    faiss::IVFSearchParameters ivf_search_params;
+                    knowherefaiss::IVFSearchParameters ivf_search_params;
                     ivf_search_params.nprobe = index_->nlist;
                     ivf_search_params.max_codes = 0;
                     ivf_search_params.max_empty_result_buckets = ivf_cfg.max_empty_result_buckets.value();
@@ -1059,7 +1059,7 @@ IvfIndexNode<DataType, IndexType>::RangeSearch(const DataSetPtr dataset, std::un
         WaitAllSuccess(futs);
         range_search_result = GetRangeSearchResult(result_dist_array, result_id_array, is_ip, nq, radius, range_filter);
     } catch (const std::exception& e) {
-        LOG_KNOWHERE_WARNING_ << "faiss inner error: " << e.what();
+        LOG_KNOWHERE_WARNING_ << "knowherefaiss inner error: " << e.what();
         return expected<DataSetPtr>::Err(Status::faiss_inner_error, e.what());
     }
 
@@ -1096,7 +1096,7 @@ IvfIndexNode<DataType, IndexType>::AnnIterator(const DataSetPtr dataset, std::un
         size_t nprobe = ivf_cfg.nprobe.value();
         // set iterator_refine_ratio = 0.0. If quantizer != flat, faiss:indexivf will not keep raw data;
         float iterator_refine_ratio = 0.0f;
-        if constexpr (std::is_same_v<IndexType, faiss::IndexScaNN>) {
+        if constexpr (std::is_same_v<IndexType, knowherefaiss::IndexScaNN>) {
             if (HasRawData(ivf_cfg.metric_type.value())) {
                 iterator_refine_ratio = ivf_cfg.iterator_refine_ratio.value();
             }
@@ -1120,7 +1120,7 @@ IvfIndexNode<DataType, IndexType>::AnnIterator(const DataSetPtr dataset, std::un
             }
 
         } catch (const std::exception& e) {
-            LOG_KNOWHERE_WARNING_ << "faiss inner error: " << e.what();
+            LOG_KNOWHERE_WARNING_ << "knowherefaiss inner error: " << e.what();
             return expected<std::vector<IndexNode::IteratorPtr>>::Err(Status::faiss_inner_error, e.what());
         }
         return vec;
@@ -1136,7 +1136,7 @@ IvfIndexNode<DataType, IndexType>::GetVectorByIds(const DataSetPtr dataset) cons
     if (!this->index_->is_trained) {
         return expected<DataSetPtr>::Err(Status::index_not_trained, "index not trained");
     }
-    if constexpr (std::is_same<IndexType, faiss::IndexBinaryIVF>::value) {
+    if constexpr (std::is_same<IndexType, knowherefaiss::IndexBinaryIVF>::value) {
         auto dim = Dim();
         auto rows = dataset->GetRows();
         auto ids = dataset->GetIds();
@@ -1150,11 +1150,11 @@ IvfIndexNode<DataType, IndexType>::GetVectorByIds(const DataSetPtr dataset) cons
             }
             return GenResultDataSet(rows, dim, std::move(data));
         } catch (const std::exception& e) {
-            LOG_KNOWHERE_WARNING_ << "faiss inner error: " << e.what();
+            LOG_KNOWHERE_WARNING_ << "knowherefaiss inner error: " << e.what();
             return expected<DataSetPtr>::Err(Status::faiss_inner_error, e.what());
         }
-    } else if constexpr (std::is_same<IndexType, faiss::IndexIVFFlat>::value ||
-                         std::is_same<IndexType, faiss::IndexIVFFlatCC>::value) {
+    } else if constexpr (std::is_same<IndexType, knowherefaiss::IndexIVFFlat>::value ||
+                         std::is_same<IndexType, knowherefaiss::IndexIVFFlatCC>::value) {
         auto dim = Dim();
         auto rows = dataset->GetRows();
         auto ids = dataset->GetIds();
@@ -1168,11 +1168,11 @@ IvfIndexNode<DataType, IndexType>::GetVectorByIds(const DataSetPtr dataset) cons
             }
             return GenResultDataSet(rows, dim, std::move(data));
         } catch (const std::exception& e) {
-            LOG_KNOWHERE_WARNING_ << "faiss inner error: " << e.what();
+            LOG_KNOWHERE_WARNING_ << "knowherefaiss inner error: " << e.what();
             return expected<DataSetPtr>::Err(Status::faiss_inner_error, e.what());
         }
-    } else if constexpr (std::is_same<IndexType, faiss::IndexScaNN>::value ||
-                         std::is_same<IndexType, faiss::IndexIVFScalarQuantizerCC>::value) {
+    } else if constexpr (std::is_same<IndexType, knowherefaiss::IndexScaNN>::value ||
+                         std::is_same<IndexType, knowherefaiss::IndexIVFScalarQuantizerCC>::value) {
         // we should never go here since we should call HasRawData() first
         if (!index_->with_raw_data()) {
             return expected<DataSetPtr>::Err(Status::not_implemented, "GetVectorByIds not implemented");
@@ -1190,7 +1190,7 @@ IvfIndexNode<DataType, IndexType>::GetVectorByIds(const DataSetPtr dataset) cons
             }
             return GenResultDataSet(rows, dim, std::move(data));
         } catch (const std::exception& e) {
-            LOG_KNOWHERE_WARNING_ << "faiss inner error: " << e.what();
+            LOG_KNOWHERE_WARNING_ << "knowherefaiss inner error: " << e.what();
             return expected<DataSetPtr>::Err(Status::faiss_inner_error, e.what());
         }
     } else {
@@ -1206,8 +1206,8 @@ IvfIndexNode<DataType, IndexType>::GetIndexMetaImpl(std::unique_ptr<Config>, IVF
         return expected<DataSetPtr>::Err(Status::empty_index, "index not loaded");
     }
 
-    auto ivf_index = dynamic_cast<faiss::IndexIVF*>(index_.get());
-    auto ivf_quantizer = dynamic_cast<faiss::IndexFlat*>(ivf_index->quantizer);
+    auto ivf_index = dynamic_cast<knowherefaiss::IndexIVF*>(index_.get());
+    auto ivf_quantizer = dynamic_cast<knowherefaiss::IndexFlat*>(ivf_index->quantizer);
 
     int64_t dim = ivf_index->d;
     int64_t nlist = ivf_index->nlist;
@@ -1218,8 +1218,8 @@ IvfIndexNode<DataType, IndexType>::GetIndexMetaImpl(std::unique_ptr<Config>, IVF
 
     for (int32_t i = 0; i < nlist; i++) {
         // copy from IndexIVF::search_preassigned
-        std::unique_ptr<faiss::InvertedLists::ScopedIds> sids =
-            std::make_unique<faiss::InvertedLists::ScopedIds>(index_->invlists, i);
+        std::unique_ptr<knowherefaiss::InvertedLists::ScopedIds> sids =
+            std::make_unique<knowherefaiss::InvertedLists::ScopedIds>(index_->invlists, i);
 
         // node ids
         auto node_num = index_->invlists->list_size(i);
@@ -1246,18 +1246,18 @@ IvfIndexNode<DataType, IndexType>::SerializeImpl(BinarySet& binset, IVFBaseTag)
             return Status::empty_index;
         }
         MemoryIOWriter writer;
-        if constexpr (std::is_same<IndexType, faiss::IndexBinaryIVF>::value) {
-            faiss::write_index_binary(index_.get(), &writer);
+        if constexpr (std::is_same<IndexType, knowherefaiss::IndexBinaryIVF>::value) {
+            knowherefaiss::write_index_binary(index_.get(), &writer);
         } else if constexpr (std::is_same<IndexType, IndexIVFRaBitQWrapper>::value) {
-            faiss::write_index(index_->index.get(), &writer);
+            knowherefaiss::write_index(index_->index.get(), &writer);
         } else {
-            faiss::write_index(index_.get(), &writer);
+            knowherefaiss::write_index(index_.get(), &writer);
         }
         std::shared_ptr<uint8_t[]> data(writer.data());
         binset.Append(Type(), data, writer.tellg());
         return Status::success;
     } catch (const std::exception& e) {
-        LOG_KNOWHERE_WARNING_ << "faiss inner error: " << e.what();
+        LOG_KNOWHERE_WARNING_ << "knowherefaiss inner error: " << e.what();
         return Status::faiss_inner_error;
     }
 }
@@ -1273,10 +1273,10 @@ IvfIndexNode<DataType, IndexType>::SerializeImpl(BinarySet& binset, IVFFlatTag)
         MemoryIOWriter writer;
         LOG_KNOWHERE_INFO_ << "request version " << this->version_.VersionNumber();
         if (this->version_ <= Version::GetMinimalVersion()) {
-            faiss::write_index_nm(index_.get(), &writer);
+            knowherefaiss::write_index_nm(index_.get(), &writer);
             LOG_KNOWHERE_INFO_ << "write IVF_FLAT_NM, file size " << writer.tellg();
         } else {
-            faiss::write_index(index_.get(), &writer);
+            knowherefaiss::write_index(index_.get(), &writer);
             LOG_KNOWHERE_INFO_ << "write IVF_FLAT, file size " << writer.tellg();
         }
         std::shared_ptr<uint8_t[]> index_data_ptr(writer.data());
@@ -1290,10 +1290,10 @@ IvfIndexNode<DataType, IndexType>::SerializeImpl(BinarySet& binset, IVFFlatTag)
             auto raw_data = std::make_unique<uint8_t[]>(raw_data_size);
             for (size_t i = 0; i < index_->nlist; i++) {
                 size_t list_size = index_->invlists->list_size(i);
-                const faiss::idx_t* ids = index_->invlists->get_ids(i);
+                const knowherefaiss::idx_t* ids = index_->invlists->get_ids(i);
                 const uint8_t* codes = index_->invlists->get_codes(i);
                 for (size_t j = 0; j < list_size; j++) {
-                    faiss::idx_t id = ids[j];
+                    knowherefaiss::idx_t id = ids[j];
                     const uint8_t* src = codes + j * dim * sizeof(float);
                     uint8_t* dst = raw_data.get() + id * dim * sizeof(float);
                     memcpy(dst, src, dim * sizeof(float));
@@ -1304,7 +1304,7 @@ IvfIndexNode<DataType, IndexType>::SerializeImpl(BinarySet& binset, IVFFlatTag)
         }
         return Status::success;
     } catch (const std::exception& e) {
-        LOG_KNOWHERE_WARNING_ << "faiss inner error: " << e.what();
+        LOG_KNOWHERE_WARNING_ << "knowherefaiss inner error: " << e.what();
         return Status::faiss_inner_error;
     }
 }
@@ -1327,7 +1327,7 @@ IvfIndexNode<DataType, IndexType>::Deserialize(const BinarySet& binset, std::sha
             // a special case for IVFRaBitQ, bcz a wrapper is involved.
 
             // deserialize
-            auto index_raw = std::unique_ptr<faiss::Index>(faiss::read_index(&reader));
+            auto index_raw = std::unique_ptr<knowherefaiss::Index>(knowherefaiss::read_index(&reader));
             auto index_wr = IndexIVFRaBitQWrapper::from_deserialized(std::move(index_raw));
             if (index_wr == nullptr) {
                 LOG_KNOWHERE_ERROR_ << "The deserialized index does not look like an IVFRaBitQ";
@@ -1338,7 +1338,7 @@ IvfIndexNode<DataType, IndexType>::Deserialize(const BinarySet& binset, std::sha
             index_ = std::move(index_wr);
         } else {
             // the default case for a regular index
-            if constexpr (std::is_same<IndexType, faiss::IndexIVFFlat>::value) {
+            if constexpr (std::is_same<IndexType, knowherefaiss::IndexIVFFlat>::value) {
                 if (this->version_ <= Version::GetMinimalVersion()) {
                     auto raw_binary = binset.GetByName("RAW_DATA");
                     const BaseConfig& base_cfg = static_cast<const BaseConfig&>(*cfg);
@@ -1347,15 +1347,15 @@ IvfIndexNode<DataType, IndexType>::Deserialize(const BinarySet& binset, std::sha
                     reader.data_ = binary->data.get();
                     reader.total_ = binary->size;
                 }
-                index_.reset(static_cast<faiss::IndexIVFFlat*>(faiss::read_index(&reader)));
-            } else if constexpr (std::is_same<IndexType, faiss::IndexBinaryIVF>::value) {
-                index_.reset(static_cast<IndexType*>(faiss::read_index_binary(&reader)));
+                index_.reset(static_cast<knowherefaiss::IndexIVFFlat*>(knowherefaiss::read_index(&reader)));
+            } else if constexpr (std::is_same<IndexType, knowherefaiss::IndexBinaryIVF>::value) {
+                index_.reset(static_cast<IndexType*>(knowherefaiss::read_index_binary(&reader)));
             } else {
-                index_.reset(static_cast<IndexType*>(faiss::read_index(&reader)));
+                index_.reset(static_cast<IndexType*>(knowherefaiss::read_index(&reader)));
             }
 
-            if constexpr (!std::is_same_v<IndexType, faiss::IndexScaNN> &&
-                          !std::is_same_v<IndexType, faiss::IndexIVFScalarQuantizerCC>) {
+            if constexpr (!std::is_same_v<IndexType, knowherefaiss::IndexScaNN> &&
+                          !std::is_same_v<IndexType, knowherefaiss::IndexIVFScalarQuantizerCC>) {
                 const BaseConfig& base_cfg = static_cast<const BaseConfig&>(*cfg);
                 if (HasRawData(base_cfg.metric_type.value())) {
                     index_->make_direct_map(true);
@@ -1363,7 +1363,7 @@ IvfIndexNode<DataType, IndexType>::Deserialize(const BinarySet& binset, std::sha
             }
         }
     } catch (const std::exception& e) {
-        LOG_KNOWHERE_WARNING_ << "faiss inner error: " << e.what();
+        LOG_KNOWHERE_WARNING_ << "knowherefaiss inner error: " << e.what();
         return Status::faiss_inner_error;
     }
     return Status::success;
@@ -1376,14 +1376,14 @@ IvfIndexNode<DataType, IndexType>::DeserializeFromFile(const std::string& filena
 
     int io_flags = 0;
     if (cfg.enable_mmap.value()) {
-        io_flags |= faiss::IO_FLAG_MMAP;
+        io_flags |= knowherefaiss::IO_FLAG_MMAP;
     }
     try {
         if constexpr (std::is_same<IndexType, IndexIVFRaBitQWrapper>::value) {
             // a special case for IVFRaBitQ, bcz a wrapper is involved.
 
             // deserialize into a wrapper
-            auto index_raw = std::unique_ptr<faiss::Index>(faiss::read_index(filename.data(), io_flags));
+            auto index_raw = std::unique_ptr<knowherefaiss::Index>(knowherefaiss::read_index(filename.data(), io_flags));
             auto index_wr = IndexIVFRaBitQWrapper::from_deserialized(std::move(index_raw));
             if (index_wr == nullptr) {
                 LOG_KNOWHERE_ERROR_ << "The deserialized index does not look like an IVFRaBitQ";
@@ -1394,13 +1394,13 @@ IvfIndexNode<DataType, IndexType>::DeserializeFromFile(const std::string& filena
             index_ = std::move(index_wr);
         } else {
             // the default case for a regular index
-            if constexpr (std::is_same<IndexType, faiss::IndexBinaryIVF>::value) {
-                index_.reset(static_cast<IndexType*>(faiss::read_index_binary(filename.data(), io_flags)));
+            if constexpr (std::is_same<IndexType, knowherefaiss::IndexBinaryIVF>::value) {
+                index_.reset(static_cast<IndexType*>(knowherefaiss::read_index_binary(filename.data(), io_flags)));
             } else {
-                index_.reset(static_cast<IndexType*>(faiss::read_index(filename.data(), io_flags)));
+                index_.reset(static_cast<IndexType*>(knowherefaiss::read_index(filename.data(), io_flags)));
             }
 
-            if constexpr (!std::is_same_v<IndexType, faiss::IndexScaNN>) {
+            if constexpr (!std::is_same_v<IndexType, knowherefaiss::IndexScaNN>) {
                 const BaseConfig& base_cfg = static_cast<const BaseConfig&>(*config);
                 if (HasRawData(base_cfg.metric_type.value())) {
                     index_->make_direct_map(true);
@@ -1408,47 +1408,47 @@ IvfIndexNode<DataType, IndexType>::DeserializeFromFile(const std::string& filena
             }
         }
     } catch (const std::exception& e) {
-        LOG_KNOWHERE_WARNING_ << "faiss inner error: " << e.what();
+        LOG_KNOWHERE_WARNING_ << "knowherefaiss inner error: " << e.what();
         return Status::faiss_inner_error;
     }
     return Status::success;
 }
 // bin1
-KNOWHERE_SIMPLE_REGISTER_DENSE_BIN_GLOBAL(IVFBIN, IvfIndexNode, knowhere::feature::MMAP, faiss::IndexBinaryIVF)
-KNOWHERE_SIMPLE_REGISTER_DENSE_BIN_GLOBAL(BIN_IVF_FLAT, IvfIndexNode, knowhere::feature::MMAP, faiss::IndexBinaryIVF)
+KNOWHERE_SIMPLE_REGISTER_DENSE_BIN_GLOBAL(IVFBIN, IvfIndexNode, knowhere::feature::MMAP, knowherefaiss::IndexBinaryIVF)
+KNOWHERE_SIMPLE_REGISTER_DENSE_BIN_GLOBAL(BIN_IVF_FLAT, IvfIndexNode, knowhere::feature::MMAP, knowherefaiss::IndexBinaryIVF)
 
 // float
-KNOWHERE_MOCK_REGISTER_DENSE_FLOAT_ALL_GLOBAL(IVFFLAT, IvfIndexNode, knowhere::feature::MMAP, faiss::IndexIVFFlat)
-KNOWHERE_MOCK_REGISTER_DENSE_FLOAT_ALL_GLOBAL(IVF_FLAT, IvfIndexNode, knowhere::feature::MMAP, faiss::IndexIVFFlat)
-KNOWHERE_MOCK_REGISTER_DENSE_FLOAT_ALL_GLOBAL(IVFFLATCC, IvfIndexNode, knowhere::feature::NONE, faiss::IndexIVFFlatCC)
-KNOWHERE_MOCK_REGISTER_DENSE_FLOAT_ALL_GLOBAL(IVF_FLAT_CC, IvfIndexNode, knowhere::feature::NONE, faiss::IndexIVFFlatCC)
-KNOWHERE_MOCK_REGISTER_DENSE_FLOAT_ALL_GLOBAL(SCANN, IvfIndexNode, knowhere::feature::MMAP, faiss::IndexScaNN)
-KNOWHERE_MOCK_REGISTER_DENSE_FLOAT_ALL_GLOBAL(IVFPQ, IvfIndexNode, knowhere::feature::MMAP, faiss::IndexIVFPQ)
-KNOWHERE_MOCK_REGISTER_DENSE_FLOAT_ALL_GLOBAL(IVF_PQ, IvfIndexNode, knowhere::feature::MMAP, faiss::IndexIVFPQ)
+KNOWHERE_MOCK_REGISTER_DENSE_FLOAT_ALL_GLOBAL(IVFFLAT, IvfIndexNode, knowhere::feature::MMAP, knowherefaiss::IndexIVFFlat)
+KNOWHERE_MOCK_REGISTER_DENSE_FLOAT_ALL_GLOBAL(IVF_FLAT, IvfIndexNode, knowhere::feature::MMAP, knowherefaiss::IndexIVFFlat)
+KNOWHERE_MOCK_REGISTER_DENSE_FLOAT_ALL_GLOBAL(IVFFLATCC, IvfIndexNode, knowhere::feature::NONE, knowherefaiss::IndexIVFFlatCC)
+KNOWHERE_MOCK_REGISTER_DENSE_FLOAT_ALL_GLOBAL(IVF_FLAT_CC, IvfIndexNode, knowhere::feature::NONE, knowherefaiss::IndexIVFFlatCC)
+KNOWHERE_MOCK_REGISTER_DENSE_FLOAT_ALL_GLOBAL(SCANN, IvfIndexNode, knowhere::feature::MMAP, knowherefaiss::IndexScaNN)
+KNOWHERE_MOCK_REGISTER_DENSE_FLOAT_ALL_GLOBAL(IVFPQ, IvfIndexNode, knowhere::feature::MMAP, knowherefaiss::IndexIVFPQ)
+KNOWHERE_MOCK_REGISTER_DENSE_FLOAT_ALL_GLOBAL(IVF_PQ, IvfIndexNode, knowhere::feature::MMAP, knowherefaiss::IndexIVFPQ)
 KNOWHERE_MOCK_REGISTER_DENSE_FLOAT_ALL_GLOBAL(IVFSQ, IvfIndexNode, knowhere::feature::MMAP,
-                                              faiss::IndexIVFScalarQuantizer)
+                                              knowherefaiss::IndexIVFScalarQuantizer)
 KNOWHERE_MOCK_REGISTER_DENSE_FLOAT_ALL_GLOBAL(IVF_SQ, IvfIndexNode, knowhere::feature::MMAP,
-                                              faiss::IndexIVFScalarQuantizer)
+                                              knowherefaiss::IndexIVFScalarQuantizer)
 KNOWHERE_MOCK_REGISTER_DENSE_FLOAT_ALL_GLOBAL(IVF_SQ8, IvfIndexNode, knowhere::feature::MMAP,
-                                              faiss::IndexIVFScalarQuantizer)
+                                              knowherefaiss::IndexIVFScalarQuantizer)
 KNOWHERE_MOCK_REGISTER_DENSE_FLOAT_ALL_GLOBAL(IVF_SQ_CC, IvfIndexNode, knowhere::feature::NONE,
-                                              faiss::IndexIVFScalarQuantizerCC)
+                                              knowherefaiss::IndexIVFScalarQuantizerCC)
 KNOWHERE_MOCK_REGISTER_DENSE_FLOAT_ALL_GLOBAL(IVFRABITQ, IvfIndexNode, knowhere::feature::MMAP, IndexIVFRaBitQWrapper)
 KNOWHERE_MOCK_REGISTER_DENSE_FLOAT_ALL_GLOBAL(IVF_RABITQ, IvfIndexNode, knowhere::feature::MMAP, IndexIVFRaBitQWrapper)
 // int
-KNOWHERE_MOCK_REGISTER_DENSE_INT_GLOBAL(IVFFLAT, IvfIndexNode, knowhere::feature::MMAP, faiss::IndexIVFFlat)
-KNOWHERE_MOCK_REGISTER_DENSE_INT_GLOBAL(IVF_FLAT, IvfIndexNode, knowhere::feature::MMAP, faiss::IndexIVFFlat)
-KNOWHERE_MOCK_REGISTER_DENSE_INT_GLOBAL(IVFFLATCC, IvfIndexNode, knowhere::feature::NONE, faiss::IndexIVFFlatCC)
-KNOWHERE_MOCK_REGISTER_DENSE_INT_GLOBAL(IVF_FLAT_CC, IvfIndexNode, knowhere::feature::NONE, faiss::IndexIVFFlatCC)
-KNOWHERE_MOCK_REGISTER_DENSE_INT_GLOBAL(SCANN, IvfIndexNode, knowhere::feature::MMAP, faiss::IndexScaNN)
-KNOWHERE_MOCK_REGISTER_DENSE_INT_GLOBAL(IVFPQ, IvfIndexNode, knowhere::feature::MMAP, faiss::IndexIVFPQ)
-KNOWHERE_MOCK_REGISTER_DENSE_INT_GLOBAL(IVF_PQ, IvfIndexNode, knowhere::feature::MMAP, faiss::IndexIVFPQ)
-KNOWHERE_MOCK_REGISTER_DENSE_INT_GLOBAL(IVFSQ, IvfIndexNode, knowhere::feature::MMAP, faiss::IndexIVFScalarQuantizer)
-KNOWHERE_MOCK_REGISTER_DENSE_INT_GLOBAL(IVF_SQ, IvfIndexNode, knowhere::feature::MMAP, faiss::IndexIVFScalarQuantizer)
-KNOWHERE_MOCK_REGISTER_DENSE_INT_GLOBAL(IVF_SQ8, IvfIndexNode, knowhere::feature::MMAP, faiss::IndexIVFScalarQuantizer)
+KNOWHERE_MOCK_REGISTER_DENSE_INT_GLOBAL(IVFFLAT, IvfIndexNode, knowhere::feature::MMAP, knowherefaiss::IndexIVFFlat)
+KNOWHERE_MOCK_REGISTER_DENSE_INT_GLOBAL(IVF_FLAT, IvfIndexNode, knowhere::feature::MMAP, knowherefaiss::IndexIVFFlat)
+KNOWHERE_MOCK_REGISTER_DENSE_INT_GLOBAL(IVFFLATCC, IvfIndexNode, knowhere::feature::NONE, knowherefaiss::IndexIVFFlatCC)
+KNOWHERE_MOCK_REGISTER_DENSE_INT_GLOBAL(IVF_FLAT_CC, IvfIndexNode, knowhere::feature::NONE, knowherefaiss::IndexIVFFlatCC)
+KNOWHERE_MOCK_REGISTER_DENSE_INT_GLOBAL(SCANN, IvfIndexNode, knowhere::feature::MMAP, knowherefaiss::IndexScaNN)
+KNOWHERE_MOCK_REGISTER_DENSE_INT_GLOBAL(IVFPQ, IvfIndexNode, knowhere::feature::MMAP, knowherefaiss::IndexIVFPQ)
+KNOWHERE_MOCK_REGISTER_DENSE_INT_GLOBAL(IVF_PQ, IvfIndexNode, knowhere::feature::MMAP, knowherefaiss::IndexIVFPQ)
+KNOWHERE_MOCK_REGISTER_DENSE_INT_GLOBAL(IVFSQ, IvfIndexNode, knowhere::feature::MMAP, knowherefaiss::IndexIVFScalarQuantizer)
+KNOWHERE_MOCK_REGISTER_DENSE_INT_GLOBAL(IVF_SQ, IvfIndexNode, knowhere::feature::MMAP, knowherefaiss::IndexIVFScalarQuantizer)
+KNOWHERE_MOCK_REGISTER_DENSE_INT_GLOBAL(IVF_SQ8, IvfIndexNode, knowhere::feature::MMAP, knowherefaiss::IndexIVFScalarQuantizer)
 KNOWHERE_MOCK_REGISTER_DENSE_INT_GLOBAL(IVF_SQ_CC, IvfIndexNode, knowhere::feature::NONE,
-                                        faiss::IndexIVFScalarQuantizerCC)
+                                        knowherefaiss::IndexIVFScalarQuantizerCC)
 // faiss index + data view refiner combination
 KNOWHERE_SIMPLE_REGISTER_DENSE_FLOAT_ALL_GLOBAL(SCANN_DVR, IndexNodeWithDataViewRefiner, knowhere::feature::NONE,
-                                                IvfIndexNode<fp32, faiss::IndexScaNN>)
+                                                IvfIndexNode<fp32, knowherefaiss::IndexScaNN>)
 }  // namespace knowhere
diff --git a/src/index/ivf/ivf_config.h b/src/index/ivf/ivf_config.h
index df2a749d..52fcf31e 100644
--- a/src/index/ivf/ivf_config.h
+++ b/src/index/ivf/ivf_config.h
@@ -150,7 +150,7 @@ class ScannConfig : public IvfFlatConfig {
                 }
             }
             case PARAM_TYPE::SEARCH: {
-                if (!faiss::support_pq_fast_scan) {
+                if (!knowherefaiss::support_pq_fast_scan) {
                     LOG_KNOWHERE_ERROR_ << "SCANN index is not supported on the current CPU model, avx2 support is "
                                            "needed for x86 arch.";
                     return Status::invalid_instruction_set;
@@ -168,7 +168,7 @@ class ScannConfig : public IvfFlatConfig {
                 break;
             }
             default: {
-                if (!faiss::support_pq_fast_scan) {
+                if (!knowherefaiss::support_pq_fast_scan) {
                     std::string msg =
                         "SCANN index is not supported on the current CPU model, avx2 support is "
                         "needed for x86 arch.";
diff --git a/src/index/ivf/ivfrbq_wrapper.cc b/src/index/ivf/ivfrbq_wrapper.cc
index d9254d76..8c3af618 100644
--- a/src/index/ivf/ivfrbq_wrapper.cc
+++ b/src/index/ivf/ivfrbq_wrapper.cc
@@ -13,36 +13,36 @@
 
 #include <memory>
 
-#include "faiss/IndexCosine.h"
-#include "faiss/IndexFlat.h"
-#include "faiss/IndexPreTransform.h"
-#include "faiss/cppcontrib/knowhere/impl/CountSizeIOWriter.h"
-#include "faiss/index_io.h"
+#include "knowherefaiss/IndexCosine.h"
+#include "knowherefaiss/IndexFlat.h"
+#include "knowherefaiss/IndexPreTransform.h"
+#include "knowherefaiss/cppcontrib/knowhere/impl/CountSizeIOWriter.h"
+#include "knowherefaiss/index_io.h"
 #include "index/refine/refine_utils.h"
 
 namespace knowhere {
 
 expected<std::unique_ptr<IndexIVFRaBitQWrapper>>
-IndexIVFRaBitQWrapper::create(const faiss::idx_t d, const size_t nlist, const IvfRaBitQConfig& ivf_rabitq_cfg,
-                              const DataFormatEnum raw_data_format, const faiss::MetricType metric) {
+IndexIVFRaBitQWrapper::create(const knowherefaiss::idx_t d, const size_t nlist, const IvfRaBitQConfig& ivf_rabitq_cfg,
+                              const DataFormatEnum raw_data_format, const knowherefaiss::MetricType metric) {
     // the index factory string is either `RR(dim),IVFx,RaBitQ,Refine(y)`,
     //   or `RR(dim),IVFx,RaBitQ`, depends on the refine parameters
 
     // create IndexIVFRaBitQ
     auto qb = ivf_rabitq_cfg.rbq_bits_query.value();
 
-    auto idx_flat = std::make_unique<faiss::IndexFlat>(d, metric, false);
-    auto idx_ivfrbq = std::make_unique<faiss::IndexIVFRaBitQ>(idx_flat.release(), d, nlist, metric);
+    auto idx_flat = std::make_unique<knowherefaiss::IndexFlat>(d, metric, false);
+    auto idx_ivfrbq = std::make_unique<knowherefaiss::IndexIVFRaBitQ>(idx_flat.release(), d, nlist, metric);
     idx_ivfrbq->own_fields = true;
     idx_ivfrbq->qb = qb;
 
     // wrap it in an IndexPreTransform
-    auto rr = std::make_unique<faiss::RandomRotationMatrix>(d, d);
-    auto idx_rr = std::make_unique<faiss::IndexPreTransform>(rr.release(), idx_ivfrbq.release());
+    auto rr = std::make_unique<knowherefaiss::RandomRotationMatrix>(d, d);
+    auto idx_rr = std::make_unique<knowherefaiss::IndexPreTransform>(rr.release(), idx_ivfrbq.release());
     idx_rr->own_fields = true;
 
     // create a refiner index, if needed
-    std::unique_ptr<faiss::Index> idx_final;
+    std::unique_ptr<knowherefaiss::Index> idx_final;
     if (ivf_rabitq_cfg.refine.value_or(false) && ivf_rabitq_cfg.refine_type.has_value()) {
         // refine is needed
         const auto base_d = idx_rr->d;
@@ -64,7 +64,7 @@ IndexIVFRaBitQWrapper::create(const faiss::idx_t d, const size_t nlist, const Iv
     return result;
 }
 
-IndexIVFRaBitQWrapper::IndexIVFRaBitQWrapper(std::unique_ptr<faiss::Index>&& index_in)
+IndexIVFRaBitQWrapper::IndexIVFRaBitQWrapper(std::unique_ptr<knowherefaiss::Index>&& index_in)
     : Index{index_in->d, index_in->metric_type}, index{std::move(index_in)} {
     ntotal = index->ntotal;
     is_trained = index->is_trained;
@@ -74,7 +74,7 @@ IndexIVFRaBitQWrapper::IndexIVFRaBitQWrapper(std::unique_ptr<faiss::Index>&& ind
 }
 
 std::unique_ptr<IndexIVFRaBitQWrapper>
-IndexIVFRaBitQWrapper::from_deserialized(std::unique_ptr<faiss::Index>&& index_in) {
+IndexIVFRaBitQWrapper::from_deserialized(std::unique_ptr<knowherefaiss::Index>&& index_in) {
     auto index = std::make_unique<IndexIVFRaBitQWrapper>(std::move(index_in));
 
     // check a provided index type
@@ -91,26 +91,26 @@ IndexIVFRaBitQWrapper::from_deserialized(std::unique_ptr<faiss::Index>&& index_i
 }
 
 void
-IndexIVFRaBitQWrapper::train(faiss::idx_t n, const float* x) {
+IndexIVFRaBitQWrapper::train(knowherefaiss::idx_t n, const float* x) {
     index->train(n, x);
     is_trained = index->is_trained;
 }
 
 void
-IndexIVFRaBitQWrapper::add(faiss::idx_t n, const float* x) {
+IndexIVFRaBitQWrapper::add(knowherefaiss::idx_t n, const float* x) {
     index->add(n, x);
     this->ntotal = index->ntotal;
 }
 
 void
-IndexIVFRaBitQWrapper::search(faiss::idx_t n, const float* x, faiss::idx_t k, float* distances, faiss::idx_t* labels,
-                              const faiss::SearchParameters* params) const {
+IndexIVFRaBitQWrapper::search(knowherefaiss::idx_t n, const float* x, knowherefaiss::idx_t k, float* distances, knowherefaiss::idx_t* labels,
+                              const knowherefaiss::SearchParameters* params) const {
     index->search(n, x, k, distances, labels, params);
 }
 
 void
-IndexIVFRaBitQWrapper::range_search(faiss::idx_t n, const float* x, float radius, faiss::RangeSearchResult* result,
-                                    const faiss::SearchParameters* params) const {
+IndexIVFRaBitQWrapper::range_search(knowherefaiss::idx_t n, const float* x, float radius, knowherefaiss::RangeSearchResult* result,
+                                    const knowherefaiss::SearchParameters* params) const {
     index->range_search(n, x, radius, result, params);
 }
 
@@ -121,53 +121,53 @@ IndexIVFRaBitQWrapper::reset() {
 }
 
 void
-IndexIVFRaBitQWrapper::merge_from(Index& otherIndex, faiss::idx_t add_id) {
+IndexIVFRaBitQWrapper::merge_from(Index& otherIndex, knowherefaiss::idx_t add_id) {
     index->merge_from(otherIndex, add_id);
 }
 
-faiss::DistanceComputer*
+knowherefaiss::DistanceComputer*
 IndexIVFRaBitQWrapper::get_distance_computer() const {
     return index->get_distance_computer();
 }
 
-faiss::IndexIVFRaBitQ*
+knowherefaiss::IndexIVFRaBitQ*
 IndexIVFRaBitQWrapper::get_ivfrabitq_index() {
     // try refine
-    faiss::IndexRefine* index_refine = dynamic_cast<faiss::IndexRefine*>(index.get());
-    faiss::Index* index_for_pt = (index_refine != nullptr) ? index_refine->base_index : index.get();
+    knowherefaiss::IndexRefine* index_refine = dynamic_cast<knowherefaiss::IndexRefine*>(index.get());
+    knowherefaiss::Index* index_for_pt = (index_refine != nullptr) ? index_refine->base_index : index.get();
 
     // pre-transform
-    faiss::IndexPreTransform* index_pt = dynamic_cast<faiss::IndexPreTransform*>(index_for_pt);
+    knowherefaiss::IndexPreTransform* index_pt = dynamic_cast<knowherefaiss::IndexPreTransform*>(index_for_pt);
     if (index_pt == nullptr) {
         return nullptr;
     }
 
-    return dynamic_cast<faiss::IndexIVFRaBitQ*>(index_pt->index);
+    return dynamic_cast<knowherefaiss::IndexIVFRaBitQ*>(index_pt->index);
 }
 
-const faiss::IndexIVFRaBitQ*
+const knowherefaiss::IndexIVFRaBitQ*
 IndexIVFRaBitQWrapper::get_ivfrabitq_index() const {
     // try refine
-    const faiss::IndexRefine* index_refine = dynamic_cast<const faiss::IndexRefine*>(index.get());
-    const faiss::Index* index_for_pt = (index_refine != nullptr) ? index_refine->base_index : index.get();
+    const knowherefaiss::IndexRefine* index_refine = dynamic_cast<const knowherefaiss::IndexRefine*>(index.get());
+    const knowherefaiss::Index* index_for_pt = (index_refine != nullptr) ? index_refine->base_index : index.get();
 
     // pre-transform
-    const faiss::IndexPreTransform* index_pt = dynamic_cast<const faiss::IndexPreTransform*>(index_for_pt);
+    const knowherefaiss::IndexPreTransform* index_pt = dynamic_cast<const knowherefaiss::IndexPreTransform*>(index_for_pt);
     if (index_pt == nullptr) {
         return nullptr;
     }
 
-    return dynamic_cast<const faiss::IndexIVFRaBitQ*>(index_pt->index);
+    return dynamic_cast<const knowherefaiss::IndexIVFRaBitQ*>(index_pt->index);
 }
 
-faiss::IndexRefine*
+knowherefaiss::IndexRefine*
 IndexIVFRaBitQWrapper::get_refine_index() {
-    return dynamic_cast<faiss::IndexRefine*>(index.get());
+    return dynamic_cast<knowherefaiss::IndexRefine*>(index.get());
 }
 
-const faiss::IndexRefine*
+const knowherefaiss::IndexRefine*
 IndexIVFRaBitQWrapper::get_refine_index() const {
-    return dynamic_cast<const faiss::IndexRefine*>(index.get());
+    return dynamic_cast<const knowherefaiss::IndexRefine*>(index.get());
 }
 
 size_t
@@ -177,26 +177,26 @@ IndexIVFRaBitQWrapper::size() const {
     }
 
     // a temporary yet expensive workaround
-    faiss::cppcontrib::knowhere::CountSizeIOWriter writer;
-    faiss::write_index(index.get(), &writer);
+    knowherefaiss::cppcontrib::knowhere::CountSizeIOWriter writer;
+    knowherefaiss::write_index(index.get(), &writer);
 
     // todo
     return writer.total_size;
 }
 
-std::unique_ptr<faiss::IVFIteratorWorkspace>
+std::unique_ptr<knowherefaiss::IVFIteratorWorkspace>
 IndexIVFRaBitQWrapper::getIteratorWorkspace(const float* query_data,
-                                            const faiss::IVFSearchParameters* ivfsearchParams) const {
+                                            const knowherefaiss::IVFSearchParameters* ivfsearchParams) const {
     // try refine
-    const faiss::IndexRefine* index_refine = dynamic_cast<const faiss::IndexRefine*>(index.get());
-    faiss::Index* index_for_pt = (index_refine != nullptr) ? index_refine->base_index : index.get();
+    const knowherefaiss::IndexRefine* index_refine = dynamic_cast<const knowherefaiss::IndexRefine*>(index.get());
+    knowherefaiss::Index* index_for_pt = (index_refine != nullptr) ? index_refine->base_index : index.get();
 
-    const faiss::IndexPreTransform* index_pt = dynamic_cast<const faiss::IndexPreTransform*>(index_for_pt);
+    const knowherefaiss::IndexPreTransform* index_pt = dynamic_cast<const knowherefaiss::IndexPreTransform*>(index_for_pt);
     if (index_pt == nullptr) {
         return nullptr;
     }
 
-    const faiss::IndexIVFRaBitQ* index_rbq = dynamic_cast<const faiss::IndexIVFRaBitQ*>(index_pt->index);
+    const knowherefaiss::IndexIVFRaBitQ* index_rbq = dynamic_cast<const knowherefaiss::IndexIVFRaBitQ*>(index_pt->index);
     if (index_rbq == nullptr) {
         return nullptr;
     }
@@ -213,7 +213,7 @@ IndexIVFRaBitQWrapper::getIteratorWorkspace(const float* query_data,
 
         // a regular use case
         workspace->dis_refine =
-            std::unique_ptr<faiss::DistanceComputer>(index_refine->refine_index->get_distance_computer());
+            std::unique_ptr<knowherefaiss::DistanceComputer>(index_refine->refine_index->get_distance_computer());
         // this points to a previously saved clone
         workspace->dis_refine->set_query(workspace->query_data.data());
     } else {
@@ -226,7 +226,7 @@ IndexIVFRaBitQWrapper::getIteratorWorkspace(const float* query_data,
 }
 
 void
-IndexIVFRaBitQWrapper::getIteratorNextBatch(faiss::IVFIteratorWorkspace* workspace, size_t current_backup_count) const {
+IndexIVFRaBitQWrapper::getIteratorNextBatch(knowherefaiss::IVFIteratorWorkspace* workspace, size_t current_backup_count) const {
     const auto ivfrbq = this->get_ivfrabitq_index();
     ivfrbq->getIteratorNextBatch(workspace, current_backup_count);
 }
diff --git a/src/index/ivf/ivfrbq_wrapper.h b/src/index/ivf/ivfrbq_wrapper.h
index 62c60aac..605cd36c 100644
--- a/src/index/ivf/ivfrbq_wrapper.h
+++ b/src/index/ivf/ivfrbq_wrapper.h
@@ -15,85 +15,85 @@
 #include <cstdint>
 #include <memory>
 
-#include "faiss/Index.h"
-#include "faiss/IndexIVF.h"
-#include "faiss/IndexIVFRaBitQ.h"
-#include "faiss/IndexRefine.h"
+#include "knowherefaiss/Index.h"
+#include "knowherefaiss/IndexIVF.h"
+#include "knowherefaiss/IndexIVFRaBitQ.h"
+#include "knowherefaiss/IndexRefine.h"
 #include "index/ivf/ivf_config.h"
 #include "knowhere/expected.h"
 
 namespace knowhere {
 
-// This is wrapper is needed, bcz we use faiss::IndexPreTransform
-//   for wrapping faiss::IndexIVFRaBitQ, optionally combined with
-//   faiss::IndexRefine.
+// This is wrapper is needed, bcz we use knowherefaiss::IndexPreTransform
+//   for wrapping knowherefaiss::IndexIVFRaBitQ, optionally combined with
+//   knowherefaiss::IndexRefine.
 // The problem is that IndexPreTransform is a generic class, suitable
 //   for any other use case as well, so this is wrong to reference
 //   IndexPreTransform in the ivf.cc file.
-struct IndexIVFRaBitQWrapper : faiss::Index {
+struct IndexIVFRaBitQWrapper : knowherefaiss::Index {
     // this is one of two:
-    // * faiss::IndexPreTransform + faiss::IndexIVFRaBitQ
-    // * faiss::IndexPreTransform + faiss::IndexRefine + faiss::IndexIVFRaBitQ
-    std::unique_ptr<faiss::Index> index;
+    // * knowherefaiss::IndexPreTransform + knowherefaiss::IndexIVFRaBitQ
+    // * knowherefaiss::IndexPreTransform + knowherefaiss::IndexRefine + knowherefaiss::IndexIVFRaBitQ
+    std::unique_ptr<knowherefaiss::Index> index;
 
-    IndexIVFRaBitQWrapper(std::unique_ptr<faiss::Index>&& index_in);
+    IndexIVFRaBitQWrapper(std::unique_ptr<knowherefaiss::Index>&& index_in);
 
     static expected<std::unique_ptr<IndexIVFRaBitQWrapper>>
-    create(const faiss::idx_t d, const size_t nlist, const IvfRaBitQConfig& ivf_rabitq_cfg,
+    create(const knowherefaiss::idx_t d, const size_t nlist, const IvfRaBitQConfig& ivf_rabitq_cfg,
            // this is the data format of the raw data (if the refine is used)
-           const DataFormatEnum raw_data_format, const faiss::MetricType metric = faiss::METRIC_L2);
+           const DataFormatEnum raw_data_format, const knowherefaiss::MetricType metric = knowherefaiss::METRIC_L2);
 
     // this is for the deserialization.
     // returns nullptr if the provided index type is not the one
     //   as expected.
     static std::unique_ptr<IndexIVFRaBitQWrapper>
-    from_deserialized(std::unique_ptr<faiss::Index>&& index_in);
+    from_deserialized(std::unique_ptr<knowherefaiss::Index>&& index_in);
 
     void
-    train(faiss::idx_t n, const float* x) override;
+    train(knowherefaiss::idx_t n, const float* x) override;
 
     void
-    add(faiss::idx_t n, const float* x) override;
+    add(knowherefaiss::idx_t n, const float* x) override;
 
     void
-    search(faiss::idx_t n, const float* x, faiss::idx_t k, float* distances, faiss::idx_t* labels,
-           const faiss::SearchParameters* params) const override;
+    search(knowherefaiss::idx_t n, const float* x, knowherefaiss::idx_t k, float* distances, knowherefaiss::idx_t* labels,
+           const knowherefaiss::SearchParameters* params) const override;
 
     void
-    range_search(faiss::idx_t n, const float* x, float radius, faiss::RangeSearchResult* result,
-                 const faiss::SearchParameters* params) const override;
+    range_search(knowherefaiss::idx_t n, const float* x, float radius, knowherefaiss::RangeSearchResult* result,
+                 const knowherefaiss::SearchParameters* params) const override;
 
     void
     reset() override;
 
     void
-    merge_from(Index& otherIndex, faiss::idx_t add_id) override;
+    merge_from(Index& otherIndex, knowherefaiss::idx_t add_id) override;
 
-    faiss::DistanceComputer*
+    knowherefaiss::DistanceComputer*
     get_distance_computer() const override;
 
     // point to IndexIVFRaBitQ or return nullptr.
     // this may also point to an index, owned by IndexRefine
-    faiss::IndexIVFRaBitQ*
+    knowherefaiss::IndexIVFRaBitQ*
     get_ivfrabitq_index();
-    const faiss::IndexIVFRaBitQ*
+    const knowherefaiss::IndexIVFRaBitQ*
     get_ivfrabitq_index() const;
 
     // point to IndexRefine or return nullptr.
-    faiss::IndexRefine*
+    knowherefaiss::IndexRefine*
     get_refine_index();
-    const faiss::IndexRefine*
+    const knowherefaiss::IndexRefine*
     get_refine_index() const;
 
     // return the size of the index
     size_t
     size() const;
 
-    std::unique_ptr<faiss::IVFIteratorWorkspace>
-    getIteratorWorkspace(const float* query_data, const faiss::IVFSearchParameters* ivfsearchParams) const;
+    std::unique_ptr<knowherefaiss::IVFIteratorWorkspace>
+    getIteratorWorkspace(const float* query_data, const knowherefaiss::IVFSearchParameters* ivfsearchParams) const;
 
     void
-    getIteratorNextBatch(faiss::IVFIteratorWorkspace* workspace, size_t current_backup_count) const;
+    getIteratorNextBatch(knowherefaiss::IVFIteratorWorkspace* workspace, size_t current_backup_count) const;
 };
 
 }  // namespace knowhere
diff --git a/src/index/minhash/minhash_lsh.h b/src/index/minhash/minhash_lsh.h
index c55424d4..c2f5b56c 100644
--- a/src/index/minhash/minhash_lsh.h
+++ b/src/index/minhash/minhash_lsh.h
@@ -11,7 +11,7 @@
 
 #ifndef MINHASH_LSH_H
 #define MINHASH_LSH_H
-#include "faiss/impl/io.h"
+#include "knowherefaiss/impl/io.h"
 #include "index/minhash/minhash_util.h"
 #include "io/file_io.h"
 #include "io/memory_io.h"
@@ -45,21 +45,21 @@ struct MinHashLSHSearchParams {
     size_t k = 1;
     size_t refine_k = 1;
     bool search_with_jaccard = false;
-    faiss::IDSelector* id_selector = nullptr;
+    knowherefaiss::IDSelector* id_selector = nullptr;
 };
 
 // index of each band
 class MinHashBandIndex {
  public:
     static size_t
-    FormatAndSave(faiss::BlockFileIOWriter& writer, const KVPair* sorted_kv, const size_t block_size,
+    FormatAndSave(knowherefaiss::BlockFileIOWriter& writer, const KVPair* sorted_kv, const size_t block_size,
                   const size_t rows);
 
     Status
     Load(FileReader& reader, size_t rows, char* mmap_data, BloomFilter<KeyType>& bloom_filter);
 
     void
-    Search(KeyType key, MinHashLSHResultHandler* res, faiss::IDSelector* id_selector) const;
+    Search(KeyType key, MinHashLSHResultHandler* res, knowherefaiss::IDSelector* id_selector) const;
 
     Status
     WarmUp() const {
@@ -149,7 +149,7 @@ class MinHashLSH {
 };
 
 size_t
-MinHashBandIndex::FormatAndSave(faiss::BlockFileIOWriter& writer, const KVPair* sorted_kv, const size_t block_size,
+MinHashBandIndex::FormatAndSave(knowherefaiss::BlockFileIOWriter& writer, const KVPair* sorted_kv, const size_t block_size,
                                 const size_t rows) {
     size_t max_num_of_a_block = block_size / sizeof(KVPair);
     size_t blocks_num = (rows + max_num_of_a_block - 1) / max_num_of_a_block;
@@ -227,8 +227,8 @@ MinHashBandIndex::Load(FileReader& reader, size_t rows, char* mmap_data, BloomFi
 }
 
 void
-MinHashBandIndex::Search(KeyType key, MinHashLSHResultHandler* res, faiss::IDSelector* id_selector) const {
-    auto block_id = faiss::u64_binary_search_ge(maxs_.data(), maxs_.size(), key);
+MinHashBandIndex::Search(KeyType key, MinHashLSHResultHandler* res, knowherefaiss::IDSelector* id_selector) const {
+    auto block_id = knowherefaiss::u64_binary_search_ge(maxs_.data(), maxs_.size(), key);
 
     if (block_id == -1 || key < mins_[block_id]) {
         return;
@@ -237,7 +237,7 @@ MinHashBandIndex::Search(KeyType key, MinHashLSHResultHandler* res, faiss::IDSel
         size_t rows = num_in_a_blk_[block_id];
         KeyType* blk_k = reinterpret_cast<KeyType*>(data_ + block_size_ * block_id);
         ValueType* blk_v = reinterpret_cast<ValueType*>(data_ + block_size_ * block_id + rows * sizeof(KeyType));
-        int inner_id = faiss::u64_binary_search_eq(blk_k, rows, key);
+        int inner_id = knowherefaiss::u64_binary_search_eq(blk_k, rows, key);
         if (inner_id != -1) {
             for (; key == blk_k[inner_id] && (size_t)inner_id < rows; inner_id++) {
                 if (id_selector == nullptr || id_selector->is_member(blk_v[inner_id])) {
@@ -275,7 +275,7 @@ MinHashLSH::BuildAndSave(MinHashLSHBuildParams* params) {
     std::shared_ptr<KVPair[]> total_kv_pair;
 
     size_t header_size = DIV_ROUND_UP(sizeof(MinHashLSH) + band_num * sizeof(size_t), block_size);
-    faiss::BlockFileIOWriter writer(params->index_file_path.c_str(), block_size, header_size);
+    knowherefaiss::BlockFileIOWriter writer(params->index_file_path.c_str(), block_size, header_size);
     // load raw data, generate hash kv for each band and save raw data
     {
         std::unique_ptr<char[]> data = nullptr;
diff --git a/src/index/minhash/minhash_util.cc b/src/index/minhash/minhash_util.cc
index 3fc68dd7..f6b5b362 100644
--- a/src/index/minhash/minhash_util.cc
+++ b/src/index/minhash/minhash_util.cc
@@ -11,7 +11,7 @@
 #include "index/minhash/minhash_util.h"
 namespace knowhere::minhash {
 namespace {
-using JcaccardSim = faiss::CMin<float, idx_t>;
+using JcaccardSim = knowherefaiss::CMin<float, idx_t>;
 using DIST1FUNC = float (*)(const char* x, const char* y, size_t element_length, size_t element_size);
 using DIST4FUNC = void (*)(const char* x, const char* y0, const char* y1, const char* y2, const char* y3, size_t size,
                            size_t element_size, float& dis0, float& dis1, float& dis2, float& dis3);
@@ -49,7 +49,7 @@ minhash_jaccard_batch_4_native(const char* x, const char* y0, const char* y1, co
 }
 
 // use minhash jaccard distance
-struct MinHashJaccardComputer : faiss::DistanceComputer {
+struct MinHashJaccardComputer : knowherefaiss::DistanceComputer {
     const char* base;
     const char* q;
     size_t element_length;  // minhash vector dim
@@ -60,11 +60,11 @@ struct MinHashJaccardComputer : faiss::DistanceComputer {
     MinHashJaccardComputer(const char* x, const size_t l, const size_t es)
         : base(x), element_length(l), element_size(es) {
         if (element_size == 4) {
-            dist1 = faiss::u32_jaccard_distance;
-            dist4 = faiss::u32_jaccard_distance_batch_4;
+            dist1 = knowherefaiss::u32_jaccard_distance;
+            dist4 = knowherefaiss::u32_jaccard_distance_batch_4;
         } else if (element_size == 8) {
-            dist1 = faiss::u64_jaccard_distance;
-            dist4 = faiss::u64_jaccard_distance_batch_4;
+            dist1 = knowherefaiss::u64_jaccard_distance;
+            dist4 = knowherefaiss::u64_jaccard_distance_batch_4;
         } else {
             dist1 = &minhash_jaccard_native;
             dist4 = &minhash_jaccard_batch_4_native;
@@ -147,7 +147,7 @@ minhash_lsh_hit_with_topk1_opt_search(const char* x, const char* y, size_t size_
             for (size_t query_id = query_beg; query_id < query_end; query_id++) {
                 auto query_key = query_hash_k.data() + mh_lsh_band * query_id;
                 for (size_t i = 0; i < mh_lsh_band; i++) {
-                    auto hit_id = faiss::u64_binary_search_eq(base_hash_k.data() + i * ny, ny, query_key[i]);
+                    auto hit_id = knowherefaiss::u64_binary_search_eq(base_hash_k.data() + i * ny, ny, query_key[i]);
                     if (hit_id != -1) {
                         all_res[query_id].push(base_hash_v[hit_id], 1.0f);
                         while (!all_res[query_id].full() && hit_id < mh_lsh_band &&
@@ -322,7 +322,7 @@ MinHashLSHHitByNy(const char* x, const char* y, size_t size_in_bytes, size_t ele
     MinHashLSHResultHandler res(ids, vals, topk);
     for (size_t i = 0; i < ny; i++) {
         if (bitset.empty() || !bitset.test(i)) {
-            res.push(i, faiss::minhash_lsh_hit(x, y + size_in_bytes * i, truncated_size, mh_lsh_band));
+            res.push(i, knowherefaiss::minhash_lsh_hit(x, y + size_in_bytes * i, truncated_size, mh_lsh_band));
             if (res.full()) {
                 break;
             }
@@ -345,11 +345,11 @@ MinHashJaccardKNNSearchByNy(const char* x, const char* y, size_t length, size_t
     // the lambda that applies a valid element.
     auto apply = [&](const float dis_in, const size_t j) {
         if (JcaccardSim::cmp(vals[0], dis_in)) {
-            faiss::heap_replace_top<JcaccardSim>(topk, vals, ids, dis_in, j);
+            knowherefaiss::heap_replace_top<JcaccardSim>(topk, vals, ids, dis_in, j);
         }
     };
-    faiss::distance_compute_if(ny, computer.get(), filter, apply);
-    faiss::heap_reorder<JcaccardSim>(topk, vals, ids);
+    knowherefaiss::distance_compute_if(ny, computer.get(), filter, apply);
+    knowherefaiss::heap_reorder<JcaccardSim>(topk, vals, ids);
 }
 
 void
@@ -362,7 +362,7 @@ MinHashJaccardKNNSearchByIDs(const char* x, const char* y, const int64_t* sel_id
     }
     auto apply = [&](const float dis_in, const size_t j) {
         if (JcaccardSim::cmp(res_vals[0], dis_in)) {
-            faiss::heap_replace_top<JcaccardSim>(topk, res_vals, res_ids, dis_in, j);
+            knowherefaiss::heap_replace_top<JcaccardSim>(topk, res_vals, res_ids, dis_in, j);
         }
     };
     auto computer = std::make_shared<MinHashJaccardComputer>(y, length, element_size);
@@ -381,7 +381,7 @@ MinHashJaccardKNNSearchByIDs(const char* x, const char* y, const int64_t* sel_id
         apply(dis, sel_ids[i]);
         i++;
     }
-    faiss::heap_reorder<JcaccardSim>(topk, res_vals, res_ids);
+    knowherefaiss::heap_reorder<JcaccardSim>(topk, res_vals, res_ids);
 }
 
 Status
diff --git a/src/index/minhash/minhash_util.h b/src/index/minhash/minhash_util.h
index 4ce6eaa4..7e494be8 100644
--- a/src/index/minhash/minhash_util.h
+++ b/src/index/minhash/minhash_util.h
@@ -11,13 +11,13 @@
 
 #pragma once
 
-#include "faiss/utils/distances_if.h"
+#include "knowherefaiss/utils/distances_if.h"
 #include "knowhere/bitsetview.h"
 #include "knowhere/comp/thread_pool.h"
 #include "knowhere/config.h"
 #include "knowhere/operands.h"
 namespace knowhere::minhash {
-using idx_t = faiss::idx_t;
+using idx_t = knowherefaiss::idx_t;
 using KeyType = uint64_t;
 using ValueType = idx_t;
 struct KVPair {
@@ -28,7 +28,7 @@ struct KVPair {
 constexpr int kBatch = 4096;
 constexpr int kQueryBatch = 64;
 constexpr int kQueryBandBatch = 4;
-using idx_t = faiss::idx_t;
+using idx_t = knowherefaiss::idx_t;
 
 struct MinHashLSHResultHandler {
     idx_t* ids_list_;
@@ -79,7 +79,7 @@ inline minhash::KeyType
 GetHashKey(const char* data, size_t size /*in bytes*/, size_t band, size_t band_i) {
     const size_t r = size / band;
     auto band_i_data = data + r * band_i;
-    return faiss::calculate_hash((const char*)band_i_data, r);
+    return knowherefaiss::calculate_hash((const char*)band_i_data, r);
 }
 
 std::shared_ptr<minhash::KVPair[]>
diff --git a/src/index/refine/refine_utils.cc b/src/index/refine/refine_utils.cc
index aed64b50..3acae78c 100644
--- a/src/index/refine/refine_utils.cc
+++ b/src/index/refine/refine_utils.cc
@@ -7,8 +7,8 @@
 #include <optional>
 #include <string>
 
-#include "faiss/IndexRefine.h"
-#include "faiss/IndexScalarQuantizer.h"
+#include "knowherefaiss/IndexRefine.h"
+#include "knowherefaiss/IndexScalarQuantizer.h"
 #include "fmt/format.h"
 #include "knowhere/log.h"
 #include "knowhere/tolower.h"
@@ -16,20 +16,20 @@
 namespace knowhere {
 
 // a supporting function
-expected<faiss::ScalarQuantizer::QuantizerType>
+expected<knowherefaiss::ScalarQuantizer::QuantizerType>
 get_sq_quantizer_type(const std::string& sq_type) {
-    std::map<std::string, faiss::ScalarQuantizer::QuantizerType> sq_types = {
-        {"sq6", faiss::ScalarQuantizer::QT_6bit},
-        {"sq8", faiss::ScalarQuantizer::QT_8bit},
-        {"fp16", faiss::ScalarQuantizer::QT_fp16},
-        {"bf16", faiss::ScalarQuantizer::QT_bf16},
-        {"int8", faiss::ScalarQuantizer::QT_8bit_direct_signed}};
+    std::map<std::string, knowherefaiss::ScalarQuantizer::QuantizerType> sq_types = {
+        {"sq6", knowherefaiss::ScalarQuantizer::QT_6bit},
+        {"sq8", knowherefaiss::ScalarQuantizer::QT_8bit},
+        {"fp16", knowherefaiss::ScalarQuantizer::QT_fp16},
+        {"bf16", knowherefaiss::ScalarQuantizer::QT_bf16},
+        {"int8", knowherefaiss::ScalarQuantizer::QT_8bit_direct_signed}};
 
     // todo: tolower
     auto sq_type_tolower = str_to_lower(sq_type);
     auto itr = sq_types.find(sq_type_tolower);
     if (itr == sq_types.cend()) {
-        return expected<faiss::ScalarQuantizer::QuantizerType>::Err(
+        return expected<knowherefaiss::ScalarQuantizer::QuantizerType>::Err(
             Status::invalid_args, fmt::format("invalid scalar quantizer type ({})", sq_type_tolower));
     }
 
@@ -60,7 +60,7 @@ is_flat_refine(const std::optional<std::string>& refine_type) {
 }
 
 bool
-has_lossless_quant(const expected<faiss::ScalarQuantizer::QuantizerType>& quant_type, DataFormatEnum dataFormat) {
+has_lossless_quant(const expected<knowherefaiss::ScalarQuantizer::QuantizerType>& quant_type, DataFormatEnum dataFormat) {
     if (!quant_type.has_value()) {
         return false;
     }
@@ -70,11 +70,11 @@ has_lossless_quant(const expected<faiss::ScalarQuantizer::QuantizerType>& quant_
         case DataFormatEnum::fp32:
             return false;
         case DataFormatEnum::fp16:
-            return quant == faiss::ScalarQuantizer::QuantizerType::QT_fp16;
+            return quant == knowherefaiss::ScalarQuantizer::QuantizerType::QT_fp16;
         case DataFormatEnum::bf16:
-            return quant == faiss::ScalarQuantizer::QuantizerType::QT_bf16;
+            return quant == knowherefaiss::ScalarQuantizer::QuantizerType::QT_bf16;
         case DataFormatEnum::int8:
-            return quant == faiss::ScalarQuantizer::QuantizerType::QT_8bit_direct_signed;
+            return quant == knowherefaiss::ScalarQuantizer::QuantizerType::QT_8bit_direct_signed;
         default:
             return false;
     }
@@ -97,14 +97,14 @@ has_lossless_refine_index(const std::optional<bool>& refine, const std::optional
 }
 
 // pick a refine index
-expected<std::unique_ptr<faiss::Index>>
+expected<std::unique_ptr<knowherefaiss::Index>>
 pick_refine_index(const DataFormatEnum data_format, const std::optional<std::string>& refine_type,
-                  std::unique_ptr<faiss::Index>&& base_index, const size_t base_d,
-                  const faiss::MetricType base_metric_type) {
+                  std::unique_ptr<knowherefaiss::Index>&& base_index, const size_t base_d,
+                  const knowherefaiss::MetricType base_metric_type) {
     // grab a type of a refine index
     expected<bool> is_fp32_flat = is_flat_refine(refine_type);
     if (!is_fp32_flat.has_value()) {
-        return expected<std::unique_ptr<faiss::Index>>::Err(Status::invalid_args, "");
+        return expected<std::unique_ptr<knowherefaiss::Index>>::Err(Status::invalid_args, "");
     }
 
     const bool is_fp32_flat_v = is_fp32_flat.value();
@@ -114,9 +114,9 @@ pick_refine_index(const DataFormatEnum data_format, const std::optional<std::str
         // make sure that we're using fp16 refine
         auto refine_sq_type = get_sq_quantizer_type(refine_type.value());
         if (!(refine_sq_type.has_value() &&
-              (refine_sq_type.value() != faiss::ScalarQuantizer::QT_bf16 && !is_fp32_flat_v))) {
+              (refine_sq_type.value() != knowherefaiss::ScalarQuantizer::QT_bf16 && !is_fp32_flat_v))) {
             LOG_KNOWHERE_ERROR_ << "fp16 input data does not accept bf16 or fp32 as a refine index.";
-            return expected<std::unique_ptr<faiss::Index>>::Err(
+            return expected<std::unique_ptr<knowherefaiss::Index>>::Err(
                 Status::invalid_args, "fp16 input data does not accept bf16 or fp32 as a refine index.");
         }
     }
@@ -125,20 +125,20 @@ pick_refine_index(const DataFormatEnum data_format, const std::optional<std::str
         // make sure that we're using bf16 refine
         auto refine_sq_type = get_sq_quantizer_type(refine_type.value());
         if (!(refine_sq_type.has_value() &&
-              (refine_sq_type.value() != faiss::ScalarQuantizer::QT_fp16 && !is_fp32_flat_v))) {
+              (refine_sq_type.value() != knowherefaiss::ScalarQuantizer::QT_fp16 && !is_fp32_flat_v))) {
             LOG_KNOWHERE_ERROR_ << "bf16 input data does not accept fp16 or fp32 as a refine index.";
-            return expected<std::unique_ptr<faiss::Index>>::Err(
+            return expected<std::unique_ptr<knowherefaiss::Index>>::Err(
                 Status::invalid_args, "bf16 input data does not accept fp16 or fp32 as a refine index.");
         }
     }
 
     // build
-    std::unique_ptr<faiss::Index> local_index = std::move(base_index);
+    std::unique_ptr<knowherefaiss::Index> local_index = std::move(base_index);
 
     // either build flat or sq
     if (is_fp32_flat_v) {
         // build IndexFlat as a refine
-        auto refine_index = std::make_unique<faiss::IndexRefineFlat>(local_index.get());
+        auto refine_index = std::make_unique<knowherefaiss::IndexRefineFlat>(local_index.get());
 
         // let refine_index to own everything
         refine_index->own_fields = true;
@@ -153,15 +153,15 @@ pick_refine_index(const DataFormatEnum data_format, const std::optional<std::str
         // a redundant check
         if (!refine_sq_type.has_value()) {
             LOG_KNOWHERE_ERROR_ << "Invalid refine type: " << refine_type.value();
-            return expected<std::unique_ptr<faiss::Index>>::Err(
+            return expected<std::unique_ptr<knowherefaiss::Index>>::Err(
                 Status::invalid_args, fmt::format("invalid refine type ({})", refine_type.value()));
         }
 
         // create an sq
         auto sq_refine =
-            std::make_unique<faiss::IndexScalarQuantizer>(base_d, refine_sq_type.value(), base_metric_type);
+            std::make_unique<knowherefaiss::IndexScalarQuantizer>(base_d, refine_sq_type.value(), base_metric_type);
 
-        auto refine_index = std::make_unique<faiss::IndexRefine>(local_index.get(), sq_refine.get());
+        auto refine_index = std::make_unique<knowherefaiss::IndexRefine>(local_index.get(), sq_refine.get());
 
         // let refine_index to own everything
         refine_index->own_refine_index = true;
diff --git a/src/index/refine/refine_utils.h b/src/index/refine/refine_utils.h
index 21d9b768..b34c64a2 100644
--- a/src/index/refine/refine_utils.h
+++ b/src/index/refine/refine_utils.h
@@ -6,31 +6,31 @@
 #include <optional>
 #include <string>
 
-#include "faiss/impl/ScalarQuantizer.h"
+#include "knowherefaiss/impl/ScalarQuantizer.h"
 #include "knowhere/expected.h"
 #include "knowhere/operands.h"
 
 namespace knowhere {
 
-expected<faiss::ScalarQuantizer::QuantizerType>
+expected<knowherefaiss::ScalarQuantizer::QuantizerType>
 get_sq_quantizer_type(const std::string& sq_type);
 
 expected<bool>
 is_flat_refine(const std::optional<std::string>& refine_type);
 
 bool
-has_lossless_quant(const expected<faiss::ScalarQuantizer::QuantizerType>& quant_type, DataFormatEnum dataFormat);
+has_lossless_quant(const expected<knowherefaiss::ScalarQuantizer::QuantizerType>& quant_type, DataFormatEnum dataFormat);
 
 bool
 has_lossless_refine_index(const std::optional<bool>& refine, const std::optional<std::string>& refine_type,
                           DataFormatEnum dataFormat);
 
-expected<std::unique_ptr<faiss::Index>>
+expected<std::unique_ptr<knowherefaiss::Index>>
 pick_refine_index(const DataFormatEnum data_format, const std::optional<std::string>& refine_type,
-                  std::unique_ptr<faiss::Index>&& base_index,
+                  std::unique_ptr<knowherefaiss::Index>&& base_index,
                   // These two could be borrowed from base_index. But it seems that
                   //   for HNSW these things are borrowed from base_index.storage.
                   //   So, let's provide these externally
-                  const size_t base_d, const faiss::MetricType base_metric_type);
+                  const size_t base_d, const knowherefaiss::MetricType base_metric_type);
 
 }  // namespace knowhere
diff --git a/src/io/memory_io.h b/src/io/memory_io.h
index 461c6aab..39da4bf7 100644
--- a/src/io/memory_io.h
+++ b/src/io/memory_io.h
@@ -11,7 +11,7 @@
 
 #pragma once
 
-#include <faiss/impl/io.h>
+#include <knowherefaiss/impl/io.h>
 
 namespace knowhere {
 
@@ -71,7 +71,7 @@ getSwappedBytes(char C) {
 
 #endif
 
-struct MemoryIOWriter : public faiss::IOWriter {
+struct MemoryIOWriter : public knowherefaiss::IOWriter {
     uint8_t* data_ = nullptr;
     size_t total_ = 0;
     size_t rp_ = 0;
@@ -102,7 +102,7 @@ struct MemoryIOWriter : public faiss::IOWriter {
     }
 };
 
-struct MemoryIOReader : public faiss::IOReader {
+struct MemoryIOReader : public knowherefaiss::IOReader {
     uint8_t* data_;
     size_t rp_ = 0;
     size_t total_ = 0;
diff --git a/src/simd/distances_avx.cc b/src/simd/distances_avx.cc
index c5db06cf..9921d8b1 100644
--- a/src/simd/distances_avx.cc
+++ b/src/simd/distances_avx.cc
@@ -17,10 +17,10 @@
 
 #include <cassert>
 
-#include "faiss/impl/platform_macros.h"
+#include "knowherefaiss/impl/platform_macros.h"
 #include "xxhash.h"
 
-namespace faiss {
+namespace knowherefaiss {
 
 #define ALIGNED(x) __attribute__((aligned(x)))
 
@@ -1145,5 +1145,5 @@ calculate_hash_avx2(const char* data, size_t size) {
     return XXH3_64bits(data, size);
 }
 
-}  // namespace faiss
+}  // namespace knowherefaiss
 #endif
diff --git a/src/simd/distances_avx.h b/src/simd/distances_avx.h
index fe9f5134..3d7baec7 100644
--- a/src/simd/distances_avx.h
+++ b/src/simd/distances_avx.h
@@ -16,7 +16,7 @@
 
 #include "knowhere/operands.h"
 
-namespace faiss {
+namespace knowherefaiss {
 
 /// Squared L2 distance between two vectors
 float
@@ -157,4 +157,4 @@ rabitq_dp_popcnt_avx(const uint8_t* q, const uint8_t* x, const size_t d, const s
 uint64_t
 calculate_hash_avx2(const char* data, size_t size);
 
-}  // namespace faiss
+}  // namespace knowherefaiss
diff --git a/src/simd/distances_avx512.cc b/src/simd/distances_avx512.cc
index af4e88a7..45c4a469 100644
--- a/src/simd/distances_avx512.cc
+++ b/src/simd/distances_avx512.cc
@@ -20,10 +20,10 @@
 #include <iostream>
 #include <string>
 
-#include "faiss/impl/platform_macros.h"
+#include "knowherefaiss/impl/platform_macros.h"
 #include "xxhash.h"
 
-namespace faiss {
+namespace knowherefaiss {
 
 namespace {
 // reads 0 <= d < 4 floats as __m128
@@ -1208,5 +1208,5 @@ u64_jaccard_distance_batch_4_avx512(const char* x, const char* y0, const char* y
     dis2 = float(d2) / element_length;
     dis3 = float(d3) / element_length;
 }
-}  // namespace faiss
+}  // namespace knowherefaiss
 #endif
diff --git a/src/simd/distances_avx512.h b/src/simd/distances_avx512.h
index 4c5e88b6..4ab89e11 100644
--- a/src/simd/distances_avx512.h
+++ b/src/simd/distances_avx512.h
@@ -16,7 +16,7 @@
 
 #include "knowhere/operands.h"
 
-namespace faiss {
+namespace knowherefaiss {
 
 float
 fvec_L2sqr_avx512(const float* x, const float* y, size_t d);
@@ -165,4 +165,4 @@ u64_jaccard_distance_avx512(const char*, const char*, size_t size, size_t);
 void
 u64_jaccard_distance_batch_4_avx512(const char*, const char*, const char*, const char*, const char*, size_t, size_t,
                                     float&, float&, float&, float&);
-}  // namespace faiss
+}  // namespace knowherefaiss
diff --git a/src/simd/distances_avx512icx.cc b/src/simd/distances_avx512icx.cc
index ba4f675c..ee460a68 100644
--- a/src/simd/distances_avx512icx.cc
+++ b/src/simd/distances_avx512icx.cc
@@ -18,7 +18,7 @@
 
 #include "distances_avx512.h"
 
-namespace faiss {
+namespace knowherefaiss {
 
 namespace {
 
@@ -115,5 +115,5 @@ rabitq_dp_popcnt_avx512icx(const uint8_t* q, const uint8_t* x, const size_t d, c
     return 0;
 }
 
-}  // namespace faiss
+}  // namespace knowherefaiss
 #endif
diff --git a/src/simd/distances_avx512icx.h b/src/simd/distances_avx512icx.h
index 4850e541..cf39b903 100644
--- a/src/simd/distances_avx512icx.h
+++ b/src/simd/distances_avx512icx.h
@@ -14,11 +14,11 @@
 #include <cstddef>
 #include <cstdint>
 
-namespace faiss {
+namespace knowherefaiss {
 
 ///////////////////////////////////////////////////////////////////////////////
 // rabitq
 int
 rabitq_dp_popcnt_avx512icx(const uint8_t* q, const uint8_t* x, const size_t d, const size_t nb);
 
-}  // namespace faiss
+}  // namespace knowherefaiss
diff --git a/src/simd/distances_neon.cc b/src/simd/distances_neon.cc
index 0fc37d41..3b582ee9 100644
--- a/src/simd/distances_neon.cc
+++ b/src/simd/distances_neon.cc
@@ -17,7 +17,7 @@
 #include <arm_neon.h>
 #include <math.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 namespace {
 inline float32x4x4_t
@@ -3520,5 +3520,5 @@ fvec_L2sqr_batch_4_bf16_patch_neon(const float* x, const float* y0, const float*
     dis3 = vaddvq_f32(sum_.val[3]);
 }
 
-}  // namespace faiss
+}  // namespace knowherefaiss
 #endif
diff --git a/src/simd/distances_neon.h b/src/simd/distances_neon.h
index 86eedbf3..c0495d45 100644
--- a/src/simd/distances_neon.h
+++ b/src/simd/distances_neon.h
@@ -16,7 +16,7 @@
 
 #include "knowhere/operands.h"
 
-namespace faiss {
+namespace knowherefaiss {
 
 /// Squared L2 distance between two vectors
 float
@@ -162,4 +162,4 @@ void
 fvec_L2sqr_batch_4_bf16_patch_neon(const float* x, const float* y0, const float* y1, const float* y2, const float* y3,
                                    const size_t dim, float& dis0, float& dis1, float& dis2, float& dis3);
 
-}  // namespace faiss
+}  // namespace knowherefaiss
diff --git a/src/simd/distances_powerpc.cc b/src/simd/distances_powerpc.cc
index 265a8ba3..e9a33f00 100644
--- a/src/simd/distances_powerpc.cc
+++ b/src/simd/distances_powerpc.cc
@@ -23,7 +23,7 @@
 #define INT32_VEC_SIZE 4
 #define INT8_VEC_SIZE 16
 
-namespace faiss {
+namespace knowherefaiss {
 
 float
 fvec_L2sqr_ppc(const float* x, const float* y, size_t d) {
@@ -514,5 +514,5 @@ ivec_L2sqr_ppc(const int8_t* x, const int8_t* y, size_t d) {
     return res;
 }
 
-}  // namespace faiss
+}  // namespace knowherefaiss
 #endif
diff --git a/src/simd/distances_powerpc.h b/src/simd/distances_powerpc.h
index 549fca2a..ef631bca 100644
--- a/src/simd/distances_powerpc.h
+++ b/src/simd/distances_powerpc.h
@@ -16,7 +16,7 @@
 #include <cstdint>
 #include <cstdio>
 
-namespace faiss {
+namespace knowherefaiss {
 
 /// Squared L2 distance between two vectors
 float
@@ -90,4 +90,4 @@ ivec_inner_product_ppc(const int8_t* x, const int8_t* y, size_t d);
 int32_t
 ivec_L2sqr_ppc(const int8_t* x, const int8_t* y, size_t d);
 
-}  // namespace faiss
+}  // namespace knowherefaiss
diff --git a/src/simd/distances_ref.cc b/src/simd/distances_ref.cc
index cd34d22b..35495e1e 100644
--- a/src/simd/distances_ref.cc
+++ b/src/simd/distances_ref.cc
@@ -16,7 +16,7 @@
 #include "knowhere/operands.h"
 #include "xxhash.h"
 
-namespace faiss {
+namespace knowherefaiss {
 
 float
 fvec_inner_product_ref(const float* x, const float* y, size_t d) {
@@ -729,4 +729,4 @@ u64_jaccard_distance_batch_4_ref(const char* x, const char* y0, const char* y1,
     return;
 }
 
-}  // namespace faiss
+}  // namespace knowherefaiss
diff --git a/src/simd/distances_ref.h b/src/simd/distances_ref.h
index c408cbbb..42109a8e 100644
--- a/src/simd/distances_ref.h
+++ b/src/simd/distances_ref.h
@@ -16,7 +16,7 @@
 
 #include "knowhere/operands.h"
 
-namespace faiss {
+namespace knowherefaiss {
 
 /// Squared L2 distance between two vectors
 float
@@ -199,4 +199,4 @@ void
 u64_jaccard_distance_batch_4_ref(const char*, const char*, const char*, const char*, const char*, size_t, size_t,
                                  float&, float&, float&, float&);
 
-}  // namespace faiss
+}  // namespace knowherefaiss
diff --git a/src/simd/distances_rvv.cc b/src/simd/distances_rvv.cc
index 9b1cc7de..e6fc1866 100644
--- a/src/simd/distances_rvv.cc
+++ b/src/simd/distances_rvv.cc
@@ -16,7 +16,7 @@
 #include <math.h>
 #include <riscv_vector.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 // =================== float distances ===================
 float
@@ -554,6 +554,6 @@ ivec_L2sqr_rvv(const int8_t* x, const int8_t* y, size_t d) {
     return res;
 }
 
-}  // namespace faiss
+}  // namespace knowherefaiss
 
 #endif
diff --git a/src/simd/distances_rvv.h b/src/simd/distances_rvv.h
index 1486fd1f..fbe48b7b 100644
--- a/src/simd/distances_rvv.h
+++ b/src/simd/distances_rvv.h
@@ -16,7 +16,7 @@
 
 #include "knowhere/operands.h"
 
-namespace faiss {
+namespace knowherefaiss {
 
 float
 fvec_inner_product_rvv(const float* x, const float* y, size_t d);
@@ -59,4 +59,4 @@ ivec_inner_product_rvv(const int8_t* x, const int8_t* y, size_t d);
 int32_t
 ivec_L2sqr_rvv(const int8_t* x, const int8_t* y, size_t d);
 
-}  // namespace faiss
+}  // namespace knowherefaiss
diff --git a/src/simd/distances_sse.cc b/src/simd/distances_sse.cc
index 8e63846a..9651192b 100644
--- a/src/simd/distances_sse.cc
+++ b/src/simd/distances_sse.cc
@@ -19,10 +19,10 @@
 #include <cstdint>
 
 #include "distances_ref.h"
-#include "faiss/impl/platform_macros.h"
+#include "knowherefaiss/impl/platform_macros.h"
 #include "xxhash.h"
 
-namespace faiss {
+namespace knowherefaiss {
 
 #define ALIGNED(x) __attribute__((aligned(x)))
 
@@ -587,5 +587,5 @@ uint64_t
 calculate_hash_sse(const char* data, size_t size) {
     return XXH3_64bits(data, size);
 }
-}  // namespace faiss
+}  // namespace knowherefaiss
 #endif
diff --git a/src/simd/distances_sse.h b/src/simd/distances_sse.h
index b77f57e0..ea498c32 100644
--- a/src/simd/distances_sse.h
+++ b/src/simd/distances_sse.h
@@ -16,7 +16,7 @@
 
 #include "knowhere/operands.h"
 
-namespace faiss {
+namespace knowherefaiss {
 
 /// Squared L2 distance between two vectors
 float
@@ -93,4 +93,4 @@ rabitq_dp_popcnt_sse(const uint8_t* q, const uint8_t* x, const size_t d, const s
 // minhash
 uint64_t
 calculate_hash_sse(const char* data, size_t size);
-}  // namespace faiss
+}  // namespace knowherefaiss
diff --git a/src/simd/distances_sve.cc b/src/simd/distances_sve.cc
index 49ce04ff..811e232e 100644
--- a/src/simd/distances_sve.cc
+++ b/src/simd/distances_sve.cc
@@ -15,9 +15,9 @@
 
 #include <cmath>
 
-#include "faiss/impl/platform_macros.h"
+#include "knowherefaiss/impl/platform_macros.h"
 #if defined(__ARM_FEATURE_SVE)
-namespace faiss {
+namespace knowherefaiss {
 namespace {
 inline size_t
 find_min_index_sve(const float* data, size_t ny) {
@@ -967,6 +967,6 @@ bf16_vec_inner_product_batch_4_sve(const knowhere::bf16* x, const knowhere::bf16
     dis3 = svaddv_f32(svptrue_b32(), acc3);
 }
 
-}  // namespace faiss
+}  // namespace knowherefaiss
 
 #endif
diff --git a/src/simd/distances_sve.h b/src/simd/distances_sve.h
index f50aea12..c2c78c14 100644
--- a/src/simd/distances_sve.h
+++ b/src/simd/distances_sve.h
@@ -17,7 +17,7 @@
 #include "knowhere/operands.h"
 
 #if defined(__ARM_FEATURE_SVE)
-namespace faiss {
+namespace knowherefaiss {
 
 float
 fvec_L2sqr_sve(const float* x, const float* y, size_t d);
@@ -109,5 +109,5 @@ bf16_vec_inner_product_batch_4_sve(const knowhere::bf16* x, const knowhere::bf16
                                    const knowhere::bf16* y2, const knowhere::bf16* y3, const size_t d, float& dis0,
                                    float& dis1, float& dis2, float& dis3);
 
-}  // namespace faiss
+}  // namespace knowherefaiss
 #endif
diff --git a/src/simd/hook.cc b/src/simd/hook.cc
index 9dc4feb5..80165653 100644
--- a/src/simd/hook.cc
+++ b/src/simd/hook.cc
@@ -13,7 +13,7 @@
 
 #include <mutex>
 
-#include "faiss/FaissHook.h"
+#include "knowherefaiss/FaissHook.h"
 
 #if defined(__x86_64__)
 #include "distances_avx.h"
@@ -46,7 +46,7 @@
 
 #include "distances_ref.h"
 
-namespace faiss {
+namespace knowherefaiss {
 
 #if defined(__x86_64__)
 bool use_avx512 = true;
@@ -598,8 +598,8 @@ fvec_hook(std::string& simd_type) {
 static int init_hook_ = []() {
     std::string simd_type;
     fvec_hook(simd_type);
-    faiss::sq_hook();
+    knowherefaiss::sq_hook();
     return 0;
 }();
 
-}  // namespace faiss
+}  // namespace knowherefaiss
diff --git a/src/simd/hook.h b/src/simd/hook.h
index 243bb917..8e2aa5f7 100644
--- a/src/simd/hook.h
+++ b/src/simd/hook.h
@@ -16,7 +16,7 @@
 
 #include "knowhere/operands.h"
 
-namespace faiss {
+namespace knowherefaiss {
 
 #if defined(__x86_64__)
 extern bool use_avx512;
@@ -159,6 +159,6 @@ disable_patch_for_fp32_bf16();
 void
 fvec_hook(std::string&);
 
-}  // namespace faiss
+}  // namespace knowherefaiss
 
 #endif /* HOOK_H */
diff --git a/src/simd/instruction_set.h b/src/simd/instruction_set.h
index c3a95e80..54071f28 100644
--- a/src/simd/instruction_set.h
+++ b/src/simd/instruction_set.h
@@ -21,7 +21,7 @@
 #include <string>
 #include <vector>
 
-namespace faiss {
+namespace knowherefaiss {
 
 class InstructionSet {
  public:
@@ -369,6 +369,6 @@ class InstructionSet {
     std::vector<std::array<int, 4>> extdata_;
 };
 
-}  // namespace faiss
+}  // namespace knowherefaiss
 
 #endif /* INSTRUCTION_SET_H */
diff --git a/tests/faiss/CMakeLists.txt b/tests/faiss/CMakeLists.txt
index e4e0c6c2..38c31bad 100644
--- a/tests/faiss/CMakeLists.txt
+++ b/tests/faiss/CMakeLists.txt
@@ -1,33 +1,33 @@
 set(FAISS_TEST_SRCS
-  ../../thirdparty/faiss/tests/test_omp_threads.cpp
-  ../../thirdparty/faiss/tests/test_heap.cpp
-  ../../thirdparty/faiss/tests/test_partitioning.cpp
-  ../../thirdparty/faiss/tests/test_simdlib.cpp
-  ../../thirdparty/faiss/tests/test_approx_topk.cpp
-  ../../thirdparty/faiss/tests/test_code_distance.cpp
-  ../../thirdparty/faiss/tests/test_cppcontrib_uintreader.cpp
-  ../../thirdparty/faiss/tests/test_distances_simd.cpp
-  ../../thirdparty/faiss/tests/test_hnsw.cpp
-  ../../thirdparty/faiss/tests/test_binary_flat.cpp
-  ../../thirdparty/faiss/tests/test_cppcontrib_sa_decode.cpp
-  ../../thirdparty/faiss/tests/test_ondisk_ivf.cpp
-  ../../thirdparty/faiss/tests/test_pq_encoding.cpp
-  ../../thirdparty/faiss/tests/test_RCQ_cropping.cpp
-  ../../thirdparty/faiss/tests/test_ivfpq_codec.cpp
-  ../../thirdparty/faiss/tests/test_ivfpq_indexing.cpp
-  ../../thirdparty/faiss/tests/test_merge.cpp
-  ../../thirdparty/faiss/tests/test_threaded_index.cpp
-  ../../thirdparty/faiss/tests/test_pairs_decoding.cpp
-  ../../thirdparty/faiss/tests/test_dealloc_invlists.cpp
-  ../../thirdparty/faiss/tests/test_params_override.cpp
-  ../../thirdparty/faiss/tests/test_sliding_ivf.cpp
-  ../../thirdparty/faiss/tests/test_transfer_invlists.cpp
-  ../../thirdparty/faiss/tests/test_distances_if.cpp
-  ../../thirdparty/faiss/tests/test_fastscan_perf.cpp
-  ../../thirdparty/faiss/tests/test_ivf_index.cpp
-  ../../thirdparty/faiss/tests/test_disable_pq_sdc_tables.cpp
-  ../../thirdparty/faiss/tests/test_common_ivf_empty_index.cpp
-  ../../thirdparty/faiss/tests/test_callback.cpp
+  ../../thirdparty/knowherefaiss/tests/test_omp_threads.cpp
+  ../../thirdparty/knowherefaiss/tests/test_heap.cpp
+  ../../thirdparty/knowherefaiss/tests/test_partitioning.cpp
+  ../../thirdparty/knowherefaiss/tests/test_simdlib.cpp
+  ../../thirdparty/knowherefaiss/tests/test_approx_topk.cpp
+  ../../thirdparty/knowherefaiss/tests/test_code_distance.cpp
+  ../../thirdparty/knowherefaiss/tests/test_cppcontrib_uintreader.cpp
+  ../../thirdparty/knowherefaiss/tests/test_distances_simd.cpp
+  ../../thirdparty/knowherefaiss/tests/test_hnsw.cpp
+  ../../thirdparty/knowherefaiss/tests/test_binary_flat.cpp
+  ../../thirdparty/knowherefaiss/tests/test_cppcontrib_sa_decode.cpp
+  ../../thirdparty/knowherefaiss/tests/test_ondisk_ivf.cpp
+  ../../thirdparty/knowherefaiss/tests/test_pq_encoding.cpp
+  ../../thirdparty/knowherefaiss/tests/test_RCQ_cropping.cpp
+  ../../thirdparty/knowherefaiss/tests/test_ivfpq_codec.cpp
+  ../../thirdparty/knowherefaiss/tests/test_ivfpq_indexing.cpp
+  ../../thirdparty/knowherefaiss/tests/test_merge.cpp
+  ../../thirdparty/knowherefaiss/tests/test_threaded_index.cpp
+  ../../thirdparty/knowherefaiss/tests/test_pairs_decoding.cpp
+  ../../thirdparty/knowherefaiss/tests/test_dealloc_invlists.cpp
+  ../../thirdparty/knowherefaiss/tests/test_params_override.cpp
+  ../../thirdparty/knowherefaiss/tests/test_sliding_ivf.cpp
+  ../../thirdparty/knowherefaiss/tests/test_transfer_invlists.cpp
+  ../../thirdparty/knowherefaiss/tests/test_distances_if.cpp
+  ../../thirdparty/knowherefaiss/tests/test_fastscan_perf.cpp
+  ../../thirdparty/knowherefaiss/tests/test_ivf_index.cpp
+  ../../thirdparty/knowherefaiss/tests/test_disable_pq_sdc_tables.cpp
+  ../../thirdparty/knowherefaiss/tests/test_common_ivf_empty_index.cpp
+  ../../thirdparty/knowherefaiss/tests/test_callback.cpp
   )
 
 find_package(GTest REQUIRED)
@@ -35,7 +35,7 @@ find_package(GTest REQUIRED)
 if(__X86_64)
   add_executable(faiss_tests ${FAISS_TEST_SRCS})
 
-  add_dependencies(faiss_tests faiss)
+  add_dependencies(faiss_tests knowherefaiss)
   target_compile_options(
     faiss_tests
     PRIVATE $<$<COMPILE_LANGUAGE:CXX>:
@@ -50,7 +50,7 @@ if(__X86_64)
             -Wno-unused-function
             -Wno-strict-aliasing>)
   target_link_libraries(
-    faiss_tests PUBLIC faiss knowhere GTest::gtest GTest::gtest_main)
+    faiss_tests PUBLIC knowherefaiss knowhere GTest::gtest GTest::gtest_main)
   target_compile_definitions(faiss_tests PRIVATE FINTEGER=int)
 endif()
 
@@ -66,7 +66,7 @@ if(__AARCH64)
             -Wno-unused-function
             -Wno-strict-aliasing>)
 
-  add_dependencies(faiss_tests faiss)
-  target_link_libraries(faiss_tests PUBLIC faiss knowhere GTest::gtest GTest::gtest_main)
+  add_dependencies(faiss_tests knowherefaiss)
+  target_link_libraries(faiss_tests PUBLIC knowherefaiss knowhere GTest::gtest GTest::gtest_main)
   target_compile_definitions(faiss_tests PRIVATE FINTEGER=int)
 endif()
diff --git a/tests/ut/test_bruteforce.cc b/tests/ut/test_bruteforce.cc
index 8ff8059d..d5bde46c 100644
--- a/tests/ut/test_bruteforce.cc
+++ b/tests/ut/test_bruteforce.cc
@@ -12,7 +12,7 @@
 #include "catch2/catch_approx.hpp"
 #include "catch2/catch_test_macros.hpp"
 #include "catch2/generators/catch_generators.hpp"
-#include "faiss/utils/Heap.h"
+#include "knowherefaiss/utils/Heap.h"
 #include "knowhere/comp/brute_force.h"
 #include "knowhere/comp/index_param.h"
 #include "knowhere/utils.h"
@@ -105,7 +105,7 @@ check_search_with_out_ids(const uint64_t nb, const uint64_t nq, const uint64_t d
     std::vector<float> dis(nq * k, std::numeric_limits<float>::quiet_NaN());
     std::vector<int64_t> ids(nq * k, -1);
     if (metric == knowhere::metric::L2) {
-        faiss::float_maxheap_array_t heaps{nq, (size_t)k, ids.data(), dis.data()};
+        knowherefaiss::float_maxheap_array_t heaps{nq, (size_t)k, ids.data(), dis.data()};
         heaps.heapify();
         for (size_t i = 0; i < block_prefix.size() - 1; i++) {
             auto begin_id = block_prefix[i];
@@ -120,7 +120,7 @@ check_search_with_out_ids(const uint64_t nb, const uint64_t nq, const uint64_t d
         }
         heaps.reorder();
     } else {
-        faiss::float_minheap_array_t heaps{nq, (size_t)k, ids.data(), dis.data()};
+        knowherefaiss::float_minheap_array_t heaps{nq, (size_t)k, ids.data(), dis.data()};
         heaps.heapify();
         for (size_t i = 0; i < block_prefix.size() - 1; i++) {
             auto begin_id = block_prefix[i];
diff --git a/tests/ut/test_cluster.cc b/tests/ut/test_cluster.cc
index bcb84e04..bd44e61d 100644
--- a/tests/ut/test_cluster.cc
+++ b/tests/ut/test_cluster.cc
@@ -14,7 +14,7 @@
 #include "catch2/catch_approx.hpp"
 #include "catch2/catch_test_macros.hpp"
 #include "catch2/generators/catch_generators.hpp"
-#include "faiss/utils/binary_distances.h"
+#include "knowherefaiss/utils/binary_distances.h"
 #include "hnswlib/hnswalg.h"
 #include "knowhere/bitsetview.h"
 #include "knowhere/cluster/cluster_factory.h"
diff --git a/tests/ut/test_data_view_index.cc b/tests/ut/test_data_view_index.cc
index 2899b916..6324cc6b 100644
--- a/tests/ut/test_data_view_index.cc
+++ b/tests/ut/test_data_view_index.cc
@@ -32,7 +32,7 @@ constexpr int kCosineMaxMissNum = 5;
 TEST_CASE("Test SCANN with data view refiner", "[float metrics]") {
     using Catch::Approx;
     auto version = GenTestVersionList();
-    if (!faiss::support_pq_fast_scan) {
+    if (!knowherefaiss::support_pq_fast_scan) {
         SKIP("pass scann test");
     }
 
@@ -185,7 +185,7 @@ TEST_CASE("Test SCANN with data view refiner", "[float metrics]") {
 TEST_CASE("Ensure topk test", "[float metrics]") {
     using Catch::Approx;
     auto version = GenTestVersionList();
-    if (!faiss::support_pq_fast_scan) {
+    if (!knowherefaiss::support_pq_fast_scan) {
         SKIP("pass scann test");
     }
 
@@ -303,7 +303,7 @@ BaseTest(const knowhere::DataSetPtr train_ds, const knowhere::DataSetPtr query_d
 }
 
 TEST_CASE("Test difference dim with difference data type", "[multi metrics]") {
-    if (!faiss::support_pq_fast_scan) {
+    if (!knowherefaiss::support_pq_fast_scan) {
         SKIP("pass scann test");
     }
     const int64_t nb = 1000, nq = 10;
@@ -340,7 +340,7 @@ TEST_CASE("Test difference dim with difference data type", "[multi metrics]") {
 }
 
 TEST_CASE("Test fp16/bf16 with quant refine", "[multi metrics]") {
-    if (!faiss::support_pq_fast_scan) {
+    if (!knowherefaiss::support_pq_fast_scan) {
         SKIP("pass scann test");
     }
     const int64_t nb = 1000, nq = 1;
diff --git a/tests/ut/test_distances.cc b/tests/ut/test_distances.cc
index 971a9f23..19921914 100644
--- a/tests/ut/test_distances.cc
+++ b/tests/ut/test_distances.cc
@@ -21,16 +21,16 @@ TEST_CASE("Test Distance Compute", "[distance]") {
     std::uniform_int_distribution<> distrib(1, 100000);
     std::uniform_real_distribution<float> fill_distrib(1, 1000000);
     std::string ins;
-    faiss::fvec_hook(ins);
+    knowherefaiss::fvec_hook(ins);
 
     using std::make_tuple;
     SECTION("Test Binary Distance Compute") {
         typedef float (*FUNC)(const float*, const float*, size_t);
         auto [real_func, gold_func] = GENERATE(table<FUNC, FUNC>({
-            make_tuple(faiss::fvec_L1, faiss::fvec_L1_ref),
-            make_tuple(faiss::fvec_L2sqr, faiss::fvec_L2sqr_ref),
-            make_tuple(faiss::fvec_Linf, faiss::fvec_Linf_ref),
-            make_tuple(faiss::fvec_inner_product, faiss::fvec_inner_product_ref),
+            make_tuple(knowherefaiss::fvec_L1, knowherefaiss::fvec_L1_ref),
+            make_tuple(knowherefaiss::fvec_L2sqr, knowherefaiss::fvec_L2sqr_ref),
+            make_tuple(knowherefaiss::fvec_Linf, knowherefaiss::fvec_Linf_ref),
+            make_tuple(knowherefaiss::fvec_inner_product, knowherefaiss::fvec_inner_product_ref),
         }));
 
         for (int i = 0; i < 1000; ++i) {
@@ -50,7 +50,7 @@ TEST_CASE("Test Distance Compute", "[distance]") {
     SECTION("Test Normal Compute") {
         typedef float (*FUNC)(const float*, size_t);
         auto [real_func, gold_func] = GENERATE(table<FUNC, FUNC>({
-            make_tuple(faiss::fvec_norm_L2sqr, faiss::fvec_norm_L2sqr_ref),
+            make_tuple(knowherefaiss::fvec_norm_L2sqr, knowherefaiss::fvec_norm_L2sqr_ref),
         }));
 
         for (int i = 0; i < 1000; ++i) {
@@ -67,7 +67,7 @@ TEST_CASE("Test Distance Compute", "[distance]") {
     SECTION("Test Madd and Argmin") {
         typedef int (*FUNC)(size_t, const float*, float, const float*, float*);
         auto [real_func, gold_func] = GENERATE(table<FUNC, FUNC>({
-            make_tuple(faiss::fvec_madd_and_argmin, faiss::fvec_madd_and_argmin_ref),
+            make_tuple(knowherefaiss::fvec_madd_and_argmin, knowherefaiss::fvec_madd_and_argmin_ref),
         }));
 
         for (int i = 0; i < 1000; ++i) {
@@ -95,7 +95,7 @@ TEST_CASE("Test Distance Compute", "[distance]") {
     SECTION("Test Madd") {
         typedef void (*FUNC)(size_t, const float*, float, const float*, float*);
         auto [real_func, gold_func] = GENERATE(table<FUNC, FUNC>({
-            make_tuple(faiss::fvec_madd, faiss::fvec_madd_ref),
+            make_tuple(knowherefaiss::fvec_madd, knowherefaiss::fvec_madd_ref),
         }));
 
         for (int i = 0; i < 1000; ++i) {
diff --git a/tests/ut/test_get_vector.cc b/tests/ut/test_get_vector.cc
index f01e8d63..f0aa5c20 100644
--- a/tests/ut/test_get_vector.cc
+++ b/tests/ut/test_get_vector.cc
@@ -196,7 +196,7 @@ TEST_CASE("Test Float Get Vector By Ids", "[Float GetVectorByIds]") {
         auto idx_expected = knowhere::IndexFactory::Instance().Create<knowhere::fp32>(name, version);
         if (name == knowhere::IndexEnum::INDEX_FAISS_SCANN) {
             // need to check cpu model for scann
-            if (!faiss::support_pq_fast_scan) {
+            if (!knowherefaiss::support_pq_fast_scan) {
                 REQUIRE(idx_expected.error() == knowhere::Status::invalid_index_error);
                 return;
             }
diff --git a/tests/ut/test_index_node.cc b/tests/ut/test_index_node.cc
index 7ba04d0e..019c256b 100644
--- a/tests/ut/test_index_node.cc
+++ b/tests/ut/test_index_node.cc
@@ -14,7 +14,7 @@
 #include "catch2/catch_approx.hpp"
 #include "catch2/catch_test_macros.hpp"
 #include "catch2/generators/catch_generators.hpp"
-#include "faiss/IndexFlat.h"
+#include "knowherefaiss/IndexFlat.h"
 #include "knowhere/comp/index_param.h"
 #include "knowhere/index/index_factory.h"
 #include "knowhere/index/index_node_data_mock_wrapper.h"
diff --git a/tests/ut/test_iterator.cc b/tests/ut/test_iterator.cc
index d53a31c2..e8e7a723 100644
--- a/tests/ut/test_iterator.cc
+++ b/tests/ut/test_iterator.cc
@@ -14,7 +14,7 @@
 #include "catch2/catch_approx.hpp"
 #include "catch2/catch_test_macros.hpp"
 #include "catch2/generators/catch_generators.hpp"
-#include "faiss/utils/binary_distances.h"
+#include "knowherefaiss/utils/binary_distances.h"
 #include "hnswlib/hnswalg.h"
 #include "knowhere/bitsetview.h"
 #include "knowhere/comp/brute_force.h"
@@ -637,7 +637,7 @@ TEST_CASE("Test Iterator BruteForce With Sparse Float Vector", "[IP metric]") {
 
 TEST_CASE("Test Scann with data view refiner", "[float metrics]") {
     using Catch::Approx;
-    if (!faiss::support_pq_fast_scan) {
+    if (!knowherefaiss::support_pq_fast_scan) {
         SKIP("pass scann test");
     }
     auto version = GenTestVersionList();
diff --git a/tests/ut/test_ivfflat_cc.cc b/tests/ut/test_ivfflat_cc.cc
index 90796187..1be6089b 100644
--- a/tests/ut/test_ivfflat_cc.cc
+++ b/tests/ut/test_ivfflat_cc.cc
@@ -15,7 +15,7 @@
 #include "catch2/catch_approx.hpp"
 #include "catch2/catch_test_macros.hpp"
 #include "catch2/generators/catch_generators.hpp"
-#include "faiss/invlists/InvertedLists.h"
+#include "knowherefaiss/invlists/InvertedLists.h"
 #include "knowhere/comp/index_param.h"
 #include "knowhere/comp/knowhere_check.h"
 #include "knowhere/index/index_factory.h"
@@ -72,7 +72,7 @@ TEST_CASE("Test Build Search Concurrency", "[Concurrency]") {
         size_t code_size = 512;
         size_t segment_size = 1024;
 
-        auto invList = std::make_unique<faiss::ConcurrentArrayInvertedLists>(nlist, code_size, segment_size, true);
+        auto invList = std::make_unique<knowherefaiss::ConcurrentArrayInvertedLists>(nlist, code_size, segment_size, true);
 
         for (size_t i = 0; i < nlist; i++) {
             REQUIRE(invList->list_size(i) == 0);
@@ -87,7 +87,7 @@ TEST_CASE("Test Build Search Concurrency", "[Concurrency]") {
                 for (size_t i = 0; i < nlist; i++) {
                     std::mt19937_64 rng(i);
                     int64_t add_size = distribution(rng);
-                    std::vector<faiss::idx_t> ids(add_size, i);
+                    std::vector<knowherefaiss::idx_t> ids(add_size, i);
                     float value = i;
                     std::vector<float> codes(add_size * dim, value);
                     std::vector<float> code_normals = knowhere::NormalizeVecs(codes.data(), add_size, dim);
@@ -104,7 +104,7 @@ TEST_CASE("Test Build Search Concurrency", "[Concurrency]") {
                 for (size_t i = 0; i < nlist; i++) {
                     std::mt19937_64 rng(i * i);
                     int64_t add_size = distribution(rng);
-                    std::vector<faiss::idx_t> ids(add_size, i);
+                    std::vector<knowherefaiss::idx_t> ids(add_size, i);
                     float value = i;
                     std::vector<float> codes(add_size * dim, value);
                     std::vector<float> code_normals = knowhere::NormalizeVecs(codes.data(), add_size, dim);
diff --git a/tests/ut/test_range_util.cc b/tests/ut/test_range_util.cc
index ecb0fe87..360f75c0 100644
--- a/tests/ut/test_range_util.cc
+++ b/tests/ut/test_range_util.cc
@@ -10,7 +10,7 @@
 // or implied. See the License for the specific language governing permissions and limitations under the License.
 
 #include "catch2/catch_test_macros.hpp"
-#include "faiss/impl/AuxIndexStructures.h"
+#include "knowherefaiss/impl/AuxIndexStructures.h"
 #include "knowhere/index/index_factory.h"
 #include "knowhere/range_util.h"
 #include "utils.h"
@@ -116,7 +116,7 @@ TEST_CASE("Test GetRangeSearchResult for HNSW/DiskANN", "[range search]") {
 #if 0
 namespace {
 void
-GenRangeSearchResult(faiss::RangeSearchResult& res, const int64_t nq, const int64_t label_min, const int64_t label_max,
+GenRangeSearchResult(knowherefaiss::RangeSearchResult& res, const int64_t nq, const int64_t label_min, const int64_t label_max,
                      const float distance_min, const float distances_max, int seed = 42) {
     std::mt19937 e(seed);
     std::uniform_int_distribution<> uniform_num(0, 10);
diff --git a/tests/ut/test_search.cc b/tests/ut/test_search.cc
index 67ed2d35..a1f118a3 100644
--- a/tests/ut/test_search.cc
+++ b/tests/ut/test_search.cc
@@ -12,7 +12,7 @@
 #include "catch2/catch_approx.hpp"
 #include "catch2/catch_test_macros.hpp"
 #include "catch2/generators/catch_generators.hpp"
-#include "faiss/utils/binary_distances.h"
+#include "knowherefaiss/utils/binary_distances.h"
 #include "hnswlib/hnswalg.h"
 #include "knowhere/bitsetview.h"
 #include "knowhere/comp/brute_force.h"
@@ -188,7 +188,7 @@ TEST_CASE("Test Mem Index With Float Vector", "[float metrics]") {
             auto idx_expected = knowhere::IndexFactory::Instance().Create<knowhere::fp32>(name, version);
             if (name == knowhere::IndexEnum::INDEX_FAISS_SCANN) {
                 // need to check cpu model for scann
-                if (!faiss::support_pq_fast_scan) {
+                if (!knowherefaiss::support_pq_fast_scan) {
                     REQUIRE(idx_expected.error() == knowhere::Status::invalid_index_error);
                     return;
                 }
@@ -278,7 +278,7 @@ TEST_CASE("Test Mem Index With Float Vector", "[float metrics]") {
         auto idx_expected = knowhere::IndexFactory::Instance().Create<knowhere::fp32>(name, version);
         if (name == knowhere::IndexEnum::INDEX_FAISS_SCANN) {
             // need to check cpu model for scann
-            if (!faiss::support_pq_fast_scan) {
+            if (!knowherefaiss::support_pq_fast_scan) {
                 REQUIRE(idx_expected.error() == knowhere::Status::invalid_index_error);
                 return;
             }
@@ -493,7 +493,7 @@ TEST_CASE("Test Mem Index With Float Vector", "[float metrics]") {
         auto idx_expected = knowhere::IndexFactory::Instance().Create<knowhere::fp32>(name, version);
         if (name == knowhere::IndexEnum::INDEX_FAISS_SCANN) {
             // need to check cpu model for scann
-            if (!faiss::support_pq_fast_scan) {
+            if (!knowherefaiss::support_pq_fast_scan) {
                 REQUIRE(idx_expected.error() == knowhere::Status::invalid_index_error);
                 return;
             }
@@ -802,9 +802,9 @@ TEST_CASE("Test Mem Index With Binary Vector", "[bool metrics]") {
             for (int64_t j = 0; j < real_topk; j++) {
                 const uint8_t* res_vector = (const uint8_t*)gv_res.value()->GetTensor() + j * code_size;
                 if (metric == knowhere::metric::SUPERSTRUCTURE) {
-                    REQUIRE(faiss::is_subset(res_vector, query_vector, code_size));
+                    REQUIRE(knowherefaiss::is_subset(res_vector, query_vector, code_size));
                 } else {
-                    REQUIRE(faiss::is_subset(query_vector, res_vector, code_size));
+                    REQUIRE(knowherefaiss::is_subset(query_vector, res_vector, code_size));
                 }
             }
         }
diff --git a/tests/ut/test_simd.cc b/tests/ut/test_simd.cc
index 74e9edd4..170055e4 100644
--- a/tests/ut/test_simd.cc
+++ b/tests/ut/test_simd.cc
@@ -55,153 +55,153 @@ TEST_CASE("Test minhash function") {
         auto x = GenRandomVector<uint64_t>(size, 1, seed, 100000);
         std::sort(x.get(), x.get() + size);
         auto key = x[1000 % size];
-        CHECK_EQ(faiss::u64_binary_search_eq(x.get(), size, key), faiss::u64_binary_search_eq_ref(x.get(), size, key));
-        CHECK_EQ(faiss::u64_binary_search_ge(x.get(), size, key), faiss::u64_binary_search_ge_ref(x.get(), size, key));
+        CHECK_EQ(knowherefaiss::u64_binary_search_eq(x.get(), size, key), knowherefaiss::u64_binary_search_eq_ref(x.get(), size, key));
+        CHECK_EQ(knowherefaiss::u64_binary_search_ge(x.get(), size, key), knowherefaiss::u64_binary_search_ge_ref(x.get(), size, key));
 
         uint64_t first_key = x[0];
-        CHECK_EQ(faiss::u64_binary_search_eq(x.get(), size, first_key),
-                 faiss::u64_binary_search_eq_ref(x.get(), size, first_key));
-        CHECK_EQ(faiss::u64_binary_search_ge(x.get(), size, first_key),
-                 faiss::u64_binary_search_ge_ref(x.get(), size, first_key));
+        CHECK_EQ(knowherefaiss::u64_binary_search_eq(x.get(), size, first_key),
+                 knowherefaiss::u64_binary_search_eq_ref(x.get(), size, first_key));
+        CHECK_EQ(knowherefaiss::u64_binary_search_ge(x.get(), size, first_key),
+                 knowherefaiss::u64_binary_search_ge_ref(x.get(), size, first_key));
 
         uint64_t last_key = x[size - 1];
-        CHECK_EQ(faiss::u64_binary_search_eq(x.get(), size, last_key),
-                 faiss::u64_binary_search_eq_ref(x.get(), size, last_key));
-        CHECK_EQ(faiss::u64_binary_search_ge(x.get(), size, last_key),
-                 faiss::u64_binary_search_ge_ref(x.get(), size, last_key));
+        CHECK_EQ(knowherefaiss::u64_binary_search_eq(x.get(), size, last_key),
+                 knowherefaiss::u64_binary_search_eq_ref(x.get(), size, last_key));
+        CHECK_EQ(knowherefaiss::u64_binary_search_ge(x.get(), size, last_key),
+                 knowherefaiss::u64_binary_search_ge_ref(x.get(), size, last_key));
 
         uint64_t mid_key = x[size / 2];
-        CHECK_EQ(faiss::u64_binary_search_eq(x.get(), size, mid_key),
-                 faiss::u64_binary_search_eq_ref(x.get(), size, mid_key));
-        CHECK_EQ(faiss::u64_binary_search_ge(x.get(), size, mid_key),
-                 faiss::u64_binary_search_ge_ref(x.get(), size, mid_key));
+        CHECK_EQ(knowherefaiss::u64_binary_search_eq(x.get(), size, mid_key),
+                 knowherefaiss::u64_binary_search_eq_ref(x.get(), size, mid_key));
+        CHECK_EQ(knowherefaiss::u64_binary_search_ge(x.get(), size, mid_key),
+                 knowherefaiss::u64_binary_search_ge_ref(x.get(), size, mid_key));
 
         if (x[0] > 0) {
             uint64_t smaller_key = x[0] - 1;
-            CHECK_EQ(faiss::u64_binary_search_eq(x.get(), size, smaller_key),
-                     faiss::u64_binary_search_eq_ref(x.get(), size, smaller_key));
-            CHECK_EQ(faiss::u64_binary_search_ge(x.get(), size, smaller_key),
-                     faiss::u64_binary_search_ge_ref(x.get(), size, smaller_key));
+            CHECK_EQ(knowherefaiss::u64_binary_search_eq(x.get(), size, smaller_key),
+                     knowherefaiss::u64_binary_search_eq_ref(x.get(), size, smaller_key));
+            CHECK_EQ(knowherefaiss::u64_binary_search_ge(x.get(), size, smaller_key),
+                     knowherefaiss::u64_binary_search_ge_ref(x.get(), size, smaller_key));
         }
 
         uint64_t larger_key = x[size - 1] + 1;
-        CHECK_EQ(faiss::u64_binary_search_eq(x.get(), size, larger_key),
-                 faiss::u64_binary_search_eq_ref(x.get(), size, larger_key));
-        CHECK_EQ(faiss::u64_binary_search_ge(x.get(), size, larger_key),
-                 faiss::u64_binary_search_ge_ref(x.get(), size, larger_key));
+        CHECK_EQ(knowherefaiss::u64_binary_search_eq(x.get(), size, larger_key),
+                 knowherefaiss::u64_binary_search_eq_ref(x.get(), size, larger_key));
+        CHECK_EQ(knowherefaiss::u64_binary_search_ge(x.get(), size, larger_key),
+                 knowherefaiss::u64_binary_search_ge_ref(x.get(), size, larger_key));
 
         if (size > 1) {
             for (size_t i = 0; i < size - 1; ++i) {
                 if (x[i + 1] > x[i] + 1) {
                     uint64_t gap_key = x[i] + 1;
-                    CHECK_EQ(faiss::u64_binary_search_eq(x.get(), size, gap_key),
-                             faiss::u64_binary_search_eq_ref(x.get(), size, gap_key));
-                    CHECK_EQ(faiss::u64_binary_search_ge(x.get(), size, gap_key),
-                             faiss::u64_binary_search_ge_ref(x.get(), size, gap_key));
+                    CHECK_EQ(knowherefaiss::u64_binary_search_eq(x.get(), size, gap_key),
+                             knowherefaiss::u64_binary_search_eq_ref(x.get(), size, gap_key));
+                    CHECK_EQ(knowherefaiss::u64_binary_search_ge(x.get(), size, gap_key),
+                             knowherefaiss::u64_binary_search_ge_ref(x.get(), size, gap_key));
                     break;
                 }
             }
         }
         if (size >= 8) {
             uint64_t simd_boundary_key = x[7];
-            CHECK_EQ(faiss::u64_binary_search_eq(x.get(), size, simd_boundary_key),
-                     faiss::u64_binary_search_eq_ref(x.get(), size, simd_boundary_key));
-            CHECK_EQ(faiss::u64_binary_search_ge(x.get(), size, simd_boundary_key),
-                     faiss::u64_binary_search_ge_ref(x.get(), size, simd_boundary_key));
+            CHECK_EQ(knowherefaiss::u64_binary_search_eq(x.get(), size, simd_boundary_key),
+                     knowherefaiss::u64_binary_search_eq_ref(x.get(), size, simd_boundary_key));
+            CHECK_EQ(knowherefaiss::u64_binary_search_ge(x.get(), size, simd_boundary_key),
+                     knowherefaiss::u64_binary_search_ge_ref(x.get(), size, simd_boundary_key));
         }
 
         if (size >= 16) {
             uint64_t double_simd_key = x[15];
-            CHECK_EQ(faiss::u64_binary_search_eq(x.get(), size, double_simd_key),
-                     faiss::u64_binary_search_eq_ref(x.get(), size, double_simd_key));
-            CHECK_EQ(faiss::u64_binary_search_ge(x.get(), size, double_simd_key),
-                     faiss::u64_binary_search_ge_ref(x.get(), size, double_simd_key));
+            CHECK_EQ(knowherefaiss::u64_binary_search_eq(x.get(), size, double_simd_key),
+                     knowherefaiss::u64_binary_search_eq_ref(x.get(), size, double_simd_key));
+            CHECK_EQ(knowherefaiss::u64_binary_search_ge(x.get(), size, double_simd_key),
+                     knowherefaiss::u64_binary_search_ge_ref(x.get(), size, double_simd_key));
         }
 
         uint64_t zero_key = 0;
-        CHECK_EQ(faiss::u64_binary_search_eq(x.get(), size, zero_key),
-                 faiss::u64_binary_search_eq_ref(x.get(), size, zero_key));
-        CHECK_EQ(faiss::u64_binary_search_ge(x.get(), size, zero_key),
-                 faiss::u64_binary_search_ge_ref(x.get(), size, zero_key));
+        CHECK_EQ(knowherefaiss::u64_binary_search_eq(x.get(), size, zero_key),
+                 knowherefaiss::u64_binary_search_eq_ref(x.get(), size, zero_key));
+        CHECK_EQ(knowherefaiss::u64_binary_search_ge(x.get(), size, zero_key),
+                 knowherefaiss::u64_binary_search_ge_ref(x.get(), size, zero_key));
 
         uint64_t max_key = UINT64_MAX;
-        CHECK_EQ(faiss::u64_binary_search_eq(x.get(), size, max_key),
-                 faiss::u64_binary_search_eq_ref(x.get(), size, max_key));
-        CHECK_EQ(faiss::u64_binary_search_ge(x.get(), size, max_key),
-                 faiss::u64_binary_search_ge_ref(x.get(), size, max_key));
+        CHECK_EQ(knowherefaiss::u64_binary_search_eq(x.get(), size, max_key),
+                 knowherefaiss::u64_binary_search_eq_ref(x.get(), size, max_key));
+        CHECK_EQ(knowherefaiss::u64_binary_search_ge(x.get(), size, max_key),
+                 knowherefaiss::u64_binary_search_ge_ref(x.get(), size, max_key));
     }
 
     SECTION("test binary search edge cases") {
         uint64_t* empty_arr = nullptr;
-        CHECK_EQ(faiss::u64_binary_search_eq(empty_arr, 0, 42), faiss::u64_binary_search_eq_ref(empty_arr, 0, 42));
-        CHECK_EQ(faiss::u64_binary_search_ge(empty_arr, 0, 42), faiss::u64_binary_search_ge_ref(empty_arr, 0, 42));
+        CHECK_EQ(knowherefaiss::u64_binary_search_eq(empty_arr, 0, 42), knowherefaiss::u64_binary_search_eq_ref(empty_arr, 0, 42));
+        CHECK_EQ(knowherefaiss::u64_binary_search_ge(empty_arr, 0, 42), knowherefaiss::u64_binary_search_ge_ref(empty_arr, 0, 42));
 
         uint64_t single_arr[] = {100};
-        CHECK_EQ(faiss::u64_binary_search_eq(single_arr, 1, 100), faiss::u64_binary_search_eq_ref(single_arr, 1, 100));
-        CHECK_EQ(faiss::u64_binary_search_eq(single_arr, 1, 99), faiss::u64_binary_search_eq_ref(single_arr, 1, 99));
-        CHECK_EQ(faiss::u64_binary_search_eq(single_arr, 1, 101), faiss::u64_binary_search_eq_ref(single_arr, 1, 101));
+        CHECK_EQ(knowherefaiss::u64_binary_search_eq(single_arr, 1, 100), knowherefaiss::u64_binary_search_eq_ref(single_arr, 1, 100));
+        CHECK_EQ(knowherefaiss::u64_binary_search_eq(single_arr, 1, 99), knowherefaiss::u64_binary_search_eq_ref(single_arr, 1, 99));
+        CHECK_EQ(knowherefaiss::u64_binary_search_eq(single_arr, 1, 101), knowherefaiss::u64_binary_search_eq_ref(single_arr, 1, 101));
 
-        CHECK_EQ(faiss::u64_binary_search_ge(single_arr, 1, 100), faiss::u64_binary_search_ge_ref(single_arr, 1, 100));
-        CHECK_EQ(faiss::u64_binary_search_ge(single_arr, 1, 99), faiss::u64_binary_search_ge_ref(single_arr, 1, 99));
-        CHECK_EQ(faiss::u64_binary_search_ge(single_arr, 1, 101), faiss::u64_binary_search_ge_ref(single_arr, 1, 101));
+        CHECK_EQ(knowherefaiss::u64_binary_search_ge(single_arr, 1, 100), knowherefaiss::u64_binary_search_ge_ref(single_arr, 1, 100));
+        CHECK_EQ(knowherefaiss::u64_binary_search_ge(single_arr, 1, 99), knowherefaiss::u64_binary_search_ge_ref(single_arr, 1, 99));
+        CHECK_EQ(knowherefaiss::u64_binary_search_ge(single_arr, 1, 101), knowherefaiss::u64_binary_search_ge_ref(single_arr, 1, 101));
 
         uint64_t identical_arr[] = {50, 50, 50, 50, 50, 50, 50, 50, 50, 50};
         size_t identical_size = sizeof(identical_arr) / sizeof(identical_arr[0]);
 
-        CHECK_EQ(faiss::u64_binary_search_eq(identical_arr, identical_size, 50),
-                 faiss::u64_binary_search_eq_ref(identical_arr, identical_size, 50));
-        CHECK_EQ(faiss::u64_binary_search_eq(identical_arr, identical_size, 49),
-                 faiss::u64_binary_search_eq_ref(identical_arr, identical_size, 49));
-        CHECK_EQ(faiss::u64_binary_search_eq(identical_arr, identical_size, 51),
-                 faiss::u64_binary_search_eq_ref(identical_arr, identical_size, 51));
+        CHECK_EQ(knowherefaiss::u64_binary_search_eq(identical_arr, identical_size, 50),
+                 knowherefaiss::u64_binary_search_eq_ref(identical_arr, identical_size, 50));
+        CHECK_EQ(knowherefaiss::u64_binary_search_eq(identical_arr, identical_size, 49),
+                 knowherefaiss::u64_binary_search_eq_ref(identical_arr, identical_size, 49));
+        CHECK_EQ(knowherefaiss::u64_binary_search_eq(identical_arr, identical_size, 51),
+                 knowherefaiss::u64_binary_search_eq_ref(identical_arr, identical_size, 51));
 
-        CHECK_EQ(faiss::u64_binary_search_ge(identical_arr, identical_size, 50),
-                 faiss::u64_binary_search_ge_ref(identical_arr, identical_size, 50));
-        CHECK_EQ(faiss::u64_binary_search_ge(identical_arr, identical_size, 49),
-                 faiss::u64_binary_search_ge_ref(identical_arr, identical_size, 49));
-        CHECK_EQ(faiss::u64_binary_search_ge(identical_arr, identical_size, 51),
-                 faiss::u64_binary_search_ge_ref(identical_arr, identical_size, 51));
+        CHECK_EQ(knowherefaiss::u64_binary_search_ge(identical_arr, identical_size, 50),
+                 knowherefaiss::u64_binary_search_ge_ref(identical_arr, identical_size, 50));
+        CHECK_EQ(knowherefaiss::u64_binary_search_ge(identical_arr, identical_size, 49),
+                 knowherefaiss::u64_binary_search_ge_ref(identical_arr, identical_size, 49));
+        CHECK_EQ(knowherefaiss::u64_binary_search_ge(identical_arr, identical_size, 51),
+                 knowherefaiss::u64_binary_search_ge_ref(identical_arr, identical_size, 51));
 
         uint64_t strict_inc[] = {1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25};
         size_t strict_size = sizeof(strict_inc) / sizeof(strict_inc[0]);
 
-        CHECK_EQ(faiss::u64_binary_search_eq(strict_inc, strict_size, 1),
-                 faiss::u64_binary_search_eq_ref(strict_inc, strict_size, 1));
-        CHECK_EQ(faiss::u64_binary_search_eq(strict_inc, strict_size, 25),
-                 faiss::u64_binary_search_eq_ref(strict_inc, strict_size, 25));
-        CHECK_EQ(faiss::u64_binary_search_eq(strict_inc, strict_size, 13),
-                 faiss::u64_binary_search_eq_ref(strict_inc, strict_size, 13));
+        CHECK_EQ(knowherefaiss::u64_binary_search_eq(strict_inc, strict_size, 1),
+                 knowherefaiss::u64_binary_search_eq_ref(strict_inc, strict_size, 1));
+        CHECK_EQ(knowherefaiss::u64_binary_search_eq(strict_inc, strict_size, 25),
+                 knowherefaiss::u64_binary_search_eq_ref(strict_inc, strict_size, 25));
+        CHECK_EQ(knowherefaiss::u64_binary_search_eq(strict_inc, strict_size, 13),
+                 knowherefaiss::u64_binary_search_eq_ref(strict_inc, strict_size, 13));
 
-        CHECK_EQ(faiss::u64_binary_search_eq(strict_inc, strict_size, 2),
-                 faiss::u64_binary_search_eq_ref(strict_inc, strict_size, 2));
-        CHECK_EQ(faiss::u64_binary_search_eq(strict_inc, strict_size, 14),
-                 faiss::u64_binary_search_eq_ref(strict_inc, strict_size, 14));
+        CHECK_EQ(knowherefaiss::u64_binary_search_eq(strict_inc, strict_size, 2),
+                 knowherefaiss::u64_binary_search_eq_ref(strict_inc, strict_size, 2));
+        CHECK_EQ(knowherefaiss::u64_binary_search_eq(strict_inc, strict_size, 14),
+                 knowherefaiss::u64_binary_search_eq_ref(strict_inc, strict_size, 14));
 
-        CHECK_EQ(faiss::u64_binary_search_ge(strict_inc, strict_size, 2),
-                 faiss::u64_binary_search_ge_ref(strict_inc, strict_size, 2));
-        CHECK_EQ(faiss::u64_binary_search_ge(strict_inc, strict_size, 14),
-                 faiss::u64_binary_search_ge_ref(strict_inc, strict_size, 14));
+        CHECK_EQ(knowherefaiss::u64_binary_search_ge(strict_inc, strict_size, 2),
+                 knowherefaiss::u64_binary_search_ge_ref(strict_inc, strict_size, 2));
+        CHECK_EQ(knowherefaiss::u64_binary_search_ge(strict_inc, strict_size, 14),
+                 knowherefaiss::u64_binary_search_ge_ref(strict_inc, strict_size, 14));
 
         uint64_t many_dups[] = {1, 1, 1, 5, 5, 5, 5, 5, 10, 10, 15, 15, 15};
         size_t dups_size = sizeof(many_dups) / sizeof(many_dups[0]);
 
-        CHECK_EQ(faiss::u64_binary_search_eq(many_dups, dups_size, 1),
-                 faiss::u64_binary_search_eq_ref(many_dups, dups_size, 1));
-        CHECK_EQ(faiss::u64_binary_search_eq(many_dups, dups_size, 5),
-                 faiss::u64_binary_search_eq_ref(many_dups, dups_size, 5));
-        CHECK_EQ(faiss::u64_binary_search_eq(many_dups, dups_size, 10),
-                 faiss::u64_binary_search_eq_ref(many_dups, dups_size, 10));
-        CHECK_EQ(faiss::u64_binary_search_eq(many_dups, dups_size, 15),
-                 faiss::u64_binary_search_eq_ref(many_dups, dups_size, 15));
-
-        CHECK_EQ(faiss::u64_binary_search_ge(many_dups, dups_size, 1),
-                 faiss::u64_binary_search_ge_ref(many_dups, dups_size, 1));
-        CHECK_EQ(faiss::u64_binary_search_ge(many_dups, dups_size, 5),
-                 faiss::u64_binary_search_ge_ref(many_dups, dups_size, 5));
-        CHECK_EQ(faiss::u64_binary_search_ge(many_dups, dups_size, 3),
-                 faiss::u64_binary_search_ge_ref(many_dups, dups_size, 3));
-        CHECK_EQ(faiss::u64_binary_search_ge(many_dups, dups_size, 12),
-                 faiss::u64_binary_search_ge_ref(many_dups, dups_size, 12));
+        CHECK_EQ(knowherefaiss::u64_binary_search_eq(many_dups, dups_size, 1),
+                 knowherefaiss::u64_binary_search_eq_ref(many_dups, dups_size, 1));
+        CHECK_EQ(knowherefaiss::u64_binary_search_eq(many_dups, dups_size, 5),
+                 knowherefaiss::u64_binary_search_eq_ref(many_dups, dups_size, 5));
+        CHECK_EQ(knowherefaiss::u64_binary_search_eq(many_dups, dups_size, 10),
+                 knowherefaiss::u64_binary_search_eq_ref(many_dups, dups_size, 10));
+        CHECK_EQ(knowherefaiss::u64_binary_search_eq(many_dups, dups_size, 15),
+                 knowherefaiss::u64_binary_search_eq_ref(many_dups, dups_size, 15));
+
+        CHECK_EQ(knowherefaiss::u64_binary_search_ge(many_dups, dups_size, 1),
+                 knowherefaiss::u64_binary_search_ge_ref(many_dups, dups_size, 1));
+        CHECK_EQ(knowherefaiss::u64_binary_search_ge(many_dups, dups_size, 5),
+                 knowherefaiss::u64_binary_search_ge_ref(many_dups, dups_size, 5));
+        CHECK_EQ(knowherefaiss::u64_binary_search_ge(many_dups, dups_size, 3),
+                 knowherefaiss::u64_binary_search_ge_ref(many_dups, dups_size, 3));
+        CHECK_EQ(knowherefaiss::u64_binary_search_ge(many_dups, dups_size, 12),
+                 knowherefaiss::u64_binary_search_ge_ref(many_dups, dups_size, 12));
     }
     SECTION("test minhash distance") {
         auto dim = GENERATE(as<size_t>{}, 1, 2, 4, 7, 8, 12, 14, 16, 21, 28, 32, 35, 42, 49, 56, 64, 128, 256);
@@ -210,26 +210,26 @@ TEST_CASE("Test minhash function") {
         auto u32_x = GenRandomVector<uint32_t>(dim, 4, seed);
         auto u32_y = GenRandomVector<uint32_t>(dim, 1, seed + 222);
         float res_dis[4], gt_ids[4];
-        CHECK_EQ(faiss::u64_jaccard_distance((const char*)u64_x.get(), (const char*)u64_x.get(), dim, 8), 1.0);
-        CHECK_EQ(faiss::u64_jaccard_distance((const char*)u64_x.get(), (const char*)u64_y.get(), dim, 8),
-                 faiss::u64_jaccard_distance_ref((const char*)u64_x.get(), (const char*)u64_y.get(), dim, 8));
-        CHECK_EQ(faiss::u32_jaccard_distance((const char*)u32_x.get(), (const char*)u32_x.get(), dim, 4), 1.0);
-        CHECK_EQ(faiss::u32_jaccard_distance((const char*)u32_x.get(), (const char*)u32_y.get(), dim, 4),
-                 faiss::u32_jaccard_distance_ref((const char*)u32_x.get(), (const char*)u32_y.get(), dim, 4));
-        faiss::u32_jaccard_distance_batch_4(
+        CHECK_EQ(knowherefaiss::u64_jaccard_distance((const char*)u64_x.get(), (const char*)u64_x.get(), dim, 8), 1.0);
+        CHECK_EQ(knowherefaiss::u64_jaccard_distance((const char*)u64_x.get(), (const char*)u64_y.get(), dim, 8),
+                 knowherefaiss::u64_jaccard_distance_ref((const char*)u64_x.get(), (const char*)u64_y.get(), dim, 8));
+        CHECK_EQ(knowherefaiss::u32_jaccard_distance((const char*)u32_x.get(), (const char*)u32_x.get(), dim, 4), 1.0);
+        CHECK_EQ(knowherefaiss::u32_jaccard_distance((const char*)u32_x.get(), (const char*)u32_y.get(), dim, 4),
+                 knowherefaiss::u32_jaccard_distance_ref((const char*)u32_x.get(), (const char*)u32_y.get(), dim, 4));
+        knowherefaiss::u32_jaccard_distance_batch_4(
             (const char*)(&u32_y[0]), (const char*)(&u32_x[0]), (const char*)(&u32_x[1]), (const char*)(&u32_x[2]),
             (const char*)(&u32_x[3]), dim, 4, res_dis[0], res_dis[1], res_dis[2], res_dis[3]);
-        faiss::u32_jaccard_distance_batch_4_ref(
+        knowherefaiss::u32_jaccard_distance_batch_4_ref(
             (const char*)(&u32_y[0]), (const char*)(&u32_x[0]), (const char*)(&u32_x[1]), (const char*)(&u32_x[2]),
             (const char*)(&u32_x[3]), dim, 4, gt_ids[0], gt_ids[1], gt_ids[2], gt_ids[3]);
         CHECK_EQ(res_dis[0], gt_ids[0]);
         CHECK_EQ(res_dis[1], gt_ids[1]);
         CHECK_EQ(res_dis[2], gt_ids[2]);
         CHECK_EQ(res_dis[3], gt_ids[3]);
-        faiss::u64_jaccard_distance_batch_4(
+        knowherefaiss::u64_jaccard_distance_batch_4(
             (const char*)(&u64_y[0]), (const char*)(&u64_x[0]), (const char*)(&u64_x[1]), (const char*)(&u64_x[2]),
             (const char*)(&u64_x[3]), dim, 8, res_dis[0], res_dis[1], res_dis[2], res_dis[3]);
-        faiss::u64_jaccard_distance_batch_4_ref(
+        knowherefaiss::u64_jaccard_distance_batch_4_ref(
             (const char*)(&u64_y[0]), (const char*)(&u64_x[0]), (const char*)(&u64_x[1]), (const char*)(&u64_x[2]),
             (const char*)(&u64_x[3]), dim, 8, gt_ids[0], gt_ids[1], gt_ids[2], gt_ids[3]);
         CHECK_EQ(res_dis[0], gt_ids[0]);
@@ -280,34 +280,34 @@ TEST_CASE("Test distance") {
         for (size_t i = 0; i < ny; i++) {
             const float* x_data = x.get();
             const float* y_data = y.get() + dim;
-            ref_ip.push_back(faiss::fvec_inner_product_ref(x_data, y_data, dim));
-            ref_L2sqr.push_back(faiss::fvec_L2sqr_ref(x_data, y_data, dim));
-            ref_L1.push_back(faiss::fvec_L1_ref(x_data, y_data, dim));
-            ref_Linf.push_back(faiss::fvec_Linf_ref(x_data, y_data, dim));
-            ref_norm_L2sqr.push_back(faiss::fvec_norm_L2sqr_ref(y_data, dim));
+            ref_ip.push_back(knowherefaiss::fvec_inner_product_ref(x_data, y_data, dim));
+            ref_L2sqr.push_back(knowherefaiss::fvec_L2sqr_ref(x_data, y_data, dim));
+            ref_L1.push_back(knowherefaiss::fvec_L1_ref(x_data, y_data, dim));
+            ref_Linf.push_back(knowherefaiss::fvec_Linf_ref(x_data, y_data, dim));
+            ref_norm_L2sqr.push_back(knowherefaiss::fvec_norm_L2sqr_ref(y_data, dim));
         }
 
         // float
         for (size_t i = 0; i < ny; i++) {
             const float* x_data = x.get();
             const float* y_data = y.get() + dim;
-            REQUIRE_THAT(faiss::fvec_inner_product(x_data, y_data, dim),
+            REQUIRE_THAT(knowherefaiss::fvec_inner_product(x_data, y_data, dim),
                          Catch::Matchers::WithinRel(ref_ip[i], tolerance));
-            REQUIRE_THAT(faiss::fvec_L2sqr(x_data, y_data, dim), Catch::Matchers::WithinRel(ref_L2sqr[i], tolerance));
-            REQUIRE_THAT(faiss::fvec_L1(x_data, y_data, dim), Catch::Matchers::WithinRel(ref_L1[i], tolerance));
-            REQUIRE_THAT(faiss::fvec_Linf(x_data, y_data, dim), Catch::Matchers::WithinRel(ref_Linf[i], tolerance));
-            REQUIRE_THAT(faiss::fvec_norm_L2sqr(y_data, dim), Catch::Matchers::WithinRel(ref_norm_L2sqr[i], tolerance));
+            REQUIRE_THAT(knowherefaiss::fvec_L2sqr(x_data, y_data, dim), Catch::Matchers::WithinRel(ref_L2sqr[i], tolerance));
+            REQUIRE_THAT(knowherefaiss::fvec_L1(x_data, y_data, dim), Catch::Matchers::WithinRel(ref_L1[i], tolerance));
+            REQUIRE_THAT(knowherefaiss::fvec_Linf(x_data, y_data, dim), Catch::Matchers::WithinRel(ref_Linf[i], tolerance));
+            REQUIRE_THAT(knowherefaiss::fvec_norm_L2sqr(y_data, dim), Catch::Matchers::WithinRel(ref_norm_L2sqr[i], tolerance));
         }
 
         // fp16
         for (size_t i = 0; i < ny; i++) {
             const knowhere::fp16* x_data = x_fp16.get();
             const knowhere::fp16* y_data = y_fp16.get() + dim;
-            REQUIRE_THAT(faiss::fp16_vec_inner_product(x_data, y_data, dim),
+            REQUIRE_THAT(knowherefaiss::fp16_vec_inner_product(x_data, y_data, dim),
                          Catch::Matchers::WithinRel(ref_ip[i], fp16_tolerance));
-            REQUIRE_THAT(faiss::fp16_vec_L2sqr(x_data, y_data, dim),
+            REQUIRE_THAT(knowherefaiss::fp16_vec_L2sqr(x_data, y_data, dim),
                          Catch::Matchers::WithinRel(ref_L2sqr[i], fp16_tolerance));
-            REQUIRE_THAT(faiss::fp16_vec_norm_L2sqr(y_data, dim),
+            REQUIRE_THAT(knowherefaiss::fp16_vec_norm_L2sqr(y_data, dim),
                          Catch::Matchers::WithinRel(ref_norm_L2sqr[i], fp16_tolerance));
         }
 
@@ -315,11 +315,11 @@ TEST_CASE("Test distance") {
         for (size_t i = 0; i < ny; i++) {
             const knowhere::bf16* x_data = x_bf16.get();
             const knowhere::bf16* y_data = y_bf16.get() + dim;
-            REQUIRE_THAT(faiss::bf16_vec_inner_product(x_data, y_data, dim),
+            REQUIRE_THAT(knowherefaiss::bf16_vec_inner_product(x_data, y_data, dim),
                          Catch::Matchers::WithinRel(ref_ip[i], bf16_tolerance));
-            REQUIRE_THAT(faiss::bf16_vec_L2sqr(x_data, y_data, dim),
+            REQUIRE_THAT(knowherefaiss::bf16_vec_L2sqr(x_data, y_data, dim),
                          Catch::Matchers::WithinRel(ref_L2sqr[i], bf16_tolerance));
-            REQUIRE_THAT(faiss::bf16_vec_norm_L2sqr(y_data, dim),
+            REQUIRE_THAT(knowherefaiss::bf16_vec_norm_L2sqr(y_data, dim),
                          Catch::Matchers::WithinRel(ref_norm_L2sqr[i], bf16_tolerance));
         }
     }
@@ -330,20 +330,20 @@ TEST_CASE("Test distance") {
         for (size_t i = 0; i < ny; i++) {
             const knowhere::int8* x_data = x_int8.get();
             const knowhere::int8* y_data = y_int8.get() + dim;
-            ref_ip.push_back(faiss::int8_vec_inner_product_ref(x_data, y_data, dim));
-            ref_L2sqr.push_back(faiss::int8_vec_L2sqr_ref(x_data, y_data, dim));
-            ref_norm_L2sqr.push_back(faiss::int8_vec_norm_L2sqr_ref(y_data, dim));
+            ref_ip.push_back(knowherefaiss::int8_vec_inner_product_ref(x_data, y_data, dim));
+            ref_L2sqr.push_back(knowherefaiss::int8_vec_L2sqr_ref(x_data, y_data, dim));
+            ref_norm_L2sqr.push_back(knowherefaiss::int8_vec_norm_L2sqr_ref(y_data, dim));
         }
 
         // int8
         for (size_t i = 0; i < ny; i++) {
             const knowhere::int8* x_data = x_int8.get();
             const knowhere::int8* y_data = y_int8.get() + dim;
-            REQUIRE_THAT(faiss::int8_vec_inner_product(x_data, y_data, dim),
+            REQUIRE_THAT(knowherefaiss::int8_vec_inner_product(x_data, y_data, dim),
                          Catch::Matchers::WithinRel(ref_ip[i], int8_tolerance));
-            REQUIRE_THAT(faiss::int8_vec_L2sqr(x_data, y_data, dim),
+            REQUIRE_THAT(knowherefaiss::int8_vec_L2sqr(x_data, y_data, dim),
                          Catch::Matchers::WithinRel(ref_L2sqr[i], int8_tolerance));
-            REQUIRE_THAT(faiss::int8_vec_norm_L2sqr(y_data, dim),
+            REQUIRE_THAT(knowherefaiss::int8_vec_norm_L2sqr(y_data, dim),
                          Catch::Matchers::WithinRel(ref_norm_L2sqr[i], int8_tolerance));
         }
     }
@@ -355,16 +355,16 @@ TEST_CASE("Test distance") {
         for (size_t i = 0; i < ny; i++) {
             const int8_t* x_data = xi.get();
             const int8_t* y_data = yi.get() + dim;
-            ref_ip.push_back(faiss::ivec_inner_product_ref(x_data, y_data, dim));
-            ref_L2sqr.push_back(faiss::ivec_L2sqr_ref(x_data, y_data, dim));
+            ref_ip.push_back(knowherefaiss::ivec_inner_product_ref(x_data, y_data, dim));
+            ref_L2sqr.push_back(knowherefaiss::ivec_L2sqr_ref(x_data, y_data, dim));
         }
 
         // int8
         for (size_t i = 0; i < ny; i++) {
             const int8_t* x_data = xi.get();
             const int8_t* y_data = yi.get() + dim;
-            CHECK_EQ(faiss::ivec_inner_product(x_data, y_data, dim), ref_ip[i]);
-            CHECK_EQ(faiss::ivec_L2sqr(x_data, y_data, dim), ref_L2sqr[i]);
+            CHECK_EQ(knowherefaiss::ivec_inner_product(x_data, y_data, dim), ref_ip[i]);
+            CHECK_EQ(knowherefaiss::ivec_L2sqr(x_data, y_data, dim), ref_L2sqr[i]);
         }
     }
 
@@ -376,17 +376,17 @@ TEST_CASE("Test distance") {
 
             // calculate the float result ref
             std::vector<float> ref_l2_batch_4(4), ref_ip_batch_4(4);
-            faiss::fvec_inner_product_batch_4_ref(x_data, y_data[0], y_data[1], y_data[2], y_data[3], dim,
+            knowherefaiss::fvec_inner_product_batch_4_ref(x_data, y_data[0], y_data[1], y_data[2], y_data[3], dim,
                                                   ref_ip_batch_4[0], ref_ip_batch_4[1], ref_ip_batch_4[2],
                                                   ref_ip_batch_4[3]);
-            faiss::fvec_L2sqr_batch_4_ref(x_data, y_data[0], y_data[1], y_data[2], y_data[3], dim, ref_l2_batch_4[0],
+            knowherefaiss::fvec_L2sqr_batch_4_ref(x_data, y_data[0], y_data[1], y_data[2], y_data[3], dim, ref_l2_batch_4[0],
                                           ref_l2_batch_4[1], ref_l2_batch_4[2], ref_l2_batch_4[3]);
 
             // float
             std::vector<float> l2_batch_4(4), ip_batch_4(4);
-            faiss::fvec_inner_product_batch_4(x_data, y_data[0], y_data[1], y_data[2], y_data[3], dim, ip_batch_4[0],
+            knowherefaiss::fvec_inner_product_batch_4(x_data, y_data[0], y_data[1], y_data[2], y_data[3], dim, ip_batch_4[0],
                                               ip_batch_4[1], ip_batch_4[2], ip_batch_4[3]);
-            faiss::fvec_L2sqr_batch_4(x_data, y_data[0], y_data[1], y_data[2], y_data[3], dim, l2_batch_4[0],
+            knowherefaiss::fvec_L2sqr_batch_4(x_data, y_data[0], y_data[1], y_data[2], y_data[3], dim, l2_batch_4[0],
                                       l2_batch_4[1], l2_batch_4[2], l2_batch_4[3]);
 
             REQUIRE_THAT(ip_batch_4[0], Catch::Matchers::WithinRel(ref_ip_batch_4[0], tolerance));
@@ -408,17 +408,17 @@ TEST_CASE("Test distance") {
 
             // calculate the fp16 result ref
             std::vector<float> ref_l2_batch_4(4), ref_ip_batch_4(4);
-            faiss::fp16_vec_inner_product_batch_4_ref(x_data, y_data[0], y_data[1], y_data[2], y_data[3], dim,
+            knowherefaiss::fp16_vec_inner_product_batch_4_ref(x_data, y_data[0], y_data[1], y_data[2], y_data[3], dim,
                                                       ref_ip_batch_4[0], ref_ip_batch_4[1], ref_ip_batch_4[2],
                                                       ref_ip_batch_4[3]);
-            faiss::fp16_vec_L2sqr_batch_4_ref(x_data, y_data[0], y_data[1], y_data[2], y_data[3], dim,
+            knowherefaiss::fp16_vec_L2sqr_batch_4_ref(x_data, y_data[0], y_data[1], y_data[2], y_data[3], dim,
                                               ref_l2_batch_4[0], ref_l2_batch_4[1], ref_l2_batch_4[2],
                                               ref_l2_batch_4[3]);
 
             std::vector<float> l2_batch_4(4), ip_batch_4(4);
-            faiss::fp16_vec_inner_product_batch_4(x_data, y_data[0], y_data[1], y_data[2], y_data[3], dim,
+            knowherefaiss::fp16_vec_inner_product_batch_4(x_data, y_data[0], y_data[1], y_data[2], y_data[3], dim,
                                                   ip_batch_4[0], ip_batch_4[1], ip_batch_4[2], ip_batch_4[3]);
-            faiss::fp16_vec_L2sqr_batch_4(x_data, y_data[0], y_data[1], y_data[2], y_data[3], dim, l2_batch_4[0],
+            knowherefaiss::fp16_vec_L2sqr_batch_4(x_data, y_data[0], y_data[1], y_data[2], y_data[3], dim, l2_batch_4[0],
                                           l2_batch_4[1], l2_batch_4[2], l2_batch_4[3]);
 
             REQUIRE_THAT(ip_batch_4[0], Catch::Matchers::WithinRel(ref_ip_batch_4[0], tolerance));
@@ -440,17 +440,17 @@ TEST_CASE("Test distance") {
 
             // calculate the bf16 result ref
             std::vector<float> ref_l2_batch_4(4), ref_ip_batch_4(4);
-            faiss::bf16_vec_inner_product_batch_4_ref(x_data, y_data[0], y_data[1], y_data[2], y_data[3], dim,
+            knowherefaiss::bf16_vec_inner_product_batch_4_ref(x_data, y_data[0], y_data[1], y_data[2], y_data[3], dim,
                                                       ref_ip_batch_4[0], ref_ip_batch_4[1], ref_ip_batch_4[2],
                                                       ref_ip_batch_4[3]);
-            faiss::bf16_vec_L2sqr_batch_4_ref(x_data, y_data[0], y_data[1], y_data[2], y_data[3], dim,
+            knowherefaiss::bf16_vec_L2sqr_batch_4_ref(x_data, y_data[0], y_data[1], y_data[2], y_data[3], dim,
                                               ref_l2_batch_4[0], ref_l2_batch_4[1], ref_l2_batch_4[2],
                                               ref_l2_batch_4[3]);
 
             std::vector<float> l2_batch_4(4), ip_batch_4(4);
-            faiss::bf16_vec_inner_product_batch_4(x_data, y_data[0], y_data[1], y_data[2], y_data[3], dim,
+            knowherefaiss::bf16_vec_inner_product_batch_4(x_data, y_data[0], y_data[1], y_data[2], y_data[3], dim,
                                                   ip_batch_4[0], ip_batch_4[1], ip_batch_4[2], ip_batch_4[3]);
-            faiss::bf16_vec_L2sqr_batch_4(x_data, y_data[0], y_data[1], y_data[2], y_data[3], dim, l2_batch_4[0],
+            knowherefaiss::bf16_vec_L2sqr_batch_4(x_data, y_data[0], y_data[1], y_data[2], y_data[3], dim, l2_batch_4[0],
                                           l2_batch_4[1], l2_batch_4[2], l2_batch_4[3]);
 
             REQUIRE_THAT(ip_batch_4[0], Catch::Matchers::WithinRel(ref_ip_batch_4[0], tolerance));
@@ -472,18 +472,18 @@ TEST_CASE("Test distance") {
 
             // calculate the int8 result ref
             std::vector<float> ref_l2_batch_4(4), ref_ip_batch_4(4);
-            faiss::int8_vec_inner_product_batch_4_ref(x_data, y_data[0], y_data[1], y_data[2], y_data[3], dim,
+            knowherefaiss::int8_vec_inner_product_batch_4_ref(x_data, y_data[0], y_data[1], y_data[2], y_data[3], dim,
                                                       ref_ip_batch_4[0], ref_ip_batch_4[1], ref_ip_batch_4[2],
                                                       ref_ip_batch_4[3]);
-            faiss::int8_vec_L2sqr_batch_4_ref(x_data, y_data[0], y_data[1], y_data[2], y_data[3], dim,
+            knowherefaiss::int8_vec_L2sqr_batch_4_ref(x_data, y_data[0], y_data[1], y_data[2], y_data[3], dim,
                                               ref_l2_batch_4[0], ref_l2_batch_4[1], ref_l2_batch_4[2],
                                               ref_l2_batch_4[3]);
 
             // int8
             std::vector<float> l2_batch_4(4), ip_batch_4(4);
-            faiss::int8_vec_inner_product_batch_4(x_data, y_data[0], y_data[1], y_data[2], y_data[3], dim,
+            knowherefaiss::int8_vec_inner_product_batch_4(x_data, y_data[0], y_data[1], y_data[2], y_data[3], dim,
                                                   ip_batch_4[0], ip_batch_4[1], ip_batch_4[2], ip_batch_4[3]);
-            faiss::int8_vec_L2sqr_batch_4(x_data, y_data[0], y_data[1], y_data[2], y_data[3], dim, l2_batch_4[0],
+            knowherefaiss::int8_vec_L2sqr_batch_4(x_data, y_data[0], y_data[1], y_data[2], y_data[3], dim, l2_batch_4[0],
                                           l2_batch_4[1], l2_batch_4[2], l2_batch_4[3]);
 
             REQUIRE_THAT(ip_batch_4[0], Catch::Matchers::WithinRel(ref_ip_batch_4[0], int8_tolerance));
@@ -501,15 +501,15 @@ TEST_CASE("Test distance") {
     SECTION("test ny distance calculation") {
         // calculate the float result ref
         auto ref_ip = std::make_unique<float[]>(ny);
-        faiss::fvec_inner_products_ny_ref(ref_ip.get(), x.get(), y.get(), dim, ny);
+        knowherefaiss::fvec_inner_products_ny_ref(ref_ip.get(), x.get(), y.get(), dim, ny);
         auto ref_l2 = std::make_unique<float[]>(ny);
-        faiss::fvec_L2sqr_ny_ref(ref_l2.get(), x.get(), y.get(), dim, ny);
+        knowherefaiss::fvec_L2sqr_ny_ref(ref_l2.get(), x.get(), y.get(), dim, ny);
 
         auto ip_dis = std::make_unique<float[]>(ny);
         auto l2_dis = std::make_unique<float[]>(ny);
 
-        faiss::fvec_inner_products_ny(ip_dis.get(), x.get(), y.get(), dim, ny);
-        faiss::fvec_L2sqr_ny(l2_dis.get(), x.get(), y.get(), dim, ny);
+        knowherefaiss::fvec_inner_products_ny(ip_dis.get(), x.get(), y.get(), dim, ny);
+        knowherefaiss::fvec_L2sqr_ny(l2_dis.get(), x.get(), y.get(), dim, ny);
         for (size_t i = 0; i < ny; i++) {
             REQUIRE_THAT(ip_dis[i], Catch::Matchers::WithinRel(ref_ip[i], tolerance));
             REQUIRE_THAT(l2_dis[i], Catch::Matchers::WithinRel(ref_l2[i], tolerance));
@@ -521,15 +521,15 @@ TEST_CASE("Test distance") {
 
         // calculate the float result ref
         auto ref_madd = std::make_unique<float[]>(dim);
-        faiss::fvec_madd_ref(dim, x.get(), bf, y.get(), ref_madd.get());
+        knowherefaiss::fvec_madd_ref(dim, x.get(), bf, y.get(), ref_madd.get());
         auto ref_madd_and_argmin = std::make_unique<float[]>(dim);
-        faiss::fvec_madd_and_argmin_ref(dim, x.get(), bf, y.get(), ref_madd_and_argmin.get());
+        knowherefaiss::fvec_madd_and_argmin_ref(dim, x.get(), bf, y.get(), ref_madd_and_argmin.get());
 
         auto madd_dis = std::make_unique<float[]>(dim);
         auto madd_and_argmin_dis = std::make_unique<float[]>(dim);
 
-        faiss::fvec_madd(dim, x.get(), bf, y.get(), madd_dis.get());
-        faiss::fvec_madd_and_argmin(dim, x.get(), bf, y.get(), madd_and_argmin_dis.get());
+        knowherefaiss::fvec_madd(dim, x.get(), bf, y.get(), madd_dis.get());
+        knowherefaiss::fvec_madd_and_argmin(dim, x.get(), bf, y.get(), madd_and_argmin_dis.get());
         for (size_t i = 0; i < dim; i++) {
             REQUIRE_THAT(madd_dis[i], Catch::Matchers::WithinRel(ref_madd[i], tolerance));
             REQUIRE_THAT(madd_and_argmin_dis[i], Catch::Matchers::WithinRel(ref_madd_and_argmin[i], tolerance));
@@ -540,27 +540,27 @@ TEST_CASE("Test distance") {
         const float* x_data = x.get();
         std::vector<const float*> y_data{y.get(), y.get() + dim, y.get() + 2 * dim, y.get() + 3 * dim};
 
-        const auto ref_ip = faiss::fvec_inner_product_ref(x.get(), y.get(), dim);
-        const auto ref_L2sqr = faiss::fvec_L2sqr_ref(x.get(), y.get(), dim);
+        const auto ref_ip = knowherefaiss::fvec_inner_product_ref(x.get(), y.get(), dim);
+        const auto ref_L2sqr = knowherefaiss::fvec_L2sqr_ref(x.get(), y.get(), dim);
 
         // calculate the bf16 patch result ref
         std::vector<float> ref_l2_batch_4(4), ref_ip_batch_4(4);
-        faiss::fvec_inner_product_batch_4_bf16_patch_ref(x_data, y_data[0], y_data[1], y_data[2], y_data[3], dim,
+        knowherefaiss::fvec_inner_product_batch_4_bf16_patch_ref(x_data, y_data[0], y_data[1], y_data[2], y_data[3], dim,
                                                          ref_ip_batch_4[0], ref_ip_batch_4[1], ref_ip_batch_4[2],
                                                          ref_ip_batch_4[3]);
-        faiss::fvec_L2sqr_batch_4_bf16_patch_ref(x_data, y_data[0], y_data[1], y_data[2], y_data[3], dim,
+        knowherefaiss::fvec_L2sqr_batch_4_bf16_patch_ref(x_data, y_data[0], y_data[1], y_data[2], y_data[3], dim,
                                                  ref_l2_batch_4[0], ref_l2_batch_4[1], ref_l2_batch_4[2],
                                                  ref_l2_batch_4[3]);
 
         auto run_test = [&]() {
-            REQUIRE_THAT(faiss::fvec_inner_product(x.get(), y.get(), dim),
+            REQUIRE_THAT(knowherefaiss::fvec_inner_product(x.get(), y.get(), dim),
                          Catch::Matchers::WithinRel(ref_ip, bf16_tolerance));
 
-            REQUIRE_THAT(faiss::fvec_L2sqr(x.get(), y.get(), dim),
+            REQUIRE_THAT(knowherefaiss::fvec_L2sqr(x.get(), y.get(), dim),
                          Catch::Matchers::WithinRel(ref_L2sqr, bf16_tolerance));
 
             std::vector<float> ip_batch_4(4);
-            faiss::fvec_inner_product_batch_4(x_data, y_data[0], y_data[1], y_data[2], y_data[3], dim, ip_batch_4[0],
+            knowherefaiss::fvec_inner_product_batch_4(x_data, y_data[0], y_data[1], y_data[2], y_data[3], dim, ip_batch_4[0],
                                               ip_batch_4[1], ip_batch_4[2], ip_batch_4[3]);
             REQUIRE_THAT(ip_batch_4[0], Catch::Matchers::WithinRel(ref_ip_batch_4[0], bf16_tolerance));
             REQUIRE_THAT(ip_batch_4[1], Catch::Matchers::WithinRel(ref_ip_batch_4[1], bf16_tolerance));
@@ -568,7 +568,7 @@ TEST_CASE("Test distance") {
             REQUIRE_THAT(ip_batch_4[3], Catch::Matchers::WithinRel(ref_ip_batch_4[3], bf16_tolerance));
 
             std::vector<float> l2_batch_4(4);
-            faiss::fvec_L2sqr_batch_4(x_data, y_data[0], y_data[1], y_data[2], y_data[3], dim, l2_batch_4[0],
+            knowherefaiss::fvec_L2sqr_batch_4(x_data, y_data[0], y_data[1], y_data[2], y_data[3], dim, l2_batch_4[0],
                                       l2_batch_4[1], l2_batch_4[2], l2_batch_4[3]);
             REQUIRE_THAT(l2_batch_4[0], Catch::Matchers::WithinRel(ref_l2_batch_4[0], bf16_tolerance));
             REQUIRE_THAT(l2_batch_4[1], Catch::Matchers::WithinRel(ref_l2_batch_4[1], bf16_tolerance));
diff --git a/tests/ut/test_type.cc b/tests/ut/test_type.cc
index a87156f4..ed471e81 100644
--- a/tests/ut/test_type.cc
+++ b/tests/ut/test_type.cc
@@ -39,9 +39,9 @@ TEST_CASE("Test bf16 patch", "[bf16 patch]") {
     auto compute_dist = [&](float* l2_dist_ret, float* ip_dist_ret) {
         for (int64_t i = 0; i < nq; i++) {
             for (int64_t j = 0; j < nb; j++) {
-                l2_dist_ret[i * nq + j] = faiss::fvec_L2sqr(query_tensor + i * dim, train_tensor + j * dim, dim);
+                l2_dist_ret[i * nq + j] = knowherefaiss::fvec_L2sqr(query_tensor + i * dim, train_tensor + j * dim, dim);
                 ip_dist_ret[i * nq + j] =
-                    faiss::fvec_inner_product(query_tensor + i * dim, train_tensor + j * dim, dim);
+                    knowherefaiss::fvec_inner_product(query_tensor + i * dim, train_tensor + j * dim, dim);
             }
         }
     };
@@ -49,9 +49,9 @@ TEST_CASE("Test bf16 patch", "[bf16 patch]") {
     auto compute_ref_dist = [&](float* l2_dist_ret, float* ip_dist_ret) {
         for (int64_t i = 0; i < nq; i++) {
             for (int64_t j = 0; j < nb; j++) {
-                l2_dist_ret[i * nq + j] = faiss::fvec_L2sqr_ref(query_tensor + i * dim, train_tensor + j * dim, dim);
+                l2_dist_ret[i * nq + j] = knowherefaiss::fvec_L2sqr_ref(query_tensor + i * dim, train_tensor + j * dim, dim);
                 ip_dist_ret[i * nq + j] =
-                    faiss::fvec_inner_product_ref(query_tensor + i * dim, train_tensor + j * dim, dim);
+                    knowherefaiss::fvec_inner_product_ref(query_tensor + i * dim, train_tensor + j * dim, dim);
             }
         }
     };
diff --git a/thirdparty/DiskANN/src/distance.cpp b/thirdparty/DiskANN/src/distance.cpp
index 7f921679..b6b47464 100644
--- a/thirdparty/DiskANN/src/distance.cpp
+++ b/thirdparty/DiskANN/src/distance.cpp
@@ -33,14 +33,14 @@ namespace diskann {
   template<>
   DISTFUN<float> get_distance_function(diskann::Metric m) {
     if (m == diskann::Metric::L2) {
-      return faiss::fvec_L2sqr;
+      return knowherefaiss::fvec_L2sqr;
     } else if (m == diskann::Metric::INNER_PRODUCT) {
       return [](const float* x, const float* y, size_t size) -> float {
-        return (-1.0) * faiss::fvec_inner_product(x, y, size);
+        return (-1.0) * knowherefaiss::fvec_inner_product(x, y, size);
       };
     } else if (m == diskann::Metric::COSINE) {
       return [](const float* x, const float* y, size_t size) -> float {
-        return (-1.0) * faiss::fvec_inner_product(x, y, size);
+        return (-1.0) * knowherefaiss::fvec_inner_product(x, y, size);
       };
     } else {
       std::stringstream stream;
@@ -55,16 +55,16 @@ namespace diskann {
   template<>
   DISTFUN<knowhere::fp16> get_distance_function(diskann::Metric m) {
     if (m == diskann::Metric::L2) {
-      return faiss::fp16_vec_L2sqr;
+      return knowherefaiss::fp16_vec_L2sqr;
     } else if (m == diskann::Metric::INNER_PRODUCT) {
       return [](const knowhere::fp16* x, const knowhere::fp16* y,
                 size_t size) -> float {
-        return (-1.0) * faiss::fp16_vec_inner_product(x, y, size);
+        return (-1.0) * knowherefaiss::fp16_vec_inner_product(x, y, size);
       };
     } else if (m == diskann::Metric::COSINE) {
       return [](const knowhere::fp16* x, const knowhere::fp16* y,
                 size_t size) -> float {
-        return (-1.0) * faiss::fp16_vec_inner_product(x, y, size);
+        return (-1.0) * knowherefaiss::fp16_vec_inner_product(x, y, size);
       };
     } else {
       std::stringstream stream;
@@ -79,16 +79,16 @@ namespace diskann {
   template<>
   DISTFUN<knowhere::bf16> get_distance_function(diskann::Metric m) {
     if (m == diskann::Metric::L2) {
-      return faiss::bf16_vec_L2sqr;
+      return knowherefaiss::bf16_vec_L2sqr;
     } else if (m == diskann::Metric::INNER_PRODUCT) {
       return [](const knowhere::bf16* x, const knowhere::bf16* y,
                 size_t size) -> float {
-        return (-1.0) * faiss::bf16_vec_inner_product(x, y, size);
+        return (-1.0) * knowherefaiss::bf16_vec_inner_product(x, y, size);
       };
     } else if (m == diskann::Metric::COSINE) {
       return [](const knowhere::bf16* x, const knowhere::bf16* y,
                 size_t size) -> float {
-        return (-1.0) * faiss::bf16_vec_inner_product(x, y, size);
+        return (-1.0) * knowherefaiss::bf16_vec_inner_product(x, y, size);
       };
     } else {
       std::stringstream stream;
@@ -104,13 +104,13 @@ namespace diskann {
   template<typename T>
   float norm_l2sqr(const T* a, size_t size) {
     if constexpr (std::is_floating_point<T>::value) {
-      return faiss::fvec_norm_L2sqr(a, size);
+      return knowherefaiss::fvec_norm_L2sqr(a, size);
     }
     if constexpr (std::is_same_v<T, knowhere::fp16>) {
-      return faiss::fp16_vec_norm_L2sqr(a, size);
+      return knowherefaiss::fp16_vec_norm_L2sqr(a, size);
     }
     if constexpr (std::is_same_v<T, knowhere::bf16>) {
-      return faiss::bf16_vec_norm_L2sqr(a, size);
+      return knowherefaiss::bf16_vec_norm_L2sqr(a, size);
     } else {
       float res = 0;
       for (size_t i = 0; i < size; i++) {
diff --git a/thirdparty/faiss/.circleci/config.yml b/thirdparty/faiss/.circleci/config.yml
index 03309391..0f7eb25f 100644
--- a/thirdparty/faiss/.circleci/config.yml
+++ b/thirdparty/faiss/.circleci/config.yml
@@ -65,7 +65,7 @@ jobs:
       - run:
           name: Install Python extension
           command: |
-            cd build/faiss/python
+            cd build/knowherefaiss/python
             python setup.py install
       - run:
           name: Python tests (CPU only)
diff --git a/thirdparty/faiss/.github/actions/build_cmake/action.yml b/thirdparty/faiss/.github/actions/build_cmake/action.yml
index 2bc476ad..d7732043 100644
--- a/thirdparty/faiss/.github/actions/build_cmake/action.yml
+++ b/thirdparty/faiss/.github/actions/build_cmake/action.yml
@@ -74,7 +74,7 @@ runs:
         make -C build test
     - name: Install Python extension
       shell: bash
-      working-directory: build/faiss/python
+      working-directory: build/knowherefaiss/python
       run: |
         $CONDA/bin/python setup.py install
     - name: Python tests (CPU only)
@@ -89,15 +89,15 @@ runs:
       run: |
         pytest --junitxml=test-results/pytest/results.xml tests/test_*.py
         pytest --junitxml=test-results/pytest/results-torch.xml tests/torch_*.py
-        cp tests/common_faiss_tests.py faiss/gpu/test
-        pytest --junitxml=test-results/pytest/results-gpu.xml faiss/gpu/test/test_*.py
-        pytest --junitxml=test-results/pytest/results-gpu-torch.xml faiss/gpu/test/torch_*.py
+        cp tests/common_faiss_tests.py knowherefaiss/gpu/test
+        pytest --junitxml=test-results/pytest/results-gpu.xml knowherefaiss/gpu/test/test_*.py
+        pytest --junitxml=test-results/pytest/results-gpu-torch.xml knowherefaiss/gpu/test/torch_*.py
     - name: Test avx2 loading
       if: inputs.opt_level == 'avx2'
       shell: bash
       run: |
-        FAISS_DISABLE_CPU_FEATURES=AVX2 LD_DEBUG=libs $CONDA/bin/python -c "import faiss" 2>&1 | grep faiss.so
-        LD_DEBUG=libs $CONDA/bin/python -c "import faiss" 2>&1 | grep faiss_avx2.so
+        FAISS_DISABLE_CPU_FEATURES=AVX2 LD_DEBUG=libs $CONDA/bin/python -c "import knowherefaiss" 2>&1 | grep knowherefaiss.so
+        LD_DEBUG=libs $CONDA/bin/python -c "import knowherefaiss" 2>&1 | grep faiss_avx2.so
     - name: Upload test results
       uses: actions/upload-artifact@v4
       with:
diff --git a/thirdparty/faiss/.github/workflows/update-doxygen.yml b/thirdparty/faiss/.github/workflows/update-doxygen.yml
index 17e543a2..f1b86fbf 100644
--- a/thirdparty/faiss/.github/workflows/update-doxygen.yml
+++ b/thirdparty/faiss/.github/workflows/update-doxygen.yml
@@ -4,7 +4,7 @@ on:
     branches:
       - main
     paths:
-      - 'faiss/**'
+      - 'knowherefaiss/**'
 jobs:
   doxygen:
     runs-on: ubuntu-latest
diff --git a/thirdparty/faiss/.gitignore b/thirdparty/faiss/.gitignore
index a5232cfb..25e123db 100644
--- a/thirdparty/faiss/.gitignore
+++ b/thirdparty/faiss/.gitignore
@@ -21,15 +21,15 @@
 /tests/gtest/
 /tests/faiss_test
 
-faiss/gpu/test/TestCodePacking
-faiss/gpu/test/TestGpuDistance
-faiss/gpu/test/TestGpuIndexBinaryFlat
-faiss/gpu/test/TestGpuIndexFlat
-faiss/gpu/test/TestGpuIndexIVFFlat
-faiss/gpu/test/TestGpuIndexIVFPQ
-faiss/gpu/test/TestGpuIndexIVFScalarQuantizer
-faiss/gpu/test/TestGpuMemoryException
-faiss/gpu/test/TestGpuSelect
+knowherefaiss/gpu/test/TestCodePacking
+knowherefaiss/gpu/test/TestGpuDistance
+knowherefaiss/gpu/test/TestGpuIndexBinaryFlat
+knowherefaiss/gpu/test/TestGpuIndexFlat
+knowherefaiss/gpu/test/TestGpuIndexIVFFlat
+knowherefaiss/gpu/test/TestGpuIndexIVFPQ
+knowherefaiss/gpu/test/TestGpuIndexIVFScalarQuantizer
+knowherefaiss/gpu/test/TestGpuMemoryException
+knowherefaiss/gpu/test/TestGpuSelect
 
 **/CMakeFiles/*
 CMakeCache.txt
diff --git a/thirdparty/faiss/INSTALL.md b/thirdparty/faiss/INSTALL.md
index 45e2c934..7092cb16 100644
--- a/thirdparty/faiss/INSTALL.md
+++ b/thirdparty/faiss/INSTALL.md
@@ -158,7 +158,7 @@ it is recommended to set the `-j` option to a fixed value (such as `-j4`).
 
 ``` shell
 $ make -C build -j swigfaiss
-$ (cd build/faiss/python && python setup.py install)
+$ (cd build/knowherefaiss/python && python setup.py install)
 ```
 
 The first command builds the python bindings for Faiss, while the second one
@@ -189,8 +189,8 @@ $ make -C build test
 ### Running the python test suite
 
 ``` shell
-$ (cd build/faiss/python && python setup.py build)
-$ PYTHONPATH="$(ls -d ./build/faiss/python/build/lib*/)" pytest tests/test_*.py
+$ (cd build/knowherefaiss/python && python setup.py build)
+$ PYTHONPATH="$(ls -d ./build/knowherefaiss/python/build/lib*/)" pytest tests/test_*.py
 ```
 
 ### Basic example
diff --git a/thirdparty/faiss/benchs/bench_6bit_codec.cpp b/thirdparty/faiss/benchs/bench_6bit_codec.cpp
index b4ac0b04..e25aab51 100644
--- a/thirdparty/faiss/benchs/bench_6bit_codec.cpp
+++ b/thirdparty/faiss/benchs/bench_6bit_codec.cpp
@@ -9,12 +9,12 @@
 #include <cstdio>
 
 #include <benchmark/benchmark.h>
-#include <faiss/impl/ScalarQuantizer.h>
-#include <faiss/utils/distances.h>
-#include <faiss/utils/random.h>
-#include <faiss/utils/utils.h>
+#include <knowherefaiss/impl/ScalarQuantizer.h>
+#include <knowherefaiss/utils/distances.h>
+#include <knowherefaiss/utils/random.h>
+#include <knowherefaiss/utils/utils.h>
 
-using namespace faiss;
+using namespace knowherefaiss;
 
 static void bench(benchmark::State& state) {
     int d = 128;
diff --git a/thirdparty/faiss/benchs/bench_cppcontrib_sa_decode.cpp b/thirdparty/faiss/benchs/bench_cppcontrib_sa_decode.cpp
index b960fb7c..64a126a8 100644
--- a/thirdparty/faiss/benchs/bench_cppcontrib_sa_decode.cpp
+++ b/thirdparty/faiss/benchs/bench_cppcontrib_sa_decode.cpp
@@ -16,19 +16,19 @@
 #include <tuple>
 #include <vector>
 
-#include <faiss/Index.h>
-#include <faiss/Index2Layer.h>
-#include <faiss/IndexIVFPQ.h>
-#include <faiss/IndexPQ.h>
-#include <faiss/impl/io.h>
-#include <faiss/index_factory.h>
-#include <faiss/index_io.h>
+#include <knowherefaiss/Index.h>
+#include <knowherefaiss/Index2Layer.h>
+#include <knowherefaiss/IndexIVFPQ.h>
+#include <knowherefaiss/IndexPQ.h>
+#include <knowherefaiss/impl/io.h>
+#include <knowherefaiss/index_factory.h>
+#include <knowherefaiss/index_io.h>
 
-#include <faiss/IndexRowwiseMinMax.h>
-#include <faiss/cppcontrib/SaDecodeKernels.h>
+#include <knowherefaiss/IndexRowwiseMinMax.h>
+#include <knowherefaiss/cppcontrib/SaDecodeKernels.h>
 
 // train a dataset
-std::tuple<std::shared_ptr<faiss::Index>, std::vector<uint8_t>> trainDataset(
+std::tuple<std::shared_ptr<knowherefaiss::Index>, std::vector<uint8_t>> trainDataset(
         const std::vector<float>& input,
         const uint64_t n,
         const uint64_t d,
@@ -37,8 +37,8 @@ std::tuple<std::shared_ptr<faiss::Index>, std::vector<uint8_t>> trainDataset(
     omp_set_num_threads(std::thread::hardware_concurrency());
 
     // train an index
-    auto index = std::shared_ptr<faiss::Index>(
-            faiss::index_factory((int)d, description.c_str()));
+    auto index = std::shared_ptr<knowherefaiss::Index>(
+            knowherefaiss::index_factory((int)d, description.c_str()));
     index->train((int)n, input.data());
 
     // encode
@@ -107,21 +107,21 @@ struct StopWatch {
 
 //
 bool testIfIVFPQ(
-        const faiss::Index* const index,
+        const knowherefaiss::Index* const index,
         const float** pqCoarseCentroidsQ,
         const float** pqFineCentroidsQ) {
     if (pqFineCentroidsQ == nullptr || pqCoarseCentroidsQ == nullptr) {
         return false;
     }
 
-    const faiss::IndexIVFPQ* const indexQ =
-            dynamic_cast<const faiss::IndexIVFPQ*>(index);
+    const knowherefaiss::IndexIVFPQ* const indexQ =
+            dynamic_cast<const knowherefaiss::IndexIVFPQ*>(index);
     if (indexQ == nullptr) {
         return false;
     }
 
     const auto coarseIndexQ =
-            dynamic_cast<const faiss::IndexFlatCodes*>(indexQ->quantizer);
+            dynamic_cast<const knowherefaiss::IndexFlatCodes*>(indexQ->quantizer);
     if (coarseIndexQ == nullptr) {
         return false;
     }
@@ -133,20 +133,20 @@ bool testIfIVFPQ(
 }
 
 bool testIfResidualPQ(
-        const faiss::Index* const index,
+        const knowherefaiss::Index* const index,
         const float** pqCoarseCentroidsQ,
         const float** pqFineCentroidsQ) {
     if (pqFineCentroidsQ == nullptr || pqCoarseCentroidsQ == nullptr) {
         return false;
     }
 
-    const faiss::Index2Layer* const indexQ =
-            dynamic_cast<const faiss::Index2Layer*>(index);
+    const knowherefaiss::Index2Layer* const indexQ =
+            dynamic_cast<const knowherefaiss::Index2Layer*>(index);
     if (indexQ == nullptr) {
         return false;
     }
 
-    const auto coarseIndexQ = dynamic_cast<const faiss::MultiIndexQuantizer*>(
+    const auto coarseIndexQ = dynamic_cast<const knowherefaiss::MultiIndexQuantizer*>(
             indexQ->q1.quantizer);
     if (coarseIndexQ == nullptr) {
         return false;
@@ -163,7 +163,7 @@ static void verifyIndex2LevelDecoder(
         const uint64_t n,
         const uint64_t d,
         const std::string& description,
-        const std::shared_ptr<faiss::Index>& index,
+        const std::shared_ptr<knowherefaiss::Index>& index,
         const std::vector<uint8_t>& encodedData,
         const uint64_t nIterations) {
     //
@@ -467,7 +467,7 @@ static void verifyMinMaxIndex2LevelDecoder(
         const uint64_t n,
         const uint64_t d,
         const std::string& description,
-        const std::shared_ptr<faiss::Index>& index,
+        const std::shared_ptr<knowherefaiss::Index>& index,
         const std::vector<uint8_t>& encodedData,
         const uint64_t nIterations) {
     //
@@ -475,8 +475,8 @@ static void verifyMinMaxIndex2LevelDecoder(
     const float* pqCoarseCentroidsQ = nullptr;
 
     // extract an index that is wrapped with IndexRowwiseMinMaxBase
-    const std::shared_ptr<faiss::IndexRowwiseMinMaxBase> indexMinMax =
-            std::dynamic_pointer_cast<faiss::IndexRowwiseMinMaxBase>(index);
+    const std::shared_ptr<knowherefaiss::IndexRowwiseMinMaxBase> indexMinMax =
+            std::dynamic_pointer_cast<knowherefaiss::IndexRowwiseMinMaxBase>(index);
 
     auto subIndex = indexMinMax->index;
 
@@ -804,12 +804,12 @@ static void verifyIndexPQDecoder(
         const uint64_t n,
         const uint64_t d,
         const std::string& description,
-        const std::shared_ptr<faiss::Index>& index,
+        const std::shared_ptr<knowherefaiss::Index>& index,
         const std::vector<uint8_t>& encodedData,
         const uint64_t nIterations) {
     //
-    const faiss::IndexPQ* const indexQ =
-            dynamic_cast<const faiss::IndexPQ*>(index.get());
+    const knowherefaiss::IndexPQ* const indexQ =
+            dynamic_cast<const knowherefaiss::IndexPQ*>(index.get());
     const float* const pqFineCentroidsQ = indexQ->pq.centroids.data();
 
     //
@@ -1097,18 +1097,18 @@ static void verifyMinMaxIndexPQDecoder(
         const uint64_t n,
         const uint64_t d,
         const std::string& description,
-        const std::shared_ptr<faiss::Index>& index,
+        const std::shared_ptr<knowherefaiss::Index>& index,
         const std::vector<uint8_t>& encodedData,
         const uint64_t nIterations) {
     // extract an index that is wrapped with IndexRowwiseMinMaxBase
-    const std::shared_ptr<faiss::IndexRowwiseMinMaxBase> indexMinMax =
-            std::dynamic_pointer_cast<faiss::IndexRowwiseMinMaxBase>(index);
+    const std::shared_ptr<knowherefaiss::IndexRowwiseMinMaxBase> indexMinMax =
+            std::dynamic_pointer_cast<knowherefaiss::IndexRowwiseMinMaxBase>(index);
 
     auto subIndex = indexMinMax->index;
 
     //
-    const faiss::IndexPQ* const indexQ =
-            dynamic_cast<const faiss::IndexPQ*>(subIndex);
+    const knowherefaiss::IndexPQ* const indexQ =
+            dynamic_cast<const knowherefaiss::IndexPQ*>(subIndex);
     const float* const pqFineCentroidsQ = indexQ->pq.centroids.data();
 
     //
@@ -1421,7 +1421,7 @@ void testIndex2LevelDecoder(
         const std::string& description,
         const uint64_t nIterations) {
     auto data = generate(n, d);
-    std::shared_ptr<faiss::Index> index;
+    std::shared_ptr<knowherefaiss::Index> index;
     std::vector<uint8_t> encodedData;
     std::tie(index, encodedData) = trainDataset(data, n, d, description);
 
@@ -1436,7 +1436,7 @@ void testMinMaxIndex2LevelDecoder(
         const std::string& description,
         const uint64_t nIterations) {
     auto data = generate(n, d);
-    std::shared_ptr<faiss::Index> index;
+    std::shared_ptr<knowherefaiss::Index> index;
     std::vector<uint8_t> encodedData;
     std::tie(index, encodedData) = trainDataset(data, n, d, description);
 
@@ -1451,7 +1451,7 @@ void testIndexPQDecoder(
         const std::string& description,
         const uint64_t nIterations) {
     auto data = generate(n, d);
-    std::shared_ptr<faiss::Index> index;
+    std::shared_ptr<knowherefaiss::Index> index;
     std::vector<uint8_t> encodedData;
     std::tie(index, encodedData) = trainDataset(data, n, d, description);
 
@@ -1465,7 +1465,7 @@ void testMinMaxIndexPQDecoder(
         const std::string& description,
         const uint64_t nIterations) {
     auto data = generate(n, d);
-    std::shared_ptr<faiss::Index> index;
+    std::shared_ptr<knowherefaiss::Index> index;
     std::vector<uint8_t> encodedData;
     std::tie(index, encodedData) = trainDataset(data, n, d, description);
 
@@ -1511,189 +1511,189 @@ int main(int argc, char** argv) {
 
     // test plain PQx8
     {
-        using T = faiss::cppcontrib::IndexPQDecoder<128, 2>;
+        using T = knowherefaiss::cppcontrib::IndexPQDecoder<128, 2>;
         testIndexPQDecoder<T>(INDEX_SIZE, 128, "PQ64np", N_ITERATIONS);
     }
     {
-        using T = faiss::cppcontrib::IndexPQDecoder<128, 4>;
+        using T = knowherefaiss::cppcontrib::IndexPQDecoder<128, 4>;
         testIndexPQDecoder<T>(INDEX_SIZE, 128, "PQ32np", N_ITERATIONS);
     }
     {
-        using T = faiss::cppcontrib::IndexPQDecoder<128, 8>;
+        using T = knowherefaiss::cppcontrib::IndexPQDecoder<128, 8>;
         testIndexPQDecoder<T>(INDEX_SIZE, 128, "PQ16np", N_ITERATIONS);
     }
     {
-        using T = faiss::cppcontrib::IndexPQDecoder<128, 16>;
+        using T = knowherefaiss::cppcontrib::IndexPQDecoder<128, 16>;
         testIndexPQDecoder<T>(INDEX_SIZE, 128, "PQ8np", N_ITERATIONS);
     }
     {
-        using T = faiss::cppcontrib::IndexPQDecoder<128, 32>;
+        using T = knowherefaiss::cppcontrib::IndexPQDecoder<128, 32>;
         testIndexPQDecoder<T>(INDEX_SIZE, 128, "PQ4np", N_ITERATIONS);
     }
 
     // test PQx10
     {
-        using T = faiss::cppcontrib::IndexPQDecoder<128, 2, 10>;
+        using T = knowherefaiss::cppcontrib::IndexPQDecoder<128, 2, 10>;
         testIndexPQDecoder<T>(INDEX_SIZE, 128, "PQ64x10np", N_ITERATIONS);
     }
     {
-        using T = faiss::cppcontrib::IndexPQDecoder<128, 4, 10>;
+        using T = knowherefaiss::cppcontrib::IndexPQDecoder<128, 4, 10>;
         testIndexPQDecoder<T>(INDEX_SIZE, 128, "PQ32x10np", N_ITERATIONS);
     }
     {
-        using T = faiss::cppcontrib::IndexPQDecoder<128, 8, 10>;
+        using T = knowherefaiss::cppcontrib::IndexPQDecoder<128, 8, 10>;
         testIndexPQDecoder<T>(INDEX_SIZE, 128, "PQ16x10np", N_ITERATIONS);
     }
     {
-        using T = faiss::cppcontrib::IndexPQDecoder<128, 16, 10>;
+        using T = knowherefaiss::cppcontrib::IndexPQDecoder<128, 16, 10>;
         testIndexPQDecoder<T>(INDEX_SIZE, 128, "PQ8x10np", N_ITERATIONS);
     }
     {
-        using T = faiss::cppcontrib::IndexPQDecoder<128, 32, 10>;
+        using T = knowherefaiss::cppcontrib::IndexPQDecoder<128, 32, 10>;
         testIndexPQDecoder<T>(INDEX_SIZE, 128, "PQ4x10np", N_ITERATIONS);
     }
 
     // test MinMaxFP16,PQx8
     {
-        using SubT = faiss::cppcontrib::IndexPQDecoder<128, 2>;
-        using T = faiss::cppcontrib::IndexMinMaxFP16Decoder<SubT>;
+        using SubT = knowherefaiss::cppcontrib::IndexPQDecoder<128, 2>;
+        using T = knowherefaiss::cppcontrib::IndexMinMaxFP16Decoder<SubT>;
         testMinMaxIndexPQDecoder<T>(
                 INDEX_SIZE, 128, "MinMaxFP16,PQ64np", N_ITERATIONS);
     }
     {
-        using SubT = faiss::cppcontrib::IndexPQDecoder<128, 4>;
-        using T = faiss::cppcontrib::IndexMinMaxFP16Decoder<SubT>;
+        using SubT = knowherefaiss::cppcontrib::IndexPQDecoder<128, 4>;
+        using T = knowherefaiss::cppcontrib::IndexMinMaxFP16Decoder<SubT>;
         testMinMaxIndexPQDecoder<T>(
                 INDEX_SIZE, 128, "MinMaxFP16,PQ32np", N_ITERATIONS);
     }
     {
-        using SubT = faiss::cppcontrib::IndexPQDecoder<128, 8>;
-        using T = faiss::cppcontrib::IndexMinMaxFP16Decoder<SubT>;
+        using SubT = knowherefaiss::cppcontrib::IndexPQDecoder<128, 8>;
+        using T = knowherefaiss::cppcontrib::IndexMinMaxFP16Decoder<SubT>;
         testMinMaxIndexPQDecoder<T>(
                 INDEX_SIZE, 128, "MinMaxFP16,PQ16np", N_ITERATIONS);
     }
     {
-        using SubT = faiss::cppcontrib::IndexPQDecoder<128, 16>;
-        using T = faiss::cppcontrib::IndexMinMaxFP16Decoder<SubT>;
+        using SubT = knowherefaiss::cppcontrib::IndexPQDecoder<128, 16>;
+        using T = knowherefaiss::cppcontrib::IndexMinMaxFP16Decoder<SubT>;
         testMinMaxIndexPQDecoder<T>(
                 INDEX_SIZE, 128, "MinMaxFP16,PQ8np", N_ITERATIONS);
     }
     {
-        using SubT = faiss::cppcontrib::IndexPQDecoder<128, 32>;
-        using T = faiss::cppcontrib::IndexMinMaxFP16Decoder<SubT>;
+        using SubT = knowherefaiss::cppcontrib::IndexPQDecoder<128, 32>;
+        using T = knowherefaiss::cppcontrib::IndexMinMaxFP16Decoder<SubT>;
         testMinMaxIndexPQDecoder<T>(
                 INDEX_SIZE, 128, "MinMaxFP16,PQ4np", N_ITERATIONS);
     }
 
     // test IVFPQ
     {
-        using T = faiss::cppcontrib::Index2LevelDecoder<128, 128, 2>;
+        using T = knowherefaiss::cppcontrib::Index2LevelDecoder<128, 128, 2>;
         testIndex2LevelDecoder<T>(
                 INDEX_SIZE, 128, "IVF256,PQ64np", N_ITERATIONS);
     }
     {
-        using T = faiss::cppcontrib::Index2LevelDecoder<128, 128, 4>;
+        using T = knowherefaiss::cppcontrib::Index2LevelDecoder<128, 128, 4>;
         testIndex2LevelDecoder<T>(
                 INDEX_SIZE, 128, "IVF256,PQ32np", N_ITERATIONS);
     }
     {
-        using T = faiss::cppcontrib::Index2LevelDecoder<128, 128, 8>;
+        using T = knowherefaiss::cppcontrib::Index2LevelDecoder<128, 128, 8>;
         testIndex2LevelDecoder<T>(
                 INDEX_SIZE, 128, "IVF256,PQ16np", N_ITERATIONS);
     }
     {
-        using T = faiss::cppcontrib::Index2LevelDecoder<128, 128, 16>;
+        using T = knowherefaiss::cppcontrib::Index2LevelDecoder<128, 128, 16>;
         testIndex2LevelDecoder<T>(
                 INDEX_SIZE, 128, "IVF256,PQ8np", N_ITERATIONS);
     }
     {
-        using T = faiss::cppcontrib::Index2LevelDecoder<128, 128, 32>;
+        using T = knowherefaiss::cppcontrib::Index2LevelDecoder<128, 128, 32>;
         testIndex2LevelDecoder<T>(
                 INDEX_SIZE, 128, "IVF256,PQ4np", N_ITERATIONS);
     }
 
     // test Residual,PQ
     {
-        using T = faiss::cppcontrib::Index2LevelDecoder<128, 32, 2>;
+        using T = knowherefaiss::cppcontrib::Index2LevelDecoder<128, 32, 2>;
         testIndex2LevelDecoder<T>(
                 INDEX_SIZE, 128, "Residual4x8,PQ64", N_ITERATIONS);
     }
     {
-        using T = faiss::cppcontrib::Index2LevelDecoder<128, 32, 4>;
+        using T = knowherefaiss::cppcontrib::Index2LevelDecoder<128, 32, 4>;
         testIndex2LevelDecoder<T>(
                 INDEX_SIZE, 128, "Residual4x8,PQ32", N_ITERATIONS);
     }
     {
-        using T = faiss::cppcontrib::Index2LevelDecoder<128, 32, 8>;
+        using T = knowherefaiss::cppcontrib::Index2LevelDecoder<128, 32, 8>;
         testIndex2LevelDecoder<T>(
                 INDEX_SIZE, 128, "Residual4x8,PQ16", N_ITERATIONS);
     }
     {
-        using T = faiss::cppcontrib::Index2LevelDecoder<128, 32, 16>;
+        using T = knowherefaiss::cppcontrib::Index2LevelDecoder<128, 32, 16>;
         testIndex2LevelDecoder<T>(
                 INDEX_SIZE, 128, "Residual4x8,PQ8", N_ITERATIONS);
     }
     {
-        using T = faiss::cppcontrib::Index2LevelDecoder<128, 32, 32>;
+        using T = knowherefaiss::cppcontrib::Index2LevelDecoder<128, 32, 32>;
         testIndex2LevelDecoder<T>(
                 INDEX_SIZE, 128, "Residual4x8,PQ4", N_ITERATIONS);
     }
 
     // test MinMaxFP16,IVFPQ
     {
-        using SubT = faiss::cppcontrib::Index2LevelDecoder<128, 128, 2>;
-        using T = faiss::cppcontrib::IndexMinMaxFP16Decoder<SubT>;
+        using SubT = knowherefaiss::cppcontrib::Index2LevelDecoder<128, 128, 2>;
+        using T = knowherefaiss::cppcontrib::IndexMinMaxFP16Decoder<SubT>;
         testMinMaxIndex2LevelDecoder<T>(
                 INDEX_SIZE, 128, "MinMaxFP16,IVF256,PQ64np", N_ITERATIONS);
     }
     {
-        using SubT = faiss::cppcontrib::Index2LevelDecoder<128, 128, 4>;
-        using T = faiss::cppcontrib::IndexMinMaxFP16Decoder<SubT>;
+        using SubT = knowherefaiss::cppcontrib::Index2LevelDecoder<128, 128, 4>;
+        using T = knowherefaiss::cppcontrib::IndexMinMaxFP16Decoder<SubT>;
         testMinMaxIndex2LevelDecoder<T>(
                 INDEX_SIZE, 128, "MinMaxFP16,IVF256,PQ32np", N_ITERATIONS);
     }
     {
-        using SubT = faiss::cppcontrib::Index2LevelDecoder<128, 128, 8>;
-        using T = faiss::cppcontrib::IndexMinMaxFP16Decoder<SubT>;
+        using SubT = knowherefaiss::cppcontrib::Index2LevelDecoder<128, 128, 8>;
+        using T = knowherefaiss::cppcontrib::IndexMinMaxFP16Decoder<SubT>;
         testMinMaxIndex2LevelDecoder<T>(
                 INDEX_SIZE, 128, "MinMaxFP16,IVF256,PQ16np", N_ITERATIONS);
     }
     {
-        using SubT = faiss::cppcontrib::Index2LevelDecoder<128, 128, 16>;
-        using T = faiss::cppcontrib::IndexMinMaxFP16Decoder<SubT>;
+        using SubT = knowherefaiss::cppcontrib::Index2LevelDecoder<128, 128, 16>;
+        using T = knowherefaiss::cppcontrib::IndexMinMaxFP16Decoder<SubT>;
         testMinMaxIndex2LevelDecoder<T>(
                 INDEX_SIZE, 128, "MinMaxFP16,IVF256,PQ8np", N_ITERATIONS);
     }
     {
-        using SubT = faiss::cppcontrib::Index2LevelDecoder<128, 128, 32>;
-        using T = faiss::cppcontrib::IndexMinMaxFP16Decoder<SubT>;
+        using SubT = knowherefaiss::cppcontrib::Index2LevelDecoder<128, 128, 32>;
+        using T = knowherefaiss::cppcontrib::IndexMinMaxFP16Decoder<SubT>;
         testMinMaxIndex2LevelDecoder<T>(
                 INDEX_SIZE, 128, "MinMaxFP16,IVF256,PQ4np", N_ITERATIONS);
     }
 
     // test Residual,PQ with unusual bits
     {
-        using T = faiss::cppcontrib::Index2LevelDecoder<128, 128, 2, 16, 10>;
+        using T = knowherefaiss::cppcontrib::Index2LevelDecoder<128, 128, 2, 16, 10>;
         testIndex2LevelDecoder<T>(
                 INDEX_SIZE, 128, "Residual1x10,PQ64x10", N_ITERATIONS);
     }
     {
-        using T = faiss::cppcontrib::Index2LevelDecoder<128, 128, 4, 16, 10>;
+        using T = knowherefaiss::cppcontrib::Index2LevelDecoder<128, 128, 4, 16, 10>;
         testIndex2LevelDecoder<T>(
                 INDEX_SIZE, 128, "Residual1x10,PQ32x10", N_ITERATIONS);
     }
     {
-        using T = faiss::cppcontrib::Index2LevelDecoder<128, 128, 8, 16, 10>;
+        using T = knowherefaiss::cppcontrib::Index2LevelDecoder<128, 128, 8, 16, 10>;
         testIndex2LevelDecoder<T>(
                 INDEX_SIZE, 128, "Residual1x10,PQ16x10", N_ITERATIONS);
     }
     {
-        using T = faiss::cppcontrib::Index2LevelDecoder<128, 128, 16, 16, 10>;
+        using T = knowherefaiss::cppcontrib::Index2LevelDecoder<128, 128, 16, 16, 10>;
         testIndex2LevelDecoder<T>(
                 INDEX_SIZE, 128, "Residual1x10,PQ8x10", N_ITERATIONS);
     }
     {
-        using T = faiss::cppcontrib::Index2LevelDecoder<128, 128, 32, 16, 10>;
+        using T = knowherefaiss::cppcontrib::Index2LevelDecoder<128, 128, 32, 16, 10>;
         testIndex2LevelDecoder<T>(
                 INDEX_SIZE, 128, "Residual1x10,PQ4x10", N_ITERATIONS);
     }
diff --git a/thirdparty/faiss/benchs/bench_hamming_computer.cpp b/thirdparty/faiss/benchs/bench_hamming_computer.cpp
index 36da7a10..84651609 100644
--- a/thirdparty/faiss/benchs/bench_hamming_computer.cpp
+++ b/thirdparty/faiss/benchs/bench_hamming_computer.cpp
@@ -11,12 +11,12 @@
 
 #include <cinttypes>
 
-#include <faiss/impl/FaissAssert.h>
-#include <faiss/utils/hamming.h>
-#include <faiss/utils/random.h>
-#include <faiss/utils/utils.h>
+#include <knowherefaiss/impl/FaissAssert.h>
+#include <knowherefaiss/utils/hamming.h>
+#include <knowherefaiss/utils/random.h>
+#include <knowherefaiss/utils/utils.h>
 
-using namespace faiss;
+using namespace knowherefaiss;
 
 // These implementations are currently slower than HammingComputerDefault so
 // they are not in the main faiss anymore.
@@ -102,7 +102,7 @@ void hamming_func_test(
         uint64_t& xorv) {
     constexpr size_t CODE_SIZE_IN_BYTES = CODE_SIZE_IN_BITS / 8;
 
-    double t0 = faiss::getmillisecs();
+    double t0 = knowherefaiss::getmillisecs();
 
     uint64_t sumx = 0;
     uint64_t xorx = 0;
@@ -123,7 +123,7 @@ void hamming_func_test(
                     const uint64_t* data2_ptr =
                             (const uint64_t*)(x2 + j * CODE_SIZE_IN_BYTES);
 
-                    uint64_t code = faiss::hamming<CODE_SIZE_IN_BITS>(
+                    uint64_t code = knowherefaiss::hamming<CODE_SIZE_IN_BITS>(
                             data1_ptr, data2_ptr);
                     local_sum += code;
                     local_xor ^= code;
@@ -138,7 +138,7 @@ void hamming_func_test(
     sumv = sumx;
     xorv = xorx;
 
-    double t1 = faiss::getmillisecs();
+    double t1 = knowherefaiss::getmillisecs();
     printf("hamming<%d>: %.3f msec, %" PRIX64 ", %" PRIX64 "\n",
            CODE_SIZE_IN_BITS,
            (t1 - t0) / nruns,
@@ -156,7 +156,7 @@ void hamming_computer_test(
         uint64_t& xorv) {
     constexpr size_t CODE_SIZE_IN_BYTES = CODE_SIZE_IN_BITS / 8;
 
-    double t0 = faiss::getmillisecs();
+    double t0 = knowherefaiss::getmillisecs();
 
     uint64_t sumx = 0;
     uint64_t xorx = 0;
@@ -192,7 +192,7 @@ void hamming_computer_test(
     sumv = sumx;
     xorv = xorx;
 
-    double t1 = faiss::getmillisecs();
+    double t1 = knowherefaiss::getmillisecs();
     printf("HammingComputer<%zd>: %.3f msec, %" PRIX64 ", %" PRIX64 "\n",
            CODE_SIZE_IN_BYTES,
            (t1 - t0) / nruns,
@@ -281,34 +281,34 @@ int main() {
     hamming_func_test<512>(x1.data(), x2.data(), n1, n2, sumx, xorx);
 
     // evaluate various HammingComputerXX
-    hamming_computer_test<faiss::HammingComputer4, 32>(
+    hamming_computer_test<knowherefaiss::HammingComputer4, 32>(
             x1.data(), x2.data(), n1, n2, sumx, xorx);
-    hamming_computer_test<faiss::HammingComputer8, 64>(
+    hamming_computer_test<knowherefaiss::HammingComputer8, 64>(
             x1.data(), x2.data(), n1, n2, sumx, xorx);
-    hamming_computer_test<faiss::HammingComputer16, 128>(
+    hamming_computer_test<knowherefaiss::HammingComputer16, 128>(
             x1.data(), x2.data(), n1, n2, sumx, xorx);
-    hamming_computer_test<faiss::HammingComputer20, 160>(
+    hamming_computer_test<knowherefaiss::HammingComputer20, 160>(
             x1.data(), x2.data(), n1, n2, sumx, xorx);
-    hamming_computer_test<faiss::HammingComputer32, 256>(
+    hamming_computer_test<knowherefaiss::HammingComputer32, 256>(
             x1.data(), x2.data(), n1, n2, sumx, xorx);
-    hamming_computer_test<faiss::HammingComputer64, 512>(
+    hamming_computer_test<knowherefaiss::HammingComputer64, 512>(
             x1.data(), x2.data(), n1, n2, sumx, xorx);
 
     // evaluate various GenHammingDistanceComputerXX
-    hamming_computer_test<faiss::GenHammingComputer8, 64>(
+    hamming_computer_test<knowherefaiss::GenHammingComputer8, 64>(
             x1.data(), x2.data(), n1, n2, sumx, xorx);
-    hamming_computer_test<faiss::GenHammingComputer16, 128>(
+    hamming_computer_test<knowherefaiss::GenHammingComputer16, 128>(
             x1.data(), x2.data(), n1, n2, sumx, xorx);
-    hamming_computer_test<faiss::GenHammingComputer32, 256>(
+    hamming_computer_test<knowherefaiss::GenHammingComputer32, 256>(
             x1.data(), x2.data(), n1, n2, sumx, xorx);
 
-    hamming_computer_test<faiss::GenHammingComputerM8, 64>(
+    hamming_computer_test<knowherefaiss::GenHammingComputerM8, 64>(
             x1.data(), x2.data(), n1, n2, sumx, xorx);
-    hamming_computer_test<faiss::GenHammingComputerM8, 128>(
+    hamming_computer_test<knowherefaiss::GenHammingComputerM8, 128>(
             x1.data(), x2.data(), n1, n2, sumx, xorx);
-    hamming_computer_test<faiss::GenHammingComputerM8, 256>(
+    hamming_computer_test<knowherefaiss::GenHammingComputerM8, 256>(
             x1.data(), x2.data(), n1, n2, sumx, xorx);
-    hamming_computer_test<faiss::GenHammingComputerM8, 512>(
+    hamming_computer_test<knowherefaiss::GenHammingComputerM8, 512>(
             x1.data(), x2.data(), n1, n2, sumx, xorx);
 
     return 0;
diff --git a/thirdparty/faiss/benchs/bench_heap_replace.cpp b/thirdparty/faiss/benchs/bench_heap_replace.cpp
index d53b44be..0d31a994 100644
--- a/thirdparty/faiss/benchs/bench_heap_replace.cpp
+++ b/thirdparty/faiss/benchs/bench_heap_replace.cpp
@@ -8,12 +8,12 @@
 #include <omp.h>
 #include <cstdio>
 
-#include <faiss/impl/FaissAssert.h>
-#include <faiss/utils/Heap.h>
-#include <faiss/utils/random.h>
-#include <faiss/utils/utils.h>
+#include <knowherefaiss/impl/FaissAssert.h>
+#include <knowherefaiss/utils/Heap.h>
+#include <knowherefaiss/utils/random.h>
+#include <knowherefaiss/utils/utils.h>
 
-using namespace faiss;
+using namespace knowherefaiss;
 
 void addn_default(
         size_t n,
diff --git a/thirdparty/faiss/benchs/bench_hnsw_knowhere.cpp b/thirdparty/faiss/benchs/bench_hnsw_knowhere.cpp
index 09d70f14..f217f007 100644
--- a/thirdparty/faiss/benchs/bench_hnsw_knowhere.cpp
+++ b/thirdparty/faiss/benchs/bench_hnsw_knowhere.cpp
@@ -1,10 +1,10 @@
-#include <faiss/index_factory.h>
-#include <faiss/IndexFlat.h>
-#include <faiss/IndexHNSW.h>
-#include <faiss/impl/IDSelector.h>
+#include <knowherefaiss/index_factory.h>
+#include <knowherefaiss/IndexFlat.h>
+#include <knowherefaiss/IndexHNSW.h>
+#include <knowherefaiss/impl/IDSelector.h>
 
-#include <faiss/cppcontrib/knowhere/utils/Bitset.h>
-#include <faiss/cppcontrib/knowhere/IndexHNSWWrapper.cpp>
+#include <knowherefaiss/cppcontrib/knowhere/utils/Bitset.h>
+#include <knowherefaiss/cppcontrib/knowhere/IndexHNSWWrapper.cpp>
 
 #include <algorithm>
 #include <chrono>
@@ -30,12 +30,12 @@ std::vector<float> generate_dataset(const size_t n, const size_t d, uint64_t see
 float get_recall_rate(
     const size_t nq,
     const size_t k,
-    const std::vector<faiss::idx_t>& baseline, 
-    const std::vector<faiss::idx_t>& candidate
+    const std::vector<knowherefaiss::idx_t>& baseline, 
+    const std::vector<knowherefaiss::idx_t>& candidate
 ) {
     size_t n = 0;
     for (size_t i = 0; i < nq; i++) {
-        std::unordered_set<faiss::idx_t> a_set(k * 4);
+        std::unordered_set<knowherefaiss::idx_t> a_set(k * 4);
         
         for (size_t j = 0; j < k; j++) {
             a_set.insert(baseline[i * k + j]);
@@ -72,15 +72,15 @@ void test(const size_t nt, const size_t d, const size_t nq, const size_t k) {
     std::vector<float> xt = generate_dataset(nt, d, 123);
 
     // create an baseline
-    std::unique_ptr<faiss::Index> baseline_index(
-        faiss::index_factory(d, "Flat", faiss::MetricType::METRIC_L2)
+    std::unique_ptr<knowherefaiss::Index> baseline_index(
+        knowherefaiss::index_factory(d, "Flat", knowherefaiss::MetricType::METRIC_L2)
     );
     baseline_index->train(nt, xt.data());
     baseline_index->add(nt, xt.data());
 
     // create an hnsw index
-    std::unique_ptr<faiss::Index> hnsw_index(
-        faiss::index_factory(d, "HNSW32,Flat", faiss::MetricType::METRIC_L2)
+    std::unique_ptr<knowherefaiss::Index> hnsw_index(
+        knowherefaiss::index_factory(d, "HNSW32,Flat", knowherefaiss::MetricType::METRIC_L2)
     );
     hnsw_index->train(nt, xt.data());
     hnsw_index->add(nt, xt.data());
@@ -103,23 +103,23 @@ void test(const size_t nt, const size_t d, const size_t nq, const size_t k) {
         const size_t nt_real = size_t(std::max(1.0, nt - (nt * percent / 100.0)));
 
         // create a bitset
-        faiss::cppcontrib::knowhere::Bitset bitset = 
-            faiss::cppcontrib::knowhere::Bitset::create_cleared(nt);
+        knowherefaiss::cppcontrib::knowhere::Bitset bitset = 
+            knowherefaiss::cppcontrib::knowhere::Bitset::create_cleared(nt);
         for (size_t i = 0; i < nt_real; i++) {
             bitset.set(ids_to_use[i]);
         }
 
         // create an IDSelector
-        faiss::IDSelectorBitmap sel(nt, bitset.bits.get());
+        knowherefaiss::IDSelectorBitmap sel(nt, bitset.bits.get());
 
         // the quant of a search
         const size_t nbatch = nq;
 
         // perform a baseline search
         std::vector<float> baseline_dis(k * nq, -1);
-        std::vector<faiss::idx_t> baseline_ids(k * nq, -1);
+        std::vector<knowherefaiss::idx_t> baseline_ids(k * nq, -1);
 
-        faiss::SearchParameters baseline_params;
+        knowherefaiss::SearchParameters baseline_params;
         baseline_params.sel = &sel;
 
         StopWatch sw_baseline;
@@ -139,9 +139,9 @@ void test(const size_t nt, const size_t d, const size_t nq, const size_t k) {
 
         // perform an hnsw search
         std::vector<float> hnsw_dis(k * nq, -1);
-        std::vector<faiss::idx_t> hnsw_ids(k * nq, -1);
+        std::vector<knowherefaiss::idx_t> hnsw_ids(k * nq, -1);
 
-        faiss::SearchParametersHNSW hnsw_params;
+        knowherefaiss::SearchParametersHNSW hnsw_params;
         hnsw_params.sel = &sel;
         hnsw_params.efSearch = 64;
 
@@ -163,15 +163,15 @@ void test(const size_t nt, const size_t d, const size_t nq, const size_t k) {
 
         // perform a cppcontrib/knowhere search
         std::vector<float> hnsw_candidate_dis(k * nq, -1);
-        std::vector<faiss::idx_t> hnsw_candidate_ids(k * nq, -1);
+        std::vector<knowherefaiss::idx_t> hnsw_candidate_ids(k * nq, -1);
 
-        faiss::cppcontrib::knowhere::SearchParametersHNSWWrapper hnsw_candidate_params;
+        knowherefaiss::cppcontrib::knowhere::SearchParametersHNSWWrapper hnsw_candidate_params;
         hnsw_candidate_params.sel = &sel;
         hnsw_candidate_params.kAlpha = ((float)nt_real / nt) * 0.7f;
         hnsw_candidate_params.efSearch = 64;
 
-        faiss::cppcontrib::knowhere::IndexHNSWWrapper wrapper(
-            dynamic_cast<faiss::IndexHNSW*>(hnsw_index.get()));
+        knowherefaiss::cppcontrib::knowhere::IndexHNSWWrapper wrapper(
+            dynamic_cast<knowherefaiss::IndexHNSW*>(hnsw_index.get()));
 
         StopWatch sw_hnsw_candidate;
         for (size_t p = 0; p < nq; p += nbatch) {
diff --git a/thirdparty/faiss/benchs/bench_ivf_selector.cpp b/thirdparty/faiss/benchs/bench_ivf_selector.cpp
index 6610ce1c..5ed103fb 100644
--- a/thirdparty/faiss/benchs/bench_ivf_selector.cpp
+++ b/thirdparty/faiss/benchs/bench_ivf_selector.cpp
@@ -9,13 +9,13 @@
 #include <unistd.h>
 #include <memory>
 
-#include <faiss/IVFlib.h>
-#include <faiss/IndexIVF.h>
-#include <faiss/impl/IDSelector.h>
-#include <faiss/index_factory.h>
-#include <faiss/index_io.h>
-#include <faiss/utils/random.h>
-#include <faiss/utils/utils.h>
+#include <knowherefaiss/IVFlib.h>
+#include <knowherefaiss/IndexIVF.h>
+#include <knowherefaiss/impl/IDSelector.h>
+#include <knowherefaiss/index_factory.h>
+#include <knowherefaiss/index_io.h>
+#include <knowherefaiss/utils/random.h>
+#include <knowherefaiss/utils/utils.h>
 
 /************************
  * This benchmark attempts to measure the runtime overhead to use an IDSelector
@@ -25,7 +25,7 @@
  */
 
 int main() {
-    using idx_t = faiss::idx_t;
+    using idx_t = knowherefaiss::idx_t;
     int d = 64;
     size_t nb = 1024 * 1024;
     size_t nq = 512 * 16;
@@ -33,9 +33,9 @@ int main() {
     std::vector<float> data((nb + nq) * d);
     float* xb = data.data();
     float* xq = data.data() + nb * d;
-    faiss::rand_smooth_vectors(nb + nq, d, data.data(), 1234);
+    knowherefaiss::rand_smooth_vectors(nb + nq, d, data.data(), 1234);
 
-    std::unique_ptr<faiss::Index> index;
+    std::unique_ptr<knowherefaiss::Index> index;
     // const char *index_key = "IVF1024,Flat";
     const char* index_key = "IVF1024,SQ8";
     printf("index_key=%s\n", index_key);
@@ -44,20 +44,20 @@ int main() {
 
     if (access(stored_name.c_str(), F_OK) != 0) {
         printf("creating index\n");
-        index.reset(faiss::index_factory(d, index_key));
+        index.reset(knowherefaiss::index_factory(d, index_key));
 
-        double t0 = faiss::getmillisecs();
+        double t0 = knowherefaiss::getmillisecs();
         index->train(nb, xb);
-        double t1 = faiss::getmillisecs();
+        double t1 = knowherefaiss::getmillisecs();
         index->add(nb, xb);
-        double t2 = faiss::getmillisecs();
+        double t2 = knowherefaiss::getmillisecs();
         printf("Write %s\n", stored_name.c_str());
-        faiss::write_index(index.get(), stored_name.c_str());
+        knowherefaiss::write_index(index.get(), stored_name.c_str());
     } else {
         printf("Read %s\n", stored_name.c_str());
-        index.reset(faiss::read_index(stored_name.c_str()));
+        index.reset(knowherefaiss::read_index(stored_name.c_str()));
     }
-    faiss::IndexIVF* index_ivf = static_cast<faiss::IndexIVF*>(index.get());
+    knowherefaiss::IndexIVF* index_ivf = static_cast<knowherefaiss::IndexIVF*>(index.get());
     index->verbose = true;
 
     for (int tt = 0; tt < 3; tt++) {
@@ -76,9 +76,9 @@ int main() {
         std::vector<float> D1(nq * k);
         std::vector<idx_t> I1(nq * k);
         {
-            double t2 = faiss::getmillisecs();
+            double t2 = knowherefaiss::getmillisecs();
             index->search(nq, xq, k, D1.data(), I1.data());
-            double t3 = faiss::getmillisecs();
+            double t3 = knowherefaiss::getmillisecs();
 
             printf("search time, no selector: %.3f ms\n", t3 - t2);
         }
@@ -86,26 +86,26 @@ int main() {
         std::vector<float> D2(nq * k);
         std::vector<idx_t> I2(nq * k);
         {
-            double t2 = faiss::getmillisecs();
-            faiss::IVFSearchParameters params;
+            double t2 = knowherefaiss::getmillisecs();
+            knowherefaiss::IVFSearchParameters params;
 
-            faiss::ivflib::search_with_parameters(
+            knowherefaiss::ivflib::search_with_parameters(
                     index.get(), nq, xq, k, D2.data(), I2.data(), &params);
-            double t3 = faiss::getmillisecs();
+            double t3 = knowherefaiss::getmillisecs();
             printf("search time with nullptr selector: %.3f ms\n", t3 - t2);
         }
         FAISS_THROW_IF_NOT(I1 == I2);
         FAISS_THROW_IF_NOT(D1 == D2);
 
         {
-            double t2 = faiss::getmillisecs();
-            faiss::IVFSearchParameters params;
-            faiss::IDSelectorAll sel;
+            double t2 = knowherefaiss::getmillisecs();
+            knowherefaiss::IVFSearchParameters params;
+            knowherefaiss::IDSelectorAll sel;
             params.sel = &sel;
 
-            faiss::ivflib::search_with_parameters(
+            knowherefaiss::ivflib::search_with_parameters(
                     index.get(), nq, xq, k, D2.data(), I2.data(), &params);
-            double t3 = faiss::getmillisecs();
+            double t3 = knowherefaiss::getmillisecs();
             printf("search time with selector: %.3f ms\n", t3 - t2);
         }
         FAISS_THROW_IF_NOT(I1 == I2);
@@ -115,15 +115,15 @@ int main() {
         std::vector<idx_t> I3(nq * k);
         {
             int nt = omp_get_max_threads();
-            double t2 = faiss::getmillisecs();
-            faiss::IVFSearchParameters params;
+            double t2 = knowherefaiss::getmillisecs();
+            knowherefaiss::IVFSearchParameters params;
 
 #pragma omp parallel for if (nt > 1)
             for (idx_t slice = 0; slice < nt; slice++) {
                 idx_t i0 = nq * slice / nt;
                 idx_t i1 = nq * (slice + 1) / nt;
                 if (i1 > i0) {
-                    faiss::ivflib::search_with_parameters(
+                    knowherefaiss::ivflib::search_with_parameters(
                             index.get(),
                             i1 - i0,
                             xq + i0 * d,
@@ -133,7 +133,7 @@ int main() {
                             &params);
                 }
             }
-            double t3 = faiss::getmillisecs();
+            double t3 = knowherefaiss::getmillisecs();
             printf("search time with null selector + manual parallel: %.3f ms\n",
                    t3 - t2);
         }
diff --git a/thirdparty/faiss/c_api/AutoTune_c.cpp b/thirdparty/faiss/c_api/AutoTune_c.cpp
index 5c1a0379..c0f29d40 100644
--- a/thirdparty/faiss/c_api/AutoTune_c.cpp
+++ b/thirdparty/faiss/c_api/AutoTune_c.cpp
@@ -9,13 +9,13 @@
 // -*- c++ -*-
 
 #include "AutoTune_c.h"
-#include <faiss/AutoTune.h>
+#include <knowherefaiss/AutoTune.h>
 #include <cstring>
 #include "macros_impl.h"
 
-using faiss::Index;
-using faiss::ParameterRange;
-using faiss::ParameterSpace;
+using knowherefaiss::Index;
+using knowherefaiss::ParameterRange;
+using knowherefaiss::ParameterSpace;
 
 const char* faiss_ParameterRange_name(const FaissParameterRange* range) {
     return reinterpret_cast<const ParameterRange*>(range)->name.c_str();
diff --git a/thirdparty/faiss/c_api/CMakeLists.txt b/thirdparty/faiss/c_api/CMakeLists.txt
index 3111a53c..b2af4d36 100644
--- a/thirdparty/faiss/c_api/CMakeLists.txt
+++ b/thirdparty/faiss/c_api/CMakeLists.txt
@@ -37,7 +37,7 @@ function(faiss_install_headers headers p)
   foreach(h ${headers})
     get_filename_component(f ${h} DIRECTORY)
     install(FILES ${h}
-      DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}/faiss/${p}/${f}
+      DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}/knowherefaiss/${p}/${f}
     )
   endforeach()
 endfunction()
diff --git a/thirdparty/faiss/c_api/Clustering_c.cpp b/thirdparty/faiss/c_api/Clustering_c.cpp
index 2206f6d5..1f3176dd 100644
--- a/thirdparty/faiss/c_api/Clustering_c.cpp
+++ b/thirdparty/faiss/c_api/Clustering_c.cpp
@@ -9,17 +9,17 @@
 // -*- c++ -*-
 
 #include "Clustering_c.h"
-#include <faiss/Clustering.h>
-#include <faiss/Index.h>
+#include <knowherefaiss/Clustering.h>
+#include <knowherefaiss/Index.h>
 #include <vector>
 #include "macros_impl.h"
 
 extern "C" {
 
-using faiss::Clustering;
-using faiss::ClusteringIterationStats;
-using faiss::ClusteringParameters;
-using faiss::Index;
+using knowherefaiss::Clustering;
+using knowherefaiss::ClusteringIterationStats;
+using knowherefaiss::ClusteringParameters;
+using knowherefaiss::Index;
 
 DEFINE_GETTER(Clustering, int, niter)
 DEFINE_GETTER(Clustering, int, nredo)
@@ -160,7 +160,7 @@ int faiss_kmeans_clustering(
         float* centroids,
         float* q_error) {
     try {
-        float out = faiss::kmeans_clustering(d, n, k, x, centroids);
+        float out = knowherefaiss::kmeans_clustering(d, n, k, x, centroids);
         if (q_error) {
             *q_error = out;
         }
diff --git a/thirdparty/faiss/c_api/IndexFlat_c.cpp b/thirdparty/faiss/c_api/IndexFlat_c.cpp
index 2d0cbb6d..24483c51 100644
--- a/thirdparty/faiss/c_api/IndexFlat_c.cpp
+++ b/thirdparty/faiss/c_api/IndexFlat_c.cpp
@@ -9,18 +9,18 @@
 // -*- c++ -*-
 
 #include "IndexFlat_c.h"
-#include <faiss/IndexFlat.h>
-#include <faiss/IndexRefine.h>
+#include <knowherefaiss/IndexFlat.h>
+#include <knowherefaiss/IndexRefine.h>
 #include "macros_impl.h"
 
 extern "C" {
 
-using faiss::Index;
-using faiss::IndexFlat;
-using faiss::IndexFlat1D;
-using faiss::IndexFlatIP;
-using faiss::IndexFlatL2;
-using faiss::IndexRefineFlat;
+using knowherefaiss::Index;
+using knowherefaiss::IndexFlat;
+using knowherefaiss::IndexFlat1D;
+using knowherefaiss::IndexFlatIP;
+using knowherefaiss::IndexFlatL2;
+using knowherefaiss::IndexRefineFlat;
 
 DEFINE_DESTRUCTOR(IndexFlat)
 DEFINE_INDEX_DOWNCAST(IndexFlat)
@@ -39,7 +39,7 @@ int faiss_IndexFlat_new_with(
         FaissMetricType metric) {
     try {
         IndexFlat* index =
-                new IndexFlat(d, static_cast<faiss::MetricType>(metric));
+                new IndexFlat(d, static_cast<knowherefaiss::MetricType>(metric));
         *p_index = reinterpret_cast<FaissIndexFlat*>(index);
         return 0;
     }
@@ -116,7 +116,7 @@ int faiss_IndexRefineFlat_new(
         FaissIndex* base_index) {
     try {
         IndexRefineFlat* index = new IndexRefineFlat(
-                reinterpret_cast<faiss::Index*>(base_index));
+                reinterpret_cast<knowherefaiss::Index*>(base_index));
         *p_index = reinterpret_cast<FaissIndexRefineFlat*>(index);
         return 0;
     }
diff --git a/thirdparty/faiss/c_api/IndexIVFFlat_c.cpp b/thirdparty/faiss/c_api/IndexIVFFlat_c.cpp
index 69f113aa..4bcfdc13 100644
--- a/thirdparty/faiss/c_api/IndexIVFFlat_c.cpp
+++ b/thirdparty/faiss/c_api/IndexIVFFlat_c.cpp
@@ -9,14 +9,14 @@
 // -*- c++ -*-
 
 #include "IndexIVFFlat_c.h"
-#include <faiss/IndexIVFFlat.h>
+#include <knowherefaiss/IndexIVFFlat.h>
 #include "Clustering_c.h"
 #include "Index_c.h"
 #include "macros_impl.h"
 
-using faiss::Index;
-using faiss::IndexIVFFlat;
-using faiss::MetricType;
+using knowherefaiss::Index;
+using knowherefaiss::IndexIVFFlat;
+using knowherefaiss::MetricType;
 
 DEFINE_DESTRUCTOR(IndexIVFFlat)
 DEFINE_INDEX_DOWNCAST(IndexIVFFlat)
diff --git a/thirdparty/faiss/c_api/IndexIVF_c.cpp b/thirdparty/faiss/c_api/IndexIVF_c.cpp
index 768a3d8d..f629b1a7 100644
--- a/thirdparty/faiss/c_api/IndexIVF_c.cpp
+++ b/thirdparty/faiss/c_api/IndexIVF_c.cpp
@@ -9,13 +9,13 @@
 // -*- c++ -*-
 
 #include "IndexIVF_c.h"
-#include <faiss/IndexIVF.h>
+#include <knowherefaiss/IndexIVF.h>
 #include "Clustering_c.h"
 #include "Index_c.h"
 #include "macros_impl.h"
 
-using faiss::IndexIVF;
-using faiss::IndexIVFStats;
+using knowherefaiss::IndexIVF;
+using knowherefaiss::IndexIVFStats;
 
 DEFINE_DESTRUCTOR(IndexIVF)
 DEFINE_INDEX_DOWNCAST(IndexIVF)
@@ -40,7 +40,7 @@ DEFINE_GETTER(IndexIVF, char, quantizer_trains_alone)
 DEFINE_GETTER(IndexIVF, int, own_fields)
 DEFINE_SETTER(IndexIVF, int, own_fields)
 
-using faiss::IndexIVF;
+using knowherefaiss::IndexIVF;
 
 int faiss_IndexIVF_merge_from(
         FaissIndexIVF* index,
@@ -127,5 +127,5 @@ void faiss_IndexIVFStats_reset(FaissIndexIVFStats* stats) {
 }
 
 FaissIndexIVFStats* faiss_get_indexIVF_stats() {
-    return reinterpret_cast<FaissIndexIVFStats*>(&faiss::indexIVF_stats);
+    return reinterpret_cast<FaissIndexIVFStats*>(&knowherefaiss::indexIVF_stats);
 }
diff --git a/thirdparty/faiss/c_api/IndexLSH_c.cpp b/thirdparty/faiss/c_api/IndexLSH_c.cpp
index b63d967a..21d61c93 100644
--- a/thirdparty/faiss/c_api/IndexLSH_c.cpp
+++ b/thirdparty/faiss/c_api/IndexLSH_c.cpp
@@ -9,11 +9,11 @@
 // -*- c++ -*-
 
 #include "IndexLSH_c.h"
-#include <faiss/IndexLSH.h>
+#include <knowherefaiss/IndexLSH.h>
 #include "macros_impl.h"
 
-using faiss::Index;
-using faiss::IndexLSH;
+using knowherefaiss::Index;
+using knowherefaiss::IndexLSH;
 
 DEFINE_DESTRUCTOR(IndexLSH)
 DEFINE_INDEX_DOWNCAST(IndexLSH)
diff --git a/thirdparty/faiss/c_api/IndexPreTransform_c.cpp b/thirdparty/faiss/c_api/IndexPreTransform_c.cpp
index 5930eb12..4eef521e 100644
--- a/thirdparty/faiss/c_api/IndexPreTransform_c.cpp
+++ b/thirdparty/faiss/c_api/IndexPreTransform_c.cpp
@@ -9,13 +9,13 @@
 // -*- c++ -*-
 
 #include "IndexPreTransform_c.h"
-#include <faiss/IndexPreTransform.h>
-#include <faiss/VectorTransform.h>
+#include <knowherefaiss/IndexPreTransform.h>
+#include <knowherefaiss/VectorTransform.h>
 #include "macros_impl.h"
 
-using faiss::Index;
-using faiss::IndexPreTransform;
-using faiss::VectorTransform;
+using knowherefaiss::Index;
+using knowherefaiss::IndexPreTransform;
+using knowherefaiss::VectorTransform;
 
 extern "C" {
 
diff --git a/thirdparty/faiss/c_api/IndexReplicas_c.cpp b/thirdparty/faiss/c_api/IndexReplicas_c.cpp
index 37b42a50..d7314ead 100644
--- a/thirdparty/faiss/c_api/IndexReplicas_c.cpp
+++ b/thirdparty/faiss/c_api/IndexReplicas_c.cpp
@@ -6,11 +6,11 @@
  */
 
 #include "IndexReplicas_c.h"
-#include <faiss/IndexReplicas.h>
+#include <knowherefaiss/IndexReplicas.h>
 #include "macros_impl.h"
 
-using faiss::Index;
-using faiss::IndexReplicas;
+using knowherefaiss::Index;
+using knowherefaiss::IndexReplicas;
 
 DEFINE_DESTRUCTOR(IndexReplicas)
 
diff --git a/thirdparty/faiss/c_api/IndexScalarQuantizer_c.cpp b/thirdparty/faiss/c_api/IndexScalarQuantizer_c.cpp
index 5c00e342..41c63e88 100644
--- a/thirdparty/faiss/c_api/IndexScalarQuantizer_c.cpp
+++ b/thirdparty/faiss/c_api/IndexScalarQuantizer_c.cpp
@@ -9,13 +9,13 @@
 // -*- c++ -*-
 
 #include "IndexScalarQuantizer_c.h"
-#include <faiss/IndexScalarQuantizer.h>
-#include <faiss/impl/ScalarQuantizer.h>
+#include <knowherefaiss/IndexScalarQuantizer.h>
+#include <knowherefaiss/impl/ScalarQuantizer.h>
 #include "macros_impl.h"
 
-using faiss::Index;
-using faiss::IndexIVFScalarQuantizer;
-using faiss::IndexScalarQuantizer;
+using knowherefaiss::Index;
+using knowherefaiss::IndexIVFScalarQuantizer;
+using knowherefaiss::IndexScalarQuantizer;
 
 DEFINE_DESTRUCTOR(IndexScalarQuantizer)
 DEFINE_INDEX_DOWNCAST(IndexScalarQuantizer)
@@ -36,8 +36,8 @@ int faiss_IndexScalarQuantizer_new_with(
     try {
         IndexScalarQuantizer* index = new IndexScalarQuantizer(
                 d,
-                static_cast<faiss::ScalarQuantizer::QuantizerType>(qt),
-                static_cast<faiss::MetricType>(metric));
+                static_cast<knowherefaiss::ScalarQuantizer::QuantizerType>(qt),
+                static_cast<knowherefaiss::MetricType>(metric));
         *p_index = reinterpret_cast<FaissIndexScalarQuantizer*>(index);
         return 0;
     }
@@ -68,7 +68,7 @@ int faiss_IndexIVFScalarQuantizer_new_with(
         FaissQuantizerType qt) {
     try {
         auto q = reinterpret_cast<Index*>(quantizer);
-        auto qt_ = static_cast<faiss::ScalarQuantizer::QuantizerType>(qt);
+        auto qt_ = static_cast<knowherefaiss::ScalarQuantizer::QuantizerType>(qt);
         IndexIVFScalarQuantizer* index =
                 new IndexIVFScalarQuantizer(q, d, nlist, qt_);
         *p_index = reinterpret_cast<FaissIndexIVFScalarQuantizer*>(index);
@@ -87,9 +87,9 @@ int faiss_IndexIVFScalarQuantizer_new_with_metric(
         int encode_residual) {
     try {
         auto q = reinterpret_cast<Index*>(quantizer);
-        auto mt = static_cast<faiss::MetricType>(metric);
+        auto mt = static_cast<knowherefaiss::MetricType>(metric);
         auto er = static_cast<bool>(encode_residual);
-        auto qt_ = static_cast<faiss::ScalarQuantizer::QuantizerType>(qt);
+        auto qt_ = static_cast<knowherefaiss::ScalarQuantizer::QuantizerType>(qt);
         IndexIVFScalarQuantizer* index =
                 new IndexIVFScalarQuantizer(q, d, nlist, qt_, mt, er);
         *p_index = reinterpret_cast<FaissIndexIVFScalarQuantizer*>(index);
diff --git a/thirdparty/faiss/c_api/IndexShards_c.cpp b/thirdparty/faiss/c_api/IndexShards_c.cpp
index e4d2c47d..adb8c4fb 100644
--- a/thirdparty/faiss/c_api/IndexShards_c.cpp
+++ b/thirdparty/faiss/c_api/IndexShards_c.cpp
@@ -6,11 +6,11 @@
  */
 
 #include "IndexShards_c.h"
-#include <faiss/IndexShards.h>
+#include <knowherefaiss/IndexShards.h>
 #include "macros_impl.h"
 
-using faiss::Index;
-using faiss::IndexShards;
+using knowherefaiss::Index;
+using knowherefaiss::IndexShards;
 
 DEFINE_DESTRUCTOR(IndexShards)
 
diff --git a/thirdparty/faiss/c_api/Index_c.cpp b/thirdparty/faiss/c_api/Index_c.cpp
index 4b44e6cd..ea849cdc 100644
--- a/thirdparty/faiss/c_api/Index_c.cpp
+++ b/thirdparty/faiss/c_api/Index_c.cpp
@@ -9,7 +9,7 @@
 // -*- c++ -*-
 
 #include "Index_c.h"
-#include <faiss/Index.h>
+#include <knowherefaiss/Index.h>
 #include "macros_impl.h"
 
 extern "C" {
@@ -29,14 +29,14 @@ DEFINE_SETTER(Index, int, verbose);
 
 int faiss_Index_train(FaissIndex* index, idx_t n, const float* x) {
     try {
-        reinterpret_cast<faiss::Index*>(index)->train(n, x);
+        reinterpret_cast<knowherefaiss::Index*>(index)->train(n, x);
     }
     CATCH_AND_HANDLE
 }
 
 int faiss_Index_add(FaissIndex* index, idx_t n, const float* x) {
     try {
-        reinterpret_cast<faiss::Index*>(index)->add(n, x);
+        reinterpret_cast<knowherefaiss::Index*>(index)->add(n, x);
     }
     CATCH_AND_HANDLE
 }
@@ -47,7 +47,7 @@ int faiss_Index_add_with_ids(
         const float* x,
         const idx_t* xids) {
     try {
-        reinterpret_cast<faiss::Index*>(index)->add_with_ids(n, x, xids);
+        reinterpret_cast<knowherefaiss::Index*>(index)->add_with_ids(n, x, xids);
     }
     CATCH_AND_HANDLE
 }
@@ -60,7 +60,7 @@ int faiss_Index_search(
         float* distances,
         idx_t* labels) {
     try {
-        reinterpret_cast<const faiss::Index*>(index)->search(
+        reinterpret_cast<const knowherefaiss::Index*>(index)->search(
                 n, x, k, distances, labels);
     }
     CATCH_AND_HANDLE
@@ -73,11 +73,11 @@ int faiss_Index_range_search(
         float radius,
         FaissRangeSearchResult* result) {
     try {
-        reinterpret_cast<const faiss::Index*>(index)->range_search(
+        reinterpret_cast<const knowherefaiss::Index*>(index)->range_search(
                 n,
                 x,
                 radius,
-                reinterpret_cast<faiss::RangeSearchResult*>(result));
+                reinterpret_cast<knowherefaiss::RangeSearchResult*>(result));
     }
     CATCH_AND_HANDLE
 }
@@ -89,14 +89,14 @@ int faiss_Index_assign(
         idx_t* labels,
         idx_t k) {
     try {
-        reinterpret_cast<faiss::Index*>(index)->assign(n, x, labels, k);
+        reinterpret_cast<knowherefaiss::Index*>(index)->assign(n, x, labels, k);
     }
     CATCH_AND_HANDLE
 }
 
 int faiss_Index_reset(FaissIndex* index) {
     try {
-        reinterpret_cast<faiss::Index*>(index)->reset();
+        reinterpret_cast<knowherefaiss::Index*>(index)->reset();
     }
     CATCH_AND_HANDLE
 }
@@ -106,8 +106,8 @@ int faiss_Index_remove_ids(
         const FaissIDSelector* sel,
         size_t* n_removed) {
     try {
-        size_t n{reinterpret_cast<faiss::Index*>(index)->remove_ids(
-                *reinterpret_cast<const faiss::IDSelector*>(sel))};
+        size_t n{reinterpret_cast<knowherefaiss::Index*>(index)->remove_ids(
+                *reinterpret_cast<const knowherefaiss::IDSelector*>(sel))};
         if (n_removed) {
             *n_removed = n;
         }
@@ -117,7 +117,7 @@ int faiss_Index_remove_ids(
 
 int faiss_Index_reconstruct(const FaissIndex* index, idx_t key, float* recons) {
     try {
-        reinterpret_cast<const faiss::Index*>(index)->reconstruct(key, recons);
+        reinterpret_cast<const knowherefaiss::Index*>(index)->reconstruct(key, recons);
     }
     CATCH_AND_HANDLE
 }
@@ -128,7 +128,7 @@ int faiss_Index_reconstruct_n(
         idx_t ni,
         float* recons) {
     try {
-        reinterpret_cast<const faiss::Index*>(index)->reconstruct_n(
+        reinterpret_cast<const knowherefaiss::Index*>(index)->reconstruct_n(
                 i0, ni, recons);
     }
     CATCH_AND_HANDLE
@@ -140,7 +140,7 @@ int faiss_Index_compute_residual(
         float* residual,
         idx_t key) {
     try {
-        reinterpret_cast<const faiss::Index*>(index)->compute_residual(
+        reinterpret_cast<const knowherefaiss::Index*>(index)->compute_residual(
                 x, residual, key);
     }
     CATCH_AND_HANDLE
@@ -153,7 +153,7 @@ int faiss_Index_compute_residual_n(
         float* residuals,
         const idx_t* keys) {
     try {
-        reinterpret_cast<const faiss::Index*>(index)->compute_residual_n(
+        reinterpret_cast<const knowherefaiss::Index*>(index)->compute_residual_n(
                 n, x, residuals, keys);
     }
     CATCH_AND_HANDLE
diff --git a/thirdparty/faiss/c_api/MetaIndexes_c.cpp b/thirdparty/faiss/c_api/MetaIndexes_c.cpp
index 3b535797..e371da79 100644
--- a/thirdparty/faiss/c_api/MetaIndexes_c.cpp
+++ b/thirdparty/faiss/c_api/MetaIndexes_c.cpp
@@ -9,12 +9,12 @@
 // -*- c++ -*-
 
 #include "MetaIndexes_c.h"
-#include <faiss/MetaIndexes.h>
+#include <knowherefaiss/MetaIndexes.h>
 #include "macros_impl.h"
 
-using faiss::Index;
-using faiss::IndexIDMap;
-using faiss::IndexIDMap2;
+using knowherefaiss::Index;
+using knowherefaiss::IndexIDMap;
+using knowherefaiss::IndexIDMap2;
 
 DEFINE_GETTER(IndexIDMap, int, own_fields)
 DEFINE_SETTER(IndexIDMap, int, own_fields)
diff --git a/thirdparty/faiss/c_api/VectorTransform_c.cpp b/thirdparty/faiss/c_api/VectorTransform_c.cpp
index 43047057..bc0779da 100644
--- a/thirdparty/faiss/c_api/VectorTransform_c.cpp
+++ b/thirdparty/faiss/c_api/VectorTransform_c.cpp
@@ -9,7 +9,7 @@
 // -*- c++ -*-
 
 #include "VectorTransform_c.h"
-#include <faiss/VectorTransform.h>
+#include <knowherefaiss/VectorTransform.h>
 #include "macros_impl.h"
 
 extern "C" {
@@ -27,7 +27,7 @@ int faiss_VectorTransform_train(
         idx_t n,
         const float* x) {
     try {
-        reinterpret_cast<faiss::VectorTransform*>(vt)->train(n, x);
+        reinterpret_cast<knowherefaiss::VectorTransform*>(vt)->train(n, x);
     }
     CATCH_AND_HANDLE
 }
@@ -36,7 +36,7 @@ float* faiss_VectorTransform_apply(
         const FaissVectorTransform* vt,
         idx_t n,
         const float* x) {
-    return reinterpret_cast<const faiss::VectorTransform*>(vt)->apply(n, x);
+    return reinterpret_cast<const knowherefaiss::VectorTransform*>(vt)->apply(n, x);
 }
 
 void faiss_VectorTransform_apply_noalloc(
@@ -44,7 +44,7 @@ void faiss_VectorTransform_apply_noalloc(
         idx_t n,
         const float* x,
         float* xt) {
-    return reinterpret_cast<const faiss::VectorTransform*>(vt)->apply_noalloc(
+    return reinterpret_cast<const knowherefaiss::VectorTransform*>(vt)->apply_noalloc(
             n, x, xt);
 }
 
@@ -53,7 +53,7 @@ void faiss_VectorTransform_reverse_transform(
         idx_t n,
         const float* xt,
         float* x) {
-    return reinterpret_cast<const faiss::VectorTransform*>(vt)
+    return reinterpret_cast<const knowherefaiss::VectorTransform*>(vt)
             ->reverse_transform(n, xt, x);
 }
 
@@ -72,12 +72,12 @@ void faiss_LinearTransform_transform_transpose(
         idx_t n,
         const float* y,
         float* x) {
-    return reinterpret_cast<const faiss::LinearTransform*>(vt)
+    return reinterpret_cast<const knowherefaiss::LinearTransform*>(vt)
             ->transform_transpose(n, y, x);
 }
 
 void faiss_LinearTransform_set_is_orthonormal(FaissLinearTransform* vt) {
-    return reinterpret_cast<faiss::LinearTransform*>(vt)->set_is_orthonormal();
+    return reinterpret_cast<knowherefaiss::LinearTransform*>(vt)->set_is_orthonormal();
 }
 
 /*********************************************
@@ -92,7 +92,7 @@ int faiss_RandomRotationMatrix_new_with(
         int d_out) {
     try {
         *p_vt = reinterpret_cast<FaissRandomRotationMatrix*>(
-                new faiss::RandomRotationMatrix(d_in, d_out));
+                new knowherefaiss::RandomRotationMatrix(d_in, d_out));
     }
     CATCH_AND_HANDLE
 }
@@ -111,7 +111,7 @@ int faiss_PCAMatrix_new_with(
         int random_rotation) {
     try {
         bool random_rotation_ = static_cast<bool>(random_rotation);
-        *p_vt = reinterpret_cast<FaissPCAMatrix*>(new faiss::PCAMatrix(
+        *p_vt = reinterpret_cast<FaissPCAMatrix*>(new knowherefaiss::PCAMatrix(
                 d_in, d_out, eigen_power, random_rotation_));
     }
     CATCH_AND_HANDLE
@@ -129,7 +129,7 @@ DEFINE_DESTRUCTOR(ITQMatrix)
 
 int faiss_ITQMatrix_new_with(FaissITQMatrix** p_vt, int d) {
     try {
-        *p_vt = reinterpret_cast<FaissITQMatrix*>(new faiss::ITQMatrix(d));
+        *p_vt = reinterpret_cast<FaissITQMatrix*>(new knowherefaiss::ITQMatrix(d));
     }
     CATCH_AND_HANDLE
 }
@@ -144,7 +144,7 @@ int faiss_ITQTransform_new_with(
     try {
         bool do_pca_ = static_cast<bool>(do_pca);
         *p_vt = reinterpret_cast<FaissITQTransform*>(
-                new faiss::ITQTransform(d_in, d_out, do_pca_));
+                new knowherefaiss::ITQTransform(d_in, d_out, do_pca_));
     }
     CATCH_AND_HANDLE
 }
@@ -160,7 +160,7 @@ DEFINE_DESTRUCTOR(OPQMatrix)
 int faiss_OPQMatrix_new_with(FaissOPQMatrix** p_vt, int d, int M, int d2) {
     try {
         *p_vt = reinterpret_cast<FaissOPQMatrix*>(
-                new faiss::OPQMatrix(d, M, d2));
+                new knowherefaiss::OPQMatrix(d, M, d2));
     }
     CATCH_AND_HANDLE
 }
@@ -188,7 +188,7 @@ int faiss_RemapDimensionsTransform_new_with(
     try {
         bool uniform_ = static_cast<bool>(uniform);
         *p_vt = reinterpret_cast<FaissRemapDimensionsTransform*>(
-                new faiss::RemapDimensionsTransform(d_in, d_out, uniform_));
+                new knowherefaiss::RemapDimensionsTransform(d_in, d_out, uniform_));
     }
     CATCH_AND_HANDLE
 }
@@ -205,7 +205,7 @@ int faiss_NormalizationTransform_new_with(
         float norm) {
     try {
         *p_vt = reinterpret_cast<FaissNormalizationTransform*>(
-                new faiss::NormalizationTransform(d, norm));
+                new knowherefaiss::NormalizationTransform(d, norm));
     }
     CATCH_AND_HANDLE
 }
@@ -221,7 +221,7 @@ DEFINE_DESTRUCTOR(CenteringTransform)
 int faiss_CenteringTransform_new_with(FaissCenteringTransform** p_vt, int d) {
     try {
         *p_vt = reinterpret_cast<FaissCenteringTransform*>(
-                new faiss::CenteringTransform(d));
+                new knowherefaiss::CenteringTransform(d));
     }
     CATCH_AND_HANDLE
 }
diff --git a/thirdparty/faiss/c_api/clone_index_c.cpp b/thirdparty/faiss/c_api/clone_index_c.cpp
index 606e5f9b..34982f4f 100644
--- a/thirdparty/faiss/c_api/clone_index_c.cpp
+++ b/thirdparty/faiss/c_api/clone_index_c.cpp
@@ -10,15 +10,15 @@
 // I/O code for indexes
 
 #include "clone_index_c.h"
-#include <faiss/clone_index.h>
+#include <knowherefaiss/clone_index.h>
 #include "macros_impl.h"
 
-using faiss::Index;
-using faiss::IndexBinary;
+using knowherefaiss::Index;
+using knowherefaiss::IndexBinary;
 
 int faiss_clone_index(const FaissIndex* idx, FaissIndex** p_out) {
     try {
-        auto out = faiss::clone_index(reinterpret_cast<const Index*>(idx));
+        auto out = knowherefaiss::clone_index(reinterpret_cast<const Index*>(idx));
         *p_out = reinterpret_cast<FaissIndex*>(out);
     }
     CATCH_AND_HANDLE
@@ -28,7 +28,7 @@ int faiss_clone_index_binary(
         const FaissIndexBinary* idx,
         FaissIndexBinary** p_out) {
     try {
-        auto out = faiss::clone_binary_index(
+        auto out = knowherefaiss::clone_binary_index(
                 reinterpret_cast<const IndexBinary*>(idx));
         *p_out = reinterpret_cast<FaissIndexBinary*>(out);
     }
diff --git a/thirdparty/faiss/c_api/clone_index_c.h b/thirdparty/faiss/c_api/clone_index_c.h
index d2da35b8..f9d12c8c 100644
--- a/thirdparty/faiss/c_api/clone_index_c.h
+++ b/thirdparty/faiss/c_api/clone_index_c.h
@@ -23,10 +23,10 @@ extern "C" {
 
 /* cloning functions */
 
-/** Clone an index. This is equivalent to `faiss::clone_index` */
+/** Clone an index. This is equivalent to `knowherefaiss::clone_index` */
 int faiss_clone_index(const FaissIndex*, FaissIndex** p_out);
 
-/** Clone a binary index. This is equivalent to `faiss::clone_index_binary` */
+/** Clone a binary index. This is equivalent to `knowherefaiss::clone_index_binary` */
 int faiss_clone_index_binary(const FaissIndexBinary*, FaissIndexBinary** p_out);
 
 #ifdef __cplusplus
diff --git a/thirdparty/faiss/c_api/error_impl.cpp b/thirdparty/faiss/c_api/error_impl.cpp
index 27f29724..169818a6 100644
--- a/thirdparty/faiss/c_api/error_impl.cpp
+++ b/thirdparty/faiss/c_api/error_impl.cpp
@@ -9,7 +9,7 @@
 // -*- c++ -*-
 
 #include "error_impl.h"
-#include <faiss/impl/FaissException.h>
+#include <knowherefaiss/impl/FaissException.h>
 #include <exception>
 #include "error_c.h"
 
diff --git a/thirdparty/faiss/c_api/gpu/DeviceUtils_c.cpp b/thirdparty/faiss/c_api/gpu/DeviceUtils_c.cpp
index 99194c5d..4a9c075d 100644
--- a/thirdparty/faiss/c_api/gpu/DeviceUtils_c.cpp
+++ b/thirdparty/faiss/c_api/gpu/DeviceUtils_c.cpp
@@ -9,13 +9,13 @@
 // -*- c++ -*-
 
 #include "DeviceUtils_c.h"
-#include <faiss/gpu/utils/DeviceUtils.h>
+#include <knowherefaiss/gpu/utils/DeviceUtils.h>
 #include "macros_impl.h"
 
 /// Returns the number of available GPU devices
 int faiss_get_num_gpus(int* p_output) {
     try {
-        int output = faiss::gpu::getNumDevices();
+        int output = knowherefaiss::gpu::getNumDevices();
         *p_output = output;
     }
     CATCH_AND_HANDLE
@@ -24,7 +24,7 @@ int faiss_get_num_gpus(int* p_output) {
 /// Starts the CUDA profiler (exposed via SWIG)
 int faiss_gpu_profiler_start() {
     try {
-        faiss::gpu::profilerStart();
+        knowherefaiss::gpu::profilerStart();
     }
     CATCH_AND_HANDLE
 }
@@ -32,7 +32,7 @@ int faiss_gpu_profiler_start() {
 /// Stops the CUDA profiler (exposed via SWIG)
 int faiss_gpu_profiler_stop() {
     try {
-        faiss::gpu::profilerStop();
+        knowherefaiss::gpu::profilerStop();
     }
     CATCH_AND_HANDLE
 }
@@ -41,7 +41,7 @@ int faiss_gpu_profiler_stop() {
 /// cudaDeviceSynchronize for each device)
 int faiss_gpu_sync_all_devices() {
     try {
-        faiss::gpu::synchronizeAllDevices();
+        knowherefaiss::gpu::synchronizeAllDevices();
     }
     CATCH_AND_HANDLE
 }
diff --git a/thirdparty/faiss/c_api/gpu/GpuAutoTune_c.cpp b/thirdparty/faiss/c_api/gpu/GpuAutoTune_c.cpp
index cbfdf084..f5a53ccd 100644
--- a/thirdparty/faiss/c_api/gpu/GpuAutoTune_c.cpp
+++ b/thirdparty/faiss/c_api/gpu/GpuAutoTune_c.cpp
@@ -9,23 +9,23 @@
 // -*- c++ -*-
 
 #include "GpuAutoTune_c.h"
-#include <faiss/Index.h>
-#include <faiss/gpu/GpuAutoTune.h>
-#include <faiss/gpu/GpuCloner.h>
-#include <faiss/gpu/GpuClonerOptions.h>
-#include <faiss/gpu/GpuResources.h>
+#include <knowherefaiss/Index.h>
+#include <knowherefaiss/gpu/GpuAutoTune.h>
+#include <knowherefaiss/gpu/GpuCloner.h>
+#include <knowherefaiss/gpu/GpuClonerOptions.h>
+#include <knowherefaiss/gpu/GpuResources.h>
 #include <vector>
 #include "GpuClonerOptions_c.h"
 #include "macros_impl.h"
 
-using faiss::Index;
-using faiss::gpu::GpuClonerOptions;
-using faiss::gpu::GpuMultipleClonerOptions;
-using faiss::gpu::GpuResourcesProvider;
+using knowherefaiss::Index;
+using knowherefaiss::gpu::GpuClonerOptions;
+using knowherefaiss::gpu::GpuMultipleClonerOptions;
+using knowherefaiss::gpu::GpuResourcesProvider;
 
 int faiss_index_gpu_to_cpu(const FaissIndex* gpu_index, FaissIndex** p_out) {
     try {
-        auto cpu_index = faiss::gpu::index_gpu_to_cpu(
+        auto cpu_index = knowherefaiss::gpu::index_gpu_to_cpu(
                 reinterpret_cast<const Index*>(gpu_index));
         *p_out = reinterpret_cast<FaissIndex*>(cpu_index);
     }
@@ -40,7 +40,7 @@ int faiss_index_cpu_to_gpu(
         FaissGpuIndex** p_out) {
     try {
         auto res = reinterpret_cast<GpuResourcesProvider*>(provider);
-        auto gpu_index = faiss::gpu::index_cpu_to_gpu(
+        auto gpu_index = knowherefaiss::gpu::index_cpu_to_gpu(
                 res, device, reinterpret_cast<const Index*>(index));
         *p_out = reinterpret_cast<FaissGpuIndex*>(gpu_index);
     }
@@ -55,7 +55,7 @@ int faiss_index_cpu_to_gpu_with_options(
         FaissGpuIndex** p_out) {
     try {
         auto res = reinterpret_cast<GpuResourcesProvider*>(provider);
-        auto gpu_index = faiss::gpu::index_cpu_to_gpu(
+        auto gpu_index = knowherefaiss::gpu::index_cpu_to_gpu(
                 res,
                 device,
                 reinterpret_cast<const Index*>(index),
@@ -79,7 +79,7 @@ int faiss_index_cpu_to_gpu_multiple(
 
         std::vector<int> dev(devices, devices + devices_size);
 
-        auto gpu_index = faiss::gpu::index_cpu_to_gpu_multiple(
+        auto gpu_index = knowherefaiss::gpu::index_cpu_to_gpu_multiple(
                 res, dev, reinterpret_cast<const Index*>(index));
         *p_out = reinterpret_cast<FaissGpuIndex*>(gpu_index);
     }
@@ -102,7 +102,7 @@ int faiss_index_cpu_to_gpu_multiple_with_options(
 
         std::vector<int> dev(devices, devices + devices_size);
 
-        auto gpu_index = faiss::gpu::index_cpu_to_gpu_multiple(
+        auto gpu_index = knowherefaiss::gpu::index_cpu_to_gpu_multiple(
                 res,
                 dev,
                 reinterpret_cast<const Index*>(index),
diff --git a/thirdparty/faiss/c_api/gpu/GpuClonerOptions_c.cpp b/thirdparty/faiss/c_api/gpu/GpuClonerOptions_c.cpp
index 9f6abed5..2db39200 100644
--- a/thirdparty/faiss/c_api/gpu/GpuClonerOptions_c.cpp
+++ b/thirdparty/faiss/c_api/gpu/GpuClonerOptions_c.cpp
@@ -9,12 +9,12 @@
 // -*- c++ -*-
 
 #include "GpuClonerOptions_c.h"
-#include <faiss/gpu/GpuClonerOptions.h>
+#include <knowherefaiss/gpu/GpuClonerOptions.h>
 #include "macros_impl.h"
 
-using faiss::gpu::GpuClonerOptions;
-using faiss::gpu::GpuMultipleClonerOptions;
-using faiss::gpu::IndicesOptions;
+using knowherefaiss::gpu::GpuClonerOptions;
+using knowherefaiss::gpu::GpuMultipleClonerOptions;
+using knowherefaiss::gpu::IndicesOptions;
 
 int faiss_GpuClonerOptions_new(FaissGpuClonerOptions** p) {
     try {
diff --git a/thirdparty/faiss/c_api/gpu/GpuIndex_c.cpp b/thirdparty/faiss/c_api/gpu/GpuIndex_c.cpp
index 9be2ca3b..c7217273 100644
--- a/thirdparty/faiss/c_api/gpu/GpuIndex_c.cpp
+++ b/thirdparty/faiss/c_api/gpu/GpuIndex_c.cpp
@@ -9,9 +9,9 @@
 // -*- c++ -*-
 
 #include "GpuIndex_c.h"
-#include <faiss/gpu/GpuIndex.h>
+#include <knowherefaiss/gpu/GpuIndex.h>
 #include "macros_impl.h"
 
-using faiss::gpu::GpuIndexConfig;
+using knowherefaiss::gpu::GpuIndexConfig;
 
 DEFINE_GETTER(GpuIndexConfig, int, device)
diff --git a/thirdparty/faiss/c_api/gpu/GpuResources_c.cpp b/thirdparty/faiss/c_api/gpu/GpuResources_c.cpp
index 3f9115af..3d592171 100644
--- a/thirdparty/faiss/c_api/gpu/GpuResources_c.cpp
+++ b/thirdparty/faiss/c_api/gpu/GpuResources_c.cpp
@@ -9,11 +9,11 @@
 // -*- c++ -*-
 
 #include "GpuResources_c.h"
-#include <faiss/gpu/GpuResources.h>
+#include <knowherefaiss/gpu/GpuResources.h>
 #include "macros_impl.h"
 
-using faiss::gpu::GpuResources;
-using faiss::gpu::GpuResourcesProvider;
+using knowherefaiss::gpu::GpuResources;
+using knowherefaiss::gpu::GpuResourcesProvider;
 
 DEFINE_DESTRUCTOR(GpuResources)
 
diff --git a/thirdparty/faiss/c_api/gpu/StandardGpuResources_c.cpp b/thirdparty/faiss/c_api/gpu/StandardGpuResources_c.cpp
index 31766d17..896aae34 100644
--- a/thirdparty/faiss/c_api/gpu/StandardGpuResources_c.cpp
+++ b/thirdparty/faiss/c_api/gpu/StandardGpuResources_c.cpp
@@ -9,10 +9,10 @@
 // -*- c++ -*-
 
 #include "StandardGpuResources_c.h"
-#include <faiss/gpu/StandardGpuResources.h>
+#include <knowherefaiss/gpu/StandardGpuResources.h>
 #include "macros_impl.h"
 
-using faiss::gpu::StandardGpuResources;
+using knowherefaiss::gpu::StandardGpuResources;
 
 DEFINE_DESTRUCTOR(StandardGpuResources)
 
diff --git a/thirdparty/faiss/c_api/gpu/macros_impl.h b/thirdparty/faiss/c_api/gpu/macros_impl.h
index f0cf6b85..5b17011d 100644
--- a/thirdparty/faiss/c_api/gpu/macros_impl.h
+++ b/thirdparty/faiss/c_api/gpu/macros_impl.h
@@ -16,26 +16,26 @@
 #define DEFINE_GETTER(clazz, ty, name)                                  \
     ty faiss_##clazz##_##name(const Faiss##clazz* obj) {                \
         return static_cast<ty>(                                         \
-                reinterpret_cast<const faiss::gpu::clazz*>(obj)->name); \
+                reinterpret_cast<const knowherefaiss::gpu::clazz*>(obj)->name); \
     }
 
 #undef DEFINE_SETTER
 #define DEFINE_SETTER(clazz, ty, name)                           \
     void faiss_##clazz##_set_##name(Faiss##clazz* obj, ty val) { \
-        reinterpret_cast<faiss::gpu::clazz*>(obj)->name = val;   \
+        reinterpret_cast<knowherefaiss::gpu::clazz*>(obj)->name = val;   \
     }
 
 #undef DEFINE_SETTER_STATIC
 #define DEFINE_SETTER_STATIC(clazz, ty_to, ty_from, name)             \
     void faiss_##clazz##_set_##name(Faiss##clazz* obj, ty_from val) { \
-        reinterpret_cast<faiss::gpu::clazz*>(obj)->name =             \
+        reinterpret_cast<knowherefaiss::gpu::clazz*>(obj)->name =             \
                 static_cast<ty_to>(val);                              \
     }
 
 #undef DEFINE_DESTRUCTOR
 #define DEFINE_DESTRUCTOR(clazz)                          \
     void faiss_##clazz##_free(Faiss##clazz* obj) {        \
-        delete reinterpret_cast<faiss::gpu::clazz*>(obj); \
+        delete reinterpret_cast<knowherefaiss::gpu::clazz*>(obj); \
     }
 
 #endif
diff --git a/thirdparty/faiss/c_api/impl/AuxIndexStructures_c.cpp b/thirdparty/faiss/c_api/impl/AuxIndexStructures_c.cpp
index 10c0b13d..6b112b93 100644
--- a/thirdparty/faiss/c_api/impl/AuxIndexStructures_c.cpp
+++ b/thirdparty/faiss/c_api/impl/AuxIndexStructures_c.cpp
@@ -9,18 +9,18 @@
 // -*- c++ -*-
 
 #include "AuxIndexStructures_c.h"
-#include <faiss/impl/AuxIndexStructures.h>
+#include <knowherefaiss/impl/AuxIndexStructures.h>
 #include <iostream>
 #include "../macros_impl.h"
 
-using faiss::BufferList;
-using faiss::DistanceComputer;
-using faiss::IDSelector;
-using faiss::IDSelectorBatch;
-using faiss::IDSelectorRange;
-using faiss::RangeQueryResult;
-using faiss::RangeSearchPartialResult;
-using faiss::RangeSearchResult;
+using knowherefaiss::BufferList;
+using knowherefaiss::DistanceComputer;
+using knowherefaiss::IDSelector;
+using knowherefaiss::IDSelectorBatch;
+using knowherefaiss::IDSelectorRange;
+using knowherefaiss::RangeQueryResult;
+using knowherefaiss::RangeSearchPartialResult;
+using knowherefaiss::RangeSearchResult;
 
 DEFINE_GETTER(RangeSearchResult, size_t, nq)
 
diff --git a/thirdparty/faiss/c_api/index_factory_c.cpp b/thirdparty/faiss/c_api/index_factory_c.cpp
index 3a1ab9ba..98a685e5 100644
--- a/thirdparty/faiss/c_api/index_factory_c.cpp
+++ b/thirdparty/faiss/c_api/index_factory_c.cpp
@@ -9,11 +9,11 @@
 // -*- c++ -*-
 
 #include "index_factory_c.h"
-#include <faiss/index_factory.h>
+#include <knowherefaiss/index_factory.h>
 #include <cstring>
 #include "macros_impl.h"
 
-using faiss::Index;
+using knowherefaiss::Index;
 
 /** Build an index with the sequence of processing steps described in
  *  the string.
@@ -24,8 +24,8 @@ int faiss_index_factory(
         const char* description,
         FaissMetricType metric) {
     try {
-        *p_index = reinterpret_cast<FaissIndex*>(faiss::index_factory(
-                d, description, static_cast<faiss::MetricType>(metric)));
+        *p_index = reinterpret_cast<FaissIndex*>(knowherefaiss::index_factory(
+                d, description, static_cast<knowherefaiss::MetricType>(metric)));
     }
     CATCH_AND_HANDLE
 }
@@ -39,7 +39,7 @@ int faiss_index_binary_factory(
         const char* description) {
     try {
         *p_index = reinterpret_cast<FaissIndexBinary*>(
-                faiss::index_binary_factory(d, description));
+                knowherefaiss::index_binary_factory(d, description));
     }
     CATCH_AND_HANDLE
 }
\ No newline at end of file
diff --git a/thirdparty/faiss/c_api/index_io_c.cpp b/thirdparty/faiss/c_api/index_io_c.cpp
index 9c807402..3590d756 100644
--- a/thirdparty/faiss/c_api/index_io_c.cpp
+++ b/thirdparty/faiss/c_api/index_io_c.cpp
@@ -10,28 +10,28 @@
 // I/O code for indexes
 
 #include "index_io_c.h"
-#include <faiss/index_io.h>
+#include <knowherefaiss/index_io.h>
 #include "macros_impl.h"
 
-using faiss::Index;
+using knowherefaiss::Index;
 
 int faiss_write_index(const FaissIndex* idx, FILE* f) {
     try {
-        faiss::write_index(reinterpret_cast<const Index*>(idx), f);
+        knowherefaiss::write_index(reinterpret_cast<const Index*>(idx), f);
     }
     CATCH_AND_HANDLE
 }
 
 int faiss_write_index_fname(const FaissIndex* idx, const char* fname) {
     try {
-        faiss::write_index(reinterpret_cast<const Index*>(idx), fname);
+        knowherefaiss::write_index(reinterpret_cast<const Index*>(idx), fname);
     }
     CATCH_AND_HANDLE
 }
 
 int faiss_read_index(FILE* f, int io_flags, FaissIndex** p_out) {
     try {
-        auto out = faiss::read_index(f, io_flags);
+        auto out = knowherefaiss::read_index(f, io_flags);
         *p_out = reinterpret_cast<FaissIndex*>(out);
     }
     CATCH_AND_HANDLE
@@ -42,7 +42,7 @@ int faiss_read_index_fname(
         int io_flags,
         FaissIndex** p_out) {
     try {
-        auto out = faiss::read_index(fname, io_flags);
+        auto out = knowherefaiss::read_index(fname, io_flags);
         *p_out = reinterpret_cast<FaissIndex*>(out);
     }
     CATCH_AND_HANDLE
diff --git a/thirdparty/faiss/c_api/index_io_c.h b/thirdparty/faiss/c_api/index_io_c.h
index 13914c4e..f83c4c02 100644
--- a/thirdparty/faiss/c_api/index_io_c.h
+++ b/thirdparty/faiss/c_api/index_io_c.h
@@ -21,13 +21,13 @@ extern "C" {
 #endif
 
 /** Write index to a file.
- * This is equivalent to `faiss::write_index` when a file descriptor is
+ * This is equivalent to `knowherefaiss::write_index` when a file descriptor is
  * provided.
  */
 int faiss_write_index(const FaissIndex* idx, FILE* f);
 
 /** Write index to a file.
- * This is equivalent to `faiss::write_index` when a file path is provided.
+ * This is equivalent to `knowherefaiss::write_index` when a file path is provided.
  */
 int faiss_write_index_fname(const FaissIndex* idx, const char* fname);
 
@@ -35,12 +35,12 @@ int faiss_write_index_fname(const FaissIndex* idx, const char* fname);
 #define FAISS_IO_FLAG_READ_ONLY 2
 
 /** Read index from a file.
- * This is equivalent to `faiss:read_index` when a file descriptor is given.
+ * This is equivalent to `knowherefaiss:read_index` when a file descriptor is given.
  */
 int faiss_read_index(FILE* f, int io_flags, FaissIndex** p_out);
 
 /** Read index from a file.
- * This is equivalent to `faiss:read_index` when a file path is given.
+ * This is equivalent to `knowherefaiss:read_index` when a file path is given.
  */
 int faiss_read_index_fname(const char* fname, int io_flags, FaissIndex** p_out);
 
diff --git a/thirdparty/faiss/c_api/macros_impl.h b/thirdparty/faiss/c_api/macros_impl.h
index 506ae42c..03bd3de8 100644
--- a/thirdparty/faiss/c_api/macros_impl.h
+++ b/thirdparty/faiss/c_api/macros_impl.h
@@ -13,7 +13,7 @@
 #ifndef MACROS_IMPL_H
 #define MACROS_IMPL_H
 
-#include <faiss/impl/FaissException.h>
+#include <knowherefaiss/impl/FaissException.h>
 #include <iostream>
 #include <stdexcept>
 #include "error_impl.h"
@@ -21,7 +21,7 @@
 
 #ifdef NDEBUG
 #define CATCH_AND_HANDLE                                                      \
-    catch (faiss::FaissException & e) {                                       \
+    catch (knowherefaiss::FaissException & e) {                                       \
         faiss_last_exception = std::make_exception_ptr(e);                    \
         return -2;                                                            \
     }                                                                         \
@@ -37,7 +37,7 @@
     return 0;
 #else
 #define CATCH_AND_HANDLE                                                      \
-    catch (faiss::FaissException & e) {                                       \
+    catch (knowherefaiss::FaissException & e) {                                       \
         std::cerr << e.what() << '\n';                                        \
         faiss_last_exception = std::make_exception_ptr(e);                    \
         return -2;                                                            \
@@ -59,44 +59,44 @@
 #define DEFINE_GETTER(clazz, ty, name)                             \
     ty faiss_##clazz##_##name(const Faiss##clazz* obj) {           \
         return static_cast<ty>(                                    \
-                reinterpret_cast<const faiss::clazz*>(obj)->name); \
+                reinterpret_cast<const knowherefaiss::clazz*>(obj)->name); \
     }
 
 #define DEFINE_GETTER_SUBCLASS(clazz, parent, ty, name)                    \
     ty faiss_##clazz##_##name(const Faiss##clazz* obj) {                   \
         return static_cast<ty>(                                            \
-                reinterpret_cast<const faiss::parent::clazz*>(obj)->name); \
+                reinterpret_cast<const knowherefaiss::parent::clazz*>(obj)->name); \
     }
 
 #define DEFINE_GETTER_PERMISSIVE(clazz, ty, name)                      \
     ty faiss_##clazz##_##name(const Faiss##clazz* obj) {               \
-        return (ty)(reinterpret_cast<const faiss::clazz*>(obj)->name); \
+        return (ty)(reinterpret_cast<const knowherefaiss::clazz*>(obj)->name); \
     }
 
 #define DEFINE_GETTER_SUBCLASS_PERMISSIVE(clazz, parent, ty, name)             \
     ty faiss_##clazz##_##name(const Faiss##clazz* obj) {                       \
-        return (ty)(reinterpret_cast<const faiss::parent::clazz*>(obj)->name); \
+        return (ty)(reinterpret_cast<const knowherefaiss::parent::clazz*>(obj)->name); \
     }
 
 #define DEFINE_SETTER(clazz, ty, name)                           \
     void faiss_##clazz##_set_##name(Faiss##clazz* obj, ty val) { \
-        reinterpret_cast<faiss::clazz*>(obj)->name = val;        \
+        reinterpret_cast<knowherefaiss::clazz*>(obj)->name = val;        \
     }
 
 #define DEFINE_SETTER_STATIC(clazz, ty_to, ty_from, name)                     \
     void faiss_##clazz##_set_##name(Faiss##clazz* obj, ty_from val) {         \
-        reinterpret_cast<faiss::clazz*>(obj)->name = static_cast<ty_to>(val); \
+        reinterpret_cast<knowherefaiss::clazz*>(obj)->name = static_cast<ty_to>(val); \
     }
 
 #define DEFINE_DESTRUCTOR(clazz)                     \
     void faiss_##clazz##_free(Faiss##clazz* obj) {   \
-        delete reinterpret_cast<faiss::clazz*>(obj); \
+        delete reinterpret_cast<knowherefaiss::clazz*>(obj); \
     }
 
 #define DEFINE_INDEX_DOWNCAST(clazz)                                        \
     Faiss##clazz* faiss_##clazz##_cast(FaissIndex* index) {                 \
-        return reinterpret_cast<Faiss##clazz*>(dynamic_cast<faiss::clazz*>( \
-                reinterpret_cast<faiss::Index*>(index)));                   \
+        return reinterpret_cast<Faiss##clazz*>(dynamic_cast<knowherefaiss::clazz*>( \
+                reinterpret_cast<knowherefaiss::Index*>(index)));                   \
     }
 
 #endif
diff --git a/thirdparty/faiss/c_api/utils/distances_c.cpp b/thirdparty/faiss/c_api/utils/distances_c.cpp
index 05872e1e..229c0d0b 100644
--- a/thirdparty/faiss/c_api/utils/distances_c.cpp
+++ b/thirdparty/faiss/c_api/utils/distances_c.cpp
@@ -9,7 +9,7 @@
 // -*- c++ -*-
 
 #include "distances_c.h"
-#include <faiss/utils/distances.h>
+#include <knowherefaiss/utils/distances.h>
 #include <cstdio>
 
 void faiss_pairwise_L2sqr(
@@ -22,7 +22,7 @@ void faiss_pairwise_L2sqr(
         int64_t ldq,
         int64_t ldb,
         int64_t ldd) {
-    faiss::pairwise_L2sqr(d, nq, xq, nb, xb, dis, ldq, ldb, ldd);
+    knowherefaiss::pairwise_L2sqr(d, nq, xq, nb, xb, dis, ldq, ldb, ldd);
 }
 
 void faiss_pairwise_L2sqr_with_defaults(
@@ -32,7 +32,7 @@ void faiss_pairwise_L2sqr_with_defaults(
         int64_t nb,
         const float* xb,
         float* dis) {
-    faiss::pairwise_L2sqr(d, nq, xq, nb, xb, dis);
+    knowherefaiss::pairwise_L2sqr(d, nq, xq, nb, xb, dis);
 }
 
 void faiss_fvec_inner_products_ny(
@@ -41,7 +41,7 @@ void faiss_fvec_inner_products_ny(
         const float* y,
         size_t d,
         size_t ny) {
-    faiss::fvec_inner_products_ny(ip, x, y, d, ny);
+    knowherefaiss::fvec_inner_products_ny(ip, x, y, d, ny);
 }
 
 void faiss_fvec_L2sqr_ny(
@@ -50,53 +50,53 @@ void faiss_fvec_L2sqr_ny(
         const float* y,
         size_t d,
         size_t ny) {
-    faiss::fvec_L2sqr_ny(dis, x, y, d, ny);
+    knowherefaiss::fvec_L2sqr_ny(dis, x, y, d, ny);
 }
 
 float faiss_fvec_norm_L2sqr(const float* x, size_t d) {
-    return faiss::fvec_norm_L2sqr(x, d);
+    return knowherefaiss::fvec_norm_L2sqr(x, d);
 }
 
 void faiss_fvec_norms_L2(float* norms, const float* x, size_t d, size_t nx) {
-    faiss::fvec_norms_L2(norms, x, d, nx);
+    knowherefaiss::fvec_norms_L2(norms, x, d, nx);
 }
 
 void faiss_fvec_norms_L2sqr(float* norms, const float* x, size_t d, size_t nx) {
-    faiss::fvec_norms_L2sqr(norms, x, d, nx);
+    knowherefaiss::fvec_norms_L2sqr(norms, x, d, nx);
 }
 
 void faiss_fvec_renorm_L2(size_t d, size_t nx, float* x) {
-    faiss::fvec_renorm_L2(d, nx, x);
+    knowherefaiss::fvec_renorm_L2(d, nx, x);
 }
 
 void faiss_set_distance_compute_blas_threshold(int value) {
-    faiss::distance_compute_blas_threshold = value;
+    knowherefaiss::distance_compute_blas_threshold = value;
 }
 
 int faiss_get_distance_compute_blas_threshold() {
-    return faiss::distance_compute_blas_threshold;
+    return knowherefaiss::distance_compute_blas_threshold;
 }
 
 void faiss_set_distance_compute_blas_query_bs(int value) {
-    faiss::distance_compute_blas_query_bs = value;
+    knowherefaiss::distance_compute_blas_query_bs = value;
 }
 
 int faiss_get_distance_compute_blas_query_bs() {
-    return faiss::distance_compute_blas_query_bs;
+    return knowherefaiss::distance_compute_blas_query_bs;
 }
 
 void faiss_set_distance_compute_blas_database_bs(int value) {
-    faiss::distance_compute_blas_database_bs = value;
+    knowherefaiss::distance_compute_blas_database_bs = value;
 }
 
 int faiss_get_distance_compute_blas_database_bs() {
-    return faiss::distance_compute_blas_database_bs;
+    return knowherefaiss::distance_compute_blas_database_bs;
 }
 
 void faiss_set_distance_compute_min_k_reservoir(int value) {
-    faiss::distance_compute_min_k_reservoir = value;
+    knowherefaiss::distance_compute_min_k_reservoir = value;
 }
 
 int faiss_get_distance_compute_min_k_reservoir() {
-    return faiss::distance_compute_min_k_reservoir;
+    return knowherefaiss::distance_compute_min_k_reservoir;
 }
diff --git a/thirdparty/faiss/conda/faiss-gpu-raft/build-pkg.sh b/thirdparty/faiss/conda/faiss-gpu-raft/build-pkg.sh
index da5fdefc..374eec1c 100644
--- a/thirdparty/faiss/conda/faiss-gpu-raft/build-pkg.sh
+++ b/thirdparty/faiss/conda/faiss-gpu-raft/build-pkg.sh
@@ -15,7 +15,7 @@ cmake -B _build_python_${PY_VER} \
       -DFAISS_ENABLE_RAFT=ON \
       -DCMAKE_BUILD_TYPE=Release \
       -DPython_EXECUTABLE=$PYTHON \
-      faiss/python
+      knowherefaiss/python
 
 make -C _build_python_${PY_VER} -j$(nproc) swigfaiss swigfaiss_avx2 swigfaiss_avx512
 
diff --git a/thirdparty/faiss/conda/faiss-gpu-raft/meta.yaml b/thirdparty/faiss/conda/faiss-gpu-raft/meta.yaml
index 1dde8e98..c8a31061 100644
--- a/thirdparty/faiss/conda/faiss-gpu-raft/meta.yaml
+++ b/thirdparty/faiss/conda/faiss-gpu-raft/meta.yaml
@@ -114,12 +114,12 @@ outputs:
       commands:
         - python -X faulthandler -m unittest discover -v -s tests/ -p "test_*"
         - python -X faulthandler -m unittest discover -v -s tests/ -p "torch_*"
-        - cp tests/common_faiss_tests.py faiss/gpu/test
-        - python -X faulthandler -m unittest discover -v -s faiss/gpu/test/ -p "test_*"
-        - python -X faulthandler -m unittest discover -v -s faiss/gpu/test/ -p "torch_*"
+        - cp tests/common_faiss_tests.py knowherefaiss/gpu/test
+        - python -X faulthandler -m unittest discover -v -s knowherefaiss/gpu/test/ -p "test_*"
+        - python -X faulthandler -m unittest discover -v -s knowherefaiss/gpu/test/ -p "torch_*"
         - sh test_cpu_dispatch.sh  # [linux64]
       files:
         - test_cpu_dispatch.sh  # [linux64]
       source_files:
         - tests/
-        - faiss/gpu/test/
+        - knowherefaiss/gpu/test/
diff --git a/thirdparty/faiss/conda/faiss-gpu/build-pkg.sh b/thirdparty/faiss/conda/faiss-gpu/build-pkg.sh
index e529a83d..2e40c1d3 100755
--- a/thirdparty/faiss/conda/faiss-gpu/build-pkg.sh
+++ b/thirdparty/faiss/conda/faiss-gpu/build-pkg.sh
@@ -15,7 +15,7 @@ cmake -B _build_python_${PY_VER} \
       -DFAISS_ENABLE_RAFT=OFF \
       -DCMAKE_BUILD_TYPE=Release \
       -DPython_EXECUTABLE=$PYTHON \
-      faiss/python
+      knowherefaiss/python
 
 make -C _build_python_${PY_VER} -j$(nproc) swigfaiss swigfaiss_avx2 swigfaiss_avx512
 
diff --git a/thirdparty/faiss/conda/faiss-gpu/meta.yaml b/thirdparty/faiss/conda/faiss-gpu/meta.yaml
index 05f7b590..39e7f68e 100644
--- a/thirdparty/faiss/conda/faiss-gpu/meta.yaml
+++ b/thirdparty/faiss/conda/faiss-gpu/meta.yaml
@@ -103,12 +103,12 @@ outputs:
       commands:
         - python -X faulthandler -m unittest discover -v -s tests/ -p "test_*"
         - python -X faulthandler -m unittest discover -v -s tests/ -p "torch_*"
-        - cp tests/common_faiss_tests.py faiss/gpu/test
-        - python -X faulthandler -m unittest discover -v -s faiss/gpu/test/ -p "test_*"
-        - python -X faulthandler -m unittest discover -v -s faiss/gpu/test/ -p "torch_*"
+        - cp tests/common_faiss_tests.py knowherefaiss/gpu/test
+        - python -X faulthandler -m unittest discover -v -s knowherefaiss/gpu/test/ -p "test_*"
+        - python -X faulthandler -m unittest discover -v -s knowherefaiss/gpu/test/ -p "torch_*"
         - sh test_cpu_dispatch.sh  # [linux64]
       files:
         - test_cpu_dispatch.sh  # [linux64]
       source_files:
         - tests/
-        - faiss/gpu/test/
+        - knowherefaiss/gpu/test/
diff --git a/thirdparty/faiss/conda/faiss/build-pkg-arm64.sh b/thirdparty/faiss/conda/faiss/build-pkg-arm64.sh
index 70fc7312..ad792d4d 100755
--- a/thirdparty/faiss/conda/faiss/build-pkg-arm64.sh
+++ b/thirdparty/faiss/conda/faiss/build-pkg-arm64.sh
@@ -13,7 +13,7 @@ cmake -B _build_python_${PY_VER} \
       -DFAISS_ENABLE_GPU=OFF \
       -DCMAKE_BUILD_TYPE=Release \
       -DPython_EXECUTABLE=$PYTHON \
-      faiss/python
+      knowherefaiss/python
 
 make -C _build_python_${PY_VER} -j$(nproc) swigfaiss
 
diff --git a/thirdparty/faiss/conda/faiss/build-pkg-osx.sh b/thirdparty/faiss/conda/faiss/build-pkg-osx.sh
index 914aed17..66aeea0c 100755
--- a/thirdparty/faiss/conda/faiss/build-pkg-osx.sh
+++ b/thirdparty/faiss/conda/faiss/build-pkg-osx.sh
@@ -17,7 +17,7 @@ cmake -B _build_python_${PY_VER} \
       -DOpenMP_libiomp5_LIBRARY=$PREFIX/lib/libiomp5.dylib \
       -DCMAKE_BUILD_TYPE=Release \
       -DPython_EXECUTABLE=$PYTHON \
-      faiss/python
+      knowherefaiss/python
 
 make -C _build_python_${PY_VER} -j$(nproc) swigfaiss swigfaiss_avx2 swigfaiss_avx512
 
diff --git a/thirdparty/faiss/conda/faiss/build-pkg.bat b/thirdparty/faiss/conda/faiss/build-pkg.bat
index 37b08556..ef50a087 100644
--- a/thirdparty/faiss/conda/faiss/build-pkg.bat
+++ b/thirdparty/faiss/conda/faiss/build-pkg.bat
@@ -10,7 +10,7 @@ cmake -B _build_python_%PY_VER% ^
       -G "Visual Studio 16 2019" ^
       -DFAISS_ENABLE_GPU=OFF ^
       -DPython_EXECUTABLE=%PYTHON% ^
-      faiss/python
+      knowherefaiss/python
 if %errorlevel% neq 0 exit /b %errorlevel%
 
 cmake --build _build_python_%PY_VER% --config Release -j %CPU_COUNT%
diff --git a/thirdparty/faiss/conda/faiss/build-pkg.sh b/thirdparty/faiss/conda/faiss/build-pkg.sh
index 92e0febf..7465f7a5 100755
--- a/thirdparty/faiss/conda/faiss/build-pkg.sh
+++ b/thirdparty/faiss/conda/faiss/build-pkg.sh
@@ -14,7 +14,7 @@ cmake -B _build_python_${PY_VER} \
       -DFAISS_ENABLE_GPU=OFF \
       -DCMAKE_BUILD_TYPE=Release \
       -DPython_EXECUTABLE=$PYTHON \
-      faiss/python
+      knowherefaiss/python
 
 make -C _build_python_${PY_VER} -j$(nproc) swigfaiss swigfaiss_avx2 swigfaiss_avx512
 
diff --git a/thirdparty/faiss/demos/demo_imi_flat.cpp b/thirdparty/faiss/demos/demo_imi_flat.cpp
index 1480422a..daaa6703 100644
--- a/thirdparty/faiss/demos/demo_imi_flat.cpp
+++ b/thirdparty/faiss/demos/demo_imi_flat.cpp
@@ -12,10 +12,10 @@
 
 #include <sys/time.h>
 
-#include <faiss/IndexFlat.h>
-#include <faiss/IndexIVFFlat.h>
-#include <faiss/IndexPQ.h>
-#include <faiss/index_io.h>
+#include <knowherefaiss/IndexFlat.h>
+#include <knowherefaiss/IndexIVFFlat.h>
+#include <knowherefaiss/IndexPQ.h>
+#include <knowherefaiss/index_io.h>
 
 double elapsed() {
     struct timeval tv;
@@ -47,7 +47,7 @@ int main() {
     // quantizer to the inverted-file index (with attribute do_delete_quantizer)
     //
     // Note: a regular clustering algorithm would be defined as:
-    //       faiss::IndexFlatL2 coarse_quantizer (d);
+    //       knowherefaiss::IndexFlatL2 coarse_quantizer (d);
     //
     // Use nhash=2 subquantizers used to define the product coarse quantizer
     // Number of bits: we will have 2^nbits_coarse centroids per subquantizer
@@ -56,7 +56,7 @@ int main() {
     size_t nbits_subq = int(log2(nb + 1) / 2);     // good choice in general
     size_t ncentroids = 1 << (nhash * nbits_subq); // total # of centroids
 
-    faiss::MultiIndexQuantizer coarse_quantizer(d, nhash, nbits_subq);
+    knowherefaiss::MultiIndexQuantizer coarse_quantizer(d, nhash, nbits_subq);
 
     printf("IMI (%ld,%ld): %ld virtual centroids (target: %ld base vectors)",
            nhash,
@@ -67,8 +67,8 @@ int main() {
     // the coarse quantizer should not be dealloced before the index
     // 4 = nb of bytes per code (d must be a multiple of this)
     // 8 = nb of bits per sub-code (almost always 8)
-    faiss::MetricType metric = faiss::METRIC_L2; // can be METRIC_INNER_PRODUCT
-    faiss::IndexIVFFlat index(&coarse_quantizer, d, ncentroids, metric);
+    knowherefaiss::MetricType metric = knowherefaiss::METRIC_L2; // can be METRIC_INNER_PRODUCT
+    knowherefaiss::IndexIVFFlat index(&coarse_quantizer, d, ncentroids, metric);
     index.quantizer_trains_alone = true;
 
     // define the number of probes. 2048 is for high-dim, overkilled in practice
@@ -132,7 +132,7 @@ int main() {
                k,
                nq);
 
-        std::vector<faiss::idx_t> nns(k * nq);
+        std::vector<knowherefaiss::idx_t> nns(k * nq);
         std::vector<float> dis(k * nq);
 
         index.search(nq, queries.data(), k, dis.data(), nns.data());
diff --git a/thirdparty/faiss/demos/demo_imi_pq.cpp b/thirdparty/faiss/demos/demo_imi_pq.cpp
index 4fab0778..21cd500f 100644
--- a/thirdparty/faiss/demos/demo_imi_pq.cpp
+++ b/thirdparty/faiss/demos/demo_imi_pq.cpp
@@ -12,10 +12,10 @@
 
 #include <sys/time.h>
 
-#include <faiss/IndexFlat.h>
-#include <faiss/IndexIVFPQ.h>
-#include <faiss/IndexPQ.h>
-#include <faiss/index_io.h>
+#include <knowherefaiss/IndexFlat.h>
+#include <knowherefaiss/IndexIVFPQ.h>
+#include <knowherefaiss/IndexPQ.h>
+#include <knowherefaiss/index_io.h>
 
 double elapsed() {
     struct timeval tv;
@@ -48,7 +48,7 @@ int main() {
     // quantizer to the inverted-file index (with attribute do_delete_quantizer)
     //
     // Note: a regular clustering algorithm would be defined as:
-    //       faiss::IndexFlatL2 coarse_quantizer (d);
+    //       knowherefaiss::IndexFlatL2 coarse_quantizer (d);
     //
     // Use nhash=2 subquantizers used to define the product coarse quantizer
     // Number of bits: we will have 2^nbits_coarse centroids per subquantizer
@@ -66,7 +66,7 @@ int main() {
     size_t ncentroids = 1 << (nhash * nbits_subq); // total # of centroids
     int bytes_per_code = 16;
 
-    faiss::MultiIndexQuantizer coarse_quantizer(d, nhash, nbits_subq);
+    knowherefaiss::MultiIndexQuantizer coarse_quantizer(d, nhash, nbits_subq);
 
     printf("IMI (%ld,%ld): %ld virtual centroids (target: %ld base vectors)",
            nhash,
@@ -77,7 +77,7 @@ int main() {
     // the coarse quantizer should not be dealloced before the index
     // 4 = nb of bytes per code (d must be a multiple of this)
     // 8 = nb of bits per sub-code (almost always 8)
-    faiss::IndexIVFPQ index(
+    knowherefaiss::IndexIVFPQ index(
             &coarse_quantizer, d, ncentroids, bytes_per_code, 8);
     index.quantizer_trains_alone = true;
 
@@ -113,8 +113,8 @@ int main() {
     }
 
     // the index can be re-loaded later with
-    // faiss::Index * idx = faiss::read_index("/tmp/trained_index.faissindex");
-    faiss::write_index(&index, "/tmp/trained_index.faissindex");
+    // knowherefaiss::Index * idx = knowherefaiss::read_index("/tmp/trained_index.faissindex");
+    knowherefaiss::write_index(&index, "/tmp/trained_index.faissindex");
 
     size_t nq;
     std::vector<float> queries;
@@ -125,7 +125,7 @@ int main() {
                nb);
 
         std::vector<float> database(nb * d);
-        std::vector<faiss::idx_t> ids(nb);
+        std::vector<knowherefaiss::idx_t> ids(nb);
         for (size_t i = 0; i < nb; i++) {
             for (size_t j = 0; j < d; j++) {
                 database[i * d + j] = distrib(rng);
@@ -168,12 +168,12 @@ int main() {
     // - given a vector float *x, finding which k centroids are
     //   closest to it (ie to find the nearest neighbors) can be done with
     //
-    //   faiss::idx_t *centroid_ids = new faiss::idx_t[k];
+    //   knowherefaiss::idx_t *centroid_ids = new knowherefaiss::idx_t[k];
     //   float *distances = new float[k];
     //   index.quantizer->search (1, x, k, dis, centroids_ids);
     //
 
-    faiss::write_index(&index, "/tmp/populated_index.faissindex");
+    knowherefaiss::write_index(&index, "/tmp/populated_index.faissindex");
 
     { // searching the database
         int k = 5;
@@ -183,7 +183,7 @@ int main() {
                k,
                nq);
 
-        std::vector<faiss::idx_t> nns(k * nq);
+        std::vector<knowherefaiss::idx_t> nns(k * nq);
         std::vector<float> dis(k * nq);
 
         index.search(nq, queries.data(), k, dis.data(), nns.data());
diff --git a/thirdparty/faiss/demos/demo_ivfpq_indexing.cpp b/thirdparty/faiss/demos/demo_ivfpq_indexing.cpp
index 9773cac2..ecad2988 100644
--- a/thirdparty/faiss/demos/demo_ivfpq_indexing.cpp
+++ b/thirdparty/faiss/demos/demo_ivfpq_indexing.cpp
@@ -12,9 +12,9 @@
 
 #include <sys/time.h>
 
-#include <faiss/IndexFlat.h>
-#include <faiss/IndexIVFPQ.h>
-#include <faiss/index_io.h>
+#include <knowherefaiss/IndexFlat.h>
+#include <knowherefaiss/IndexIVFPQ.h>
+#include <knowherefaiss/index_io.h>
 
 double elapsed() {
     struct timeval tv;
@@ -36,7 +36,7 @@ int main() {
     size_t nt = 100 * 1000;
 
     // make the index object and train it
-    faiss::IndexFlatL2 coarse_quantizer(d);
+    knowherefaiss::IndexFlatL2 coarse_quantizer(d);
 
     // a reasonable number of centroids to index nb vectors
     int ncentroids = int(4 * sqrt(nb));
@@ -44,7 +44,7 @@ int main() {
     // the coarse quantizer should not be dealloced before the index
     // 4 = nb of bytes per code (d must be a multiple of this)
     // 8 = nb of bits per sub-code (almost always 8)
-    faiss::IndexIVFPQ index(&coarse_quantizer, d, ncentroids, 4, 8);
+    knowherefaiss::IndexIVFPQ index(&coarse_quantizer, d, ncentroids, 4, 8);
 
     std::mt19937 rng;
 
@@ -118,7 +118,7 @@ int main() {
                k,
                nq);
 
-        std::vector<faiss::idx_t> nns(k * nq);
+        std::vector<knowherefaiss::idx_t> nns(k * nq);
         std::vector<float> dis(k * nq);
 
         index.search(nq, queries.data(), k, dis.data(), nns.data());
diff --git a/thirdparty/faiss/demos/demo_nndescent.cpp b/thirdparty/faiss/demos/demo_nndescent.cpp
index 34594b03..0b4a7350 100644
--- a/thirdparty/faiss/demos/demo_nndescent.cpp
+++ b/thirdparty/faiss/demos/demo_nndescent.cpp
@@ -10,8 +10,8 @@
 #include <cstdlib>
 #include <random>
 
-#include <faiss/IndexFlat.h>
-#include <faiss/IndexNNDescent.h>
+#include <knowherefaiss/IndexFlat.h>
+#include <knowherefaiss/IndexNNDescent.h>
 
 using namespace std::chrono;
 
@@ -26,7 +26,7 @@ int main(void) {
     std::mt19937 rng(12345);
 
     // make the index object and train it
-    faiss::IndexNNDescentFlat index(d, K, faiss::METRIC_L2);
+    knowherefaiss::IndexNNDescentFlat index(d, K, knowherefaiss::METRIC_L2);
     index.nndescent.S = 10;
     index.nndescent.R = 32;
     index.nndescent.L = K;
@@ -34,7 +34,7 @@ int main(void) {
     index.verbose = true;
 
     // generate labels by IndexFlat
-    faiss::IndexFlat bruteforce(d, faiss::METRIC_L2);
+    knowherefaiss::IndexFlat bruteforce(d, knowherefaiss::METRIC_L2);
 
     std::vector<float> database(nb * d);
     for (size_t i = 0; i < nb * d; i++) {
@@ -58,8 +58,8 @@ int main(void) {
         }
 
         int k = 5;
-        std::vector<faiss::idx_t> nns(k * nq);
-        std::vector<faiss::idx_t> gt_nns(k * nq);
+        std::vector<knowherefaiss::idx_t> nns(k * nq);
+        std::vector<knowherefaiss::idx_t> gt_nns(k * nq);
         std::vector<float> dis(k * nq);
 
         auto start = high_resolution_clock::now();
diff --git a/thirdparty/faiss/demos/demo_residual_quantizer.cpp b/thirdparty/faiss/demos/demo_residual_quantizer.cpp
index 6a0fe4e7..858ac4cb 100644
--- a/thirdparty/faiss/demos/demo_residual_quantizer.cpp
+++ b/thirdparty/faiss/demos/demo_residual_quantizer.cpp
@@ -9,14 +9,14 @@
 #include <cstdio>
 #include <memory>
 
-#include <faiss/IVFlib.h>
-#include <faiss/IndexAdditiveQuantizer.h>
-#include <faiss/IndexIVFAdditiveQuantizer.h>
-#include <faiss/MetricType.h>
-#include <faiss/utils/distances.h>
-#include <faiss/utils/hamming.h>
-#include <faiss/utils/random.h>
-#include <faiss/utils/utils.h>
+#include <knowherefaiss/IVFlib.h>
+#include <knowherefaiss/IndexAdditiveQuantizer.h>
+#include <knowherefaiss/IndexIVFAdditiveQuantizer.h>
+#include <knowherefaiss/MetricType.h>
+#include <knowherefaiss/utils/distances.h>
+#include <knowherefaiss/utils/hamming.h>
+#include <knowherefaiss/utils/random.h>
+#include <knowherefaiss/utils/utils.h>
 
 /* This demo file shows how to:
  * - use a DistanceComputer to compute distances with encoded vectors
@@ -29,15 +29,15 @@ int main() {
     /******************************************
      * Generate a test dataset
      ******************************************/
-    using idx_t = faiss::idx_t;
+    using idx_t = knowherefaiss::idx_t;
     size_t d = 128;
     size_t nt = 10000;
     size_t nb = 10000;
     size_t nq = 100;
-    double t0 = faiss::getmillisecs();
+    double t0 = knowherefaiss::getmillisecs();
 
     auto tic = [t0]() {
-        printf("[%.3f s] ", (faiss::getmillisecs() - t0) / 1000);
+        printf("[%.3f s] ", (knowherefaiss::getmillisecs() - t0) / 1000);
     };
 
     tic();
@@ -48,7 +48,7 @@ int main() {
            nt);
 
     std::vector<float> buf(d * (nq + nt + nb));
-    faiss::rand_smooth_vectors(nq + nt + nb, d, buf.data(), 1234);
+    knowherefaiss::rand_smooth_vectors(nq + nt + nb, d, buf.data(), 1234);
     const float* xt = buf.data();
     const float* xb = buf.data() + nt * d;
     const float* xq = buf.data() + (nt + nb) * d;
@@ -58,13 +58,13 @@ int main() {
     std::vector<float> unused(k * nq);
     tic();
     printf("compute ground truth, k=%zd\n", k);
-    faiss::knn_L2sqr(xq, xb, d, nq, nb, k, unused.data(), gt.data());
+    knowherefaiss::knn_L2sqr(xq, xb, d, nq, nb, k, unused.data(), gt.data());
 
     // a function to compute the accuracy
     auto accuracy = [&](const idx_t* I) {
         idx_t accu = 0;
         for (idx_t q = 0; q < nq; q++) {
-            accu += faiss::ranklist_intersection_size(
+            accu += knowherefaiss::ranklist_intersection_size(
                     k, gt.data() + q * k, k, I + q * k);
         }
         return double(accu) / (k * nq);
@@ -74,8 +74,8 @@ int main() {
      * Prepare the residual quantizer
      ******************************************/
 
-    faiss::ResidualQuantizer rq(
-            d, 7, 6, faiss::AdditiveQuantizer::ST_norm_qint8);
+    knowherefaiss::ResidualQuantizer rq(
+            d, 7, 6, knowherefaiss::AdditiveQuantizer::ST_norm_qint8);
     // do cheap an inaccurate training
     rq.cp.niter = 5;
     rq.max_beam_size = 5;
@@ -95,8 +95,8 @@ int main() {
      * Verify that a distance computer gives the same distances
      ****************************************************************/
     {
-        faiss::IndexResidualQuantizer index(
-                rq.d, rq.nbits, faiss::METRIC_L2, rq.search_type);
+        knowherefaiss::IndexResidualQuantizer index(
+                rq.d, rq.nbits, knowherefaiss::METRIC_L2, rq.search_type);
 
         // override trained index
         index.rq = rq;
@@ -115,7 +115,7 @@ int main() {
 
         tic();
         printf("Accuracy (intersection @ %zd): %.3f\n", k, accuracy(I.data()));
-        std::unique_ptr<faiss::FlatCodesDistanceComputer> dc(
+        std::unique_ptr<knowherefaiss::FlatCodesDistanceComputer> dc(
                 index.get_FlatCodesDistanceComputer());
 
         float max_diff12 = 0, max_diff13 = 0;
@@ -158,7 +158,7 @@ int main() {
         // build a coarse quantizer from the 2 first levels of the RQ
         std::vector<size_t> nbits(2);
         std::copy(rq.nbits.begin(), rq.nbits.begin() + 2, nbits.begin());
-        faiss::ResidualCoarseQuantizer rcq(rq.d, nbits);
+        knowherefaiss::ResidualCoarseQuantizer rcq(rq.d, nbits);
 
         // set the coarse quantizer from the 2 first quantizers
         rcq.rq.initialize_from(rq);
@@ -174,8 +174,8 @@ int main() {
         printf("RCQ nlist = %zd tot_bits=%zd\n", nlist, rcq.rq.tot_bits);
 
         // build a IVFResidualQuantizer from that
-        faiss::IndexIVFResidualQuantizer index(
-                &rcq, rcq.d, nlist, rq.nbits, faiss::METRIC_L2, rq.search_type);
+        knowherefaiss::IndexIVFResidualQuantizer index(
+                &rcq, rcq.d, nlist, rq.nbits, knowherefaiss::METRIC_L2, rq.search_type);
         index.by_residual = false;
         index.rq = rq;
         index.is_trained = true;
@@ -195,7 +195,7 @@ int main() {
             } else if (filled_with == "manual") {
                 // compute inverted lists and add elements manually
                 // fill in the inverted index manually
-                faiss::InvertedLists& invlists = *index.invlists;
+                knowherefaiss::InvertedLists& invlists = *index.invlists;
 
                 // assign vectors to inverted lists
                 std::vector<idx_t> listnos(nb);
@@ -212,12 +212,12 @@ int main() {
             } else if (filled_with == "derived") {
                 // Since we have the raw codes precomputed, their prefix is the
                 // inverted list index, so let's use that.
-                faiss::InvertedLists& invlists = *index.invlists;
+                knowherefaiss::InvertedLists& invlists = *index.invlists;
 
                 // populate inverted lists
                 for (idx_t i = 0; i < nb; i++) {
                     const uint8_t* code = &raw_codes[i * code_size];
-                    faiss::BitstringReader rd(code, code_size);
+                    knowherefaiss::BitstringReader rd(code, code_size);
                     idx_t list_no =
                             rd.read(rcq.rq.tot_bits); // read the list number
                     invlists.add_entry(list_no, i, code);
@@ -254,8 +254,8 @@ int main() {
         // build a coarse quantizer from the 2 first levels of the RQ
         int nlevel = 2;
 
-        std::unique_ptr<faiss::IndexIVFResidualQuantizer> index(
-                faiss::ivflib::ivf_residual_from_quantizer(rq, nlevel));
+        std::unique_ptr<knowherefaiss::IndexIVFResidualQuantizer> index(
+                knowherefaiss::ivflib::ivf_residual_from_quantizer(rq, nlevel));
 
         // there are 2 ways of filling up the index...
         for (std::string filled_with : {"add", "derived"}) {
@@ -270,7 +270,7 @@ int main() {
                 // standard add method
                 index->add(nb, xb);
             } else if (filled_with == "derived") {
-                faiss::ivflib::ivf_residual_add_from_flat_codes(
+                knowherefaiss::ivflib::ivf_residual_add_from_flat_codes(
                         index.get(), nb, raw_codes.data(), rq.code_size);
             }
 
diff --git a/thirdparty/faiss/demos/demo_sift1M.cpp b/thirdparty/faiss/demos/demo_sift1M.cpp
index 598565f8..8fcf9f96 100644
--- a/thirdparty/faiss/demos/demo_sift1M.cpp
+++ b/thirdparty/faiss/demos/demo_sift1M.cpp
@@ -17,8 +17,8 @@
 
 #include <sys/time.h>
 
-#include <faiss/AutoTune.h>
-#include <faiss/index_factory.h>
+#include <knowherefaiss/AutoTune.h>
+#include <knowherefaiss/index_factory.h>
 
 /**
  * To run this demo, please download the ANN_SIFT1M dataset from
@@ -90,7 +90,7 @@ int main() {
     // const char *index_key = "IMI2x8,PQ8+16";
     // const char *index_key = "OPQ16_64,IMI2x8,PQ8+16";
 
-    faiss::Index* index;
+    knowherefaiss::Index* index;
 
     size_t d;
 
@@ -104,7 +104,7 @@ int main() {
                elapsed() - t0,
                index_key,
                d);
-        index = faiss::index_factory(d, index_key);
+        index = knowherefaiss::index_factory(d, index_key);
 
         printf("[%.3f s] Training on %ld vectors\n", elapsed() - t0, nt);
 
@@ -141,7 +141,7 @@ int main() {
     }
 
     size_t k;         // nb of results per query in the GT
-    faiss::idx_t* gt; // nq * k matrix of ground-truth nearest-neighbors
+    knowherefaiss::idx_t* gt; // nq * k matrix of ground-truth nearest-neighbors
 
     {
         printf("[%.3f s] Loading ground truth for %ld queries\n",
@@ -153,7 +153,7 @@ int main() {
         int* gt_int = ivecs_read("sift1M/sift_groundtruth.ivecs", &k, &nq2);
         assert(nq2 == nq || !"incorrect nb of ground truth entries");
 
-        gt = new faiss::idx_t[k * nq];
+        gt = new knowherefaiss::idx_t[k * nq];
         for (int i = 0; i < k * nq; i++) {
             gt[i] = gt_int[i];
         }
@@ -171,13 +171,13 @@ int main() {
                k,
                nq);
 
-        faiss::OneRecallAtRCriterion crit(nq, 1);
+        knowherefaiss::OneRecallAtRCriterion crit(nq, 1);
         crit.set_groundtruth(k, nullptr, gt);
         crit.nnn = k; // by default, the criterion will request only 1 NN
 
         printf("[%.3f s] Preparing auto-tune parameters\n", elapsed() - t0);
 
-        faiss::ParameterSpace params;
+        knowherefaiss::ParameterSpace params;
         params.initialize(index);
 
         printf("[%.3f s] Auto-tuning over %ld parameters (%ld combinations)\n",
@@ -185,7 +185,7 @@ int main() {
                params.parameter_ranges.size(),
                params.n_combinations());
 
-        faiss::OperatingPoints ops;
+        knowherefaiss::OperatingPoints ops;
         params.explore(index, nq, xq, crit, &ops);
 
         printf("[%.3f s] Found the following operating points: \n",
@@ -206,7 +206,7 @@ int main() {
 
     { // Use the found configuration to perform a search
 
-        faiss::ParameterSpace params;
+        knowherefaiss::ParameterSpace params;
 
         printf("[%.3f s] Setting parameter configuration \"%s\" on index\n",
                elapsed() - t0,
@@ -219,7 +219,7 @@ int main() {
                nq);
 
         // output buffers
-        faiss::idx_t* I = new faiss::idx_t[nq * k];
+        knowherefaiss::idx_t* I = new knowherefaiss::idx_t[nq * k];
         float* D = new float[nq * k];
 
         index->search(nq, xq, k, D, I);
diff --git a/thirdparty/faiss/demos/demo_weighted_kmeans.cpp b/thirdparty/faiss/demos/demo_weighted_kmeans.cpp
index 24502913..605a3064 100644
--- a/thirdparty/faiss/demos/demo_weighted_kmeans.cpp
+++ b/thirdparty/faiss/demos/demo_weighted_kmeans.cpp
@@ -9,11 +9,11 @@
 #include <cstdlib>
 #include <memory>
 
-#include <faiss/Clustering.h>
-#include <faiss/IndexFlat.h>
-#include <faiss/IndexHNSW.h>
-#include <faiss/utils/distances.h>
-#include <faiss/utils/random.h>
+#include <knowherefaiss/Clustering.h>
+#include <knowherefaiss/IndexFlat.h>
+#include <knowherefaiss/IndexHNSW.h>
+#include <knowherefaiss/utils/distances.h>
+#include <knowherefaiss/utils/random.h>
 
 namespace {
 
@@ -32,7 +32,7 @@ float weighted_kmeans_clustering(
         const float* weights,
         float* centroids,
         WeightedKMeansType index_num) {
-    using namespace faiss;
+    using namespace knowherefaiss;
     Clustering clus(d, k);
     clus.verbose = true;
 
@@ -87,12 +87,12 @@ void generate_trainset(
     // same sampling as test_build_blocks.py test_weighted
 
     ccent.resize(d * 2 * nc);
-    faiss::float_randn(ccent.data(), d * 2 * nc, 123);
-    faiss::fvec_renorm_L2(d, 2 * nc, ccent.data());
+    knowherefaiss::float_randn(ccent.data(), d * 2 * nc, 123);
+    knowherefaiss::fvec_renorm_L2(d, 2 * nc, ccent.data());
     n = nc * n_big + nc * n_small;
     x.resize(d * n);
     weights.resize(n);
-    faiss::float_randn(x.data(), x.size(), 1234);
+    knowherefaiss::float_randn(x.data(), x.size(), 1234);
 
     float* xi = x.data();
     float* w = weights.data();
@@ -153,10 +153,10 @@ int main(int argc, char** argv) {
                     (WeightedKMeansType)index_num);
 
             { // compute distance of points to centroids
-                faiss::IndexFlatL2 cent_index(d);
+                knowherefaiss::IndexFlatL2 cent_index(d);
                 cent_index.add(nc, centroids.data());
                 std::vector<float> dis(n);
-                std::vector<faiss::idx_t> idx(n);
+                std::vector<knowherefaiss::idx_t> idx(n);
 
                 cent_index.search(
                         nc * 2, ccent.data(), 1, dis.data(), idx.data());
diff --git a/thirdparty/faiss/demos/rocksdb_ivf/RocksDBInvertedLists.cpp b/thirdparty/faiss/demos/rocksdb_ivf/RocksDBInvertedLists.cpp
index 8d692f0b..e6d24e46 100644
--- a/thirdparty/faiss/demos/rocksdb_ivf/RocksDBInvertedLists.cpp
+++ b/thirdparty/faiss/demos/rocksdb_ivf/RocksDBInvertedLists.cpp
@@ -2,9 +2,9 @@
 
 #include "RocksDBInvertedLists.h"
 
-#include <faiss/impl/FaissAssert.h>
+#include <knowherefaiss/impl/FaissAssert.h>
 
-using namespace faiss;
+using namespace knowherefaiss;
 
 namespace faiss_rocksdb {
 
diff --git a/thirdparty/faiss/demos/rocksdb_ivf/RocksDBInvertedLists.h b/thirdparty/faiss/demos/rocksdb_ivf/RocksDBInvertedLists.h
index f9d70a4f..e85fb450 100644
--- a/thirdparty/faiss/demos/rocksdb_ivf/RocksDBInvertedLists.h
+++ b/thirdparty/faiss/demos/rocksdb_ivf/RocksDBInvertedLists.h
@@ -2,20 +2,20 @@
 
 #pragma once
 
-#include <faiss/invlists/InvertedLists.h>
+#include <knowherefaiss/invlists/InvertedLists.h>
 
 #include <rocksdb/db.h>
 
 namespace faiss_rocksdb {
 
-struct RocksDBInvertedListsIterator : faiss::InvertedListsIterator {
+struct RocksDBInvertedListsIterator : knowherefaiss::InvertedListsIterator {
     RocksDBInvertedListsIterator(
             rocksdb::DB* db,
             size_t list_no,
             size_t code_size);
     virtual bool is_available() const override;
     virtual void next() override;
-    virtual std::pair<faiss::idx_t, const uint8_t*> get_id_and_codes() override;
+    virtual std::pair<knowherefaiss::idx_t, const uint8_t*> get_id_and_codes() override;
 
    private:
     std::unique_ptr<rocksdb::Iterator> it;
@@ -24,7 +24,7 @@ struct RocksDBInvertedListsIterator : faiss::InvertedListsIterator {
     std::vector<uint8_t> codes; // buffer for returning codes in next()
 };
 
-struct RocksDBInvertedLists : faiss::InvertedLists {
+struct RocksDBInvertedLists : knowherefaiss::InvertedLists {
     RocksDBInvertedLists(
             const char* db_directory,
             size_t nlist,
@@ -32,24 +32,24 @@ struct RocksDBInvertedLists : faiss::InvertedLists {
 
     size_t list_size(size_t list_no) const override;
     const uint8_t* get_codes(size_t list_no) const override;
-    const faiss::idx_t* get_ids(size_t list_no) const override;
+    const knowherefaiss::idx_t* get_ids(size_t list_no) const override;
 
     size_t add_entries(
             size_t list_no,
             size_t n_entry,
-            const faiss::idx_t* ids,
+            const knowherefaiss::idx_t* ids,
             const uint8_t* code) override;
 
     void update_entries(
             size_t list_no,
             size_t offset,
             size_t n_entry,
-            const faiss::idx_t* ids,
+            const knowherefaiss::idx_t* ids,
             const uint8_t* code) override;
 
     void resize(size_t list_no, size_t new_size) override;
 
-    faiss::InvertedListsIterator* get_iterator(
+    knowherefaiss::InvertedListsIterator* get_iterator(
             size_t list_no,
             void* inverted_list_context) const override;
 
diff --git a/thirdparty/faiss/demos/rocksdb_ivf/demo_rocksdb_ivf.cpp b/thirdparty/faiss/demos/rocksdb_ivf/demo_rocksdb_ivf.cpp
index 72cf39eb..2f011a15 100644
--- a/thirdparty/faiss/demos/rocksdb_ivf/demo_rocksdb_ivf.cpp
+++ b/thirdparty/faiss/demos/rocksdb_ivf/demo_rocksdb_ivf.cpp
@@ -6,13 +6,13 @@
 
 #include "RocksDBInvertedLists.h"
 
-#include <faiss/IndexFlat.h>
-#include <faiss/IndexIVFFlat.h>
-#include <faiss/impl/AuxIndexStructures.h>
-#include <faiss/impl/FaissException.h>
-#include <faiss/utils/random.h>
+#include <knowherefaiss/IndexFlat.h>
+#include <knowherefaiss/IndexIVFFlat.h>
+#include <knowherefaiss/impl/AuxIndexStructures.h>
+#include <knowherefaiss/impl/FaissException.h>
+#include <knowherefaiss/utils/random.h>
 
-using namespace faiss;
+using namespace knowherefaiss;
 
 int main(int argc, char* argv[]) {
     try {
diff --git a/thirdparty/faiss/faiss/.flake8 b/thirdparty/faiss/knowherefaiss/.flake8
similarity index 100%
rename from thirdparty/faiss/faiss/.flake8
rename to thirdparty/faiss/knowherefaiss/.flake8
diff --git a/thirdparty/faiss/faiss/AutoTune.cpp b/thirdparty/faiss/knowherefaiss/AutoTune.cpp
similarity index 95%
rename from thirdparty/faiss/faiss/AutoTune.cpp
rename to thirdparty/faiss/knowherefaiss/AutoTune.cpp
index 7c663a1d..5d51c7c2 100644
--- a/thirdparty/faiss/faiss/AutoTune.cpp
+++ b/thirdparty/faiss/knowherefaiss/AutoTune.cpp
@@ -11,36 +11,36 @@
  * implementation of Hyper-parameter auto-tuning
  */
 
-#include <faiss/AutoTune.h>
+#include <knowherefaiss/AutoTune.h>
 
 #include <cinttypes>
 #include <cmath>
 #include <typeinfo>
 
-#include <faiss/impl/FaissAssert.h>
-#include <faiss/utils/random.h>
-#include <faiss/utils/utils.h>
-
-#include <faiss/IndexFlat.h>
-#include <faiss/IndexHNSW.h>
-#include <faiss/IndexIVF.h>
-#include <faiss/IndexIVFFlat.h>
-#include <faiss/IndexIVFPQ.h>
-#include <faiss/IndexIVFPQR.h>
-#include <faiss/IndexLSH.h>
-#include <faiss/IndexPQ.h>
-#include <faiss/IndexPreTransform.h>
-#include <faiss/IndexRefine.h>
-#include <faiss/IndexScalarQuantizer.h>
-#include <faiss/IndexShardsIVF.h>
-#include <faiss/MetaIndexes.h>
-#include <faiss/VectorTransform.h>
-
-#include <faiss/IndexBinaryFlat.h>
-#include <faiss/IndexBinaryHNSW.h>
-#include <faiss/IndexBinaryIVF.h>
-
-namespace faiss {
+#include <knowherefaiss/impl/FaissAssert.h>
+#include <knowherefaiss/utils/random.h>
+#include <knowherefaiss/utils/utils.h>
+
+#include <knowherefaiss/IndexFlat.h>
+#include <knowherefaiss/IndexHNSW.h>
+#include <knowherefaiss/IndexIVF.h>
+#include <knowherefaiss/IndexIVFFlat.h>
+#include <knowherefaiss/IndexIVFPQ.h>
+#include <knowherefaiss/IndexIVFPQR.h>
+#include <knowherefaiss/IndexLSH.h>
+#include <knowherefaiss/IndexPQ.h>
+#include <knowherefaiss/IndexPreTransform.h>
+#include <knowherefaiss/IndexRefine.h>
+#include <knowherefaiss/IndexScalarQuantizer.h>
+#include <knowherefaiss/IndexShardsIVF.h>
+#include <knowherefaiss/MetaIndexes.h>
+#include <knowherefaiss/VectorTransform.h>
+
+#include <knowherefaiss/IndexBinaryFlat.h>
+#include <knowherefaiss/IndexBinaryHNSW.h>
+#include <knowherefaiss/IndexBinaryIVF.h>
+
+namespace knowherefaiss {
 
 AutoTuneCriterion::AutoTuneCriterion(idx_t nq, idx_t nnn)
         : nq(nq), nnn(nnn), gt_nnn(0) {}
@@ -744,4 +744,4 @@ void ParameterSpace::explore(
     }
 }
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/AutoTune.h b/thirdparty/faiss/knowherefaiss/AutoTune.h
similarity index 97%
rename from thirdparty/faiss/faiss/AutoTune.h
rename to thirdparty/faiss/knowherefaiss/AutoTune.h
index d8c80e84..0a1da8ce 100644
--- a/thirdparty/faiss/faiss/AutoTune.h
+++ b/thirdparty/faiss/knowherefaiss/AutoTune.h
@@ -13,10 +13,10 @@
 #include <stdint.h>
 #include <vector>
 
-#include <faiss/Index.h>
-#include <faiss/IndexBinary.h>
+#include <knowherefaiss/Index.h>
+#include <knowherefaiss/IndexBinary.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 /**
  * Evaluation criterion. Returns a performance measure in [0,1],
@@ -207,6 +207,6 @@ struct ParameterSpace {
     virtual ~ParameterSpace() {}
 };
 
-} // namespace faiss
+} // namespace knowherefaiss
 
 #endif
diff --git a/thirdparty/faiss/faiss/CMakeLists.txt b/thirdparty/faiss/knowherefaiss/CMakeLists.txt
similarity index 98%
rename from thirdparty/faiss/faiss/CMakeLists.txt
rename to thirdparty/faiss/knowherefaiss/CMakeLists.txt
index 693d0ae8..d8461983 100644
--- a/thirdparty/faiss/faiss/CMakeLists.txt
+++ b/thirdparty/faiss/knowherefaiss/CMakeLists.txt
@@ -251,13 +251,13 @@ add_library(faiss ${FAISS_SRC})
 #   add_compile_options(/bigobj)
 # endif()
 
-# Handle `#include <faiss/foo.h>`.
+# Handle `#include <knowherefaiss/foo.h>`.
 target_include_directories(faiss PUBLIC
   $<BUILD_INTERFACE:${PROJECT_SOURCE_DIR}>)
-# Handle `#include <faiss/foo.h>`.
+# Handle `#include <knowherefaiss/foo.h>`.
 #target_include_directories(faiss_avx2 PUBLIC
 #  $<BUILD_INTERFACE:${PROJECT_SOURCE_DIR}>)
-# Handle `#include <faiss/foo.h>`.
+# Handle `#include <knowherefaiss/foo.h>`.
 # target_include_directories(faiss_avx512 PUBLIC
 #   $<BUILD_INTERFACE:${PROJECT_SOURCE_DIR}>)
 
@@ -338,7 +338,7 @@ install(TARGETS faiss
 foreach(header ${FAISS_HEADERS})
   get_filename_component(dir ${header} DIRECTORY )
   install(FILES ${header}
-    DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}/faiss/${dir}
+    DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}/knowherefaiss/${dir}
   )
 endforeach()
 
diff --git a/thirdparty/faiss/faiss/Clustering.cpp b/thirdparty/faiss/knowherefaiss/Clustering.cpp
similarity index 98%
rename from thirdparty/faiss/faiss/Clustering.cpp
rename to thirdparty/faiss/knowherefaiss/Clustering.cpp
index f306ed24..3a68ef30 100644
--- a/thirdparty/faiss/faiss/Clustering.cpp
+++ b/thirdparty/faiss/knowherefaiss/Clustering.cpp
@@ -7,9 +7,9 @@
 
 // -*- c++ -*-
 
-#include <faiss/Clustering.h>
-#include <faiss/VectorTransform.h>
-#include <faiss/impl/AuxIndexStructures.h>
+#include <knowherefaiss/Clustering.h>
+#include <knowherefaiss/VectorTransform.h>
+#include <knowherefaiss/impl/AuxIndexStructures.h>
 
 #include <chrono>
 #include <cinttypes>
@@ -19,15 +19,15 @@
 
 #include <omp.h>
 
-#include <faiss/FaissHook.h>
-#include <faiss/IndexFlat.h>
-#include <faiss/impl/FaissAssert.h>
-#include <faiss/impl/kmeans1d.h>
-#include <faiss/utils/distances.h>
-#include <faiss/utils/random.h>
-#include <faiss/utils/utils.h>
+#include <knowherefaiss/FaissHook.h>
+#include <knowherefaiss/IndexFlat.h>
+#include <knowherefaiss/impl/FaissAssert.h>
+#include <knowherefaiss/impl/kmeans1d.h>
+#include <knowherefaiss/utils/distances.h>
+#include <knowherefaiss/utils/random.h>
+#include <knowherefaiss/utils/utils.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 Clustering::Clustering(int d, int k) : d(d), k(k) {}
 
@@ -850,4 +850,4 @@ void ProgressiveDimClustering::train(
     }
 }
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/Clustering.h b/thirdparty/faiss/knowherefaiss/Clustering.h
similarity index 98%
rename from thirdparty/faiss/faiss/Clustering.h
rename to thirdparty/faiss/knowherefaiss/Clustering.h
index fdc493e3..04b3a892 100644
--- a/thirdparty/faiss/faiss/Clustering.h
+++ b/thirdparty/faiss/knowherefaiss/Clustering.h
@@ -9,11 +9,11 @@
 
 #ifndef FAISS_CLUSTERING_H
 #define FAISS_CLUSTERING_H
-#include <faiss/Index.h>
+#include <knowherefaiss/Index.h>
 
 #include <vector>
 
-namespace faiss {
+namespace knowherefaiss {
 
 /**
  * The algorithm of clustering
@@ -120,7 +120,7 @@ struct Clustering : ClusteringParameters {
     virtual void train(
             idx_t n,
             const float* x,
-            faiss::Index& index,
+            knowherefaiss::Index& index,
             const float* x_weights = nullptr);
 
     /**
@@ -253,6 +253,6 @@ float kmeans_clustering(
         const float* x,
         float* centroids);
 
-} // namespace faiss
+} // namespace knowherefaiss
 
 #endif
diff --git a/thirdparty/faiss/faiss/FaissHook.cpp b/thirdparty/faiss/knowherefaiss/FaissHook.cpp
similarity index 83%
rename from thirdparty/faiss/faiss/FaissHook.cpp
rename to thirdparty/faiss/knowherefaiss/FaissHook.cpp
index 953785a6..d16c9400 100644
--- a/thirdparty/faiss/faiss/FaissHook.cpp
+++ b/thirdparty/faiss/knowherefaiss/FaissHook.cpp
@@ -4,12 +4,12 @@
 #include <iostream>
 #include <mutex>
 
-#include <faiss/FaissHook.h>
-#include <faiss/impl/ScalarQuantizerDC.h>
-#include <faiss/impl/ScalarQuantizerDC_avx.h>
-#include <faiss/impl/ScalarQuantizerDC_avx512.h>
-#include <faiss/impl/ScalarQuantizerDC_neon.h>
-namespace faiss {
+#include <knowherefaiss/FaissHook.h>
+#include <knowherefaiss/impl/ScalarQuantizerDC.h>
+#include <knowherefaiss/impl/ScalarQuantizerDC_avx.h>
+#include <knowherefaiss/impl/ScalarQuantizerDC_avx512.h>
+#include <knowherefaiss/impl/ScalarQuantizerDC_neon.h>
+namespace knowherefaiss {
 
 sq_get_distance_computer_func_ptr sq_get_distance_computer =
         sq_get_distance_computer_ref;
@@ -52,4 +52,4 @@ void sq_hook() {
 #endif
 }
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/FaissHook.h b/thirdparty/faiss/knowherefaiss/FaissHook.h
similarity index 86%
rename from thirdparty/faiss/faiss/FaissHook.h
rename to thirdparty/faiss/knowherefaiss/FaissHook.h
index 5f6ad457..5add44c9 100644
--- a/thirdparty/faiss/faiss/FaissHook.h
+++ b/thirdparty/faiss/knowherefaiss/FaissHook.h
@@ -5,10 +5,10 @@
 
 #include <string>
 
-#include <faiss/MetricType.h>
-#include <faiss/impl/ScalarQuantizer.h>
+#include <knowherefaiss/MetricType.h>
+#include <knowherefaiss/impl/ScalarQuantizer.h>
 #include "simd/hook.h"
-namespace faiss {
+namespace knowherefaiss {
 
 // todo aguzhva: replace FaissHook.h with simd/hook.h
 
@@ -36,4 +36,4 @@ extern sq_get_distance_computer_func_ptr sq_get_distance_computer;
 extern sq_sel_quantizer_func_ptr sq_sel_quantizer;
 extern sq_sel_inv_list_scanner_func_ptr sq_sel_inv_list_scanner;
 void sq_hook();
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/IVFlib.cpp b/thirdparty/faiss/knowherefaiss/IVFlib.cpp
similarity index 90%
rename from thirdparty/faiss/faiss/IVFlib.cpp
rename to thirdparty/faiss/knowherefaiss/IVFlib.cpp
index 2d80d6c2..02e75576 100644
--- a/thirdparty/faiss/faiss/IVFlib.cpp
+++ b/thirdparty/faiss/knowherefaiss/IVFlib.cpp
@@ -5,33 +5,33 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/IVFlib.h>
+#include <knowherefaiss/IVFlib.h>
 #include <omp.h>
 
 #include <memory>
 
-#include <faiss/FaissHook.h>
-#include <faiss/IndexAdditiveQuantizer.h>
-#include <faiss/IndexIVFAdditiveQuantizer.h>
-#include <faiss/IndexIVFIndependentQuantizer.h>
-#include <faiss/IndexPreTransform.h>
-#include <faiss/IndexRefine.h>
-#include <faiss/MetaIndexes.h>
-#include <faiss/impl/FaissAssert.h>
-#include <faiss/utils/distances.h>
-#include <faiss/utils/hamming.h>
-#include <faiss/utils/utils.h>
-
-namespace faiss {
+#include <knowherefaiss/FaissHook.h>
+#include <knowherefaiss/IndexAdditiveQuantizer.h>
+#include <knowherefaiss/IndexIVFAdditiveQuantizer.h>
+#include <knowherefaiss/IndexIVFIndependentQuantizer.h>
+#include <knowherefaiss/IndexPreTransform.h>
+#include <knowherefaiss/IndexRefine.h>
+#include <knowherefaiss/MetaIndexes.h>
+#include <knowherefaiss/impl/FaissAssert.h>
+#include <knowherefaiss/utils/distances.h>
+#include <knowherefaiss/utils/hamming.h>
+#include <knowherefaiss/utils/utils.h>
+
+namespace knowherefaiss {
 namespace ivflib {
 
 void check_compatible_for_merge(const Index* index0, const Index* index1) {
-    const faiss::IndexPreTransform* pt0 =
-            dynamic_cast<const faiss::IndexPreTransform*>(index0);
+    const knowherefaiss::IndexPreTransform* pt0 =
+            dynamic_cast<const knowherefaiss::IndexPreTransform*>(index0);
 
     if (pt0) {
-        const faiss::IndexPreTransform* pt1 =
-                dynamic_cast<const faiss::IndexPreTransform*>(index1);
+        const knowherefaiss::IndexPreTransform* pt1 =
+                dynamic_cast<const knowherefaiss::IndexPreTransform*>(index1);
         FAISS_THROW_IF_NOT_MSG(pt1, "both indexes should be pretransforms");
 
         FAISS_THROW_IF_NOT(pt0->chain.size() == pt1->chain.size());
@@ -47,10 +47,10 @@ void check_compatible_for_merge(const Index* index0, const Index* index1) {
             index0->d == index1->d &&
             index0->metric_type == index1->metric_type);
 
-    const faiss::IndexIVF* ivf0 = dynamic_cast<const faiss::IndexIVF*>(index0);
+    const knowherefaiss::IndexIVF* ivf0 = dynamic_cast<const knowherefaiss::IndexIVF*>(index0);
     if (ivf0) {
-        const faiss::IndexIVF* ivf1 =
-                dynamic_cast<const faiss::IndexIVF*>(index1);
+        const knowherefaiss::IndexIVF* ivf1 =
+                dynamic_cast<const knowherefaiss::IndexIVF*>(index1);
         FAISS_THROW_IF_NOT(ivf1);
 
         ivf0->check_compatible_for_merge(*ivf1);
@@ -99,7 +99,7 @@ IndexIVF* extract_index_ivf(Index* index) {
     return const_cast<IndexIVF*>(extract_index_ivf((const Index*)(index)));
 }
 
-void merge_into(faiss::Index* index0, faiss::Index* index1, bool shift_ids) {
+void merge_into(knowherefaiss::Index* index0, knowherefaiss::Index* index1, bool shift_ids) {
     check_compatible_for_merge(index0, index1);
     IndexIVF* ivf0 = extract_index_ivf(index0);
     IndexIVF* ivf1 = extract_index_ivf(index1);
@@ -112,23 +112,23 @@ void merge_into(faiss::Index* index0, faiss::Index* index1, bool shift_ids) {
 }
 
 void search_centroid(
-        faiss::Index* index,
+        knowherefaiss::Index* index,
         const float* x,
         int n,
         idx_t* centroid_ids) {
     std::unique_ptr<float[]> del;
-    if (auto index_pre = dynamic_cast<faiss::IndexPreTransform*>(index)) {
+    if (auto index_pre = dynamic_cast<knowherefaiss::IndexPreTransform*>(index)) {
         x = index_pre->apply_chain(n, x);
         del.reset((float*)x);
         index = index_pre->index;
     }
-    faiss::IndexIVF* index_ivf = dynamic_cast<faiss::IndexIVF*>(index);
+    knowherefaiss::IndexIVF* index_ivf = dynamic_cast<knowherefaiss::IndexIVF*>(index);
     assert(index_ivf);
     index_ivf->quantizer->assign(n, x, centroid_ids);
 }
 
 void search_and_return_centroids(
-        faiss::Index* index,
+        knowherefaiss::Index* index,
         size_t n,
         const float* xin,
         long k,
@@ -138,12 +138,12 @@ void search_and_return_centroids(
         idx_t* result_centroid_ids) {
     const float* x = xin;
     std::unique_ptr<float[]> del;
-    if (auto index_pre = dynamic_cast<faiss::IndexPreTransform*>(index)) {
+    if (auto index_pre = dynamic_cast<knowherefaiss::IndexPreTransform*>(index)) {
         x = index_pre->apply_chain(n, x);
         del.reset((float*)x);
         index = index_pre->index;
     }
-    faiss::IndexIVF* index_ivf = dynamic_cast<faiss::IndexIVF*>(index);
+    knowherefaiss::IndexIVF* index_ivf = dynamic_cast<knowherefaiss::IndexIVF*>(index);
     assert(index_ivf);
 
     size_t nprobe = index_ivf->nprobe;
@@ -475,7 +475,7 @@ IndexIVFResidualQuantizer* ivf_residual_from_quantizer(
                     rq.d,
                     nlist,
                     nbits_refined,
-                    faiss::METRIC_L2,
+                    knowherefaiss::METRIC_L2,
                     rq.search_type));
     index->own_fields = true;
     rcq.release();
@@ -492,7 +492,7 @@ void ivf_residual_add_from_flat_codes(
         const uint8_t* raw_codes,
         int64_t code_size) {
     const ResidualCoarseQuantizer* rcq =
-            dynamic_cast<const faiss::ResidualCoarseQuantizer*>(
+            dynamic_cast<const knowherefaiss::ResidualCoarseQuantizer*>(
                     index->quantizer);
     FAISS_THROW_IF_NOT_MSG(rcq, "the coarse quantizer must be a RCQ");
     if (code_size < 0) {
@@ -539,4 +539,4 @@ void ivf_residual_add_from_flat_codes(
 }
 
 } // namespace ivflib
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/IVFlib.h b/thirdparty/faiss/knowherefaiss/IVFlib.h
similarity index 98%
rename from thirdparty/faiss/faiss/IVFlib.h
rename to thirdparty/faiss/knowherefaiss/IVFlib.h
index 5524b41e..2869306a 100644
--- a/thirdparty/faiss/faiss/IVFlib.h
+++ b/thirdparty/faiss/knowherefaiss/IVFlib.h
@@ -14,10 +14,10 @@
  * IndexIVFs embedded within an IndexPreTransform.
  */
 
-#include <faiss/IndexIVF.h>
+#include <knowherefaiss/IndexIVF.h>
 #include <vector>
 
-namespace faiss {
+namespace knowherefaiss {
 
 struct IndexIVFResidualQuantizer;
 struct IndexResidualQuantizer;
@@ -168,6 +168,6 @@ void ivf_residual_add_from_flat_codes(
         int64_t code_size = -1);
 
 } // namespace ivflib
-} // namespace faiss
+} // namespace knowherefaiss
 
 #endif
diff --git a/thirdparty/faiss/faiss/Index.cpp b/thirdparty/faiss/knowherefaiss/Index.cpp
similarity index 93%
rename from thirdparty/faiss/faiss/Index.cpp
rename to thirdparty/faiss/knowherefaiss/Index.cpp
index 123ec5e0..b4471665 100644
--- a/thirdparty/faiss/faiss/Index.cpp
+++ b/thirdparty/faiss/knowherefaiss/Index.cpp
@@ -7,18 +7,18 @@
 
 // -*- c++ -*-
 
-#include <faiss/Index.h>
+#include <knowherefaiss/Index.h>
 
-#include <faiss/FaissHook.h>
+#include <knowherefaiss/FaissHook.h>
 
-#include <faiss/impl/AuxIndexStructures.h>
-#include <faiss/impl/DistanceComputer.h>
-#include <faiss/impl/FaissAssert.h>
-#include <faiss/utils/distances.h>
+#include <knowherefaiss/impl/AuxIndexStructures.h>
+#include <knowherefaiss/impl/DistanceComputer.h>
+#include <knowherefaiss/impl/FaissAssert.h>
+#include <knowherefaiss/utils/distances.h>
 
 #include <cstring>
 
-namespace faiss {
+namespace knowherefaiss {
 
 Index::~Index() = default;
 
@@ -184,4 +184,4 @@ void Index::check_compatible_for_merge(const Index& /* otherIndex */) const {
     FAISS_THROW_MSG("check_compatible_for_merge() not implemented");
 }
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/Index.h b/thirdparty/faiss/knowherefaiss/Index.h
similarity index 98%
rename from thirdparty/faiss/faiss/Index.h
rename to thirdparty/faiss/knowherefaiss/Index.h
index 6fac99c3..38bdd5a4 100644
--- a/thirdparty/faiss/faiss/Index.h
+++ b/thirdparty/faiss/knowherefaiss/Index.h
@@ -10,7 +10,7 @@
 #ifndef FAISS_INDEX_H
 #define FAISS_INDEX_H
 
-#include <faiss/MetricType.h>
+#include <knowherefaiss/MetricType.h>
 #include <cstdio>
 #include <sstream>
 #include <string>
@@ -21,7 +21,7 @@
 #define FAISS_VERSION_PATCH 0
 
 /**
- * @namespace faiss
+ * @namespace knowherefaiss
  *
  * Throughout the library, vectors are provided as float * pointers.
  * Most algorithms can be optimized when several vectors are processed
@@ -36,7 +36,7 @@
  * an n*d matrix, which implies a row-major storage.
  */
 
-namespace faiss {
+namespace knowherefaiss {
 
 /// Forward declarations see impl/AuxIndexStructures.h, impl/IDSelector.h and
 /// impl/DistanceComputer.h
@@ -298,6 +298,6 @@ struct Index {
     virtual void check_compatible_for_merge(const Index& otherIndex) const;
 };
 
-} // namespace faiss
+} // namespace knowherefaiss
 
 #endif
diff --git a/thirdparty/faiss/faiss/Index2Layer.cpp b/thirdparty/faiss/knowherefaiss/Index2Layer.cpp
similarity index 95%
rename from thirdparty/faiss/faiss/Index2Layer.cpp
rename to thirdparty/faiss/knowherefaiss/Index2Layer.cpp
index 0cb70791..e9a5dfe4 100644
--- a/thirdparty/faiss/faiss/Index2Layer.cpp
+++ b/thirdparty/faiss/knowherefaiss/Index2Layer.cpp
@@ -7,9 +7,9 @@
 
 // -*- c++ -*-
 
-#include <faiss/Index2Layer.h>
+#include <knowherefaiss/Index2Layer.h>
 
-#include <faiss/impl/platform_macros.h>
+#include <knowherefaiss/impl/platform_macros.h>
 #include <cassert>
 #include <cinttypes>
 #include <cmath>
@@ -22,16 +22,16 @@
 
 #include <algorithm>
 
-#include <faiss/FaissHook.h>
-#include <faiss/IndexIVFPQ.h>
+#include <knowherefaiss/FaissHook.h>
+#include <knowherefaiss/IndexIVFPQ.h>
 
-#include <faiss/IndexFlat.h>
-#include <faiss/impl/AuxIndexStructures.h>
-#include <faiss/impl/FaissAssert.h>
-#include <faiss/utils/distances.h>
-#include <faiss/utils/utils.h>
+#include <knowherefaiss/IndexFlat.h>
+#include <knowherefaiss/impl/AuxIndexStructures.h>
+#include <knowherefaiss/impl/FaissAssert.h>
+#include <knowherefaiss/utils/distances.h>
+#include <knowherefaiss/utils/utils.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 /*************************************
  * Index2Layer implementation
@@ -345,4 +345,4 @@ void Index2Layer::sa_decode(idx_t n, const uint8_t* bytes, float* x) const {
     }
 }
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/Index2Layer.h b/thirdparty/faiss/knowherefaiss/Index2Layer.h
similarity index 89%
rename from thirdparty/faiss/faiss/Index2Layer.h
rename to thirdparty/faiss/knowherefaiss/Index2Layer.h
index 3b049990..bc00271a 100644
--- a/thirdparty/faiss/faiss/Index2Layer.h
+++ b/thirdparty/faiss/knowherefaiss/Index2Layer.h
@@ -11,12 +11,12 @@
 
 #include <vector>
 
-#include <faiss/IndexFlatCodes.h>
-#include <faiss/IndexIVF.h>
-#include <faiss/IndexPQ.h>
-#include <faiss/impl/platform_macros.h>
+#include <knowherefaiss/IndexFlatCodes.h>
+#include <knowherefaiss/IndexIVF.h>
+#include <knowherefaiss/IndexPQ.h>
+#include <knowherefaiss/impl/platform_macros.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 struct IndexIVFPQ;
 
@@ -75,4 +75,4 @@ struct Index2Layer : IndexFlatCodes {
 // block size used in Index2Layer::sa_encode
 FAISS_API extern int index2layer_sa_encode_bs;
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/IndexAdditiveQuantizer.cpp b/thirdparty/faiss/knowherefaiss/IndexAdditiveQuantizer.cpp
similarity index 98%
rename from thirdparty/faiss/faiss/IndexAdditiveQuantizer.cpp
rename to thirdparty/faiss/knowherefaiss/IndexAdditiveQuantizer.cpp
index 719dcafb..20bd3005 100644
--- a/thirdparty/faiss/faiss/IndexAdditiveQuantizer.cpp
+++ b/thirdparty/faiss/knowherefaiss/IndexAdditiveQuantizer.cpp
@@ -5,20 +5,20 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/IndexAdditiveQuantizer.h>
+#include <knowherefaiss/IndexAdditiveQuantizer.h>
 
 #include <algorithm>
 #include <cmath>
 #include <cstring>
 
-#include <faiss/impl/FaissAssert.h>
-#include <faiss/impl/ResidualQuantizer.h>
-#include <faiss/impl/ResultHandler.h>
-#include <faiss/utils/distances.h>
-#include <faiss/utils/extra_distances.h>
-#include <faiss/utils/utils.h>
+#include <knowherefaiss/impl/FaissAssert.h>
+#include <knowherefaiss/impl/ResidualQuantizer.h>
+#include <knowherefaiss/impl/ResultHandler.h>
+#include <knowherefaiss/utils/distances.h>
+#include <knowherefaiss/utils/extra_distances.h>
+#include <knowherefaiss/utils/utils.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 /**************************************************************************************
  * IndexAdditiveQuantizer
@@ -631,4 +631,4 @@ LocalSearchCoarseQuantizer::LocalSearchCoarseQuantizer() {
     aq = &lsq;
 }
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/IndexAdditiveQuantizer.h b/thirdparty/faiss/knowherefaiss/IndexAdditiveQuantizer.h
similarity index 95%
rename from thirdparty/faiss/faiss/IndexAdditiveQuantizer.h
rename to thirdparty/faiss/knowherefaiss/IndexAdditiveQuantizer.h
index 48f54c8b..35a5740f 100644
--- a/thirdparty/faiss/faiss/IndexAdditiveQuantizer.h
+++ b/thirdparty/faiss/knowherefaiss/IndexAdditiveQuantizer.h
@@ -8,18 +8,18 @@
 #ifndef FAISS_INDEX_ADDITIVE_QUANTIZER_H
 #define FAISS_INDEX_ADDITIVE_QUANTIZER_H
 
-#include <faiss/impl/AdditiveQuantizer.h>
+#include <knowherefaiss/impl/AdditiveQuantizer.h>
 
 #include <cstdint>
 #include <vector>
 
-#include <faiss/IndexFlatCodes.h>
-#include <faiss/impl/LocalSearchQuantizer.h>
-#include <faiss/impl/ProductAdditiveQuantizer.h>
-#include <faiss/impl/ResidualQuantizer.h>
-#include <faiss/impl/platform_macros.h>
+#include <knowherefaiss/IndexFlatCodes.h>
+#include <knowherefaiss/impl/LocalSearchQuantizer.h>
+#include <knowherefaiss/impl/ProductAdditiveQuantizer.h>
+#include <knowherefaiss/impl/ResidualQuantizer.h>
+#include <knowherefaiss/impl/platform_macros.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 /// Abstract class for additive quantizers. The search functions are in common.
 struct IndexAdditiveQuantizer : IndexFlatCodes {
@@ -257,6 +257,6 @@ struct LocalSearchCoarseQuantizer : AdditiveCoarseQuantizer {
     LocalSearchCoarseQuantizer();
 };
 
-} // namespace faiss
+} // namespace knowherefaiss
 
 #endif
diff --git a/thirdparty/faiss/faiss/IndexAdditiveQuantizerFastScan.cpp b/thirdparty/faiss/knowherefaiss/IndexAdditiveQuantizerFastScan.cpp
similarity index 95%
rename from thirdparty/faiss/faiss/IndexAdditiveQuantizerFastScan.cpp
rename to thirdparty/faiss/knowherefaiss/IndexAdditiveQuantizerFastScan.cpp
index 1ad4d609..21947fef 100644
--- a/thirdparty/faiss/faiss/IndexAdditiveQuantizerFastScan.cpp
+++ b/thirdparty/faiss/knowherefaiss/IndexAdditiveQuantizerFastScan.cpp
@@ -5,7 +5,7 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/IndexAdditiveQuantizerFastScan.h>
+#include <knowherefaiss/IndexAdditiveQuantizerFastScan.h>
 
 #include <cassert>
 #include <climits>
@@ -13,15 +13,15 @@
 
 #include <omp.h>
 
-#include <faiss/impl/FaissAssert.h>
-#include <faiss/impl/LocalSearchQuantizer.h>
-#include <faiss/impl/LookupTableScaler.h>
-#include <faiss/impl/ResidualQuantizer.h>
-#include <faiss/impl/pq4_fast_scan.h>
-#include <faiss/utils/quantize_lut.h>
-#include <faiss/utils/utils.h>
+#include <knowherefaiss/impl/FaissAssert.h>
+#include <knowherefaiss/impl/LocalSearchQuantizer.h>
+#include <knowherefaiss/impl/LookupTableScaler.h>
+#include <knowherefaiss/impl/ResidualQuantizer.h>
+#include <knowherefaiss/impl/pq4_fast_scan.h>
+#include <knowherefaiss/utils/quantize_lut.h>
+#include <knowherefaiss/utils/utils.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 inline size_t roundup(size_t a, size_t b) {
     return (a + b - 1) / b * b;
@@ -296,4 +296,4 @@ IndexProductLocalSearchQuantizerFastScan::
     aq = &plsq;
 }
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/IndexAdditiveQuantizerFastScan.h b/thirdparty/faiss/knowherefaiss/IndexAdditiveQuantizerFastScan.h
similarity index 95%
rename from thirdparty/faiss/faiss/IndexAdditiveQuantizerFastScan.h
rename to thirdparty/faiss/knowherefaiss/IndexAdditiveQuantizerFastScan.h
index d7d23336..45a3eef5 100644
--- a/thirdparty/faiss/faiss/IndexAdditiveQuantizerFastScan.h
+++ b/thirdparty/faiss/knowherefaiss/IndexAdditiveQuantizerFastScan.h
@@ -7,13 +7,13 @@
 
 #pragma once
 
-#include <faiss/IndexAdditiveQuantizer.h>
-#include <faiss/IndexFastScan.h>
-#include <faiss/impl/AdditiveQuantizer.h>
-#include <faiss/impl/ProductAdditiveQuantizer.h>
-#include <faiss/utils/AlignedTable.h>
+#include <knowherefaiss/IndexAdditiveQuantizer.h>
+#include <knowherefaiss/IndexFastScan.h>
+#include <knowherefaiss/impl/AdditiveQuantizer.h>
+#include <knowherefaiss/impl/ProductAdditiveQuantizer.h>
+#include <knowherefaiss/utils/AlignedTable.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 /** Fast scan version of IndexAQ. Works for 4-bit AQ for now.
  *
@@ -196,4 +196,4 @@ struct IndexProductLocalSearchQuantizerFastScan
     IndexProductLocalSearchQuantizerFastScan();
 };
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/IndexBinary.cpp b/thirdparty/faiss/knowherefaiss/IndexBinary.cpp
similarity index 95%
rename from thirdparty/faiss/faiss/IndexBinary.cpp
rename to thirdparty/faiss/knowherefaiss/IndexBinary.cpp
index 9c1adf83..858a3a0c 100644
--- a/thirdparty/faiss/faiss/IndexBinary.cpp
+++ b/thirdparty/faiss/knowherefaiss/IndexBinary.cpp
@@ -7,13 +7,13 @@
 
 // -*- c++ -*-
 
-#include <faiss/IndexBinary.h>
-#include <faiss/impl/FaissAssert.h>
+#include <knowherefaiss/IndexBinary.h>
+#include <knowherefaiss/impl/FaissAssert.h>
 
 #include <cinttypes>
 #include <cstring>
 
-namespace faiss {
+namespace knowherefaiss {
 
 IndexBinary::IndexBinary(idx_t d, MetricType metric)
         : d(d), code_size(d / 8), metric_type(metric) {
@@ -103,4 +103,4 @@ void IndexBinary::check_compatible_for_merge(
     FAISS_THROW_MSG("check_compatible_for_merge() not implemented");
 }
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/IndexBinary.h b/thirdparty/faiss/knowherefaiss/IndexBinary.h
similarity index 98%
rename from thirdparty/faiss/faiss/IndexBinary.h
rename to thirdparty/faiss/knowherefaiss/IndexBinary.h
index a08c34db..1e2ce20c 100644
--- a/thirdparty/faiss/faiss/IndexBinary.h
+++ b/thirdparty/faiss/knowherefaiss/IndexBinary.h
@@ -15,9 +15,9 @@
 #include <string>
 #include <typeinfo>
 
-#include <faiss/Index.h>
+#include <knowherefaiss/Index.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 /// Forward declarations see AuxIndexStructures.h
 struct IDSelector;
@@ -175,6 +175,6 @@ struct IndexBinary {
             const IndexBinary& otherIndex) const;
 };
 
-} // namespace faiss
+} // namespace knowherefaiss
 
 #endif // FAISS_INDEX_BINARY_H
diff --git a/thirdparty/faiss/faiss/IndexBinaryFlat.cpp b/thirdparty/faiss/knowherefaiss/IndexBinaryFlat.cpp
similarity index 92%
rename from thirdparty/faiss/faiss/IndexBinaryFlat.cpp
rename to thirdparty/faiss/knowherefaiss/IndexBinaryFlat.cpp
index 87400c31..9ff27b63 100644
--- a/thirdparty/faiss/faiss/IndexBinaryFlat.cpp
+++ b/thirdparty/faiss/knowherefaiss/IndexBinaryFlat.cpp
@@ -7,21 +7,21 @@
 
 // -*- c++ -*-
 
-#include <faiss/IndexBinaryFlat.h>
+#include <knowherefaiss/IndexBinaryFlat.h>
 
-#include <faiss/impl/AuxIndexStructures.h>
-#include <faiss/impl/FaissAssert.h>
-#include <faiss/impl/IDSelector.h>
-#include <faiss/utils/Heap.h>
+#include <knowherefaiss/impl/AuxIndexStructures.h>
+#include <knowherefaiss/impl/FaissAssert.h>
+#include <knowherefaiss/impl/IDSelector.h>
+#include <knowherefaiss/utils/Heap.h>
 
 // todo aguzhva: merge binary_distances with hamming_distances
-#include <faiss/utils/binary_distances.h>
-#include <faiss/utils/hamming.h>
+#include <knowherefaiss/utils/binary_distances.h>
+#include <knowherefaiss/utils/hamming.h>
 
-#include <faiss/utils/utils.h>
+#include <knowherefaiss/utils/utils.h>
 #include <cstring>
 
-namespace faiss {
+namespace knowherefaiss {
 
 IndexBinaryFlat::IndexBinaryFlat(idx_t d) : IndexBinary(d) {}
 
@@ -180,4 +180,4 @@ void IndexBinaryFlat::range_search(
     // ====================================================
 }
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/IndexBinaryFlat.h b/thirdparty/faiss/knowherefaiss/IndexBinaryFlat.h
similarity index 90%
rename from thirdparty/faiss/faiss/IndexBinaryFlat.h
rename to thirdparty/faiss/knowherefaiss/IndexBinaryFlat.h
index 13190bf6..0ac15c69 100644
--- a/thirdparty/faiss/faiss/IndexBinaryFlat.h
+++ b/thirdparty/faiss/knowherefaiss/IndexBinaryFlat.h
@@ -12,12 +12,12 @@
 
 #include <vector>
 
-#include <faiss/IndexBinary.h>
+#include <knowherefaiss/IndexBinary.h>
 
-#include <faiss/impl/maybe_owned_vector.h>
-#include <faiss/utils/approx_topk/mode.h>
+#include <knowherefaiss/impl/maybe_owned_vector.h>
+#include <knowherefaiss/utils/approx_topk/mode.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 /** Index that stores the full vectors and performs exhaustive search. */
 struct IndexBinaryFlat : IndexBinary {
@@ -67,6 +67,6 @@ struct IndexBinaryFlat : IndexBinary {
     IndexBinaryFlat() {}
 };
 
-} // namespace faiss
+} // namespace knowherefaiss
 
 #endif // INDEX_BINARY_FLAT_H
diff --git a/thirdparty/faiss/faiss/IndexBinaryFromFloat.cpp b/thirdparty/faiss/knowherefaiss/IndexBinaryFromFloat.cpp
similarity index 91%
rename from thirdparty/faiss/faiss/IndexBinaryFromFloat.cpp
rename to thirdparty/faiss/knowherefaiss/IndexBinaryFromFloat.cpp
index 407c9199..3e60e65c 100644
--- a/thirdparty/faiss/faiss/IndexBinaryFromFloat.cpp
+++ b/thirdparty/faiss/knowherefaiss/IndexBinaryFromFloat.cpp
@@ -7,14 +7,14 @@
 
 // -*- c++ -*-
 
-#include <faiss/IndexBinaryFromFloat.h>
+#include <knowherefaiss/IndexBinaryFromFloat.h>
 
-#include <faiss/impl/FaissAssert.h>
-#include <faiss/utils/utils.h>
+#include <knowherefaiss/impl/FaissAssert.h>
+#include <knowherefaiss/utils/utils.h>
 #include <algorithm>
 #include <memory>
 
-namespace faiss {
+namespace knowherefaiss {
 
 IndexBinaryFromFloat::IndexBinaryFromFloat() = default;
 
@@ -83,4 +83,4 @@ void IndexBinaryFromFloat::train(idx_t n, const uint8_t* x) {
     ntotal = index->ntotal;
 }
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/IndexBinaryFromFloat.h b/thirdparty/faiss/knowherefaiss/IndexBinaryFromFloat.h
similarity index 92%
rename from thirdparty/faiss/faiss/IndexBinaryFromFloat.h
rename to thirdparty/faiss/knowherefaiss/IndexBinaryFromFloat.h
index 3f6c98c9..9add6ae8 100644
--- a/thirdparty/faiss/faiss/IndexBinaryFromFloat.h
+++ b/thirdparty/faiss/knowherefaiss/IndexBinaryFromFloat.h
@@ -10,9 +10,9 @@
 #ifndef FAISS_INDEX_BINARY_FROM_FLOAT_H
 #define FAISS_INDEX_BINARY_FROM_FLOAT_H
 
-#include <faiss/IndexBinary.h>
+#include <knowherefaiss/IndexBinary.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 struct Index;
 
@@ -49,6 +49,6 @@ struct IndexBinaryFromFloat : IndexBinary {
     void train(idx_t n, const uint8_t* x) override;
 };
 
-} // namespace faiss
+} // namespace knowherefaiss
 
 #endif // FAISS_INDEX_BINARY_FROM_FLOAT_H
diff --git a/thirdparty/faiss/faiss/IndexBinaryHNSW.cpp b/thirdparty/faiss/knowherefaiss/IndexBinaryHNSW.cpp
similarity index 94%
rename from thirdparty/faiss/faiss/IndexBinaryHNSW.cpp
rename to thirdparty/faiss/knowherefaiss/IndexBinaryHNSW.cpp
index 6063b2bc..15330054 100644
--- a/thirdparty/faiss/faiss/IndexBinaryHNSW.cpp
+++ b/thirdparty/faiss/knowherefaiss/IndexBinaryHNSW.cpp
@@ -5,7 +5,7 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/IndexBinaryHNSW.h>
+#include <knowherefaiss/IndexBinaryHNSW.h>
 
 #include <omp.h>
 #include <cassert>
@@ -22,16 +22,16 @@
 #include <sys/types.h>
 #include <cstdint>
 
-#include <faiss/IndexBinaryFlat.h>
-#include <faiss/impl/AuxIndexStructures.h>
-#include <faiss/impl/DistanceComputer.h>
-#include <faiss/impl/FaissAssert.h>
-#include <faiss/impl/ResultHandler.h>
-#include <faiss/utils/Heap.h>
-#include <faiss/utils/hamming.h>
-#include <faiss/utils/random.h>
+#include <knowherefaiss/IndexBinaryFlat.h>
+#include <knowherefaiss/impl/AuxIndexStructures.h>
+#include <knowherefaiss/impl/DistanceComputer.h>
+#include <knowherefaiss/impl/FaissAssert.h>
+#include <knowherefaiss/impl/ResultHandler.h>
+#include <knowherefaiss/utils/Heap.h>
+#include <knowherefaiss/utils/hamming.h>
+#include <knowherefaiss/utils/random.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 /**************************************************************
  * add / search blocks of descriptors
@@ -301,4 +301,4 @@ DistanceComputer* IndexBinaryHNSW::get_distance_computer() const {
     return dispatch_HammingComputer(code_size, bd, flat_storage);
 }
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/IndexBinaryHNSW.h b/thirdparty/faiss/knowherefaiss/IndexBinaryHNSW.h
similarity index 87%
rename from thirdparty/faiss/faiss/IndexBinaryHNSW.h
rename to thirdparty/faiss/knowherefaiss/IndexBinaryHNSW.h
index 3ba919ab..e0002e9c 100644
--- a/thirdparty/faiss/faiss/IndexBinaryHNSW.h
+++ b/thirdparty/faiss/knowherefaiss/IndexBinaryHNSW.h
@@ -9,11 +9,11 @@
 
 #pragma once
 
-#include <faiss/IndexBinaryFlat.h>
-#include <faiss/impl/HNSW.h>
-#include <faiss/utils/utils.h>
+#include <knowherefaiss/IndexBinaryFlat.h>
+#include <knowherefaiss/impl/HNSW.h>
+#include <knowherefaiss/utils/utils.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 /** The HNSW index is a normal random-access index with a HNSW
  * link structure built on top */
@@ -55,4 +55,4 @@ struct IndexBinaryHNSW : IndexBinary {
     void reset() override;
 };
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/IndexBinaryHash.cpp b/thirdparty/faiss/knowherefaiss/IndexBinaryHash.cpp
similarity index 97%
rename from thirdparty/faiss/faiss/IndexBinaryHash.cpp
rename to thirdparty/faiss/knowherefaiss/IndexBinaryHash.cpp
index ecfb0e02..56985030 100644
--- a/thirdparty/faiss/faiss/IndexBinaryHash.cpp
+++ b/thirdparty/faiss/knowherefaiss/IndexBinaryHash.cpp
@@ -7,21 +7,21 @@
 
 // -*- c++ -*-
 
-#include <faiss/IndexBinaryHash.h>
+#include <knowherefaiss/IndexBinaryHash.h>
 
 #include <cinttypes>
 #include <cstdio>
 #include <memory>
 #include <unordered_set>
 
-#include <faiss/utils/hamming.h>
-#include <faiss/utils/utils.h>
+#include <knowherefaiss/utils/hamming.h>
+#include <knowherefaiss/utils/utils.h>
 
-#include <faiss/impl/AuxIndexStructures.h>
-#include <faiss/impl/FaissAssert.h>
-#include <faiss/impl/platform_macros.h>
+#include <knowherefaiss/impl/AuxIndexStructures.h>
+#include <knowherefaiss/impl/FaissAssert.h>
+#include <knowherefaiss/impl/platform_macros.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 void IndexBinaryHash::InvertedList::add(
         idx_t id,
@@ -479,4 +479,4 @@ size_t IndexBinaryMultiHash::hashtable_size() const {
     return tot;
 }
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/IndexBinaryHash.h b/thirdparty/faiss/knowherefaiss/IndexBinaryHash.h
similarity index 92%
rename from thirdparty/faiss/faiss/IndexBinaryHash.h
rename to thirdparty/faiss/knowherefaiss/IndexBinaryHash.h
index d39290ca..3f0c2952 100644
--- a/thirdparty/faiss/faiss/IndexBinaryHash.h
+++ b/thirdparty/faiss/knowherefaiss/IndexBinaryHash.h
@@ -13,12 +13,12 @@
 #include <unordered_map>
 #include <vector>
 
-#include <faiss/IndexBinary.h>
-#include <faiss/IndexBinaryFlat.h>
-#include <faiss/impl/platform_macros.h>
-#include <faiss/utils/Heap.h>
+#include <knowherefaiss/IndexBinary.h>
+#include <knowherefaiss/IndexBinaryFlat.h>
+#include <knowherefaiss/impl/platform_macros.h>
+#include <knowherefaiss/utils/Heap.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 struct RangeSearchResult;
 
@@ -123,6 +123,6 @@ struct IndexBinaryMultiHash : IndexBinary {
     size_t hashtable_size() const;
 };
 
-} // namespace faiss
+} // namespace knowherefaiss
 
 #endif
diff --git a/thirdparty/faiss/faiss/IndexBinaryIVF.cpp b/thirdparty/faiss/knowherefaiss/IndexBinaryIVF.cpp
similarity index 98%
rename from thirdparty/faiss/faiss/IndexBinaryIVF.cpp
rename to thirdparty/faiss/knowherefaiss/IndexBinaryIVF.cpp
index 11808a78..4cd64ac3 100644
--- a/thirdparty/faiss/faiss/IndexBinaryIVF.cpp
+++ b/thirdparty/faiss/knowherefaiss/IndexBinaryIVF.cpp
@@ -7,7 +7,7 @@
 
 // -*- c++ -*-
 
-#include <faiss/IndexBinaryIVF.h>
+#include <knowherefaiss/IndexBinaryIVF.h>
 
 #include <omp.h>
 #include <cinttypes>
@@ -16,16 +16,16 @@
 #include <algorithm>
 #include <memory>
 
-#include <faiss/IndexFlat.h>
-#include <faiss/IndexLSH.h>
-#include <faiss/impl/AuxIndexStructures.h>
-#include <faiss/impl/FaissAssert.h>
-#include <faiss/utils/jaccard-inl.h>
-#include <faiss/utils/hamming.h>
-#include <faiss/utils/sorting.h>
-#include <faiss/utils/utils.h>
+#include <knowherefaiss/IndexFlat.h>
+#include <knowherefaiss/IndexLSH.h>
+#include <knowherefaiss/impl/AuxIndexStructures.h>
+#include <knowherefaiss/impl/FaissAssert.h>
+#include <knowherefaiss/utils/jaccard-inl.h>
+#include <knowherefaiss/utils/hamming.h>
+#include <knowherefaiss/utils/sorting.h>
+#include <knowherefaiss/utils/utils.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 IndexBinaryIVF::IndexBinaryIVF(IndexBinary* quantizer, size_t d, size_t nlist)
         : IndexBinary(d),
@@ -1240,4 +1240,4 @@ IndexBinaryIVF::~IndexBinaryIVF() {
     }
 }
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/IndexBinaryIVF.h b/thirdparty/faiss/knowherefaiss/IndexBinaryIVF.h
similarity index 97%
rename from thirdparty/faiss/faiss/IndexBinaryIVF.h
rename to thirdparty/faiss/knowherefaiss/IndexBinaryIVF.h
index bbc05b6a..e7f2cc0d 100644
--- a/thirdparty/faiss/faiss/IndexBinaryIVF.h
+++ b/thirdparty/faiss/knowherefaiss/IndexBinaryIVF.h
@@ -12,12 +12,12 @@
 
 #include <vector>
 
-#include <faiss/Clustering.h>
-#include <faiss/IndexBinary.h>
-#include <faiss/IndexIVF.h>
-#include <faiss/utils/Heap.h>
+#include <knowherefaiss/Clustering.h>
+#include <knowherefaiss/IndexBinary.h>
+#include <knowherefaiss/IndexIVF.h>
+#include <knowherefaiss/utils/Heap.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 struct BinaryInvertedListScanner;
 
@@ -278,6 +278,6 @@ struct BinaryInvertedListScanner {
     virtual ~BinaryInvertedListScanner() {}
 };
 
-} // namespace faiss
+} // namespace knowherefaiss
 
 #endif // FAISS_INDEX_BINARY_IVF_H
diff --git a/thirdparty/faiss/faiss/IndexCosine.cpp b/thirdparty/faiss/knowherefaiss/IndexCosine.cpp
similarity index 96%
rename from thirdparty/faiss/faiss/IndexCosine.cpp
rename to thirdparty/faiss/knowherefaiss/IndexCosine.cpp
index 16409576..9b3bf20b 100644
--- a/thirdparty/faiss/faiss/IndexCosine.cpp
+++ b/thirdparty/faiss/knowherefaiss/IndexCosine.cpp
@@ -9,19 +9,19 @@
 // is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 // or implied. See the License for the specific language governing permissions and limitations under the License.
 
-#include <faiss/IndexCosine.h>
+#include <knowherefaiss/IndexCosine.h>
 
 #include <cmath>
 #include <cstddef>
 #include <cstdint>
 #include <memory>
 
-#include <faiss/FaissHook.h>
-#include <faiss/impl/DistanceComputer.h>
-#include <faiss/impl/FaissAssert.h>
-#include <faiss/utils/prefetch.h>
+#include <knowherefaiss/FaissHook.h>
+#include <knowherefaiss/impl/DistanceComputer.h>
+#include <knowherefaiss/impl/FaissAssert.h>
+#include <knowherefaiss/utils/prefetch.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 //////////////////////////////////////////////////////////////////////////////////
 
@@ -164,7 +164,7 @@ void WithCosineNormDistanceComputer::set_query(const float* x) {
     basedis->set_query(x);
 
     if (x != nullptr) {
-        const float query_l2norm = faiss::fvec_norm_L2sqr(x, d);
+        const float query_l2norm = knowherefaiss::fvec_norm_L2sqr(x, d);
         inverse_query_norm = (query_l2norm <= 0) ? 1.0f : (1.0f / sqrtf(query_l2norm));
     } else {
         inverse_query_norm = 0;
@@ -341,7 +341,7 @@ DistanceComputer* IndexScalarQuantizerCosine::get_distance_computer() const {
     return new WithCosineNormDistanceComputer(
         this->get_inverse_l2_norms(),
         this->d,
-        std::unique_ptr<faiss::DistanceComputer>(IndexScalarQuantizer::get_FlatCodesDistanceComputer())
+        std::unique_ptr<knowherefaiss::DistanceComputer>(IndexScalarQuantizer::get_FlatCodesDistanceComputer())
     );
 }
 
@@ -386,7 +386,7 @@ DistanceComputer* IndexPQCosine::get_distance_computer() const {
     return new WithCosineNormDistanceComputer(
         this->get_inverse_l2_norms(),
         this->d,
-        std::unique_ptr<faiss::DistanceComputer>(IndexPQ::get_FlatCodesDistanceComputer())
+        std::unique_ptr<knowherefaiss::DistanceComputer>(IndexPQ::get_FlatCodesDistanceComputer())
     );
 }
 
@@ -437,7 +437,7 @@ DistanceComputer* IndexProductResidualQuantizerCosine::get_distance_computer() c
     return new WithCosineNormDistanceComputer(
         this->get_inverse_l2_norms(),
         this->d,
-        std::unique_ptr<faiss::DistanceComputer>(IndexProductResidualQuantizer::get_FlatCodesDistanceComputer())
+        std::unique_ptr<knowherefaiss::DistanceComputer>(IndexProductResidualQuantizer::get_FlatCodesDistanceComputer())
     );
 }
 
diff --git a/thirdparty/faiss/faiss/IndexCosine.h b/thirdparty/faiss/knowherefaiss/IndexCosine.h
similarity index 95%
rename from thirdparty/faiss/faiss/IndexCosine.h
rename to thirdparty/faiss/knowherefaiss/IndexCosine.h
index 6fe392b3..28be63b2 100644
--- a/thirdparty/faiss/faiss/IndexCosine.h
+++ b/thirdparty/faiss/knowherefaiss/IndexCosine.h
@@ -16,15 +16,15 @@
 #include <cstddef>
 #include <cstdint>
 
-#include <faiss/IndexAdditiveQuantizer.h>
-#include <faiss/IndexFlat.h>
-#include <faiss/IndexHNSW.h>
-#include <faiss/IndexScalarQuantizer.h>
-#include <faiss/IndexPQ.h>
-#include <faiss/impl/DistanceComputer.h>
+#include <knowherefaiss/IndexAdditiveQuantizer.h>
+#include <knowherefaiss/IndexFlat.h>
+#include <knowherefaiss/IndexHNSW.h>
+#include <knowherefaiss/IndexScalarQuantizer.h>
+#include <knowherefaiss/IndexPQ.h>
+#include <knowherefaiss/impl/DistanceComputer.h>
 
 
-namespace faiss {
+namespace knowherefaiss {
 
 // a distance computer wrapper that normalizes the distance over a query
 struct WithCosineNormDistanceComputer : DistanceComputer {
diff --git a/thirdparty/faiss/faiss/IndexFastScan.cpp b/thirdparty/faiss/knowherefaiss/IndexFastScan.cpp
similarity index 96%
rename from thirdparty/faiss/faiss/IndexFastScan.cpp
rename to thirdparty/faiss/knowherefaiss/IndexFastScan.cpp
index 7c011b80..fc119e1a 100644
--- a/thirdparty/faiss/faiss/IndexFastScan.cpp
+++ b/thirdparty/faiss/knowherefaiss/IndexFastScan.cpp
@@ -5,7 +5,7 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/IndexFastScan.h>
+#include <knowherefaiss/IndexFastScan.h>
 
 #include <cassert>
 #include <climits>
@@ -13,21 +13,21 @@
 
 #include <omp.h>
 
-#include <faiss/impl/FaissAssert.h>
-#include <faiss/impl/IDSelector.h>
-#include <faiss/impl/LookupTableScaler.h>
-#include <faiss/impl/ResultHandler.h>
-#include <faiss/utils/distances.h>
-#include <faiss/utils/extra_distances.h>
-#include <faiss/utils/hamming.h>
-#include <faiss/utils/random.h>
-#include <faiss/utils/utils.h>
+#include <knowherefaiss/impl/FaissAssert.h>
+#include <knowherefaiss/impl/IDSelector.h>
+#include <knowherefaiss/impl/LookupTableScaler.h>
+#include <knowherefaiss/impl/ResultHandler.h>
+#include <knowherefaiss/utils/distances.h>
+#include <knowherefaiss/utils/extra_distances.h>
+#include <knowherefaiss/utils/hamming.h>
+#include <knowherefaiss/utils/random.h>
+#include <knowherefaiss/utils/utils.h>
 
-#include <faiss/impl/pq4_fast_scan.h>
-#include <faiss/impl/simd_result_handlers.h>
-#include <faiss/utils/quantize_lut.h>
+#include <knowherefaiss/impl/pq4_fast_scan.h>
+#include <knowherefaiss/impl/simd_result_handlers.h>
+#include <knowherefaiss/utils/quantize_lut.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 using namespace simd_result_handlers;
 
@@ -559,4 +559,4 @@ void IndexFastScan::reconstruct(idx_t key, float* recons) const {
     sa_decode(1, code.data(), recons);
 }
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/IndexFastScan.h b/thirdparty/faiss/knowherefaiss/IndexFastScan.h
similarity index 96%
rename from thirdparty/faiss/faiss/IndexFastScan.h
rename to thirdparty/faiss/knowherefaiss/IndexFastScan.h
index c410d735..b3ca2342 100644
--- a/thirdparty/faiss/faiss/IndexFastScan.h
+++ b/thirdparty/faiss/knowherefaiss/IndexFastScan.h
@@ -7,10 +7,10 @@
 
 #pragma once
 
-#include <faiss/Index.h>
-#include <faiss/utils/AlignedTable.h>
+#include <knowherefaiss/Index.h>
+#include <knowherefaiss/utils/AlignedTable.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 struct CodePacker;
 struct NormTableScaler;
@@ -150,4 +150,4 @@ struct IndexFastScan : Index {
 //
 // FAISS_API extern FastScanStats FastScan_stats;
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/IndexFlat.cpp b/thirdparty/faiss/knowherefaiss/IndexFlat.cpp
similarity index 97%
rename from thirdparty/faiss/faiss/IndexFlat.cpp
rename to thirdparty/faiss/knowherefaiss/IndexFlat.cpp
index 5f246522..7832374a 100644
--- a/thirdparty/faiss/faiss/IndexFlat.cpp
+++ b/thirdparty/faiss/knowherefaiss/IndexFlat.cpp
@@ -7,22 +7,22 @@
 
 // -*- c++ -*-
 
-#include <faiss/FaissHook.h>
-#include <faiss/IndexFlat.h>
-
-#include <faiss/impl/AuxIndexStructures.h>
-#include <faiss/impl/FaissAssert.h>
-#include <faiss/utils/Heap.h>
-#include <faiss/utils/distances.h>
-#include <faiss/utils/extra_distances.h>
-#include <faiss/utils/prefetch.h>
-#include <faiss/utils/sorting.h>
-#include <faiss/utils/utils.h>
+#include <knowherefaiss/FaissHook.h>
+#include <knowherefaiss/IndexFlat.h>
+
+#include <knowherefaiss/impl/AuxIndexStructures.h>
+#include <knowherefaiss/impl/FaissAssert.h>
+#include <knowherefaiss/utils/Heap.h>
+#include <knowherefaiss/utils/distances.h>
+#include <knowherefaiss/utils/extra_distances.h>
+#include <knowherefaiss/utils/prefetch.h>
+#include <knowherefaiss/utils/sorting.h>
+#include <knowherefaiss/utils/utils.h>
 #include <cstring>
 
 #include "knowhere/utils.h"
 
-namespace faiss {
+namespace knowherefaiss {
 
 IndexFlat::IndexFlat(idx_t d, MetricType metric, bool is_cosine)
         : IndexFlatCodes(sizeof(float) * d, d, metric) {
@@ -559,4 +559,4 @@ void IndexFlat1D::search(
     }
 }
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/IndexFlat.h b/thirdparty/faiss/knowherefaiss/IndexFlat.h
similarity index 97%
rename from thirdparty/faiss/faiss/IndexFlat.h
rename to thirdparty/faiss/knowherefaiss/IndexFlat.h
index 4da54a6b..f6b545ff 100644
--- a/thirdparty/faiss/faiss/IndexFlat.h
+++ b/thirdparty/faiss/knowherefaiss/IndexFlat.h
@@ -12,9 +12,9 @@
 
 #include <vector>
 
-#include <faiss/IndexFlatCodes.h>
+#include <knowherefaiss/IndexFlatCodes.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 /** Index that stores the full vectors and performs exhaustive search */
 struct IndexFlat : IndexFlatCodes {
@@ -143,6 +143,6 @@ struct IndexFlat1D : IndexFlatL2 {
             const SearchParameters* params = nullptr) const override;
 };
 
-} // namespace faiss
+} // namespace knowherefaiss
 
 #endif
diff --git a/thirdparty/faiss/faiss/IndexFlatCodes.cpp b/thirdparty/faiss/knowherefaiss/IndexFlatCodes.cpp
similarity index 90%
rename from thirdparty/faiss/faiss/IndexFlatCodes.cpp
rename to thirdparty/faiss/knowherefaiss/IndexFlatCodes.cpp
index 897b350c..9a7a8ecd 100644
--- a/thirdparty/faiss/faiss/IndexFlatCodes.cpp
+++ b/thirdparty/faiss/knowherefaiss/IndexFlatCodes.cpp
@@ -5,15 +5,15 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/IndexFlatCodes.h>
+#include <knowherefaiss/IndexFlatCodes.h>
 
-#include <faiss/impl/AuxIndexStructures.h>
-#include <faiss/impl/CodePacker.h>
-#include <faiss/impl/DistanceComputer.h>
-#include <faiss/impl/FaissAssert.h>
-#include <faiss/impl/IDSelector.h>
+#include <knowherefaiss/impl/AuxIndexStructures.h>
+#include <knowherefaiss/impl/CodePacker.h>
+#include <knowherefaiss/impl/DistanceComputer.h>
+#include <knowherefaiss/impl/FaissAssert.h>
+#include <knowherefaiss/impl/IDSelector.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 IndexFlatCodes::IndexFlatCodes(size_t code_size, idx_t d, MetricType metric)
         : Index(d, metric), code_size(code_size) {}
@@ -115,4 +115,4 @@ void IndexFlatCodes::permute_entries(const idx_t* perm) {
     std::swap(codes, new_codes);
 }
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/IndexFlatCodes.h b/thirdparty/faiss/knowherefaiss/IndexFlatCodes.h
similarity index 90%
rename from thirdparty/faiss/faiss/IndexFlatCodes.h
rename to thirdparty/faiss/knowherefaiss/IndexFlatCodes.h
index 414c863b..00727a46 100644
--- a/thirdparty/faiss/faiss/IndexFlatCodes.h
+++ b/thirdparty/faiss/knowherefaiss/IndexFlatCodes.h
@@ -9,13 +9,13 @@
 
 #pragma once
 
-#include <faiss/Index.h>
-#include <faiss/impl/DistanceComputer.h>
+#include <knowherefaiss/Index.h>
+#include <knowherefaiss/impl/DistanceComputer.h>
 #include <vector>
 
-#include <faiss/impl/maybe_owned_vector.h>
+#include <knowherefaiss/impl/maybe_owned_vector.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 struct CodePacker;
 
@@ -68,4 +68,4 @@ struct IndexFlatCodes : Index {
     void permute_entries(const idx_t* perm);
 };
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/IndexFlatElkan.cpp b/thirdparty/faiss/knowherefaiss/IndexFlatElkan.cpp
similarity index 94%
rename from thirdparty/faiss/faiss/IndexFlatElkan.cpp
rename to thirdparty/faiss/knowherefaiss/IndexFlatElkan.cpp
index a6c836f2..befa5e6d 100644
--- a/thirdparty/faiss/faiss/IndexFlatElkan.cpp
+++ b/thirdparty/faiss/knowherefaiss/IndexFlatElkan.cpp
@@ -9,14 +9,14 @@
 // is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 // or implied. See the License for the specific language governing permissions and limitations under the License.
 
-#include <faiss/IndexFlatElkan.h>
+#include <knowherefaiss/IndexFlatElkan.h>
 
 #include <memory>
 
-#include <faiss/impl/FaissAssert.h>
-#include <faiss/utils/distances.h>
+#include <knowherefaiss/impl/FaissAssert.h>
+#include <knowherefaiss/utils/distances.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 IndexFlatElkan::IndexFlatElkan(idx_t d, MetricType metric, bool is_cosine, bool use_elkan)
         : IndexFlat(d, metric, is_cosine) {
diff --git a/thirdparty/faiss/faiss/IndexFlatElkan.h b/thirdparty/faiss/knowherefaiss/IndexFlatElkan.h
similarity index 97%
rename from thirdparty/faiss/faiss/IndexFlatElkan.h
rename to thirdparty/faiss/knowherefaiss/IndexFlatElkan.h
index 095ddb5c..9d958a19 100644
--- a/thirdparty/faiss/faiss/IndexFlatElkan.h
+++ b/thirdparty/faiss/knowherefaiss/IndexFlatElkan.h
@@ -11,10 +11,10 @@
 
 #pragma once
 
-#include <faiss/IndexFlat.h>
+#include <knowherefaiss/IndexFlat.h>
 #include <memory>
 
-namespace faiss {
+namespace knowherefaiss {
 
 // This is a special modification of IndexFlat that does two things.
 // 1. It allows to use elkan algorithm for the search. It is slower, 
diff --git a/thirdparty/faiss/faiss/IndexHNSW.cpp b/thirdparty/faiss/knowherefaiss/IndexHNSW.cpp
similarity index 97%
rename from thirdparty/faiss/faiss/IndexHNSW.cpp
rename to thirdparty/faiss/knowherefaiss/IndexHNSW.cpp
index f9732ed3..0cf8215c 100644
--- a/thirdparty/faiss/faiss/IndexHNSW.cpp
+++ b/thirdparty/faiss/knowherefaiss/IndexHNSW.cpp
@@ -5,7 +5,7 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/IndexHNSW.h>
+#include <knowherefaiss/IndexHNSW.h>
 
 #include <omp.h>
 #include <cassert>
@@ -25,15 +25,15 @@
 #include <sys/types.h>
 #include <cstdint>
 
-#include <faiss/Index2Layer.h>
-#include <faiss/IndexFlat.h>
-#include <faiss/IndexIVFPQ.h>
-#include <faiss/impl/AuxIndexStructures.h>
-#include <faiss/impl/FaissAssert.h>
-#include <faiss/impl/ResultHandler.h>
-#include <faiss/utils/distances.h>
-#include <faiss/utils/random.h>
-#include <faiss/utils/sorting.h>
+#include <knowherefaiss/Index2Layer.h>
+#include <knowherefaiss/IndexFlat.h>
+#include <knowherefaiss/IndexIVFPQ.h>
+#include <knowherefaiss/impl/AuxIndexStructures.h>
+#include <knowherefaiss/impl/FaissAssert.h>
+#include <knowherefaiss/impl/ResultHandler.h>
+#include <knowherefaiss/utils/distances.h>
+#include <knowherefaiss/utils/random.h>
+#include <knowherefaiss/utils/sorting.h>
 
 extern "C" {
 
@@ -55,7 +55,7 @@ int sgemm_(
         FINTEGER* ldc);
 }
 
-namespace faiss {
+namespace knowherefaiss {
 
 using MinimaxHeap = HNSW::MinimaxHeap;
 using storage_idx_t = HNSW::storage_idx_t;
@@ -753,9 +753,9 @@ int search_from_candidates_2(
                 // never seen before --> add to heap
                 if (vt.visited[v1] < vt.visno) {
                     if (nres < k) {
-                        faiss::maxheap_push(++nres, D, I, d, v1);
+                        knowherefaiss::maxheap_push(++nres, D, I, d, v1);
                     } else if (d < D[0]) {
-                        faiss::maxheap_replace_top(nres, D, I, d, v1);
+                        knowherefaiss::maxheap_replace_top(nres, D, I, d, v1);
                     }
                 }
                 vt.visited[v1] = vt.visno + 1;
@@ -987,4 +987,4 @@ void IndexHNSWCagra::search(
     }
 }
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/IndexHNSW.h b/thirdparty/faiss/knowherefaiss/IndexHNSW.h
similarity index 95%
rename from thirdparty/faiss/faiss/IndexHNSW.h
rename to thirdparty/faiss/knowherefaiss/IndexHNSW.h
index 0768eb88..21986e2d 100644
--- a/thirdparty/faiss/faiss/IndexHNSW.h
+++ b/thirdparty/faiss/knowherefaiss/IndexHNSW.h
@@ -11,13 +11,13 @@
 
 #include <vector>
 
-#include <faiss/IndexFlat.h>
-#include <faiss/IndexPQ.h>
-#include <faiss/IndexScalarQuantizer.h>
-#include <faiss/impl/HNSW.h>
-#include <faiss/utils/utils.h>
+#include <knowherefaiss/IndexFlat.h>
+#include <knowherefaiss/IndexPQ.h>
+#include <knowherefaiss/IndexScalarQuantizer.h>
+#include <knowherefaiss/impl/HNSW.h>
+#include <knowherefaiss/utils/utils.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 struct IndexHNSW;
 
@@ -197,4 +197,4 @@ struct IndexHNSWCagra : IndexHNSW {
             const SearchParameters* params = nullptr) const override;
 };
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/IndexIDMap.cpp b/thirdparty/faiss/knowherefaiss/IndexIDMap.cpp
similarity index 96%
rename from thirdparty/faiss/faiss/IndexIDMap.cpp
rename to thirdparty/faiss/knowherefaiss/IndexIDMap.cpp
index b1272cf6..def353df 100644
--- a/thirdparty/faiss/faiss/IndexIDMap.cpp
+++ b/thirdparty/faiss/knowherefaiss/IndexIDMap.cpp
@@ -7,19 +7,19 @@
 
 // -*- c++ -*-
 
-#include <faiss/IndexIDMap.h>
+#include <knowherefaiss/IndexIDMap.h>
 
 #include <cinttypes>
 #include <cstdint>
 #include <cstdio>
 #include <limits>
 
-#include <faiss/impl/AuxIndexStructures.h>
-#include <faiss/impl/FaissAssert.h>
-#include <faiss/utils/Heap.h>
-#include <faiss/utils/WorkerThread.h>
+#include <knowherefaiss/impl/AuxIndexStructures.h>
+#include <knowherefaiss/impl/FaissAssert.h>
+#include <knowherefaiss/utils/Heap.h>
+#include <knowherefaiss/utils/WorkerThread.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 namespace {
 
@@ -285,4 +285,4 @@ template struct IndexIDMapTemplate<IndexBinary>;
 template struct IndexIDMap2Template<Index>;
 template struct IndexIDMap2Template<IndexBinary>;
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/IndexIDMap.h b/thirdparty/faiss/knowherefaiss/IndexIDMap.h
similarity index 95%
rename from thirdparty/faiss/faiss/IndexIDMap.h
rename to thirdparty/faiss/knowherefaiss/IndexIDMap.h
index 73c8cdec..335ec17d 100644
--- a/thirdparty/faiss/faiss/IndexIDMap.h
+++ b/thirdparty/faiss/knowherefaiss/IndexIDMap.h
@@ -7,14 +7,14 @@
 
 #pragma once
 
-#include <faiss/Index.h>
-#include <faiss/IndexBinary.h>
-#include <faiss/impl/IDSelector.h>
+#include <knowherefaiss/Index.h>
+#include <knowherefaiss/IndexBinary.h>
+#include <knowherefaiss/impl/IDSelector.h>
 
 #include <unordered_map>
 #include <vector>
 
-namespace faiss {
+namespace knowherefaiss {
 
 /** Index that translates search results to ids */
 template <typename IndexT>
@@ -126,4 +126,4 @@ struct IDSelectorTranslated : IDSelector {
     }
 };
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/IndexIVF.cpp b/thirdparty/faiss/knowherefaiss/IndexIVF.cpp
similarity index 99%
rename from thirdparty/faiss/faiss/IndexIVF.cpp
rename to thirdparty/faiss/knowherefaiss/IndexIVF.cpp
index 59090ca0..6fa5bf14 100644
--- a/thirdparty/faiss/faiss/IndexIVF.cpp
+++ b/thirdparty/faiss/knowherefaiss/IndexIVF.cpp
@@ -7,7 +7,7 @@
 
 // -*- c++ -*-
 
-#include <faiss/IndexIVF.h>
+#include <knowherefaiss/IndexIVF.h>
 
 #include <omp.h>
 #include <cstdint>
@@ -20,18 +20,18 @@
 #include <memory>
 #include <vector>
 
-#include <faiss/utils/hamming.h>
-#include <faiss/utils/utils.h>
+#include <knowherefaiss/utils/hamming.h>
+#include <knowherefaiss/utils/utils.h>
 
-#include <faiss/IndexFlat.h>
-#include <faiss/impl/AuxIndexStructures.h>
-#include <faiss/impl/CodePacker.h>
-#include <faiss/impl/FaissAssert.h>
-#include <faiss/impl/IDSelector.h>
+#include <knowherefaiss/IndexFlat.h>
+#include <knowherefaiss/impl/AuxIndexStructures.h>
+#include <knowherefaiss/impl/CodePacker.h>
+#include <knowherefaiss/impl/FaissAssert.h>
+#include <knowherefaiss/impl/IDSelector.h>
 
 #include "knowhere/object.h"
 
-namespace faiss {
+namespace knowherefaiss {
 
 using ScopedIds = InvertedLists::ScopedIds;
 using ScopedCodes = InvertedLists::ScopedCodes;
@@ -1621,4 +1621,4 @@ void InvertedListScanner::iterate_codes_range(
     }
 }
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/IndexIVF.h b/thirdparty/faiss/knowherefaiss/IndexIVF.h
similarity index 98%
rename from thirdparty/faiss/faiss/IndexIVF.h
rename to thirdparty/faiss/knowherefaiss/IndexIVF.h
index 3f4d8c35..d74c0176 100644
--- a/thirdparty/faiss/faiss/IndexIVF.h
+++ b/thirdparty/faiss/knowherefaiss/IndexIVF.h
@@ -15,17 +15,17 @@
 #include <unordered_map>
 #include <vector>
 
-#include <faiss/Clustering.h>
-#include <faiss/Index.h>
-#include <faiss/impl/IDSelector.h>
-#include <faiss/impl/platform_macros.h>
-#include <faiss/invlists/DirectMap.h>
-#include <faiss/invlists/InvertedLists.h>
-#include <faiss/utils/Heap.h>
+#include <knowherefaiss/Clustering.h>
+#include <knowherefaiss/Index.h>
+#include <knowherefaiss/impl/IDSelector.h>
+#include <knowherefaiss/impl/platform_macros.h>
+#include <knowherefaiss/invlists/DirectMap.h>
+#include <knowherefaiss/invlists/InvertedLists.h>
+#include <knowherefaiss/utils/Heap.h>
 
 #include "knowhere/object.h"
 
-namespace faiss {
+namespace knowherefaiss {
 
 /** Encapsulates a quantizer object for the IndexIVF
  *
@@ -630,6 +630,6 @@ struct IndexIVFStats {
 // global var that collects them all
 FAISS_API extern IndexIVFStats indexIVF_stats;
 
-} // namespace faiss
+} // namespace knowherefaiss
 
 #endif
diff --git a/thirdparty/faiss/faiss/IndexIVFAdditiveQuantizer.cpp b/thirdparty/faiss/knowherefaiss/IndexIVFAdditiveQuantizer.cpp
similarity index 96%
rename from thirdparty/faiss/faiss/IndexIVFAdditiveQuantizer.cpp
rename to thirdparty/faiss/knowherefaiss/IndexIVFAdditiveQuantizer.cpp
index 1e468b3f..6777762c 100644
--- a/thirdparty/faiss/faiss/IndexIVFAdditiveQuantizer.cpp
+++ b/thirdparty/faiss/knowherefaiss/IndexIVFAdditiveQuantizer.cpp
@@ -5,21 +5,21 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/IndexIVFAdditiveQuantizer.h>
+#include <knowherefaiss/IndexIVFAdditiveQuantizer.h>
 
 #include <algorithm>
 #include <cmath>
 #include <cstring>
 
-#include <faiss/FaissHook.h>
-#include <faiss/impl/FaissAssert.h>
-#include <faiss/impl/ResidualQuantizer.h>
-#include <faiss/impl/ResultHandler.h>
-#include <faiss/utils/distances.h>
-#include <faiss/utils/extra_distances.h>
-#include <faiss/utils/utils.h>
+#include <knowherefaiss/FaissHook.h>
+#include <knowherefaiss/impl/FaissAssert.h>
+#include <knowherefaiss/impl/ResidualQuantizer.h>
+#include <knowherefaiss/impl/ResultHandler.h>
+#include <knowherefaiss/utils/distances.h>
+#include <knowherefaiss/utils/extra_distances.h>
+#include <knowherefaiss/utils/utils.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 /**************************************************************************************
  * IndexIVFAdditiveQuantizer
@@ -384,4 +384,4 @@ IndexIVFProductLocalSearchQuantizer::IndexIVFProductLocalSearchQuantizer()
 IndexIVFProductLocalSearchQuantizer::~IndexIVFProductLocalSearchQuantizer() =
         default;
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/IndexIVFAdditiveQuantizer.h b/thirdparty/faiss/knowherefaiss/IndexIVFAdditiveQuantizer.h
similarity index 94%
rename from thirdparty/faiss/faiss/IndexIVFAdditiveQuantizer.h
rename to thirdparty/faiss/knowherefaiss/IndexIVFAdditiveQuantizer.h
index 54e0a710..35992547 100644
--- a/thirdparty/faiss/faiss/IndexIVFAdditiveQuantizer.h
+++ b/thirdparty/faiss/knowherefaiss/IndexIVFAdditiveQuantizer.h
@@ -8,18 +8,18 @@
 #ifndef FAISS_INDEX_IVF_ADDITIVE_QUANTIZER_H
 #define FAISS_INDEX_IVF_ADDITIVE_QUANTIZER_H
 
-#include <faiss/impl/AdditiveQuantizer.h>
+#include <knowherefaiss/impl/AdditiveQuantizer.h>
 
 #include <cstdint>
 #include <vector>
 
-#include <faiss/IndexIVF.h>
-#include <faiss/impl/LocalSearchQuantizer.h>
-#include <faiss/impl/ProductAdditiveQuantizer.h>
-#include <faiss/impl/ResidualQuantizer.h>
-#include <faiss/impl/platform_macros.h>
+#include <knowherefaiss/IndexIVF.h>
+#include <knowherefaiss/impl/LocalSearchQuantizer.h>
+#include <knowherefaiss/impl/ProductAdditiveQuantizer.h>
+#include <knowherefaiss/impl/ResidualQuantizer.h>
+#include <knowherefaiss/impl/platform_macros.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 /// Abstract class for IVF additive quantizers.
 /// The search functions are in common.
@@ -180,6 +180,6 @@ struct IndexIVFProductLocalSearchQuantizer : IndexIVFAdditiveQuantizer {
     virtual ~IndexIVFProductLocalSearchQuantizer();
 };
 
-} // namespace faiss
+} // namespace knowherefaiss
 
 #endif
diff --git a/thirdparty/faiss/faiss/IndexIVFAdditiveQuantizerFastScan.cpp b/thirdparty/faiss/knowherefaiss/IndexIVFAdditiveQuantizerFastScan.cpp
similarity index 96%
rename from thirdparty/faiss/faiss/IndexIVFAdditiveQuantizerFastScan.cpp
rename to thirdparty/faiss/knowherefaiss/IndexIVFAdditiveQuantizerFastScan.cpp
index a3a59912..07ce3e75 100644
--- a/thirdparty/faiss/faiss/IndexIVFAdditiveQuantizerFastScan.cpp
+++ b/thirdparty/faiss/knowherefaiss/IndexIVFAdditiveQuantizerFastScan.cpp
@@ -5,7 +5,7 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/IndexIVFAdditiveQuantizerFastScan.h>
+#include <knowherefaiss/IndexIVFAdditiveQuantizerFastScan.h>
 
 #include <cassert>
 #include <cinttypes>
@@ -15,20 +15,20 @@
 
 #include <memory>
 
-#include <faiss/impl/AuxIndexStructures.h>
-#include <faiss/impl/FaissAssert.h>
-#include <faiss/impl/LookupTableScaler.h>
-#include <faiss/impl/pq4_fast_scan.h>
-#include <faiss/invlists/BlockInvertedLists.h>
-#include <faiss/utils/distances.h>
-#include <faiss/utils/hamming.h>
-#include <faiss/utils/quantize_lut.h>
-#include <faiss/utils/simdlib.h>
-#include <faiss/utils/utils.h>
+#include <knowherefaiss/impl/AuxIndexStructures.h>
+#include <knowherefaiss/impl/FaissAssert.h>
+#include <knowherefaiss/impl/LookupTableScaler.h>
+#include <knowherefaiss/impl/pq4_fast_scan.h>
+#include <knowherefaiss/invlists/BlockInvertedLists.h>
+#include <knowherefaiss/utils/distances.h>
+#include <knowherefaiss/utils/hamming.h>
+#include <knowherefaiss/utils/quantize_lut.h>
+#include <knowherefaiss/utils/simdlib.h>
+#include <knowherefaiss/utils/utils.h>
 
 #include "simd/hook.h"
 
-namespace faiss {
+namespace knowherefaiss {
 
 inline size_t roundup(size_t a, size_t b) {
     return (a + b - 1) / b * b;
@@ -567,4 +567,4 @@ IndexIVFProductResidualQuantizerFastScan::
     aq = &prq;
 }
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/IndexIVFAdditiveQuantizerFastScan.h b/thirdparty/faiss/knowherefaiss/IndexIVFAdditiveQuantizerFastScan.h
similarity index 93%
rename from thirdparty/faiss/faiss/IndexIVFAdditiveQuantizerFastScan.h
rename to thirdparty/faiss/knowherefaiss/IndexIVFAdditiveQuantizerFastScan.h
index 643628de..54d1f256 100644
--- a/thirdparty/faiss/faiss/IndexIVFAdditiveQuantizerFastScan.h
+++ b/thirdparty/faiss/knowherefaiss/IndexIVFAdditiveQuantizerFastScan.h
@@ -9,13 +9,13 @@
 
 #include <memory>
 
-#include <faiss/IndexIVFAdditiveQuantizer.h>
-#include <faiss/IndexIVFFastScan.h>
-#include <faiss/impl/AdditiveQuantizer.h>
-#include <faiss/impl/ProductAdditiveQuantizer.h>
-#include <faiss/utils/AlignedTable.h>
+#include <knowherefaiss/IndexIVFAdditiveQuantizer.h>
+#include <knowherefaiss/IndexIVFFastScan.h>
+#include <knowherefaiss/impl/AdditiveQuantizer.h>
+#include <knowherefaiss/impl/ProductAdditiveQuantizer.h>
+#include <knowherefaiss/utils/AlignedTable.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 /** Fast scan version of IVFAQ. Works for 4-bit AQ for now.
  *
@@ -169,4 +169,4 @@ struct IndexIVFProductResidualQuantizerFastScan
     IndexIVFProductResidualQuantizerFastScan();
 };
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/IndexIVFFastScan.cpp b/thirdparty/faiss/knowherefaiss/IndexIVFFastScan.cpp
similarity index 98%
rename from thirdparty/faiss/faiss/IndexIVFFastScan.cpp
rename to thirdparty/faiss/knowherefaiss/IndexIVFFastScan.cpp
index a1ceb936..a26fcb3d 100644
--- a/thirdparty/faiss/faiss/IndexIVFFastScan.cpp
+++ b/thirdparty/faiss/knowherefaiss/IndexIVFFastScan.cpp
@@ -5,7 +5,7 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/IndexIVFFastScan.h>
+#include <knowherefaiss/IndexIVFFastScan.h>
 
 #include <cassert>
 #include <cinttypes>
@@ -16,21 +16,21 @@
 
 #include <memory>
 
-#include <faiss/IndexIVFPQ.h>
-#include <faiss/impl/AuxIndexStructures.h>
-#include <faiss/impl/FaissAssert.h>
-#include <faiss/impl/LookupTableScaler.h>
-#include <faiss/impl/pq4_fast_scan.h>
-#include <faiss/impl/simd_result_handlers.h>
-#include <faiss/invlists/BlockInvertedLists.h>
-#include <faiss/utils/distances.h>
-#include <faiss/utils/hamming.h>
-#include <faiss/utils/quantize_lut.h>
-#include <faiss/utils/utils.h>
+#include <knowherefaiss/IndexIVFPQ.h>
+#include <knowherefaiss/impl/AuxIndexStructures.h>
+#include <knowherefaiss/impl/FaissAssert.h>
+#include <knowherefaiss/impl/LookupTableScaler.h>
+#include <knowherefaiss/impl/pq4_fast_scan.h>
+#include <knowherefaiss/impl/simd_result_handlers.h>
+#include <knowherefaiss/invlists/BlockInvertedLists.h>
+#include <knowherefaiss/utils/distances.h>
+#include <knowherefaiss/utils/hamming.h>
+#include <knowherefaiss/utils/quantize_lut.h>
+#include <knowherefaiss/utils/utils.h>
 
 #include <knowhere/utils.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 using namespace simd_result_handlers;
 
@@ -1826,4 +1826,4 @@ void IndexIVFFastScan::get_interator_next_batch_implem_10(
 
 // IVFFastScanStats IVFFastScan_stats;
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/IndexIVFFastScan.h b/thirdparty/faiss/knowherefaiss/IndexIVFFastScan.h
similarity index 98%
rename from thirdparty/faiss/faiss/IndexIVFFastScan.h
rename to thirdparty/faiss/knowherefaiss/IndexIVFFastScan.h
index 1a9377de..eb9fedd0 100644
--- a/thirdparty/faiss/faiss/IndexIVFFastScan.h
+++ b/thirdparty/faiss/knowherefaiss/IndexIVFFastScan.h
@@ -9,10 +9,10 @@
 
 #include <memory>
 
-#include <faiss/IndexIVF.h>
-#include <faiss/utils/AlignedTable.h>
+#include <knowherefaiss/IndexIVF.h>
+#include <knowherefaiss/utils/AlignedTable.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 struct NormTableScaler;
 struct SIMDResultHandlerToFloat;
@@ -334,4 +334,4 @@ struct IndexIVFFastScan : IndexIVF {
 //
 // FAISS_API extern IVFFastScanStats IVFFastScan_stats;
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/IndexIVFFlat.cpp b/thirdparty/faiss/knowherefaiss/IndexIVFFlat.cpp
similarity index 98%
rename from thirdparty/faiss/faiss/IndexIVFFlat.cpp
rename to thirdparty/faiss/knowherefaiss/IndexIVFFlat.cpp
index 1e26f0c0..0f0c9f55 100644
--- a/thirdparty/faiss/faiss/IndexIVFFlat.cpp
+++ b/thirdparty/faiss/knowherefaiss/IndexIVFFlat.cpp
@@ -7,7 +7,7 @@
 
 // -*- c++ -*-
 
-#include <faiss/IndexIVFFlat.h>
+#include <knowherefaiss/IndexIVFFlat.h>
 
 #include <omp.h>
 
@@ -19,18 +19,18 @@
 #include "knowhere/utils.h"
 #include "knowhere/bitsetview_idselector.h"
 
-#include <faiss/IndexFlat.h>
+#include <knowherefaiss/IndexFlat.h>
 
-#include <faiss/FaissHook.h>
-#include <faiss/impl/AuxIndexStructures.h>
-#include <faiss/impl/IDSelector.h>
+#include <knowherefaiss/FaissHook.h>
+#include <knowherefaiss/impl/AuxIndexStructures.h>
+#include <knowherefaiss/impl/IDSelector.h>
 
-#include <faiss/impl/FaissAssert.h>
-#include <faiss/utils/distances.h>
-#include <faiss/utils/distances_if.h>
-#include <faiss/utils/utils.h>
+#include <knowherefaiss/impl/FaissAssert.h>
+#include <knowherefaiss/utils/distances.h>
+#include <knowherefaiss/utils/distances_if.h>
+#include <knowherefaiss/utils/utils.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 /*****************************************
  * IndexIVFFlat implementation
@@ -53,7 +53,7 @@ IndexIVFFlat::IndexIVFFlat(
 void IndexIVFFlat::restore_codes(
         const uint8_t* raw_data,
         const size_t raw_size) {
-    auto ails = dynamic_cast<faiss::ArrayInvertedLists*>(invlists);
+    auto ails = dynamic_cast<knowherefaiss::ArrayInvertedLists*>(invlists);
     ails->restore_codes(raw_data, raw_size, is_cosine);
 }
 
@@ -836,4 +836,4 @@ void IndexIVFFlatDedup::reconstruct_from_offset(int64_t, int64_t, float*)
     FAISS_THROW_MSG("not implemented");
 }
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/IndexIVFFlat.h b/thirdparty/faiss/knowherefaiss/IndexIVFFlat.h
similarity index 97%
rename from thirdparty/faiss/faiss/IndexIVFFlat.h
rename to thirdparty/faiss/knowherefaiss/IndexIVFFlat.h
index 67037f84..f2419a90 100644
--- a/thirdparty/faiss/faiss/IndexIVFFlat.h
+++ b/thirdparty/faiss/knowherefaiss/IndexIVFFlat.h
@@ -13,11 +13,11 @@
 #include <stdint.h>
 #include <unordered_map>
 
-#include <faiss/IndexIVF.h>
+#include <knowherefaiss/IndexIVF.h>
 
 #include "knowhere/object.h"
 
-namespace faiss {
+namespace knowherefaiss {
 /** Inverted file with stored vectors. Here the inverted file
  * pre-selects the vectors to be searched, but they are not otherwise
  * encoded, the code array just contains the raw float entries.
@@ -129,6 +129,6 @@ struct IndexIVFFlatDedup : IndexIVFFlat {
     IndexIVFFlatDedup() {}
 };
 
-} // namespace faiss
+} // namespace knowherefaiss
 
 #endif
diff --git a/thirdparty/faiss/faiss/IndexIVFIndependentQuantizer.cpp b/thirdparty/faiss/knowherefaiss/IndexIVFIndependentQuantizer.cpp
similarity index 95%
rename from thirdparty/faiss/faiss/IndexIVFIndependentQuantizer.cpp
rename to thirdparty/faiss/knowherefaiss/IndexIVFIndependentQuantizer.cpp
index 76ae6718..9abbcb03 100644
--- a/thirdparty/faiss/faiss/IndexIVFIndependentQuantizer.cpp
+++ b/thirdparty/faiss/knowherefaiss/IndexIVFIndependentQuantizer.cpp
@@ -5,12 +5,12 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/IndexIVFIndependentQuantizer.h>
-#include <faiss/IndexIVFPQ.h>
-#include <faiss/impl/FaissAssert.h>
-#include <faiss/utils/utils.h>
+#include <knowherefaiss/IndexIVFIndependentQuantizer.h>
+#include <knowherefaiss/IndexIVFPQ.h>
+#include <knowherefaiss/impl/FaissAssert.h>
+#include <knowherefaiss/utils/utils.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 IndexIVFIndependentQuantizer::IndexIVFIndependentQuantizer(
         Index* quantizer,
@@ -169,4 +169,4 @@ void IndexIVFIndependentQuantizer::train(idx_t n, const float* x) {
     is_trained = true;
 }
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/IndexIVFIndependentQuantizer.h b/thirdparty/faiss/knowherefaiss/IndexIVFIndependentQuantizer.h
similarity index 90%
rename from thirdparty/faiss/faiss/IndexIVFIndependentQuantizer.h
rename to thirdparty/faiss/knowherefaiss/IndexIVFIndependentQuantizer.h
index 4fe16666..5095b5c8 100644
--- a/thirdparty/faiss/faiss/IndexIVFIndependentQuantizer.h
+++ b/thirdparty/faiss/knowherefaiss/IndexIVFIndependentQuantizer.h
@@ -7,10 +7,10 @@
 
 #pragma once
 
-#include <faiss/IndexIVF.h>
-#include <faiss/VectorTransform.h>
+#include <knowherefaiss/IndexIVF.h>
+#include <knowherefaiss/VectorTransform.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 /** An IVF index with a quantizer that has a different input dimension from the
  * payload size. The vectors to encode are obtained from the input vectors by a
@@ -53,4 +53,4 @@ struct IndexIVFIndependentQuantizer : Index {
     ~IndexIVFIndependentQuantizer() override;
 };
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/IndexIVFPQ.cpp b/thirdparty/faiss/knowherefaiss/IndexIVFPQ.cpp
similarity index 98%
rename from thirdparty/faiss/faiss/IndexIVFPQ.cpp
rename to thirdparty/faiss/knowherefaiss/IndexIVFPQ.cpp
index 47009ce4..e8d1c842 100644
--- a/thirdparty/faiss/faiss/IndexIVFPQ.cpp
+++ b/thirdparty/faiss/knowherefaiss/IndexIVFPQ.cpp
@@ -7,7 +7,7 @@
 
 // -*- c++ -*-
 
-#include <faiss/IndexIVFPQ.h>
+#include <knowherefaiss/IndexIVFPQ.h>
 
 #include <cassert>
 #include <cinttypes>
@@ -17,26 +17,26 @@
 
 #include <algorithm>
 
-#include <faiss/utils/Heap.h>
-#include <faiss/utils/distances.h>
-#include <faiss/utils/utils.h>
+#include <knowherefaiss/utils/Heap.h>
+#include <knowherefaiss/utils/distances.h>
+#include <knowherefaiss/utils/utils.h>
 
-#include <faiss/Clustering.h>
-#include <faiss/FaissHook.h>
-#include <faiss/IndexFlat.h>
+#include <knowherefaiss/Clustering.h>
+#include <knowherefaiss/FaissHook.h>
+#include <knowherefaiss/IndexFlat.h>
 
-#include <faiss/utils/hamming.h>
+#include <knowherefaiss/utils/hamming.h>
 
-#include <faiss/impl/FaissAssert.h>
+#include <knowherefaiss/impl/FaissAssert.h>
 
-#include <faiss/impl/AuxIndexStructures.h>
-#include <faiss/impl/IDSelector.h>
+#include <knowherefaiss/impl/AuxIndexStructures.h>
+#include <knowherefaiss/impl/IDSelector.h>
 
-#include <faiss/impl/ProductQuantizer.h>
+#include <knowherefaiss/impl/ProductQuantizer.h>
 
-#include <faiss/impl/code_distance/code_distance.h>
+#include <knowherefaiss/impl/code_distance/code_distance.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 /*****************************************
  * IndexIVFPQ implementation
@@ -1396,4 +1396,4 @@ size_t IndexIVFPQ::find_duplicates(idx_t* dup_ids, size_t* lims) const {
     return ngroup;
 }
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/IndexIVFPQ.h b/thirdparty/faiss/knowherefaiss/IndexIVFPQ.h
similarity index 96%
rename from thirdparty/faiss/faiss/IndexIVFPQ.h
rename to thirdparty/faiss/knowherefaiss/IndexIVFPQ.h
index 9ed29a06..89b1a6be 100644
--- a/thirdparty/faiss/faiss/IndexIVFPQ.h
+++ b/thirdparty/faiss/knowherefaiss/IndexIVFPQ.h
@@ -12,12 +12,12 @@
 
 #include <vector>
 
-#include <faiss/IndexIVF.h>
-#include <faiss/IndexPQ.h>
-#include <faiss/impl/platform_macros.h>
-#include <faiss/utils/AlignedTable.h>
+#include <knowherefaiss/IndexIVF.h>
+#include <knowherefaiss/IndexPQ.h>
+#include <knowherefaiss/impl/platform_macros.h>
+#include <knowherefaiss/utils/AlignedTable.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 struct IVFPQSearchParameters : IVFSearchParameters {
     size_t scan_table_threshold; ///< use table computation or on-the-fly?
@@ -187,6 +187,6 @@ struct IndexIVFPQStats {
 // global var that collects them all
 FAISS_API extern IndexIVFPQStats indexIVFPQ_stats;
 
-} // namespace faiss
+} // namespace knowherefaiss
 
 #endif
diff --git a/thirdparty/faiss/faiss/IndexIVFPQFastScan.cpp b/thirdparty/faiss/knowherefaiss/IndexIVFPQFastScan.cpp
similarity index 94%
rename from thirdparty/faiss/faiss/IndexIVFPQFastScan.cpp
rename to thirdparty/faiss/knowherefaiss/IndexIVFPQFastScan.cpp
index 4bfae9f8..f0f5dc39 100644
--- a/thirdparty/faiss/faiss/IndexIVFPQFastScan.cpp
+++ b/thirdparty/faiss/knowherefaiss/IndexIVFPQFastScan.cpp
@@ -5,7 +5,7 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/IndexIVFPQFastScan.h>
+#include <knowherefaiss/IndexIVFPQFastScan.h>
 
 #include <cassert>
 #include <cinttypes>
@@ -15,21 +15,21 @@
 
 #include <memory>
 
-#include <faiss/impl/AuxIndexStructures.h>
-#include <faiss/impl/FaissAssert.h>
-#include <faiss/utils/distances.h>
-#include <faiss/utils/simdlib.h>
-#include <faiss/utils/utils.h>
+#include <knowherefaiss/impl/AuxIndexStructures.h>
+#include <knowherefaiss/impl/FaissAssert.h>
+#include <knowherefaiss/utils/distances.h>
+#include <knowherefaiss/utils/simdlib.h>
+#include <knowherefaiss/utils/utils.h>
 
-#include <faiss/invlists/BlockInvertedLists.h>
+#include <knowherefaiss/invlists/BlockInvertedLists.h>
 
-#include <faiss/impl/pq4_fast_scan.h>
-#include <faiss/impl/simd_result_handlers.h>
-#include <faiss/utils/quantize_lut.h>
+#include <knowherefaiss/impl/pq4_fast_scan.h>
+#include <knowherefaiss/impl/simd_result_handlers.h>
+#include <knowherefaiss/utils/quantize_lut.h>
 
 #include <knowhere/utils.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 using namespace simd_result_handlers;
 
@@ -325,4 +325,4 @@ void IndexIVFPQFastScan::sa_decode(idx_t n, const uint8_t* codes, float* x)
     }
 }
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/IndexIVFPQFastScan.h b/thirdparty/faiss/knowherefaiss/IndexIVFPQFastScan.h
similarity index 92%
rename from thirdparty/faiss/faiss/IndexIVFPQFastScan.h
rename to thirdparty/faiss/knowherefaiss/IndexIVFPQFastScan.h
index d7768ccc..b829ff66 100644
--- a/thirdparty/faiss/faiss/IndexIVFPQFastScan.h
+++ b/thirdparty/faiss/knowherefaiss/IndexIVFPQFastScan.h
@@ -9,12 +9,12 @@
 
 #include <memory>
 
-#include <faiss/IndexIVFFastScan.h>
-#include <faiss/IndexIVFPQ.h>
-#include <faiss/impl/ProductQuantizer.h>
-#include <faiss/utils/AlignedTable.h>
+#include <knowherefaiss/IndexIVFFastScan.h>
+#include <knowherefaiss/IndexIVFPQ.h>
+#include <knowherefaiss/impl/ProductQuantizer.h>
+#include <knowherefaiss/utils/AlignedTable.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 /** Fast scan version of IVFPQ. Works for 4-bit PQ for now.
  *
@@ -95,4 +95,4 @@ struct IndexIVFPQFastScan : IndexIVFFastScan {
     void sa_decode(idx_t n, const uint8_t* bytes, float* x) const override;
 };
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/IndexIVFPQR.cpp b/thirdparty/faiss/knowherefaiss/IndexIVFPQR.cpp
similarity index 95%
rename from thirdparty/faiss/faiss/IndexIVFPQR.cpp
rename to thirdparty/faiss/knowherefaiss/IndexIVFPQR.cpp
index fd33d175..5068104a 100644
--- a/thirdparty/faiss/faiss/IndexIVFPQR.cpp
+++ b/thirdparty/faiss/knowherefaiss/IndexIVFPQR.cpp
@@ -7,18 +7,18 @@
 
 // -*- c++ -*-
 
-#include <faiss/IndexIVFPQR.h>
+#include <knowherefaiss/IndexIVFPQR.h>
 
 #include <cinttypes>
 
-#include <faiss/utils/Heap.h>
-#include <faiss/utils/distances.h>
-#include <faiss/utils/utils.h>
+#include <knowherefaiss/utils/Heap.h>
+#include <knowherefaiss/utils/distances.h>
+#include <knowherefaiss/utils/utils.h>
 
-#include <faiss/FaissHook.h>
-#include <faiss/impl/FaissAssert.h>
+#include <knowherefaiss/FaissHook.h>
+#include <knowherefaiss/impl/FaissAssert.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 /*****************************************
  * IndexIVFPQR implementation
@@ -237,4 +237,4 @@ size_t IndexIVFPQR::remove_ids(const IDSelector& /*sel*/) {
     return 0;
 }
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/IndexIVFPQR.h b/thirdparty/faiss/knowherefaiss/IndexIVFPQR.h
similarity index 95%
rename from thirdparty/faiss/faiss/IndexIVFPQR.h
rename to thirdparty/faiss/knowherefaiss/IndexIVFPQR.h
index 99ce6166..e9e1346c 100644
--- a/thirdparty/faiss/faiss/IndexIVFPQR.h
+++ b/thirdparty/faiss/knowherefaiss/IndexIVFPQR.h
@@ -11,9 +11,9 @@
 
 #include <vector>
 
-#include <faiss/IndexIVFPQ.h>
+#include <knowherefaiss/IndexIVFPQ.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 /** Index with an additional level of PQ refinement */
 struct IndexIVFPQR : IndexIVFPQ {
@@ -72,4 +72,4 @@ struct IndexIVFPQR : IndexIVFPQ {
     IndexIVFPQR();
 };
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/IndexIVFRaBitQ.cpp b/thirdparty/faiss/knowherefaiss/IndexIVFRaBitQ.cpp
similarity index 97%
rename from thirdparty/faiss/faiss/IndexIVFRaBitQ.cpp
rename to thirdparty/faiss/knowherefaiss/IndexIVFRaBitQ.cpp
index 44731e40..55c48e27 100644
--- a/thirdparty/faiss/faiss/IndexIVFRaBitQ.cpp
+++ b/thirdparty/faiss/knowherefaiss/IndexIVFRaBitQ.cpp
@@ -1,4 +1,4 @@
-#include <faiss/IndexIVFRaBitQ.h>
+#include <knowherefaiss/IndexIVFRaBitQ.h>
 
 #include <omp.h>
 
@@ -7,11 +7,11 @@
 #include <memory>
 #include <vector>
 
-#include <faiss/impl/FaissAssert.h>
-#include <faiss/impl/RaBitQuantizer.h>
-#include <faiss/utils/distances_if.h>
+#include <knowherefaiss/impl/FaissAssert.h>
+#include <knowherefaiss/impl/RaBitQuantizer.h>
+#include <knowherefaiss/utils/distances_if.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 IndexIVFRaBitQ::IndexIVFRaBitQ(
         Index* quantizer,
@@ -292,4 +292,4 @@ DistanceComputer* IndexIVFRaBitQ::get_distance_computer() const {
     return dc;
 }
 
-} // namespace faiss
\ No newline at end of file
+} // namespace knowherefaiss
\ No newline at end of file
diff --git a/thirdparty/faiss/faiss/IndexIVFRaBitQ.h b/thirdparty/faiss/knowherefaiss/IndexIVFRaBitQ.h
similarity index 90%
rename from thirdparty/faiss/faiss/IndexIVFRaBitQ.h
rename to thirdparty/faiss/knowherefaiss/IndexIVFRaBitQ.h
index 947d6eb0..78b635af 100644
--- a/thirdparty/faiss/faiss/IndexIVFRaBitQ.h
+++ b/thirdparty/faiss/knowherefaiss/IndexIVFRaBitQ.h
@@ -3,12 +3,12 @@
 #include <cstddef>
 #include <cstdint>
 
-#include <faiss/Index.h>
-#include <faiss/IndexIVF.h>
+#include <knowherefaiss/Index.h>
+#include <knowherefaiss/IndexIVF.h>
 
-#include <faiss/impl/RaBitQuantizer.h>
+#include <knowherefaiss/impl/RaBitQuantizer.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 struct IVFRaBitQSearchParameters : IVFSearchParameters {
     uint8_t qb = 0;
@@ -61,4 +61,4 @@ struct IndexIVFRaBitQ : IndexIVF {
     DistanceComputer* get_distance_computer() const override;
 };
 
-} // namespace faiss
\ No newline at end of file
+} // namespace knowherefaiss
\ No newline at end of file
diff --git a/thirdparty/faiss/faiss/IndexIVFScalarQuantizerCC.cpp b/thirdparty/faiss/knowherefaiss/IndexIVFScalarQuantizerCC.cpp
similarity index 97%
rename from thirdparty/faiss/faiss/IndexIVFScalarQuantizerCC.cpp
rename to thirdparty/faiss/knowherefaiss/IndexIVFScalarQuantizerCC.cpp
index 5ce222a4..d886fa61 100644
--- a/thirdparty/faiss/faiss/IndexIVFScalarQuantizerCC.cpp
+++ b/thirdparty/faiss/knowherefaiss/IndexIVFScalarQuantizerCC.cpp
@@ -1,7 +1,7 @@
-#include <faiss/IndexIVFScalarQuantizerCC.h>
+#include <knowherefaiss/IndexIVFScalarQuantizerCC.h>
 #include <omp.h>
 
-namespace faiss {
+namespace knowherefaiss {
 IndexIVFScalarQuantizerCC::IndexIVFScalarQuantizerCC(
         Index* quantizer,
         size_t d,
@@ -134,4 +134,4 @@ void IndexIVFScalarQuantizerCC::reconstruct_n(idx_t i0, idx_t ni, float* recons)
         const {
     FAISS_THROW_MSG("IndexIVFScalarQuantizerCC not support reconstruct_n");
 }
-} // namespace faiss
\ No newline at end of file
+} // namespace knowherefaiss
\ No newline at end of file
diff --git a/thirdparty/faiss/faiss/IndexIVFScalarQuantizerCC.h b/thirdparty/faiss/knowherefaiss/IndexIVFScalarQuantizerCC.h
similarity index 92%
rename from thirdparty/faiss/faiss/IndexIVFScalarQuantizerCC.h
rename to thirdparty/faiss/knowherefaiss/IndexIVFScalarQuantizerCC.h
index 5f208b9b..a8e615e7 100644
--- a/thirdparty/faiss/faiss/IndexIVFScalarQuantizerCC.h
+++ b/thirdparty/faiss/knowherefaiss/IndexIVFScalarQuantizerCC.h
@@ -1,11 +1,11 @@
 #pragma once
-#include <faiss/IndexScalarQuantizer.h>
+#include <knowherefaiss/IndexScalarQuantizer.h>
 #include <cstdio>
 #include <fstream>
 #include <optional>
 #include "knowhere/utils.h"
 #include "utils/data_backup_file.h"
-namespace faiss {
+namespace knowherefaiss {
 
 /***************************************************
  *IndexIVFScalarQuantizerCC
@@ -44,4 +44,4 @@ struct IndexIVFScalarQuantizerCC : IndexIVFScalarQuantizer {
 
     void reconstruct_n(idx_t i0, idx_t ni, float* recons) const override;
 };
-} // namespace faiss
\ No newline at end of file
+} // namespace knowherefaiss
\ No newline at end of file
diff --git a/thirdparty/faiss/faiss/IndexIVFSpectralHash.cpp b/thirdparty/faiss/knowherefaiss/IndexIVFSpectralHash.cpp
similarity index 96%
rename from thirdparty/faiss/faiss/IndexIVFSpectralHash.cpp
rename to thirdparty/faiss/knowherefaiss/IndexIVFSpectralHash.cpp
index eed39f1c..0ab5e573 100644
--- a/thirdparty/faiss/faiss/IndexIVFSpectralHash.cpp
+++ b/thirdparty/faiss/knowherefaiss/IndexIVFSpectralHash.cpp
@@ -7,21 +7,21 @@
 
 // -*- c++ -*-
 
-#include <faiss/IndexIVFSpectralHash.h>
+#include <knowherefaiss/IndexIVFSpectralHash.h>
 
 #include <algorithm>
 #include <cstdint>
 #include <memory>
 
-#include <faiss/IndexLSH.h>
-#include <faiss/IndexPreTransform.h>
-#include <faiss/VectorTransform.h>
-#include <faiss/impl/AuxIndexStructures.h>
-#include <faiss/impl/FaissAssert.h>
-#include <faiss/utils/hamming.h>
-#include <faiss/utils/utils.h>
+#include <knowherefaiss/IndexLSH.h>
+#include <knowherefaiss/IndexPreTransform.h>
+#include <knowherefaiss/VectorTransform.h>
+#include <knowherefaiss/impl/AuxIndexStructures.h>
+#include <knowherefaiss/impl/FaissAssert.h>
+#include <knowherefaiss/utils/hamming.h>
+#include <knowherefaiss/utils/utils.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 IndexIVFSpectralHash::IndexIVFSpectralHash(
         Index* quantizer,
@@ -347,4 +347,4 @@ void IndexIVFSpectralHash::replace_vt(IndexPreTransform* encoder, bool own) {
     replace_vt(encoder->chain[0], own);
 }
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/IndexIVFSpectralHash.h b/thirdparty/faiss/knowherefaiss/IndexIVFSpectralHash.h
similarity index 96%
rename from thirdparty/faiss/faiss/IndexIVFSpectralHash.h
rename to thirdparty/faiss/knowherefaiss/IndexIVFSpectralHash.h
index e7d73305..b9e3ba40 100644
--- a/thirdparty/faiss/faiss/IndexIVFSpectralHash.h
+++ b/thirdparty/faiss/knowherefaiss/IndexIVFSpectralHash.h
@@ -12,9 +12,9 @@
 
 #include <vector>
 
-#include <faiss/IndexIVF.h>
+#include <knowherefaiss/IndexIVF.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 struct VectorTransform;
 struct IndexPreTransform;
@@ -85,6 +85,6 @@ struct IndexIVFSpectralHash : IndexIVF {
     ~IndexIVFSpectralHash() override;
 };
 
-} // namespace faiss
+} // namespace knowherefaiss
 
 #endif
diff --git a/thirdparty/faiss/faiss/IndexLSH.cpp b/thirdparty/faiss/knowherefaiss/IndexLSH.cpp
similarity index 94%
rename from thirdparty/faiss/faiss/IndexLSH.cpp
rename to thirdparty/faiss/knowherefaiss/IndexLSH.cpp
index 40c8456f..d9b9a1f7 100644
--- a/thirdparty/faiss/faiss/IndexLSH.cpp
+++ b/thirdparty/faiss/knowherefaiss/IndexLSH.cpp
@@ -5,7 +5,7 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/IndexLSH.h>
+#include <knowherefaiss/IndexLSH.h>
 
 #include <cstdio>
 #include <cstring>
@@ -13,12 +13,12 @@
 #include <algorithm>
 #include <memory>
 
-#include <faiss/impl/FaissAssert.h>
-#include <faiss/utils/binary_distances.h>
-#include <faiss/utils/hamming.h>
-#include <faiss/utils/utils.h>
+#include <knowherefaiss/impl/FaissAssert.h>
+#include <knowherefaiss/utils/binary_distances.h>
+#include <knowherefaiss/utils/hamming.h>
+#include <knowherefaiss/utils/utils.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 /***************************************************************
  * IndexLSH
@@ -122,7 +122,7 @@ void IndexLSH::search(
     int_maxheap_array_t res = {size_t(n), size_t(k), labels, idistances.get()};
 
     binary_knn_hc(
-        faiss::METRIC_Hamming,
+        knowherefaiss::METRIC_Hamming,
         &res, 
         qcodes.get(), 
         codes.data(), 
@@ -183,4 +183,4 @@ void IndexLSH::sa_decode(idx_t n, const uint8_t* bytes, float* x) const {
     }
 }
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/IndexLSH.h b/thirdparty/faiss/knowherefaiss/IndexLSH.h
similarity index 93%
rename from thirdparty/faiss/faiss/IndexLSH.h
rename to thirdparty/faiss/knowherefaiss/IndexLSH.h
index bba0f974..7beed15b 100644
--- a/thirdparty/faiss/faiss/IndexLSH.h
+++ b/thirdparty/faiss/knowherefaiss/IndexLSH.h
@@ -12,10 +12,10 @@
 
 #include <vector>
 
-#include <faiss/IndexFlatCodes.h>
-#include <faiss/VectorTransform.h>
+#include <knowherefaiss/IndexFlatCodes.h>
+#include <knowherefaiss/VectorTransform.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 /** The sign of each vector component is put in a binary signature */
 struct IndexLSH : IndexFlatCodes {
@@ -68,6 +68,6 @@ struct IndexLSH : IndexFlatCodes {
     void sa_decode(idx_t n, const uint8_t* bytes, float* x) const override;
 };
 
-} // namespace faiss
+} // namespace knowherefaiss
 
 #endif
diff --git a/thirdparty/faiss/faiss/IndexLattice.cpp b/thirdparty/faiss/knowherefaiss/IndexLattice.cpp
similarity index 93%
rename from thirdparty/faiss/faiss/IndexLattice.cpp
rename to thirdparty/faiss/knowherefaiss/IndexLattice.cpp
index ffa294aa..c5bcf344 100644
--- a/thirdparty/faiss/faiss/IndexLattice.cpp
+++ b/thirdparty/faiss/knowherefaiss/IndexLattice.cpp
@@ -7,14 +7,14 @@
 
 // -*- c++ -*-
 
-#include <faiss/IndexLattice.h>
-#include <faiss/impl/FaissAssert.h>
-#include <faiss/utils/distances.h>
-#include <faiss/utils/hamming.h> // for the bitstring routines
+#include <knowherefaiss/IndexLattice.h>
+#include <knowherefaiss/impl/FaissAssert.h>
+#include <knowherefaiss/utils/distances.h>
+#include <knowherefaiss/utils/hamming.h> // for the bitstring routines
 
 #include "simd/hook.h"
 
-namespace faiss {
+namespace knowherefaiss {
 
 IndexLattice::IndexLattice(idx_t d, int nsq, int scale_nbit, int r2)
         : Index(d),
@@ -134,4 +134,4 @@ void IndexLattice::reset() {
     FAISS_THROW_MSG("not implemented");
 }
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/IndexLattice.h b/thirdparty/faiss/knowherefaiss/IndexLattice.h
similarity index 91%
rename from thirdparty/faiss/faiss/IndexLattice.h
rename to thirdparty/faiss/knowherefaiss/IndexLattice.h
index a9eb62b6..8b7f6c90 100644
--- a/thirdparty/faiss/faiss/IndexLattice.h
+++ b/thirdparty/faiss/knowherefaiss/IndexLattice.h
@@ -12,10 +12,10 @@
 
 #include <vector>
 
-#include <faiss/IndexIVF.h>
-#include <faiss/impl/lattice_Zn.h>
+#include <knowherefaiss/IndexIVF.h>
+#include <knowherefaiss/impl/lattice_Zn.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 /** Index that encodes a vector with a series of Zn lattice quantizers
  */
@@ -60,6 +60,6 @@ struct IndexLattice : Index {
     void reset() override;
 };
 
-} // namespace faiss
+} // namespace knowherefaiss
 
 #endif
diff --git a/thirdparty/faiss/faiss/IndexNNDescent.cpp b/thirdparty/faiss/knowherefaiss/IndexNNDescent.cpp
similarity index 93%
rename from thirdparty/faiss/faiss/IndexNNDescent.cpp
rename to thirdparty/faiss/knowherefaiss/IndexNNDescent.cpp
index 382e9c41..86bc7863 100644
--- a/thirdparty/faiss/faiss/IndexNNDescent.cpp
+++ b/thirdparty/faiss/knowherefaiss/IndexNNDescent.cpp
@@ -7,7 +7,7 @@
 
 // -*- c++ -*-
 
-#include <faiss/IndexNNDescent.h>
+#include <knowherefaiss/IndexNNDescent.h>
 
 #include <omp.h>
 
@@ -21,12 +21,12 @@
 #ifdef __SSE__
 #endif
 
-#include <faiss/IndexFlat.h>
-#include <faiss/impl/AuxIndexStructures.h>
-#include <faiss/impl/FaissAssert.h>
-#include <faiss/utils/Heap.h>
-#include <faiss/utils/distances.h>
-#include <faiss/utils/random.h>
+#include <knowherefaiss/IndexFlat.h>
+#include <knowherefaiss/impl/AuxIndexStructures.h>
+#include <knowherefaiss/impl/FaissAssert.h>
+#include <knowherefaiss/utils/Heap.h>
+#include <knowherefaiss/utils/distances.h>
+#include <knowherefaiss/utils/random.h>
 
 extern "C" {
 
@@ -48,7 +48,7 @@ int sgemm_(
         FINTEGER* ldc);
 }
 
-namespace faiss {
+namespace knowherefaiss {
 
 using storage_idx_t = NNDescent::storage_idx_t;
 
@@ -196,4 +196,4 @@ IndexNNDescentFlat::IndexNNDescentFlat(int d, int M, MetricType metric)
     is_trained = true;
 }
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/IndexNNDescent.h b/thirdparty/faiss/knowherefaiss/IndexNNDescent.h
similarity index 90%
rename from thirdparty/faiss/faiss/IndexNNDescent.h
rename to thirdparty/faiss/knowherefaiss/IndexNNDescent.h
index 9b253205..8bf522e9 100644
--- a/thirdparty/faiss/faiss/IndexNNDescent.h
+++ b/thirdparty/faiss/knowherefaiss/IndexNNDescent.h
@@ -11,11 +11,11 @@
 
 #include <vector>
 
-#include <faiss/IndexFlat.h>
-#include <faiss/impl/NNDescent.h>
-#include <faiss/utils/utils.h>
+#include <knowherefaiss/IndexFlat.h>
+#include <knowherefaiss/impl/NNDescent.h>
+#include <knowherefaiss/utils/utils.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 /** The NNDescent index is a normal random-access index with an NNDescent
  * link structure built on top */
@@ -69,4 +69,4 @@ struct IndexNNDescentFlat : IndexNNDescent {
     IndexNNDescentFlat(int d, int K, MetricType metric = METRIC_L2);
 };
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/IndexNSG.cpp b/thirdparty/faiss/knowherefaiss/IndexNSG.cpp
similarity index 96%
rename from thirdparty/faiss/faiss/IndexNSG.cpp
rename to thirdparty/faiss/knowherefaiss/IndexNSG.cpp
index 2d1c3d82..b6b32397 100644
--- a/thirdparty/faiss/faiss/IndexNSG.cpp
+++ b/thirdparty/faiss/knowherefaiss/IndexNSG.cpp
@@ -7,21 +7,21 @@
 
 // -*- c++ -*-
 
-#include <faiss/IndexNSG.h>
+#include <knowherefaiss/IndexNSG.h>
 
 #include <omp.h>
 
 #include <cinttypes>
 #include <memory>
 
-#include <faiss/IndexFlat.h>
-#include <faiss/IndexNNDescent.h>
-#include <faiss/impl/AuxIndexStructures.h>
-#include <faiss/impl/FaissAssert.h>
-#include <faiss/utils/Heap.h>
-#include <faiss/utils/distances.h>
+#include <knowherefaiss/IndexFlat.h>
+#include <knowherefaiss/IndexNNDescent.h>
+#include <knowherefaiss/impl/AuxIndexStructures.h>
+#include <knowherefaiss/impl/FaissAssert.h>
+#include <knowherefaiss/utils/Heap.h>
+#include <knowherefaiss/utils/distances.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 using namespace nsg;
 
@@ -315,4 +315,4 @@ IndexNSGSQ::IndexNSGSQ(
 
 IndexNSGSQ::IndexNSGSQ() = default;
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/IndexNSG.h b/thirdparty/faiss/knowherefaiss/IndexNSG.h
similarity index 89%
rename from thirdparty/faiss/faiss/IndexNSG.h
rename to thirdparty/faiss/knowherefaiss/IndexNSG.h
index 172b10c9..1bfc1133 100644
--- a/thirdparty/faiss/faiss/IndexNSG.h
+++ b/thirdparty/faiss/knowherefaiss/IndexNSG.h
@@ -11,14 +11,14 @@
 
 #include <vector>
 
-#include <faiss/IndexFlat.h>
-#include <faiss/IndexNNDescent.h>
-#include <faiss/IndexPQ.h>
-#include <faiss/IndexScalarQuantizer.h>
-#include <faiss/impl/NSG.h>
-#include <faiss/utils/utils.h>
+#include <knowherefaiss/IndexFlat.h>
+#include <knowherefaiss/IndexNNDescent.h>
+#include <knowherefaiss/IndexPQ.h>
+#include <knowherefaiss/IndexScalarQuantizer.h>
+#include <knowherefaiss/impl/NSG.h>
+#include <knowherefaiss/utils/utils.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 /** The NSG index is a normal random-access index with a NSG
  * link structure built on top */
@@ -106,4 +106,4 @@ struct IndexNSGSQ : IndexNSG {
             MetricType metric = METRIC_L2);
 };
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/IndexPQ.cpp b/thirdparty/faiss/knowherefaiss/IndexPQ.cpp
similarity index 99%
rename from thirdparty/faiss/faiss/IndexPQ.cpp
rename to thirdparty/faiss/knowherefaiss/IndexPQ.cpp
index da019c8b..e3d9c374 100644
--- a/thirdparty/faiss/faiss/IndexPQ.cpp
+++ b/thirdparty/faiss/knowherefaiss/IndexPQ.cpp
@@ -5,7 +5,7 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/IndexPQ.h>
+#include <knowherefaiss/IndexPQ.h>
 
 #include <cinttypes>
 #include <cmath>
@@ -16,13 +16,13 @@
 #include <algorithm>
 #include <memory>
 
-#include <faiss/impl/DistanceComputer.h>
-#include <faiss/impl/FaissAssert.h>
-#include <faiss/utils/hamming.h>
+#include <knowherefaiss/impl/DistanceComputer.h>
+#include <knowherefaiss/impl/FaissAssert.h>
+#include <knowherefaiss/utils/hamming.h>
 
-#include <faiss/impl/code_distance/code_distance.h>
+#include <knowherefaiss/impl/code_distance/code_distance.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 /*********************************************************
  * IndexPQ implementation
@@ -1117,4 +1117,4 @@ void MultiIndexQuantizer2::search(
     }
 }
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/IndexPQ.h b/thirdparty/faiss/knowherefaiss/IndexPQ.h
similarity index 95%
rename from thirdparty/faiss/faiss/IndexPQ.h
rename to thirdparty/faiss/knowherefaiss/IndexPQ.h
index 32810a24..b76d65ab 100644
--- a/thirdparty/faiss/faiss/IndexPQ.h
+++ b/thirdparty/faiss/knowherefaiss/IndexPQ.h
@@ -12,12 +12,12 @@
 
 #include <vector>
 
-#include <faiss/IndexFlatCodes.h>
-#include <faiss/impl/PolysemousTraining.h>
-#include <faiss/impl/ProductQuantizer.h>
-#include <faiss/impl/platform_macros.h>
+#include <knowherefaiss/IndexFlatCodes.h>
+#include <knowherefaiss/impl/PolysemousTraining.h>
+#include <knowherefaiss/impl/ProductQuantizer.h>
+#include <knowherefaiss/impl/platform_macros.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 /** Index based on a product quantizer. Stored vectors are
  * approximated by PQ codes. */
@@ -194,6 +194,6 @@ struct MultiIndexQuantizer2 : MultiIndexQuantizer {
             const SearchParameters* params = nullptr) const override;
 };
 
-} // namespace faiss
+} // namespace knowherefaiss
 
 #endif
diff --git a/thirdparty/faiss/faiss/IndexPQFastScan.cpp b/thirdparty/faiss/knowherefaiss/IndexPQFastScan.cpp
similarity index 87%
rename from thirdparty/faiss/faiss/IndexPQFastScan.cpp
rename to thirdparty/faiss/knowherefaiss/IndexPQFastScan.cpp
index b8a6cdbe..74c45f03 100644
--- a/thirdparty/faiss/faiss/IndexPQFastScan.cpp
+++ b/thirdparty/faiss/knowherefaiss/IndexPQFastScan.cpp
@@ -5,7 +5,7 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/IndexPQFastScan.h>
+#include <knowherefaiss/IndexPQFastScan.h>
 
 #include <cassert>
 #include <climits>
@@ -13,11 +13,11 @@
 
 #include <omp.h>
 
-#include <faiss/impl/FaissAssert.h>
-#include <faiss/impl/pq4_fast_scan.h>
-#include <faiss/utils/utils.h>
+#include <knowherefaiss/impl/FaissAssert.h>
+#include <knowherefaiss/impl/pq4_fast_scan.h>
+#include <knowherefaiss/utils/utils.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 inline size_t roundup(size_t a, size_t b) {
     return (a + b - 1) / b * b;
@@ -71,4 +71,4 @@ void IndexPQFastScan::sa_decode(idx_t n, const uint8_t* bytes, float* x) const {
     pq.decode(bytes, x, n);
 }
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/IndexPQFastScan.h b/thirdparty/faiss/knowherefaiss/IndexPQFastScan.h
similarity index 87%
rename from thirdparty/faiss/faiss/IndexPQFastScan.h
rename to thirdparty/faiss/knowherefaiss/IndexPQFastScan.h
index 220da378..a171f52b 100644
--- a/thirdparty/faiss/faiss/IndexPQFastScan.h
+++ b/thirdparty/faiss/knowherefaiss/IndexPQFastScan.h
@@ -7,12 +7,12 @@
 
 #pragma once
 
-#include <faiss/IndexFastScan.h>
-#include <faiss/IndexPQ.h>
-#include <faiss/impl/ProductQuantizer.h>
-#include <faiss/utils/AlignedTable.h>
+#include <knowherefaiss/IndexFastScan.h>
+#include <knowherefaiss/IndexPQ.h>
+#include <knowherefaiss/impl/ProductQuantizer.h>
+#include <knowherefaiss/utils/AlignedTable.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 /** Fast scan version of IndexPQ. Works for 4-bit PQ for now.
  *
@@ -59,4 +59,4 @@ struct IndexPQFastScan : IndexFastScan {
     void sa_decode(idx_t n, const uint8_t* bytes, float* x) const override;
 };
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/IndexPreTransform.cpp b/thirdparty/faiss/knowherefaiss/IndexPreTransform.cpp
similarity index 97%
rename from thirdparty/faiss/faiss/IndexPreTransform.cpp
rename to thirdparty/faiss/knowherefaiss/IndexPreTransform.cpp
index 8bc847a9..72a747f3 100644
--- a/thirdparty/faiss/faiss/IndexPreTransform.cpp
+++ b/thirdparty/faiss/knowherefaiss/IndexPreTransform.cpp
@@ -7,18 +7,18 @@
 
 // -*- c++ -*-
 
-#include <faiss/IndexPreTransform.h>
+#include <knowherefaiss/IndexPreTransform.h>
 
 #include <cmath>
 #include <cstdio>
 #include <cstring>
 #include <memory>
 
-#include <faiss/impl/AuxIndexStructures.h>
-#include <faiss/impl/DistanceComputer.h>
-#include <faiss/impl/FaissAssert.h>
+#include <knowherefaiss/impl/AuxIndexStructures.h>
+#include <knowherefaiss/impl/DistanceComputer.h>
+#include <knowherefaiss/impl/FaissAssert.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 /*********************************************
  * IndexPreTransform
@@ -334,4 +334,4 @@ DistanceComputer* IndexPreTransform::get_distance_computer() const {
     }
 }
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/IndexPreTransform.h b/thirdparty/faiss/knowherefaiss/IndexPreTransform.h
similarity index 95%
rename from thirdparty/faiss/faiss/IndexPreTransform.h
rename to thirdparty/faiss/knowherefaiss/IndexPreTransform.h
index 3ad7b28f..0b7fd569 100644
--- a/thirdparty/faiss/faiss/IndexPreTransform.h
+++ b/thirdparty/faiss/knowherefaiss/IndexPreTransform.h
@@ -9,10 +9,10 @@
 
 #pragma once
 
-#include <faiss/Index.h>
-#include <faiss/VectorTransform.h>
+#include <knowherefaiss/Index.h>
+#include <knowherefaiss/VectorTransform.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 struct SearchParametersPreTransform : SearchParameters {
     // nothing to add here.
@@ -99,4 +99,4 @@ struct IndexPreTransform : Index {
     ~IndexPreTransform() override;
 };
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/IndexRaBitQ.cpp b/thirdparty/faiss/knowherefaiss/IndexRaBitQ.cpp
similarity index 95%
rename from thirdparty/faiss/faiss/IndexRaBitQ.cpp
rename to thirdparty/faiss/knowherefaiss/IndexRaBitQ.cpp
index cccbed35..20ac180c 100644
--- a/thirdparty/faiss/faiss/IndexRaBitQ.cpp
+++ b/thirdparty/faiss/knowherefaiss/IndexRaBitQ.cpp
@@ -1,9 +1,9 @@
-#include <faiss/IndexRaBitQ.h>
+#include <knowherefaiss/IndexRaBitQ.h>
 
-#include <faiss/impl/FaissAssert.h>
-#include <faiss/impl/ResultHandler.h>
+#include <knowherefaiss/impl/FaissAssert.h>
+#include <knowherefaiss/impl/ResultHandler.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 IndexRaBitQ::IndexRaBitQ() = default;
 
@@ -138,4 +138,4 @@ void IndexRaBitQ::range_search(
     dispatch_range_ResultHandler(result, radius, metric_type, sel, r, this, x);
 }
 
-} // namespace faiss
\ No newline at end of file
+} // namespace knowherefaiss
\ No newline at end of file
diff --git a/thirdparty/faiss/faiss/IndexRaBitQ.h b/thirdparty/faiss/knowherefaiss/IndexRaBitQ.h
similarity index 91%
rename from thirdparty/faiss/faiss/IndexRaBitQ.h
rename to thirdparty/faiss/knowherefaiss/IndexRaBitQ.h
index aa706996..9c40ab33 100644
--- a/thirdparty/faiss/faiss/IndexRaBitQ.h
+++ b/thirdparty/faiss/knowherefaiss/IndexRaBitQ.h
@@ -1,9 +1,9 @@
 #pragma once
 
-#include <faiss/IndexFlatCodes.h>
-#include <faiss/impl/RaBitQuantizer.h>
+#include <knowherefaiss/IndexFlatCodes.h>
+#include <knowherefaiss/impl/RaBitQuantizer.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 struct RaBitQSearchParameters : SearchParameters {
     uint8_t qb = 0;
@@ -55,4 +55,4 @@ struct IndexRaBitQ : IndexFlatCodes {
             const SearchParameters* params = nullptr) const override;
 };
 
-} // namespace faiss
\ No newline at end of file
+} // namespace knowherefaiss
\ No newline at end of file
diff --git a/thirdparty/faiss/faiss/IndexRefine.cpp b/thirdparty/faiss/knowherefaiss/IndexRefine.cpp
similarity index 96%
rename from thirdparty/faiss/faiss/IndexRefine.cpp
rename to thirdparty/faiss/knowherefaiss/IndexRefine.cpp
index 58b822da..89760f74 100644
--- a/thirdparty/faiss/faiss/IndexRefine.cpp
+++ b/thirdparty/faiss/knowherefaiss/IndexRefine.cpp
@@ -5,17 +5,17 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/IndexRefine.h>
+#include <knowherefaiss/IndexRefine.h>
 
-#include <faiss/IndexFlat.h>
-#include <faiss/impl/AuxIndexStructures.h>
-#include <faiss/impl/FaissAssert.h>
-#include <faiss/utils/Heap.h>
-#include <faiss/utils/distances.h>
-#include <faiss/utils/distances_if.h>
-#include <faiss/utils/utils.h>
+#include <knowherefaiss/IndexFlat.h>
+#include <knowherefaiss/impl/AuxIndexStructures.h>
+#include <knowherefaiss/impl/FaissAssert.h>
+#include <knowherefaiss/utils/Heap.h>
+#include <knowherefaiss/utils/distances.h>
+#include <knowherefaiss/utils/distances_if.h>
+#include <knowherefaiss/utils/utils.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 /***************************************************
  * IndexRefine
@@ -329,4 +329,4 @@ void IndexRefineFlat::search(
     }
 }
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/IndexRefine.h b/thirdparty/faiss/knowherefaiss/IndexRefine.h
similarity index 96%
rename from thirdparty/faiss/faiss/IndexRefine.h
rename to thirdparty/faiss/knowherefaiss/IndexRefine.h
index f912df95..f32eda05 100644
--- a/thirdparty/faiss/faiss/IndexRefine.h
+++ b/thirdparty/faiss/knowherefaiss/IndexRefine.h
@@ -7,9 +7,9 @@
 
 #pragma once
 
-#include <faiss/Index.h>
+#include <knowherefaiss/Index.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 struct IndexRefineSearchParameters : SearchParameters {
     float k_factor = 1;
@@ -95,4 +95,4 @@ struct IndexRefineFlat : IndexRefine {
             const SearchParameters* params = nullptr) const override;
 };
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/IndexReplicas.cpp b/thirdparty/faiss/knowherefaiss/IndexReplicas.cpp
similarity index 94%
rename from thirdparty/faiss/faiss/IndexReplicas.cpp
rename to thirdparty/faiss/knowherefaiss/IndexReplicas.cpp
index 85f3fda7..7fba3345 100644
--- a/thirdparty/faiss/faiss/IndexReplicas.cpp
+++ b/thirdparty/faiss/knowherefaiss/IndexReplicas.cpp
@@ -7,10 +7,10 @@
 
 #include <cinttypes>
 
-#include <faiss/IndexReplicas.h>
-#include <faiss/impl/FaissAssert.h>
+#include <knowherefaiss/IndexReplicas.h>
+#include <knowherefaiss/impl/FaissAssert.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 namespace {
 
@@ -140,13 +140,13 @@ void IndexReplicasTemplate<IndexT>::search(
     size_t componentsPerVec = sizeof(component_t) == 1 ? (dim + 7) / 8 : dim;
 
     // Partition the query by the number of indices we have
-    faiss::idx_t queriesPerIndex =
-            (faiss::idx_t)(n + this->count() - 1) / (faiss::idx_t)this->count();
+    knowherefaiss::idx_t queriesPerIndex =
+            (knowherefaiss::idx_t)(n + this->count() - 1) / (knowherefaiss::idx_t)this->count();
     FAISS_ASSERT(n / queriesPerIndex <= this->count());
 
     auto fn = [queriesPerIndex, componentsPerVec, n, x, k, distances, labels](
                       int i, const IndexT* index) {
-        faiss::idx_t base = (faiss::idx_t)i * queriesPerIndex;
+        knowherefaiss::idx_t base = (knowherefaiss::idx_t)i * queriesPerIndex;
 
         if (base < n) {
             auto numForIndex = std::min(queriesPerIndex, n - base);
@@ -204,4 +204,4 @@ void IndexReplicasTemplate<IndexT>::syncWithSubIndexes() {
 template class IndexReplicasTemplate<Index>;
 template class IndexReplicasTemplate<IndexBinary>;
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/IndexReplicas.h b/thirdparty/faiss/knowherefaiss/IndexReplicas.h
similarity index 87%
rename from thirdparty/faiss/faiss/IndexReplicas.h
rename to thirdparty/faiss/knowherefaiss/IndexReplicas.h
index 84b12a7b..3e2a72e6 100644
--- a/thirdparty/faiss/faiss/IndexReplicas.h
+++ b/thirdparty/faiss/knowherefaiss/IndexReplicas.h
@@ -7,13 +7,13 @@
 
 #pragma once
 
-#include <faiss/Index.h>
-#include <faiss/IndexBinary.h>
-#include <faiss/impl/ThreadedIndex.h>
+#include <knowherefaiss/Index.h>
+#include <knowherefaiss/IndexBinary.h>
+#include <knowherefaiss/impl/ThreadedIndex.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
-/// Takes individual faiss::Index instances, and splits queries for
+/// Takes individual knowherefaiss::Index instances, and splits queries for
 /// sending to each Index instance, and joins the results together
 /// when done.
 /// Each index is managed by a separate CPU thread.
@@ -48,15 +48,15 @@ class IndexReplicasTemplate : public ThreadedIndex<IndexT> {
         this->removeIndex(index);
     }
 
-    /// faiss::Index API
+    /// knowherefaiss::Index API
     /// All indices receive the same call
     void train(idx_t n, const component_t* x) override;
 
-    /// faiss::Index API
+    /// knowherefaiss::Index API
     /// All indices receive the same call
     void add(idx_t n, const component_t* x) override;
 
-    /// faiss::Index API
+    /// knowherefaiss::Index API
     /// Query is partitioned into a slice for each sub-index
     /// split by ceil(n / #indices) for our sub-indices
     void search(
@@ -85,4 +85,4 @@ class IndexReplicasTemplate : public ThreadedIndex<IndexT> {
 using IndexReplicas = IndexReplicasTemplate<Index>;
 using IndexBinaryReplicas = IndexReplicasTemplate<IndexBinary>;
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/IndexRowwiseMinMax.cpp b/thirdparty/faiss/knowherefaiss/IndexRowwiseMinMax.cpp
similarity index 98%
rename from thirdparty/faiss/faiss/IndexRowwiseMinMax.cpp
rename to thirdparty/faiss/knowherefaiss/IndexRowwiseMinMax.cpp
index 045bc306..82167658 100644
--- a/thirdparty/faiss/faiss/IndexRowwiseMinMax.cpp
+++ b/thirdparty/faiss/knowherefaiss/IndexRowwiseMinMax.cpp
@@ -5,20 +5,20 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/IndexRowwiseMinMax.h>
+#include <knowherefaiss/IndexRowwiseMinMax.h>
 
 #include <cstdint>
 #include <cstring>
 #include <limits>
 
-#include <faiss/impl/FaissAssert.h>
-#include <faiss/utils/fp16.h>
+#include <knowherefaiss/impl/FaissAssert.h>
+#include <knowherefaiss/utils/fp16.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 namespace {
 
-using idx_t = faiss::idx_t;
+using idx_t = knowherefaiss::idx_t;
 
 struct StorageMinMaxFP16 {
     uint16_t scaler;
@@ -442,4 +442,4 @@ void IndexRowwiseMinMax::train_inplace(idx_t n, float* x) {
     train_inplace_impl<StorageMinMaxFP32>(this, n, x);
 }
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/IndexRowwiseMinMax.h b/thirdparty/faiss/knowherefaiss/IndexRowwiseMinMax.h
similarity index 95%
rename from thirdparty/faiss/faiss/IndexRowwiseMinMax.h
rename to thirdparty/faiss/knowherefaiss/IndexRowwiseMinMax.h
index 5e16da4b..829bc96c 100644
--- a/thirdparty/faiss/faiss/IndexRowwiseMinMax.h
+++ b/thirdparty/faiss/knowherefaiss/IndexRowwiseMinMax.h
@@ -10,10 +10,10 @@
 #include <cstdint>
 #include <vector>
 
-#include <faiss/Index.h>
-#include <faiss/impl/platform_macros.h>
+#include <knowherefaiss/Index.h>
+#include <knowherefaiss/impl/platform_macros.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 /// Index wrapper that performs rowwise normalization to [0,1], preserving
 /// the coefficients. This is a vector codec index only.
@@ -96,4 +96,4 @@ struct IndexRowwiseMinMax : IndexRowwiseMinMaxBase {
 FAISS_API extern int rowwise_minmax_sa_encode_bs;
 FAISS_API extern int rowwise_minmax_sa_decode_bs;
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/IndexScaNN.cpp b/thirdparty/faiss/knowherefaiss/IndexScaNN.cpp
similarity index 91%
rename from thirdparty/faiss/faiss/IndexScaNN.cpp
rename to thirdparty/faiss/knowherefaiss/IndexScaNN.cpp
index b473676d..4a79830f 100644
--- a/thirdparty/faiss/faiss/IndexScaNN.cpp
+++ b/thirdparty/faiss/knowherefaiss/IndexScaNN.cpp
@@ -1,16 +1,16 @@
-#include <faiss/IndexIVFPQFastScan.h>
-#include <faiss/IndexScaNN.h>
+#include <knowherefaiss/IndexIVFPQFastScan.h>
+#include <knowherefaiss/IndexScaNN.h>
 
-#include <faiss/IndexFlat.h>
-#include <faiss/impl/AuxIndexStructures.h>
-#include <faiss/impl/FaissAssert.h>
-#include <faiss/utils/Heap.h>
-#include <faiss/utils/distances.h>
-#include <faiss/utils/utils.h>
-#include <faiss/FaissHook.h>
-#include <faiss/IndexCosine.h>
+#include <knowherefaiss/IndexFlat.h>
+#include <knowherefaiss/impl/AuxIndexStructures.h>
+#include <knowherefaiss/impl/FaissAssert.h>
+#include <knowherefaiss/utils/Heap.h>
+#include <knowherefaiss/utils/distances.h>
+#include <knowherefaiss/utils/utils.h>
+#include <knowherefaiss/FaissHook.h>
+#include <knowherefaiss/IndexCosine.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 /***************************************************
  * IndexScaNN
@@ -265,14 +265,14 @@ std::unique_ptr<IVFIteratorWorkspace> IndexScaNN::getIteratorWorkspace(
     if (refine_index) {
         auto refine = dynamic_cast<const IndexFlat*>(refine_index);
         if (base->is_cosine) {
-            iterator->dis_refine = std::unique_ptr<faiss::DistanceComputer>(
-                    new faiss::WithCosineNormDistanceComputer(
+            iterator->dis_refine = std::unique_ptr<knowherefaiss::DistanceComputer>(
+                    new knowherefaiss::WithCosineNormDistanceComputer(
                             base->inverse_norms.data(),
                             base->d,
-                            std::unique_ptr<faiss::DistanceComputer>(
+                            std::unique_ptr<knowherefaiss::DistanceComputer>(
                                     refine->get_distance_computer())));
         } else {
-            iterator->dis_refine = std::unique_ptr<faiss::DistanceComputer>(
+            iterator->dis_refine = std::unique_ptr<knowherefaiss::DistanceComputer>(
                     refine->get_FlatCodesDistanceComputer());
         }
         iterator->dis_refine->set_query(query_data);
@@ -290,4 +290,4 @@ void IndexScaNN::getIteratorNextBatch(
     return base->getIteratorNextBatch(workspace, current_backup_count);
 }
 
-} // namespace faiss
\ No newline at end of file
+} // namespace knowherefaiss
\ No newline at end of file
diff --git a/thirdparty/faiss/faiss/IndexScaNN.h b/thirdparty/faiss/knowherefaiss/IndexScaNN.h
similarity index 91%
rename from thirdparty/faiss/faiss/IndexScaNN.h
rename to thirdparty/faiss/knowherefaiss/IndexScaNN.h
index 9748953b..ae7419fe 100644
--- a/thirdparty/faiss/faiss/IndexScaNN.h
+++ b/thirdparty/faiss/knowherefaiss/IndexScaNN.h
@@ -1,9 +1,9 @@
 #pragma once
 
-#include <faiss/Index.h>
-#include <faiss/IndexRefine.h>
+#include <knowherefaiss/Index.h>
+#include <knowherefaiss/IndexRefine.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 struct IndexScaNNSearchParameters : SearchParameters {
     size_t reorder_k = 1;
@@ -54,4 +54,4 @@ struct IndexScaNN : IndexRefine {
             size_t current_backup_count) const;
 };
 
-} // namespace faiss
\ No newline at end of file
+} // namespace knowherefaiss
\ No newline at end of file
diff --git a/thirdparty/faiss/faiss/IndexScalarQuantizer.cpp b/thirdparty/faiss/knowherefaiss/IndexScalarQuantizer.cpp
similarity index 96%
rename from thirdparty/faiss/faiss/IndexScalarQuantizer.cpp
rename to thirdparty/faiss/knowherefaiss/IndexScalarQuantizer.cpp
index 80ec365f..1c2397b6 100644
--- a/thirdparty/faiss/faiss/IndexScalarQuantizer.cpp
+++ b/thirdparty/faiss/knowherefaiss/IndexScalarQuantizer.cpp
@@ -7,20 +7,20 @@
 
 // -*- c++ -*-
 
-#include <faiss/IndexScalarQuantizer.h>
+#include <knowherefaiss/IndexScalarQuantizer.h>
 
 #include <algorithm>
 #include <cstdio>
 
 #include <omp.h>
 
-#include <faiss/impl/AuxIndexStructures.h>
-#include <faiss/impl/FaissAssert.h>
-#include <faiss/impl/IDSelector.h>
-#include <faiss/impl/ScalarQuantizer.h>
-#include <faiss/utils/utils.h>
+#include <knowherefaiss/impl/AuxIndexStructures.h>
+#include <knowherefaiss/impl/FaissAssert.h>
+#include <knowherefaiss/impl/IDSelector.h>
+#include <knowherefaiss/impl/ScalarQuantizer.h>
+#include <knowherefaiss/utils/utils.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 /*******************************************************************
  * IndexScalarQuantizer implementation
@@ -286,4 +286,4 @@ void IndexIVFScalarQuantizer::reconstruct_from_offset(
     }
 }
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/IndexScalarQuantizer.h b/thirdparty/faiss/knowherefaiss/IndexScalarQuantizer.h
similarity index 92%
rename from thirdparty/faiss/faiss/IndexScalarQuantizer.h
rename to thirdparty/faiss/knowherefaiss/IndexScalarQuantizer.h
index 04ddd817..dbd32026 100644
--- a/thirdparty/faiss/faiss/IndexScalarQuantizer.h
+++ b/thirdparty/faiss/knowherefaiss/IndexScalarQuantizer.h
@@ -13,12 +13,12 @@
 #include <stdint.h>
 #include <vector>
 
-#include <faiss/IndexFlatCodes.h>
-#include <faiss/IndexIVF.h>
-#include <faiss/impl/ScalarQuantizer.h>
-#include <faiss/impl/ScalarQuantizerOp.h>
+#include <knowherefaiss/IndexFlatCodes.h>
+#include <knowherefaiss/IndexIVF.h>
+#include <knowherefaiss/impl/ScalarQuantizer.h>
+#include <knowherefaiss/impl/ScalarQuantizerOp.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 /**
  * Flat index built on a scalar quantizer.
@@ -110,6 +110,6 @@ struct IndexIVFScalarQuantizer : IndexIVF {
     void sa_decode(idx_t n, const uint8_t* bytes, float* x) const override;
 };
 
-} // namespace faiss
+} // namespace knowherefaiss
 
 #endif
diff --git a/thirdparty/faiss/faiss/IndexShards.cpp b/thirdparty/faiss/knowherefaiss/IndexShards.cpp
similarity index 96%
rename from thirdparty/faiss/faiss/IndexShards.cpp
rename to thirdparty/faiss/knowherefaiss/IndexShards.cpp
index 716e69a5..77b2d02c 100644
--- a/thirdparty/faiss/faiss/IndexShards.cpp
+++ b/thirdparty/faiss/knowherefaiss/IndexShards.cpp
@@ -5,17 +5,17 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/IndexShards.h>
+#include <knowherefaiss/IndexShards.h>
 
 #include <cinttypes>
 #include <cstdio>
 #include <functional>
 
-#include <faiss/impl/FaissAssert.h>
-#include <faiss/utils/Heap.h>
-#include <faiss/utils/WorkerThread.h>
+#include <knowherefaiss/impl/FaissAssert.h>
+#include <knowherefaiss/utils/Heap.h>
+#include <knowherefaiss/utils/WorkerThread.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 // subroutines
 namespace {
@@ -267,4 +267,4 @@ void IndexShardsTemplate<IndexT>::search(
 template struct IndexShardsTemplate<Index>;
 template struct IndexShardsTemplate<IndexBinary>;
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/IndexShards.h b/thirdparty/faiss/knowherefaiss/IndexShards.h
similarity index 95%
rename from thirdparty/faiss/faiss/IndexShards.h
rename to thirdparty/faiss/knowherefaiss/IndexShards.h
index 278d5724..e5de1b02 100644
--- a/thirdparty/faiss/faiss/IndexShards.h
+++ b/thirdparty/faiss/knowherefaiss/IndexShards.h
@@ -7,11 +7,11 @@
 
 #pragma once
 
-#include <faiss/Index.h>
-#include <faiss/IndexBinary.h>
-#include <faiss/impl/ThreadedIndex.h>
+#include <knowherefaiss/Index.h>
+#include <knowherefaiss/IndexBinary.h>
+#include <knowherefaiss/impl/ThreadedIndex.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 /**
  * Index that concatenates the results from several sub-indexes
@@ -108,4 +108,4 @@ struct IndexShardsTemplate : public ThreadedIndex<IndexT> {
 using IndexShards = IndexShardsTemplate<Index>;
 using IndexBinaryShards = IndexShardsTemplate<IndexBinary>;
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/IndexShardsIVF.cpp b/thirdparty/faiss/knowherefaiss/IndexShardsIVF.cpp
similarity index 96%
rename from thirdparty/faiss/faiss/IndexShardsIVF.cpp
rename to thirdparty/faiss/knowherefaiss/IndexShardsIVF.cpp
index 6ec5c31d..3ade9a12 100644
--- a/thirdparty/faiss/faiss/IndexShardsIVF.cpp
+++ b/thirdparty/faiss/knowherefaiss/IndexShardsIVF.cpp
@@ -7,18 +7,18 @@
 
 // -*- c++ -*-
 
-#include <faiss/IndexShardsIVF.h>
+#include <knowherefaiss/IndexShardsIVF.h>
 
 #include <cinttypes>
 #include <cstdio>
 #include <functional>
 
-#include <faiss/impl/FaissAssert.h>
-#include <faiss/utils/Heap.h>
-#include <faiss/utils/WorkerThread.h>
-#include <faiss/utils/utils.h>
+#include <knowherefaiss/impl/FaissAssert.h>
+#include <knowherefaiss/utils/Heap.h>
+#include <knowherefaiss/utils/WorkerThread.h>
+#include <knowherefaiss/utils/utils.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 // subroutines
 namespace {
@@ -242,4 +242,4 @@ void IndexShardsIVF::search(
     }
 }
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/IndexShardsIVF.h b/thirdparty/faiss/knowherefaiss/IndexShardsIVF.h
similarity index 88%
rename from thirdparty/faiss/faiss/IndexShardsIVF.h
rename to thirdparty/faiss/knowherefaiss/IndexShardsIVF.h
index 8b17e22b..f2ffcb51 100644
--- a/thirdparty/faiss/faiss/IndexShardsIVF.h
+++ b/thirdparty/faiss/knowherefaiss/IndexShardsIVF.h
@@ -7,10 +7,10 @@
 
 #pragma once
 
-#include <faiss/IndexIVF.h>
-#include <faiss/IndexShards.h>
+#include <knowherefaiss/IndexIVF.h>
+#include <knowherefaiss/IndexShards.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 /**
  * IndexShards with a common coarse quantizer. All the indexes added should be
@@ -39,4 +39,4 @@ struct IndexShardsIVF : public IndexShards, Level1Quantizer {
             const SearchParameters* params = nullptr) const override;
 };
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/MatrixStats.cpp b/thirdparty/faiss/knowherefaiss/MatrixStats.cpp
similarity index 98%
rename from thirdparty/faiss/faiss/MatrixStats.cpp
rename to thirdparty/faiss/knowherefaiss/MatrixStats.cpp
index f2f9a431..da9affd8 100644
--- a/thirdparty/faiss/faiss/MatrixStats.cpp
+++ b/thirdparty/faiss/knowherefaiss/MatrixStats.cpp
@@ -7,16 +7,16 @@
 
 // -*- c++ -*-
 
-#include <faiss/MatrixStats.h>
+#include <knowherefaiss/MatrixStats.h>
 
 #include <cstdarg> /* va_list, va_start, va_arg, va_end */
 
-#include <faiss/utils/utils.h>
+#include <knowherefaiss/utils/utils.h>
 #include <cinttypes>
 #include <cmath>
 #include <cstdio>
 
-namespace faiss {
+namespace knowherefaiss {
 
 /*********************************************************************
  * MatrixStats
@@ -249,4 +249,4 @@ MatrixStats::MatrixStats(size_t n, size_t d, const float* x) : n(n), d(d) {
     nbuf = 0;
 }
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/MatrixStats.h b/thirdparty/faiss/knowherefaiss/MatrixStats.h
similarity index 96%
rename from thirdparty/faiss/faiss/MatrixStats.h
rename to thirdparty/faiss/knowherefaiss/MatrixStats.h
index 45a7c97d..82a56b6e 100644
--- a/thirdparty/faiss/faiss/MatrixStats.h
+++ b/thirdparty/faiss/knowherefaiss/MatrixStats.h
@@ -15,7 +15,7 @@
 #include <unordered_map>
 #include <vector>
 
-namespace faiss {
+namespace knowherefaiss {
 
 /** Reports some statistics on a dataset and comments on them.
  *
@@ -68,4 +68,4 @@ struct MatrixStats {
     void do_comment(const char* fmt, ...);
 };
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/MetaIndexes.cpp b/thirdparty/faiss/knowherefaiss/MetaIndexes.cpp
similarity index 94%
rename from thirdparty/faiss/faiss/MetaIndexes.cpp
rename to thirdparty/faiss/knowherefaiss/MetaIndexes.cpp
index afa9ecc3..eb083e2a 100644
--- a/thirdparty/faiss/faiss/MetaIndexes.cpp
+++ b/thirdparty/faiss/knowherefaiss/MetaIndexes.cpp
@@ -7,22 +7,22 @@
 
 // -*- c++ -*-
 
-#include <faiss/MetaIndexes.h>
+#include <knowherefaiss/MetaIndexes.h>
 
 #include <cinttypes>
 #include <cstdint>
 #include <cstdio>
 #include <limits>
 
-#include <faiss/impl/AuxIndexStructures.h>
-#include <faiss/impl/FaissAssert.h>
-#include <faiss/impl/IDSelector.h>
-#include <faiss/utils/Heap.h>
-#include <faiss/utils/WorkerThread.h>
-#include <faiss/utils/random.h>
-#include <faiss/utils/utils.h>
+#include <knowherefaiss/impl/AuxIndexStructures.h>
+#include <knowherefaiss/impl/FaissAssert.h>
+#include <knowherefaiss/impl/IDSelector.h>
+#include <knowherefaiss/utils/Heap.h>
+#include <knowherefaiss/utils/WorkerThread.h>
+#include <knowherefaiss/utils/random.h>
+#include <knowherefaiss/utils/utils.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 /*****************************************************
  * IndexSplitVectors implementation
@@ -240,4 +240,4 @@ void IndexRandom::reset() {
 
 IndexRandom::~IndexRandom() = default;
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/MetaIndexes.h b/thirdparty/faiss/knowherefaiss/MetaIndexes.h
similarity index 89%
rename from thirdparty/faiss/faiss/MetaIndexes.h
rename to thirdparty/faiss/knowherefaiss/MetaIndexes.h
index d94809cd..d310bd20 100644
--- a/thirdparty/faiss/faiss/MetaIndexes.h
+++ b/thirdparty/faiss/knowherefaiss/MetaIndexes.h
@@ -10,13 +10,13 @@
 #ifndef META_INDEXES_H
 #define META_INDEXES_H
 
-#include <faiss/Index.h>
-#include <faiss/IndexIDMap.h>
-#include <faiss/IndexReplicas.h>
-#include <faiss/IndexShards.h>
+#include <knowherefaiss/Index.h>
+#include <knowherefaiss/IndexIDMap.h>
+#include <knowherefaiss/IndexReplicas.h>
+#include <knowherefaiss/IndexShards.h>
 #include <vector>
 
-namespace faiss {
+namespace knowherefaiss {
 
 /** splits input vectors in segments and assigns each segment to a sub-index
  * used to distribute a MultiIndexQuantizer
@@ -78,6 +78,6 @@ struct IndexRandom : Index {
     ~IndexRandom() override;
 };
 
-} // namespace faiss
+} // namespace knowherefaiss
 
 #endif
diff --git a/thirdparty/faiss/faiss/MetricType.h b/thirdparty/faiss/knowherefaiss/MetricType.h
similarity index 94%
rename from thirdparty/faiss/faiss/MetricType.h
rename to thirdparty/faiss/knowherefaiss/MetricType.h
index aa0ab4bc..21b36735 100644
--- a/thirdparty/faiss/faiss/MetricType.h
+++ b/thirdparty/faiss/knowherefaiss/MetricType.h
@@ -10,9 +10,9 @@
 #ifndef FAISS_METRIC_TYPE_H
 #define FAISS_METRIC_TYPE_H
 
-#include <faiss/impl/platform_macros.h>
+#include <knowherefaiss/impl/platform_macros.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 /// The metric space for vector comparison for Faiss indices and algorithms.
 ///
@@ -24,7 +24,7 @@ enum MetricType {
     METRIC_L2 = 1,            ///< squared L2 search
     METRIC_L1 = 2,            ///< L1 (aka cityblock)
     METRIC_Linf = 3,          ///< infinity distance
-    METRIC_Lp = 4,            ///< L_p distance, p is given by a faiss::Index
+    METRIC_Lp = 4,            ///< L_p distance, p is given by a knowherefaiss::Index
                               /// metric_arg
 
     // Note: Faiss 1.7.4 defines METRIC_Jaccard=23,
@@ -56,6 +56,6 @@ constexpr bool is_similarity_metric(MetricType metric_type) {
             (metric_type == METRIC_Jaccard));
 }
 
-} // namespace faiss
+} // namespace knowherefaiss
 
 #endif
diff --git a/thirdparty/faiss/faiss/VectorTransform.cpp b/thirdparty/faiss/knowherefaiss/VectorTransform.cpp
similarity index 99%
rename from thirdparty/faiss/faiss/VectorTransform.cpp
rename to thirdparty/faiss/knowherefaiss/VectorTransform.cpp
index 77712935..e1b5c5b9 100644
--- a/thirdparty/faiss/faiss/VectorTransform.cpp
+++ b/thirdparty/faiss/knowherefaiss/VectorTransform.cpp
@@ -7,7 +7,7 @@
 
 // -*- c++ -*-
 
-#include <faiss/VectorTransform.h>
+#include <knowherefaiss/VectorTransform.h>
 
 #include <cinttypes>
 #include <cmath>
@@ -15,14 +15,14 @@
 #include <cstring>
 #include <memory>
 
-#include <faiss/FaissHook.h>
-#include <faiss/IndexPQ.h>
-#include <faiss/impl/FaissAssert.h>
-#include <faiss/utils/distances.h>
-#include <faiss/utils/random.h>
-#include <faiss/utils/utils.h>
+#include <knowherefaiss/FaissHook.h>
+#include <knowherefaiss/IndexPQ.h>
+#include <knowherefaiss/impl/FaissAssert.h>
+#include <knowherefaiss/utils/distances.h>
+#include <knowherefaiss/utils/random.h>
+#include <knowherefaiss/utils/utils.h>
 
-using namespace faiss;
+using namespace knowherefaiss;
 
 extern "C" {
 
diff --git a/thirdparty/faiss/faiss/VectorTransform.h b/thirdparty/faiss/knowherefaiss/VectorTransform.h
similarity index 99%
rename from thirdparty/faiss/faiss/VectorTransform.h
rename to thirdparty/faiss/knowherefaiss/VectorTransform.h
index 55e46e81..20706c11 100644
--- a/thirdparty/faiss/faiss/VectorTransform.h
+++ b/thirdparty/faiss/knowherefaiss/VectorTransform.h
@@ -17,9 +17,9 @@
 #include <stdint.h>
 #include <vector>
 
-#include <faiss/Index.h>
+#include <knowherefaiss/Index.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 /** Any transformation applied on a set of vectors */
 struct VectorTransform {
@@ -308,6 +308,6 @@ struct CenteringTransform : VectorTransform {
     void check_identical(const VectorTransform& other) const override;
 };
 
-} // namespace faiss
+} // namespace knowherefaiss
 
 #endif
diff --git a/thirdparty/faiss/faiss/clone_index.cpp b/thirdparty/faiss/knowherefaiss/clone_index.cpp
similarity index 89%
rename from thirdparty/faiss/faiss/clone_index.cpp
rename to thirdparty/faiss/knowherefaiss/clone_index.cpp
index db16455f..963985b4 100644
--- a/thirdparty/faiss/faiss/clone_index.cpp
+++ b/thirdparty/faiss/knowherefaiss/clone_index.cpp
@@ -7,49 +7,49 @@
 
 // -*- c++ -*-
 
-#include <faiss/clone_index.h>
+#include <knowherefaiss/clone_index.h>
 
 #include <cstdio>
 #include <cstdlib>
 
-#include <faiss/impl/FaissAssert.h>
-
-#include <faiss/Index2Layer.h>
-#include <faiss/IndexAdditiveQuantizer.h>
-#include <faiss/IndexAdditiveQuantizerFastScan.h>
-#include <faiss/IndexBinary.h>
-#include <faiss/IndexBinaryFlat.h>
-#include <faiss/IndexFlat.h>
-#include <faiss/IndexHNSW.h>
-#include <faiss/IndexIVF.h>
-#include <faiss/IndexIVFAdditiveQuantizerFastScan.h>
-#include <faiss/IndexIVFFlat.h>
-#include <faiss/IndexIVFPQ.h>
-#include <faiss/IndexIVFPQFastScan.h>
-#include <faiss/IndexIVFPQR.h>
-#include <faiss/IndexIVFSpectralHash.h>
-#include <faiss/IndexLSH.h>
-#include <faiss/IndexLattice.h>
-#include <faiss/IndexNSG.h>
-#include <faiss/IndexPQ.h>
-#include <faiss/IndexPQFastScan.h>
-#include <faiss/IndexPreTransform.h>
-#include <faiss/IndexRefine.h>
-#include <faiss/IndexRowwiseMinMax.h>
-#include <faiss/IndexScalarQuantizer.h>
-
-#include <faiss/MetaIndexes.h>
-#include <faiss/VectorTransform.h>
-
-#include <faiss/impl/LocalSearchQuantizer.h>
-#include <faiss/impl/ProductQuantizer.h>
-#include <faiss/impl/ResidualQuantizer.h>
-#include <faiss/impl/ScalarQuantizer.h>
-#include <faiss/impl/pq4_fast_scan.h>
-
-#include <faiss/invlists/BlockInvertedLists.h>
-
-namespace faiss {
+#include <knowherefaiss/impl/FaissAssert.h>
+
+#include <knowherefaiss/Index2Layer.h>
+#include <knowherefaiss/IndexAdditiveQuantizer.h>
+#include <knowherefaiss/IndexAdditiveQuantizerFastScan.h>
+#include <knowherefaiss/IndexBinary.h>
+#include <knowherefaiss/IndexBinaryFlat.h>
+#include <knowherefaiss/IndexFlat.h>
+#include <knowherefaiss/IndexHNSW.h>
+#include <knowherefaiss/IndexIVF.h>
+#include <knowherefaiss/IndexIVFAdditiveQuantizerFastScan.h>
+#include <knowherefaiss/IndexIVFFlat.h>
+#include <knowherefaiss/IndexIVFPQ.h>
+#include <knowherefaiss/IndexIVFPQFastScan.h>
+#include <knowherefaiss/IndexIVFPQR.h>
+#include <knowherefaiss/IndexIVFSpectralHash.h>
+#include <knowherefaiss/IndexLSH.h>
+#include <knowherefaiss/IndexLattice.h>
+#include <knowherefaiss/IndexNSG.h>
+#include <knowherefaiss/IndexPQ.h>
+#include <knowherefaiss/IndexPQFastScan.h>
+#include <knowherefaiss/IndexPreTransform.h>
+#include <knowherefaiss/IndexRefine.h>
+#include <knowherefaiss/IndexRowwiseMinMax.h>
+#include <knowherefaiss/IndexScalarQuantizer.h>
+
+#include <knowherefaiss/MetaIndexes.h>
+#include <knowherefaiss/VectorTransform.h>
+
+#include <knowherefaiss/impl/LocalSearchQuantizer.h>
+#include <knowherefaiss/impl/ProductQuantizer.h>
+#include <knowherefaiss/impl/ResidualQuantizer.h>
+#include <knowherefaiss/impl/ScalarQuantizer.h>
+#include <knowherefaiss/impl/pq4_fast_scan.h>
+
+#include <knowherefaiss/invlists/BlockInvertedLists.h>
+
+namespace knowherefaiss {
 
 /*************************************************************
  * cloning functions
@@ -390,4 +390,4 @@ IndexBinary* clone_binary_index(const IndexBinary* index) {
     }
 }
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/clone_index.h b/thirdparty/faiss/knowherefaiss/clone_index.h
similarity index 94%
rename from thirdparty/faiss/faiss/clone_index.h
rename to thirdparty/faiss/knowherefaiss/clone_index.h
index a251b847..11bc4a46 100644
--- a/thirdparty/faiss/faiss/clone_index.h
+++ b/thirdparty/faiss/knowherefaiss/clone_index.h
@@ -11,7 +11,7 @@
 
 #pragma once
 
-namespace faiss {
+namespace knowherefaiss {
 
 // todo aguzhva: get rid of this file by adding Index* Index::clone() function.
 //   same for quantizers.
@@ -44,4 +44,4 @@ Quantizer* clone_Quantizer(const Quantizer* quant);
 
 IndexBinary* clone_binary_index(const IndexBinary* index);
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/cppcontrib/SaDecodeKernels.h b/thirdparty/faiss/knowherefaiss/cppcontrib/SaDecodeKernels.h
similarity index 91%
rename from thirdparty/faiss/faiss/cppcontrib/SaDecodeKernels.h
rename to thirdparty/faiss/knowherefaiss/cppcontrib/SaDecodeKernels.h
index ae333e1f..44ca9ccb 100644
--- a/thirdparty/faiss/faiss/cppcontrib/SaDecodeKernels.h
+++ b/thirdparty/faiss/knowherefaiss/cppcontrib/SaDecodeKernels.h
@@ -7,7 +7,7 @@
 
 #pragma once
 
-// This file contains a custom fast implementation of faiss::Index::sa_decode()
+// This file contains a custom fast implementation of knowherefaiss::Index::sa_decode()
 //   function for the following index families:
 //   * IVF256,PQ[1]x8np
 //   * Residual[1]x8,PQ[2]x8
@@ -97,7 +97,7 @@
 // For example, "PQ8np" for 160-dim data translates into
 //   IndexPQDecoder<160,20>
 //
-// Unlike the general purpose version in faiss::Index::sa_decode(),
+// Unlike the general purpose version in knowherefaiss::Index::sa_decode(),
 //   this version provides the following functions (please note that
 //   pqCoarseCentroids params are not available for IndexPQDecoder,
 //   but the functionality is the same as for Index2LevelDecoder):
@@ -115,7 +115,7 @@
 // * ::accum(), which is used to create a linear combination
 //   of decoded vectors:
 //   {
-//     const faiss::Index* const index;
+//     const knowherefaiss::Index* const index;
 //     const uint8_t* const input;
 //     float weight;
 //
@@ -139,7 +139,7 @@
 //   per call. This provides an additional speedup because of a CPU
 //   superscalar architecture:
 //   {
-//     const faiss::Index* const index;
+//     const knowherefaiss::Index* const index;
 //     const uint8_t* const input0;
 //     float weight0;
 //     const uint8_t* const input1;
@@ -186,7 +186,7 @@
 // * And one more overload for ::accum() that decodes and accumulates
 //   three vectors per call.
 //   {
-//     const faiss::Index* const index;
+//     const knowherefaiss::Index* const index;
 //     const uint8_t* const input0;
 //     float weight0;
 //     const uint8_t* const input1;
@@ -265,8 +265,8 @@
 // In this case, please use the following contruction for the decoding,
 // basically, wrapping a kernel in a kernel:
 //   {
-//      using SubT = faiss::cppcontrib::Index2LevelDecoder<128, 128, 2>;
-//      using T = faiss::cppcontrib::IndexMinMaxFP16Decoder<SubT>;
+//      using SubT = knowherefaiss::cppcontrib::Index2LevelDecoder<128, 128, 2>;
+//      using T = knowherefaiss::cppcontrib::IndexMinMaxFP16Decoder<SubT>;
 //      // do T::store(...) or T::accum(...)
 //   }
 //
@@ -294,7 +294,7 @@
 //   }
 // This is similar to the following regular pseudo-code:
 //   {
-//     const faiss::Index* const index;
+//     const knowherefaiss::Index* const index;
 //     const uint8_t* const __restrict input;
 //     const float* const __restrict weights;
 //     float* const __restrict output;
@@ -307,16 +307,16 @@
 //         output[j] += weights[i] * buffer[j];
 //     }
 
-#include <faiss/cppcontrib/sa_decode/MinMax-inl.h>
-#include <faiss/cppcontrib/sa_decode/MinMaxFP16-inl.h>
+#include <knowherefaiss/cppcontrib/sa_decode/MinMax-inl.h>
+#include <knowherefaiss/cppcontrib/sa_decode/MinMaxFP16-inl.h>
 
 #ifdef __AVX2__
-#include <faiss/cppcontrib/sa_decode/Level2-avx2-inl.h>
-#include <faiss/cppcontrib/sa_decode/PQ-avx2-inl.h>
+#include <knowherefaiss/cppcontrib/sa_decode/Level2-avx2-inl.h>
+#include <knowherefaiss/cppcontrib/sa_decode/PQ-avx2-inl.h>
 #elif defined(__ARM_NEON)
-#include <faiss/cppcontrib/sa_decode/Level2-neon-inl.h>
-#include <faiss/cppcontrib/sa_decode/PQ-neon-inl.h>
+#include <knowherefaiss/cppcontrib/sa_decode/Level2-neon-inl.h>
+#include <knowherefaiss/cppcontrib/sa_decode/PQ-neon-inl.h>
 #else
-#include <faiss/cppcontrib/sa_decode/Level2-inl.h>
-#include <faiss/cppcontrib/sa_decode/PQ-inl.h>
+#include <knowherefaiss/cppcontrib/sa_decode/Level2-inl.h>
+#include <knowherefaiss/cppcontrib/sa_decode/PQ-inl.h>
 #endif
diff --git a/thirdparty/faiss/faiss/cppcontrib/detail/CoarseBitType.h b/thirdparty/faiss/knowherefaiss/cppcontrib/detail/CoarseBitType.h
similarity index 90%
rename from thirdparty/faiss/faiss/cppcontrib/detail/CoarseBitType.h
rename to thirdparty/faiss/knowherefaiss/cppcontrib/detail/CoarseBitType.h
index 7b438fed..c0314440 100644
--- a/thirdparty/faiss/faiss/cppcontrib/detail/CoarseBitType.h
+++ b/thirdparty/faiss/knowherefaiss/cppcontrib/detail/CoarseBitType.h
@@ -9,7 +9,7 @@
 
 #include <cstdint>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace cppcontrib {
 namespace detail {
 
@@ -28,4 +28,4 @@ struct CoarseBitType<16> {
 
 } // namespace detail
 } // namespace cppcontrib
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/cppcontrib/detail/UintReader.h b/thirdparty/faiss/knowherefaiss/cppcontrib/detail/UintReader.h
similarity index 99%
rename from thirdparty/faiss/faiss/cppcontrib/detail/UintReader.h
rename to thirdparty/faiss/knowherefaiss/cppcontrib/detail/UintReader.h
index 4a64a1a2..c10fb103 100644
--- a/thirdparty/faiss/faiss/cppcontrib/detail/UintReader.h
+++ b/thirdparty/faiss/knowherefaiss/cppcontrib/detail/UintReader.h
@@ -7,10 +7,10 @@
 
 #pragma once
 
-#include <faiss/impl/platform_macros.h>
+#include <knowherefaiss/impl/platform_macros.h>
 #include <cstdint>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace cppcontrib {
 namespace detail {
 
@@ -348,4 +348,4 @@ using UintReaderRaw =
 
 } // namespace detail
 } // namespace cppcontrib
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/cppcontrib/knowhere/IndexBruteForceWrapper.cpp b/thirdparty/faiss/knowherefaiss/cppcontrib/knowhere/IndexBruteForceWrapper.cpp
similarity index 93%
rename from thirdparty/faiss/faiss/cppcontrib/knowhere/IndexBruteForceWrapper.cpp
rename to thirdparty/faiss/knowherefaiss/cppcontrib/knowhere/IndexBruteForceWrapper.cpp
index 30c85a2e..f0921581 100644
--- a/thirdparty/faiss/faiss/cppcontrib/knowhere/IndexBruteForceWrapper.cpp
+++ b/thirdparty/faiss/knowherefaiss/cppcontrib/knowhere/IndexBruteForceWrapper.cpp
@@ -9,22 +9,22 @@
 // is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 // or implied. See the License for the specific language governing permissions and limitations under the License.
 
-#include <faiss/cppcontrib/knowhere/IndexBruteForceWrapper.h>
+#include <knowherefaiss/cppcontrib/knowhere/IndexBruteForceWrapper.h>
 
 #include <algorithm>
 #include <memory>
 
-#include <faiss/Index.h>
-#include <faiss/MetricType.h>
-#include <faiss/impl/AuxIndexStructures.h>
-#include <faiss/impl/DistanceComputer.h>
-#include <faiss/impl/FaissAssert.h>
-#include <faiss/impl/IDSelector.h>
-#include <faiss/impl/ResultHandler.h>
+#include <knowherefaiss/Index.h>
+#include <knowherefaiss/MetricType.h>
+#include <knowherefaiss/impl/AuxIndexStructures.h>
+#include <knowherefaiss/impl/DistanceComputer.h>
+#include <knowherefaiss/impl/FaissAssert.h>
+#include <knowherefaiss/impl/IDSelector.h>
+#include <knowherefaiss/impl/ResultHandler.h>
 
-#include <faiss/cppcontrib/knowhere/impl/Bruteforce.h>
+#include <knowherefaiss/cppcontrib/knowhere/impl/Bruteforce.h>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace cppcontrib {
 namespace knowhere {
 
diff --git a/thirdparty/faiss/faiss/cppcontrib/knowhere/IndexBruteForceWrapper.h b/thirdparty/faiss/knowherefaiss/cppcontrib/knowhere/IndexBruteForceWrapper.h
similarity index 91%
rename from thirdparty/faiss/faiss/cppcontrib/knowhere/IndexBruteForceWrapper.h
rename to thirdparty/faiss/knowherefaiss/cppcontrib/knowhere/IndexBruteForceWrapper.h
index d5974df6..cb17b9f2 100644
--- a/thirdparty/faiss/faiss/cppcontrib/knowhere/IndexBruteForceWrapper.h
+++ b/thirdparty/faiss/knowherefaiss/cppcontrib/knowhere/IndexBruteForceWrapper.h
@@ -11,11 +11,11 @@
 
 #pragma once
 
-#include <faiss/Index.h>
+#include <knowherefaiss/Index.h>
 
-#include <faiss/cppcontrib/knowhere/IndexWrapper.h>
+#include <knowherefaiss/cppcontrib/knowhere/IndexWrapper.h>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace cppcontrib {
 namespace knowhere {
 
diff --git a/thirdparty/faiss/faiss/cppcontrib/knowhere/IndexHNSWWrapper.cpp b/thirdparty/faiss/knowherefaiss/cppcontrib/knowhere/IndexHNSWWrapper.cpp
similarity index 95%
rename from thirdparty/faiss/faiss/cppcontrib/knowhere/IndexHNSWWrapper.cpp
rename to thirdparty/faiss/knowherefaiss/cppcontrib/knowhere/IndexHNSWWrapper.cpp
index f797e14e..5014a56b 100644
--- a/thirdparty/faiss/faiss/cppcontrib/knowhere/IndexHNSWWrapper.cpp
+++ b/thirdparty/faiss/knowherefaiss/cppcontrib/knowhere/IndexHNSWWrapper.cpp
@@ -9,22 +9,22 @@
 // is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 // or implied. See the License for the specific language governing permissions and limitations under the License.
 
-#include <faiss/cppcontrib/knowhere/IndexHNSWWrapper.h>
+#include <knowherefaiss/cppcontrib/knowhere/IndexHNSWWrapper.h>
 
 #include <algorithm>
 #include <memory>
 
-#include <faiss/IndexHNSW.h>
-#include <faiss/MetricType.h>
-#include <faiss/impl/AuxIndexStructures.h>
-#include <faiss/impl/DistanceComputer.h>
-#include <faiss/impl/FaissAssert.h>
-#include <faiss/impl/HNSW.h>
+#include <knowherefaiss/IndexHNSW.h>
+#include <knowherefaiss/MetricType.h>
+#include <knowherefaiss/impl/AuxIndexStructures.h>
+#include <knowherefaiss/impl/DistanceComputer.h>
+#include <knowherefaiss/impl/FaissAssert.h>
+#include <knowherefaiss/impl/HNSW.h>
 
-#include <faiss/cppcontrib/knowhere/impl/HnswSearcher.h>
-#include <faiss/cppcontrib/knowhere/utils/Bitset.h>
+#include <knowherefaiss/cppcontrib/knowhere/impl/HnswSearcher.h>
+#include <knowherefaiss/cppcontrib/knowhere/utils/Bitset.h>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace cppcontrib {
 namespace knowhere {
 
diff --git a/thirdparty/faiss/faiss/cppcontrib/knowhere/IndexHNSWWrapper.h b/thirdparty/faiss/knowherefaiss/cppcontrib/knowhere/IndexHNSWWrapper.h
similarity index 93%
rename from thirdparty/faiss/faiss/cppcontrib/knowhere/IndexHNSWWrapper.h
rename to thirdparty/faiss/knowherefaiss/cppcontrib/knowhere/IndexHNSWWrapper.h
index 792668a4..60de550b 100644
--- a/thirdparty/faiss/faiss/cppcontrib/knowhere/IndexHNSWWrapper.h
+++ b/thirdparty/faiss/knowherefaiss/cppcontrib/knowhere/IndexHNSWWrapper.h
@@ -14,11 +14,11 @@
 #include <cstddef>
 #include <cstdint>
 
-#include <faiss/IndexHNSW.h>
+#include <knowherefaiss/IndexHNSW.h>
 
-#include <faiss/cppcontrib/knowhere/IndexWrapper.h>
+#include <knowherefaiss/cppcontrib/knowhere/IndexWrapper.h>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace cppcontrib {
 namespace knowhere {
 
diff --git a/thirdparty/faiss/faiss/cppcontrib/knowhere/IndexWrapper.cpp b/thirdparty/faiss/knowherefaiss/cppcontrib/knowhere/IndexWrapper.cpp
similarity index 95%
rename from thirdparty/faiss/faiss/cppcontrib/knowhere/IndexWrapper.cpp
rename to thirdparty/faiss/knowherefaiss/cppcontrib/knowhere/IndexWrapper.cpp
index aaeab714..3c189cc9 100644
--- a/thirdparty/faiss/faiss/cppcontrib/knowhere/IndexWrapper.cpp
+++ b/thirdparty/faiss/knowherefaiss/cppcontrib/knowhere/IndexWrapper.cpp
@@ -9,9 +9,9 @@
 // is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
 // or implied. See the License for the specific language governing permissions and limitations under the License.
 
-#include <faiss/cppcontrib/knowhere/IndexWrapper.h>
+#include <knowherefaiss/cppcontrib/knowhere/IndexWrapper.h>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace cppcontrib {
 namespace knowhere {
 
diff --git a/thirdparty/faiss/faiss/cppcontrib/knowhere/IndexWrapper.h b/thirdparty/faiss/knowherefaiss/cppcontrib/knowhere/IndexWrapper.h
similarity index 96%
rename from thirdparty/faiss/faiss/cppcontrib/knowhere/IndexWrapper.h
rename to thirdparty/faiss/knowherefaiss/cppcontrib/knowhere/IndexWrapper.h
index 78379260..f41d1be7 100644
--- a/thirdparty/faiss/faiss/cppcontrib/knowhere/IndexWrapper.h
+++ b/thirdparty/faiss/knowherefaiss/cppcontrib/knowhere/IndexWrapper.h
@@ -11,9 +11,9 @@
 
 #pragma once
 
-#include <faiss/Index.h>
+#include <knowherefaiss/Index.h>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace cppcontrib {
 namespace knowhere {
 
diff --git a/thirdparty/faiss/faiss/cppcontrib/knowhere/impl/Bruteforce.h b/thirdparty/faiss/knowherefaiss/cppcontrib/knowhere/impl/Bruteforce.h
similarity index 94%
rename from thirdparty/faiss/faiss/cppcontrib/knowhere/impl/Bruteforce.h
rename to thirdparty/faiss/knowherefaiss/cppcontrib/knowhere/impl/Bruteforce.h
index 4e5de731..d28052e6 100644
--- a/thirdparty/faiss/faiss/cppcontrib/knowhere/impl/Bruteforce.h
+++ b/thirdparty/faiss/knowherefaiss/cppcontrib/knowhere/impl/Bruteforce.h
@@ -17,11 +17,11 @@
 #include <type_traits>
 #include <utility>
 
-#include <faiss/MetricType.h>
-#include <faiss/impl/AuxIndexStructures.h>
-#include <faiss/utils/Heap.h>
+#include <knowherefaiss/MetricType.h>
+#include <knowherefaiss/impl/AuxIndexStructures.h>
+#include <knowherefaiss/utils/Heap.h>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace cppcontrib {
 namespace knowhere {
 
diff --git a/thirdparty/faiss/faiss/cppcontrib/knowhere/impl/CountSizeIOWriter.h b/thirdparty/faiss/knowherefaiss/cppcontrib/knowhere/impl/CountSizeIOWriter.h
similarity index 94%
rename from thirdparty/faiss/faiss/cppcontrib/knowhere/impl/CountSizeIOWriter.h
rename to thirdparty/faiss/knowherefaiss/cppcontrib/knowhere/impl/CountSizeIOWriter.h
index 7384cbeb..b794d955 100644
--- a/thirdparty/faiss/faiss/cppcontrib/knowhere/impl/CountSizeIOWriter.h
+++ b/thirdparty/faiss/knowherefaiss/cppcontrib/knowhere/impl/CountSizeIOWriter.h
@@ -11,9 +11,9 @@
 
 #pragma once
 
-#include <faiss/impl/io.h>
+#include <knowherefaiss/impl/io.h>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace cppcontrib {
 namespace knowhere {
 
diff --git a/thirdparty/faiss/faiss/cppcontrib/knowhere/impl/HnswSearcher.h b/thirdparty/faiss/knowherefaiss/cppcontrib/knowhere/impl/HnswSearcher.h
similarity index 90%
rename from thirdparty/faiss/faiss/cppcontrib/knowhere/impl/HnswSearcher.h
rename to thirdparty/faiss/knowherefaiss/cppcontrib/knowhere/impl/HnswSearcher.h
index a5192609..896c7815 100644
--- a/thirdparty/faiss/faiss/cppcontrib/knowhere/impl/HnswSearcher.h
+++ b/thirdparty/faiss/knowherefaiss/cppcontrib/knowhere/impl/HnswSearcher.h
@@ -23,19 +23,19 @@
 #include <queue>
 
 // Faiss-specific headers
-#include <faiss/Index.h>
-#include <faiss/IndexHNSW.h>
-#include <faiss/impl/AuxIndexStructures.h>
-#include <faiss/impl/DistanceComputer.h>
-#include <faiss/impl/FaissException.h>
-#include <faiss/impl/HNSW.h>
-#include <faiss/impl/ResultHandler.h>
-#include <faiss/utils/ordered_key_value.h>
+#include <knowherefaiss/Index.h>
+#include <knowherefaiss/IndexHNSW.h>
+#include <knowherefaiss/impl/AuxIndexStructures.h>
+#include <knowherefaiss/impl/DistanceComputer.h>
+#include <knowherefaiss/impl/FaissException.h>
+#include <knowherefaiss/impl/HNSW.h>
+#include <knowherefaiss/impl/ResultHandler.h>
+#include <knowherefaiss/utils/ordered_key_value.h>
 
 // Knowhere-specific headers
-#include <faiss/cppcontrib/knowhere/impl/Neighbor.h>
+#include <knowherefaiss/cppcontrib/knowhere/impl/Neighbor.h>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace cppcontrib {
 namespace knowhere {
 
@@ -59,12 +59,12 @@ template <
         typename VisitedT,
         typename FilterT>
 struct v2_hnsw_searcher {
-    using storage_idx_t = faiss::HNSW::storage_idx_t;
-    using idx_t = faiss::idx_t;
+    using storage_idx_t = knowherefaiss::HNSW::storage_idx_t;
+    using idx_t = knowherefaiss::idx_t;
 
     // hnsw structure.
     // the reference is not owned.
-    const faiss::HNSW& hnsw;
+    const knowherefaiss::HNSW& hnsw;
 
     // computes distances. it already knows the query vector.
     // the reference is not owned.
@@ -87,17 +87,17 @@ struct v2_hnsw_searcher {
 
     // custom parameters of HNSW search.
     // the pointer is not owned.
-    const faiss::SearchParametersHNSW* params;
+    const knowherefaiss::SearchParametersHNSW* params;
 
     //
     v2_hnsw_searcher(
-            const faiss::HNSW& hnsw_,
+            const knowherefaiss::HNSW& hnsw_,
             DistanceComputerT& qdis_,
             GraphVisitorT& graph_visitor_,
             VisitedT& visited_nodes_,
             const FilterT& filter_,
             const float kAlpha_,
-            const faiss::SearchParametersHNSW* params_)
+            const knowherefaiss::SearchParametersHNSW* params_)
             : hnsw{hnsw_},
               qdis{qdis_},
               graph_visitor{graph_visitor_},
@@ -113,11 +113,11 @@ struct v2_hnsw_searcher {
 
     // greedily update a nearest vector at a given level.
     // * the update starts from the value in 'nearest'.
-    faiss::HNSWStats greedy_update_nearest(
+    knowherefaiss::HNSWStats greedy_update_nearest(
             const int level,
             storage_idx_t& nearest,
             float& d_nearest) {
-        faiss::HNSWStats stats;
+        knowherefaiss::HNSWStats stats;
 
         for (;;) {
             storage_idx_t prev_nearest = nearest;
@@ -170,7 +170,7 @@ struct v2_hnsw_searcher {
 
     // no loops, just check neighbors of a single node.
     template <typename FuncAddCandidate>
-    faiss::HNSWStats evaluate_single_node(
+    knowherefaiss::HNSWStats evaluate_single_node(
             const idx_t node_id,
             const int level,
             float& accumulated_alpha,
@@ -179,7 +179,7 @@ struct v2_hnsw_searcher {
         // bool do_dis_check = params ? params->check_relative_distance
         //                            : hnsw.check_relative_distance;
 
-        faiss::HNSWStats stats;
+        knowherefaiss::HNSWStats stats;
 
         size_t begin = 0;
         size_t end = 0;
@@ -293,12 +293,12 @@ struct v2_hnsw_searcher {
 
     // perform the search on a given level.
     // it is assumed that retset is initialized and contains the initial nodes.
-    faiss::HNSWStats search_on_a_level(
+    knowherefaiss::HNSWStats search_on_a_level(
             knowhere::NeighborSetDoublePopList& retset,
             const int level,
             knowhere::IteratorMinHeap* const __restrict disqualified = nullptr,
             const float initial_accumulated_alpha = 1.0f) {
-        faiss::HNSWStats stats;
+        knowherefaiss::HNSWStats stats;
 
         //
         float accumulated_alpha = initial_accumulated_alpha;
@@ -314,7 +314,7 @@ struct v2_hnsw_searcher {
             const knowhere::Neighbor neighbor = retset.pop();
 
             // analyze its neighbors
-            faiss::HNSWStats local_stats = evaluate_single_node(
+            knowherefaiss::HNSWStats local_stats = evaluate_single_node(
                     neighbor.id,
                     level,
                     accumulated_alpha,
@@ -331,10 +331,10 @@ struct v2_hnsw_searcher {
     }
 
     // traverse down to the level 0
-    faiss::HNSWStats greedy_search_top_levels(
+    knowherefaiss::HNSWStats greedy_search_top_levels(
             storage_idx_t& nearest,
             float& d_nearest) {
-        faiss::HNSWStats stats;
+        knowherefaiss::HNSWStats stats;
 
         // iterate through upper levels
         for (int level = hnsw.max_level; level >= 1; level--) {
@@ -342,7 +342,7 @@ struct v2_hnsw_searcher {
             graph_visitor.visit_level(level);
 
             // alter the value of 'nearest'
-            faiss::HNSWStats local_stats =
+            knowherefaiss::HNSWStats local_stats =
                     greedy_update_nearest(level, nearest, d_nearest);
 
             // update stats
@@ -355,11 +355,11 @@ struct v2_hnsw_searcher {
     }
 
     // perform the search.
-    faiss::HNSWStats search(
+    knowherefaiss::HNSWStats search(
             const idx_t k,
             float* __restrict distances,
             idx_t* __restrict labels) {
-        faiss::HNSWStats stats;
+        knowherefaiss::HNSWStats stats;
 
         // is the graph empty?
         if (hnsw.entry_point == -1) {
@@ -413,7 +413,7 @@ struct v2_hnsw_searcher {
         }
 
         // perform the search of the level 0.
-        faiss::HNSWStats local_stats = search_on_a_level(retset, 0);
+        knowherefaiss::HNSWStats local_stats = search_on_a_level(retset, 0);
 
         // todo: switch to brute-force in case of (retset.size() < k)
 
@@ -438,12 +438,12 @@ struct v2_hnsw_searcher {
         return stats;
     }
 
-    faiss::HNSWStats range_search(
+    knowherefaiss::HNSWStats range_search(
             const float radius,
-            typename faiss::RangeSearchBlockResultHandler<
-                    faiss::CMax<float, int64_t>>::
+            typename knowherefaiss::RangeSearchBlockResultHandler<
+                    knowherefaiss::CMax<float, int64_t>>::
                     SingleResultHandler* const __restrict rres) {
-        faiss::HNSWStats stats;
+        knowherefaiss::HNSWStats stats;
 
         // is the graph empty?
         if (hnsw.entry_point == -1) {
@@ -497,7 +497,7 @@ struct v2_hnsw_searcher {
         }
 
         // perform the search of the level 0.
-        faiss::HNSWStats local_stats = search_on_a_level(retset, 0);
+        knowherefaiss::HNSWStats local_stats = search_on_a_level(retset, 0);
 
         // update stats
         if (track_hnsw_stats) {
@@ -505,7 +505,7 @@ struct v2_hnsw_searcher {
         }
 
         // select candidates that match our criteria
-        faiss::HNSWStats pick_stats;
+        knowherefaiss::HNSWStats pick_stats;
 
         visited_nodes.clear();
 
@@ -565,4 +565,4 @@ struct v2_hnsw_searcher {
 
 } // namespace knowhere
 } // namespace cppcontrib
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/cppcontrib/knowhere/impl/Neighbor.h b/thirdparty/faiss/knowherefaiss/cppcontrib/knowhere/impl/Neighbor.h
similarity index 99%
rename from thirdparty/faiss/faiss/cppcontrib/knowhere/impl/Neighbor.h
rename to thirdparty/faiss/knowherefaiss/cppcontrib/knowhere/impl/Neighbor.h
index b2ec3cae..6e624c06 100644
--- a/thirdparty/faiss/faiss/cppcontrib/knowhere/impl/Neighbor.h
+++ b/thirdparty/faiss/knowherefaiss/cppcontrib/knowhere/impl/Neighbor.h
@@ -19,7 +19,7 @@
 #include <memory>
 #include <queue>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace cppcontrib {
 namespace knowhere {
 
diff --git a/thirdparty/faiss/faiss/cppcontrib/knowhere/utils/Bitset.h b/thirdparty/faiss/knowherefaiss/cppcontrib/knowhere/utils/Bitset.h
similarity index 99%
rename from thirdparty/faiss/faiss/cppcontrib/knowhere/utils/Bitset.h
rename to thirdparty/faiss/knowherefaiss/cppcontrib/knowhere/utils/Bitset.h
index c739dbf8..b0ac766b 100644
--- a/thirdparty/faiss/faiss/cppcontrib/knowhere/utils/Bitset.h
+++ b/thirdparty/faiss/knowherefaiss/cppcontrib/knowhere/utils/Bitset.h
@@ -16,7 +16,7 @@
 #include <cstring>
 #include <memory>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace cppcontrib {
 namespace knowhere {
 
diff --git a/thirdparty/faiss/faiss/cppcontrib/sa_decode/Level2-avx2-inl.h b/thirdparty/faiss/knowherefaiss/cppcontrib/sa_decode/Level2-avx2-inl.h
similarity index 99%
rename from thirdparty/faiss/faiss/cppcontrib/sa_decode/Level2-avx2-inl.h
rename to thirdparty/faiss/knowherefaiss/cppcontrib/sa_decode/Level2-avx2-inl.h
index 75ca7b8e..0da45d7a 100644
--- a/thirdparty/faiss/faiss/cppcontrib/sa_decode/Level2-avx2-inl.h
+++ b/thirdparty/faiss/knowherefaiss/cppcontrib/sa_decode/Level2-avx2-inl.h
@@ -13,9 +13,9 @@
 #include <cstddef>
 #include <cstdint>
 
-#include <faiss/cppcontrib/detail/UintReader.h>
+#include <knowherefaiss/cppcontrib/detail/UintReader.h>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace cppcontrib {
 
 ////////////////////////////////////////////////////////////////////////////////////
@@ -2068,5 +2068,5 @@ struct Index2LevelDecoder {
 };
 
 } // namespace cppcontrib
-} // namespace faiss
+} // namespace knowherefaiss
 #endif // LEVEL2_AVX2_INL_H
diff --git a/thirdparty/faiss/faiss/cppcontrib/sa_decode/Level2-inl.h b/thirdparty/faiss/knowherefaiss/cppcontrib/sa_decode/Level2-inl.h
similarity index 99%
rename from thirdparty/faiss/faiss/cppcontrib/sa_decode/Level2-inl.h
rename to thirdparty/faiss/knowherefaiss/cppcontrib/sa_decode/Level2-inl.h
index 1eb7767b..5553e54c 100644
--- a/thirdparty/faiss/faiss/cppcontrib/sa_decode/Level2-inl.h
+++ b/thirdparty/faiss/knowherefaiss/cppcontrib/sa_decode/Level2-inl.h
@@ -11,10 +11,10 @@
 #include <cstddef>
 #include <cstdint>
 
-#include <faiss/cppcontrib/detail/CoarseBitType.h>
-#include <faiss/impl/platform_macros.h>
+#include <knowherefaiss/cppcontrib/detail/CoarseBitType.h>
+#include <knowherefaiss/impl/platform_macros.h>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace cppcontrib {
 
 bool isBigEndian() {
@@ -463,5 +463,5 @@ struct Index2LevelDecoder {
 };
 
 } // namespace cppcontrib
-} // namespace faiss
+} // namespace knowherefaiss
 #endif // LEVEL2_INL_H
diff --git a/thirdparty/faiss/faiss/cppcontrib/sa_decode/Level2-neon-inl.h b/thirdparty/faiss/knowherefaiss/cppcontrib/sa_decode/Level2-neon-inl.h
similarity index 99%
rename from thirdparty/faiss/faiss/cppcontrib/sa_decode/Level2-neon-inl.h
rename to thirdparty/faiss/knowherefaiss/cppcontrib/sa_decode/Level2-neon-inl.h
index 20e815a0..7f80ce67 100644
--- a/thirdparty/faiss/faiss/cppcontrib/sa_decode/Level2-neon-inl.h
+++ b/thirdparty/faiss/knowherefaiss/cppcontrib/sa_decode/Level2-neon-inl.h
@@ -13,9 +13,9 @@
 #include <cstddef>
 #include <cstdint>
 
-#include <faiss/cppcontrib/detail/UintReader.h>
+#include <knowherefaiss/cppcontrib/detail/UintReader.h>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace cppcontrib {
 
 namespace {
@@ -2157,5 +2157,5 @@ struct Index2LevelDecoder {
 };
 
 } // namespace cppcontrib
-} // namespace faiss
+} // namespace knowherefaiss
 #endif // LEVEL2_NEON_INL_H
diff --git a/thirdparty/faiss/faiss/cppcontrib/sa_decode/MinMax-inl.h b/thirdparty/faiss/knowherefaiss/cppcontrib/sa_decode/MinMax-inl.h
similarity index 99%
rename from thirdparty/faiss/faiss/cppcontrib/sa_decode/MinMax-inl.h
rename to thirdparty/faiss/knowherefaiss/cppcontrib/sa_decode/MinMax-inl.h
index a310bebf..f2c4d4d8 100644
--- a/thirdparty/faiss/faiss/cppcontrib/sa_decode/MinMax-inl.h
+++ b/thirdparty/faiss/knowherefaiss/cppcontrib/sa_decode/MinMax-inl.h
@@ -10,7 +10,7 @@
 #include <cstddef>
 #include <cstdint>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace cppcontrib {
 
 template <typename SubIndexT>
@@ -464,4 +464,4 @@ struct IndexMinMaxDecoder {
 };
 
 } // namespace cppcontrib
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/cppcontrib/sa_decode/MinMaxFP16-inl.h b/thirdparty/faiss/knowherefaiss/cppcontrib/sa_decode/MinMaxFP16-inl.h
similarity index 79%
rename from thirdparty/faiss/faiss/cppcontrib/sa_decode/MinMaxFP16-inl.h
rename to thirdparty/faiss/knowherefaiss/cppcontrib/sa_decode/MinMaxFP16-inl.h
index b7375fb9..e4a30980 100644
--- a/thirdparty/faiss/faiss/cppcontrib/sa_decode/MinMaxFP16-inl.h
+++ b/thirdparty/faiss/knowherefaiss/cppcontrib/sa_decode/MinMaxFP16-inl.h
@@ -10,9 +10,9 @@
 #include <cstddef>
 #include <cstdint>
 
-#include <faiss/utils/fp16.h>
+#include <knowherefaiss/utils/fp16.h>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace cppcontrib {
 
 template <typename SubIndexT>
@@ -28,8 +28,8 @@ struct IndexMinMaxFP16Decoder {
             float* const __restrict outputStore) {
         const uint16_t* const __restrict codeFP16 =
                 reinterpret_cast<const uint16_t*>(code);
-        const float scaler = faiss::decode_fp16(codeFP16[0]);
-        const float minv = faiss::decode_fp16(codeFP16[1]);
+        const float scaler = knowherefaiss::decode_fp16(codeFP16[0]);
+        const float minv = knowherefaiss::decode_fp16(codeFP16[1]);
 
         SubIndexT::store(
                 pqCoarseCentroids,
@@ -49,8 +49,8 @@ struct IndexMinMaxFP16Decoder {
             float* const __restrict outputStore) {
         const uint16_t* const __restrict codeFP16 =
                 reinterpret_cast<const uint16_t*>(code);
-        const float scaler = faiss::decode_fp16(codeFP16[0]);
-        const float minv = faiss::decode_fp16(codeFP16[1]);
+        const float scaler = knowherefaiss::decode_fp16(codeFP16[0]);
+        const float minv = knowherefaiss::decode_fp16(codeFP16[1]);
 
         SubIndexT::store(
                 pqFineCentroids, code + 2 * sizeof(uint16_t), outputStore);
@@ -72,8 +72,8 @@ struct IndexMinMaxFP16Decoder {
             float& minvAccum) {
         const uint16_t* const __restrict codeFP16 =
                 reinterpret_cast<const uint16_t*>(code);
-        const float scaler = faiss::decode_fp16(codeFP16[0]) * weight;
-        const float minv = faiss::decode_fp16(codeFP16[1]) * weight;
+        const float scaler = knowherefaiss::decode_fp16(codeFP16[0]) * weight;
+        const float minv = knowherefaiss::decode_fp16(codeFP16[1]) * weight;
 
         SubIndexT::accum(
                 pqCoarseCentroids,
@@ -97,8 +97,8 @@ struct IndexMinMaxFP16Decoder {
             float& minvAccum) {
         const uint16_t* const __restrict codeFP16 =
                 reinterpret_cast<const uint16_t*>(code);
-        const float scaler = faiss::decode_fp16(codeFP16[0]) * weight;
-        const float minv = faiss::decode_fp16(codeFP16[1]) * weight;
+        const float scaler = knowherefaiss::decode_fp16(codeFP16[0]) * weight;
+        const float minv = knowherefaiss::decode_fp16(codeFP16[1]) * weight;
 
         SubIndexT::accum(
                 pqFineCentroids,
@@ -130,13 +130,13 @@ struct IndexMinMaxFP16Decoder {
             float& minvAccum) {
         const uint16_t* const __restrict code0FP16 =
                 reinterpret_cast<const uint16_t*>(code0);
-        const float scaler0 = faiss::decode_fp16(code0FP16[0]) * weight0;
-        const float minv0 = faiss::decode_fp16(code0FP16[1]) * weight0;
+        const float scaler0 = knowherefaiss::decode_fp16(code0FP16[0]) * weight0;
+        const float minv0 = knowherefaiss::decode_fp16(code0FP16[1]) * weight0;
 
         const uint16_t* const __restrict code1FP16 =
                 reinterpret_cast<const uint16_t*>(code1);
-        const float scaler1 = faiss::decode_fp16(code1FP16[0]) * weight1;
-        const float minv1 = faiss::decode_fp16(code1FP16[1]) * weight1;
+        const float scaler1 = knowherefaiss::decode_fp16(code1FP16[0]) * weight1;
+        const float minv1 = knowherefaiss::decode_fp16(code1FP16[1]) * weight1;
 
         SubIndexT::accum(
                 pqCoarseCentroids0,
@@ -171,13 +171,13 @@ struct IndexMinMaxFP16Decoder {
             float& minvAccum) {
         const uint16_t* const __restrict code0FP16 =
                 reinterpret_cast<const uint16_t*>(code0);
-        const float scaler0 = faiss::decode_fp16(code0FP16[0]) * weight0;
-        const float minv0 = faiss::decode_fp16(code0FP16[1]) * weight0;
+        const float scaler0 = knowherefaiss::decode_fp16(code0FP16[0]) * weight0;
+        const float minv0 = knowherefaiss::decode_fp16(code0FP16[1]) * weight0;
 
         const uint16_t* const __restrict code1FP16 =
                 reinterpret_cast<const uint16_t*>(code1);
-        const float scaler1 = faiss::decode_fp16(code1FP16[0]) * weight1;
-        const float minv1 = faiss::decode_fp16(code1FP16[1]) * weight1;
+        const float scaler1 = knowherefaiss::decode_fp16(code1FP16[0]) * weight1;
+        const float minv1 = knowherefaiss::decode_fp16(code1FP16[1]) * weight1;
 
         SubIndexT::accum(
                 pqCoarseCentroids,
@@ -209,13 +209,13 @@ struct IndexMinMaxFP16Decoder {
             float& minvAccum) {
         const uint16_t* const __restrict code0FP16 =
                 reinterpret_cast<const uint16_t*>(code0);
-        const float scaler0 = faiss::decode_fp16(code0FP16[0]) * weight0;
-        const float minv0 = faiss::decode_fp16(code0FP16[1]) * weight0;
+        const float scaler0 = knowherefaiss::decode_fp16(code0FP16[0]) * weight0;
+        const float minv0 = knowherefaiss::decode_fp16(code0FP16[1]) * weight0;
 
         const uint16_t* const __restrict code1FP16 =
                 reinterpret_cast<const uint16_t*>(code1);
-        const float scaler1 = faiss::decode_fp16(code1FP16[0]) * weight1;
-        const float minv1 = faiss::decode_fp16(code1FP16[1]) * weight1;
+        const float scaler1 = knowherefaiss::decode_fp16(code1FP16[0]) * weight1;
+        const float minv1 = knowherefaiss::decode_fp16(code1FP16[1]) * weight1;
 
         SubIndexT::accum(
                 pqFineCentroids0,
@@ -246,13 +246,13 @@ struct IndexMinMaxFP16Decoder {
             float& minvAccum) {
         const uint16_t* const __restrict code0FP16 =
                 reinterpret_cast<const uint16_t*>(code0);
-        const float scaler0 = faiss::decode_fp16(code0FP16[0]) * weight0;
-        const float minv0 = faiss::decode_fp16(code0FP16[1]) * weight0;
+        const float scaler0 = knowherefaiss::decode_fp16(code0FP16[0]) * weight0;
+        const float minv0 = knowherefaiss::decode_fp16(code0FP16[1]) * weight0;
 
         const uint16_t* const __restrict code1FP16 =
                 reinterpret_cast<const uint16_t*>(code1);
-        const float scaler1 = faiss::decode_fp16(code1FP16[0]) * weight1;
-        const float minv1 = faiss::decode_fp16(code1FP16[1]) * weight1;
+        const float scaler1 = knowherefaiss::decode_fp16(code1FP16[0]) * weight1;
+        const float minv1 = knowherefaiss::decode_fp16(code1FP16[1]) * weight1;
 
         SubIndexT::accum(
                 pqFineCentroids,
@@ -291,18 +291,18 @@ struct IndexMinMaxFP16Decoder {
             float& minvAccum) {
         const uint16_t* const __restrict code0FP16 =
                 reinterpret_cast<const uint16_t*>(code0);
-        const float scaler0 = faiss::decode_fp16(code0FP16[0]) * weight0;
-        const float minv0 = faiss::decode_fp16(code0FP16[1]) * weight0;
+        const float scaler0 = knowherefaiss::decode_fp16(code0FP16[0]) * weight0;
+        const float minv0 = knowherefaiss::decode_fp16(code0FP16[1]) * weight0;
 
         const uint16_t* const __restrict code1FP16 =
                 reinterpret_cast<const uint16_t*>(code1);
-        const float scaler1 = faiss::decode_fp16(code1FP16[0]) * weight1;
-        const float minv1 = faiss::decode_fp16(code1FP16[1]) * weight1;
+        const float scaler1 = knowherefaiss::decode_fp16(code1FP16[0]) * weight1;
+        const float minv1 = knowherefaiss::decode_fp16(code1FP16[1]) * weight1;
 
         const uint16_t* const __restrict code2FP16 =
                 reinterpret_cast<const uint16_t*>(code2);
-        const float scaler2 = faiss::decode_fp16(code2FP16[0]) * weight2;
-        const float minv2 = faiss::decode_fp16(code2FP16[1]) * weight2;
+        const float scaler2 = knowherefaiss::decode_fp16(code2FP16[0]) * weight2;
+        const float minv2 = knowherefaiss::decode_fp16(code2FP16[1]) * weight2;
 
         SubIndexT::accum(
                 pqCoarseCentroids0,
@@ -344,18 +344,18 @@ struct IndexMinMaxFP16Decoder {
             float& minvAccum) {
         const uint16_t* const __restrict code0FP16 =
                 reinterpret_cast<const uint16_t*>(code0);
-        const float scaler0 = faiss::decode_fp16(code0FP16[0]) * weight0;
-        const float minv0 = faiss::decode_fp16(code0FP16[1]) * weight0;
+        const float scaler0 = knowherefaiss::decode_fp16(code0FP16[0]) * weight0;
+        const float minv0 = knowherefaiss::decode_fp16(code0FP16[1]) * weight0;
 
         const uint16_t* const __restrict code1FP16 =
                 reinterpret_cast<const uint16_t*>(code1);
-        const float scaler1 = faiss::decode_fp16(code1FP16[0]) * weight1;
-        const float minv1 = faiss::decode_fp16(code1FP16[1]) * weight1;
+        const float scaler1 = knowherefaiss::decode_fp16(code1FP16[0]) * weight1;
+        const float minv1 = knowherefaiss::decode_fp16(code1FP16[1]) * weight1;
 
         const uint16_t* const __restrict code2FP16 =
                 reinterpret_cast<const uint16_t*>(code2);
-        const float scaler2 = faiss::decode_fp16(code2FP16[0]) * weight2;
-        const float minv2 = faiss::decode_fp16(code2FP16[1]) * weight2;
+        const float scaler2 = knowherefaiss::decode_fp16(code2FP16[0]) * weight2;
+        const float minv2 = knowherefaiss::decode_fp16(code2FP16[1]) * weight2;
 
         SubIndexT::accum(
                 pqCoarseCentroids,
@@ -393,18 +393,18 @@ struct IndexMinMaxFP16Decoder {
             float& minvAccum) {
         const uint16_t* const __restrict code0FP16 =
                 reinterpret_cast<const uint16_t*>(code0);
-        const float scaler0 = faiss::decode_fp16(code0FP16[0]) * weight0;
-        const float minv0 = faiss::decode_fp16(code0FP16[1]) * weight0;
+        const float scaler0 = knowherefaiss::decode_fp16(code0FP16[0]) * weight0;
+        const float minv0 = knowherefaiss::decode_fp16(code0FP16[1]) * weight0;
 
         const uint16_t* const __restrict code1FP16 =
                 reinterpret_cast<const uint16_t*>(code1);
-        const float scaler1 = faiss::decode_fp16(code1FP16[0]) * weight1;
-        const float minv1 = faiss::decode_fp16(code1FP16[1]) * weight1;
+        const float scaler1 = knowherefaiss::decode_fp16(code1FP16[0]) * weight1;
+        const float minv1 = knowherefaiss::decode_fp16(code1FP16[1]) * weight1;
 
         const uint16_t* const __restrict code2FP16 =
                 reinterpret_cast<const uint16_t*>(code2);
-        const float scaler2 = faiss::decode_fp16(code2FP16[0]) * weight2;
-        const float minv2 = faiss::decode_fp16(code2FP16[1]) * weight2;
+        const float scaler2 = knowherefaiss::decode_fp16(code2FP16[0]) * weight2;
+        const float minv2 = knowherefaiss::decode_fp16(code2FP16[1]) * weight2;
 
         SubIndexT::accum(
                 pqFineCentroids0,
@@ -441,18 +441,18 @@ struct IndexMinMaxFP16Decoder {
             float& minvAccum) {
         const uint16_t* const __restrict code0FP16 =
                 reinterpret_cast<const uint16_t*>(code0);
-        const float scaler0 = faiss::decode_fp16(code0FP16[0]) * weight0;
-        const float minv0 = faiss::decode_fp16(code0FP16[1]) * weight0;
+        const float scaler0 = knowherefaiss::decode_fp16(code0FP16[0]) * weight0;
+        const float minv0 = knowherefaiss::decode_fp16(code0FP16[1]) * weight0;
 
         const uint16_t* const __restrict code1FP16 =
                 reinterpret_cast<const uint16_t*>(code1);
-        const float scaler1 = faiss::decode_fp16(code1FP16[0]) * weight1;
-        const float minv1 = faiss::decode_fp16(code1FP16[1]) * weight1;
+        const float scaler1 = knowherefaiss::decode_fp16(code1FP16[0]) * weight1;
+        const float minv1 = knowherefaiss::decode_fp16(code1FP16[1]) * weight1;
 
         const uint16_t* const __restrict code2FP16 =
                 reinterpret_cast<const uint16_t*>(code2);
-        const float scaler2 = faiss::decode_fp16(code2FP16[0]) * weight2;
-        const float minv2 = faiss::decode_fp16(code2FP16[1]) * weight2;
+        const float scaler2 = knowherefaiss::decode_fp16(code2FP16[0]) * weight2;
+        const float minv2 = knowherefaiss::decode_fp16(code2FP16[1]) * weight2;
 
         SubIndexT::accum(
                 pqFineCentroids,
@@ -469,4 +469,4 @@ struct IndexMinMaxFP16Decoder {
 };
 
 } // namespace cppcontrib
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/cppcontrib/sa_decode/PQ-avx2-inl.h b/thirdparty/faiss/knowherefaiss/cppcontrib/sa_decode/PQ-avx2-inl.h
similarity index 99%
rename from thirdparty/faiss/faiss/cppcontrib/sa_decode/PQ-avx2-inl.h
rename to thirdparty/faiss/knowherefaiss/cppcontrib/sa_decode/PQ-avx2-inl.h
index d63f52af..8164ffae 100644
--- a/thirdparty/faiss/faiss/cppcontrib/sa_decode/PQ-avx2-inl.h
+++ b/thirdparty/faiss/knowherefaiss/cppcontrib/sa_decode/PQ-avx2-inl.h
@@ -13,9 +13,9 @@
 #include <cstddef>
 #include <cstdint>
 
-#include <faiss/cppcontrib/detail/UintReader.h>
+#include <knowherefaiss/cppcontrib/detail/UintReader.h>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace cppcontrib {
 
 ////////////////////////////////////////////////////////////////////////////////////
@@ -1621,5 +1621,5 @@ struct IndexPQDecoder {
 };
 
 } // namespace cppcontrib
-} // namespace faiss
+} // namespace knowherefaiss
 #endif // PQ_AVX2_INL_H
diff --git a/thirdparty/faiss/faiss/cppcontrib/sa_decode/PQ-inl.h b/thirdparty/faiss/knowherefaiss/cppcontrib/sa_decode/PQ-inl.h
similarity index 99%
rename from thirdparty/faiss/faiss/cppcontrib/sa_decode/PQ-inl.h
rename to thirdparty/faiss/knowherefaiss/cppcontrib/sa_decode/PQ-inl.h
index de6622de..3007ceff 100644
--- a/thirdparty/faiss/faiss/cppcontrib/sa_decode/PQ-inl.h
+++ b/thirdparty/faiss/knowherefaiss/cppcontrib/sa_decode/PQ-inl.h
@@ -11,7 +11,7 @@
 #include <cstddef>
 #include <cstdint>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace cppcontrib {
 
 ////////////////////////////////////////////////////////////////////////////////////
@@ -253,5 +253,5 @@ struct IndexPQDecoder {
 };
 
 } // namespace cppcontrib
-} // namespace faiss
+} // namespace knowherefaiss
 #endif // PQ_INL_H
diff --git a/thirdparty/faiss/faiss/cppcontrib/sa_decode/PQ-neon-inl.h b/thirdparty/faiss/knowherefaiss/cppcontrib/sa_decode/PQ-neon-inl.h
similarity index 99%
rename from thirdparty/faiss/faiss/cppcontrib/sa_decode/PQ-neon-inl.h
rename to thirdparty/faiss/knowherefaiss/cppcontrib/sa_decode/PQ-neon-inl.h
index a84014d2..729dee8b 100644
--- a/thirdparty/faiss/faiss/cppcontrib/sa_decode/PQ-neon-inl.h
+++ b/thirdparty/faiss/knowherefaiss/cppcontrib/sa_decode/PQ-neon-inl.h
@@ -13,9 +13,9 @@
 #include <cstddef>
 #include <cstdint>
 
-#include <faiss/cppcontrib/detail/UintReader.h>
+#include <knowherefaiss/cppcontrib/detail/UintReader.h>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace cppcontrib {
 
 ////////////////////////////////////////////////////////////////////////////////////
@@ -1456,5 +1456,5 @@ struct IndexPQDecoder {
 };
 
 } // namespace cppcontrib
-} // namespace faiss
+} // namespace knowherefaiss
 #endif // PQ_NEON_INL_H
diff --git a/thirdparty/faiss/faiss/gpu/CMakeLists.txt b/thirdparty/faiss/knowherefaiss/gpu/CMakeLists.txt
similarity index 98%
rename from thirdparty/faiss/faiss/gpu/CMakeLists.txt
rename to thirdparty/faiss/knowherefaiss/gpu/CMakeLists.txt
index 2a7b6190..2dd050f5 100644
--- a/thirdparty/faiss/faiss/gpu/CMakeLists.txt
+++ b/thirdparty/faiss/knowherefaiss/gpu/CMakeLists.txt
@@ -174,7 +174,7 @@ target_sources(faiss_avx2 PRIVATE ${FAISS_GPU_SRC})
 foreach(header ${FAISS_GPU_HEADERS})
   get_filename_component(dir ${header} DIRECTORY )
   install(FILES ${header}
-    DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}/faiss/gpu/${dir}
+    DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}/knowherefaiss/gpu/${dir}
   )
 endforeach()
 
diff --git a/thirdparty/faiss/faiss/gpu/GpuAutoTune.cpp b/thirdparty/faiss/knowherefaiss/gpu/GpuAutoTune.cpp
similarity index 77%
rename from thirdparty/faiss/faiss/gpu/GpuAutoTune.cpp
rename to thirdparty/faiss/knowherefaiss/gpu/GpuAutoTune.cpp
index 2720df42..9f42f8f8 100644
--- a/thirdparty/faiss/faiss/gpu/GpuAutoTune.cpp
+++ b/thirdparty/faiss/knowherefaiss/gpu/GpuAutoTune.cpp
@@ -5,24 +5,24 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/gpu/GpuAutoTune.h>
+#include <knowherefaiss/gpu/GpuAutoTune.h>
 #include <typeinfo>
 
-#include <faiss/IndexPreTransform.h>
-#include <faiss/IndexReplicas.h>
-#include <faiss/IndexShards.h>
-#include <faiss/gpu/GpuIndex.h>
-#include <faiss/gpu/GpuIndexFlat.h>
-#include <faiss/gpu/GpuIndexIVFFlat.h>
-#include <faiss/gpu/GpuIndexIVFPQ.h>
-#include <faiss/gpu/GpuIndexIVFScalarQuantizer.h>
-#include <faiss/gpu/utils/DeviceUtils.h>
-#include <faiss/impl/FaissAssert.h>
+#include <knowherefaiss/IndexPreTransform.h>
+#include <knowherefaiss/IndexReplicas.h>
+#include <knowherefaiss/IndexShards.h>
+#include <knowherefaiss/gpu/GpuIndex.h>
+#include <knowherefaiss/gpu/GpuIndexFlat.h>
+#include <knowherefaiss/gpu/GpuIndexIVFFlat.h>
+#include <knowherefaiss/gpu/GpuIndexIVFPQ.h>
+#include <knowherefaiss/gpu/GpuIndexIVFScalarQuantizer.h>
+#include <knowherefaiss/gpu/utils/DeviceUtils.h>
+#include <knowherefaiss/impl/FaissAssert.h>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
-using namespace ::faiss;
+using namespace ::knowherefaiss;
 
 /**********************************************************
  * Parameters to auto-tune on GpuIndex'es
@@ -87,4 +87,4 @@ void GpuParameterSpace::set_index_parameter(
 }
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/GpuAutoTune.h b/thirdparty/faiss/knowherefaiss/gpu/GpuAutoTune.h
similarity index 63%
rename from thirdparty/faiss/faiss/gpu/GpuAutoTune.h
rename to thirdparty/faiss/knowherefaiss/gpu/GpuAutoTune.h
index fbe9a11d..11e2c683 100644
--- a/thirdparty/faiss/faiss/gpu/GpuAutoTune.h
+++ b/thirdparty/faiss/knowherefaiss/gpu/GpuAutoTune.h
@@ -7,23 +7,23 @@
 
 #pragma once
 
-#include <faiss/AutoTune.h>
-#include <faiss/Index.h>
+#include <knowherefaiss/AutoTune.h>
+#include <knowherefaiss/Index.h>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 /// parameter space and setters for GPU indexes
-struct GpuParameterSpace : faiss::ParameterSpace {
+struct GpuParameterSpace : knowherefaiss::ParameterSpace {
     /// initialize with reasonable parameters for the index
-    void initialize(const faiss::Index* index) override;
+    void initialize(const knowherefaiss::Index* index) override;
 
     /// set a combination of parameters on an index
     void set_index_parameter(
-            faiss::Index* index,
+            knowherefaiss::Index* index,
             const std::string& name,
             double val) const override;
 };
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/GpuCloner.cpp b/thirdparty/faiss/knowherefaiss/gpu/GpuCloner.cpp
similarity index 85%
rename from thirdparty/faiss/faiss/gpu/GpuCloner.cpp
rename to thirdparty/faiss/knowherefaiss/gpu/GpuCloner.cpp
index 4987b199..260c7137 100644
--- a/thirdparty/faiss/faiss/gpu/GpuCloner.cpp
+++ b/thirdparty/faiss/knowherefaiss/gpu/GpuCloner.cpp
@@ -5,30 +5,30 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/gpu/GpuCloner.h>
-#include <faiss/impl/FaissAssert.h>
+#include <knowherefaiss/gpu/GpuCloner.h>
+#include <knowherefaiss/impl/FaissAssert.h>
 #include <typeinfo>
 
-#include <faiss/gpu/StandardGpuResources.h>
-
-#include <faiss/IndexFlat.h>
-#include <faiss/IndexIVF.h>
-#include <faiss/IndexIVFFlat.h>
-#include <faiss/IndexIVFPQ.h>
-#include <faiss/IndexPreTransform.h>
-#include <faiss/IndexReplicas.h>
-#include <faiss/IndexScalarQuantizer.h>
-#include <faiss/MetaIndexes.h>
-#include <faiss/gpu/GpuIndex.h>
-#include <faiss/gpu/GpuIndexFlat.h>
-#include <faiss/gpu/GpuIndexIVFFlat.h>
-#include <faiss/gpu/GpuIndexIVFPQ.h>
-#include <faiss/gpu/GpuIndexIVFScalarQuantizer.h>
-#include <faiss/gpu/utils/DeviceUtils.h>
-#include <faiss/impl/FaissAssert.h>
-#include <faiss/index_io.h>
-
-namespace faiss {
+#include <knowherefaiss/gpu/StandardGpuResources.h>
+
+#include <knowherefaiss/IndexFlat.h>
+#include <knowherefaiss/IndexIVF.h>
+#include <knowherefaiss/IndexIVFFlat.h>
+#include <knowherefaiss/IndexIVFPQ.h>
+#include <knowherefaiss/IndexPreTransform.h>
+#include <knowherefaiss/IndexReplicas.h>
+#include <knowherefaiss/IndexScalarQuantizer.h>
+#include <knowherefaiss/MetaIndexes.h>
+#include <knowherefaiss/gpu/GpuIndex.h>
+#include <knowherefaiss/gpu/GpuIndexFlat.h>
+#include <knowherefaiss/gpu/GpuIndexIVFFlat.h>
+#include <knowherefaiss/gpu/GpuIndexIVFPQ.h>
+#include <knowherefaiss/gpu/GpuIndexIVFScalarQuantizer.h>
+#include <knowherefaiss/gpu/utils/DeviceUtils.h>
+#include <knowherefaiss/impl/FaissAssert.h>
+#include <knowherefaiss/index_io.h>
+
+namespace knowherefaiss {
 namespace gpu {
 
 /**********************************************************
@@ -100,7 +100,7 @@ Index* ToCPUCloner::clone_Index(const Index* index) {
     }
 }
 
-faiss::Index* index_gpu_to_cpu(const faiss::Index* gpu_index) {
+knowherefaiss::Index* index_gpu_to_cpu(const knowherefaiss::Index* gpu_index) {
     ToCPUCloner cl;
     return cl.clone_Index(gpu_index);
 }
@@ -143,7 +143,7 @@ Index* ToGpuCloner::clone_Index(const Index* index) {
         }
         assert(gif->getNumVecs() == index->ntotal);
         return gif;
-    } else if (auto ifl = dynamic_cast<const faiss::IndexIVFFlat*>(index)) {
+    } else if (auto ifl = dynamic_cast<const knowherefaiss::IndexIVFFlat*>(index)) {
         GpuIndexIVFFlatConfig config;
         config.device = device;
         config.indicesOptions = indicesOptions;
@@ -159,7 +159,7 @@ Index* ToGpuCloner::clone_Index(const Index* index) {
         res->copyFrom(ifl);
         return res;
     } else if (
-            auto ifl = dynamic_cast<const faiss::IndexIVFScalarQuantizer*>(
+            auto ifl = dynamic_cast<const knowherefaiss::IndexIVFScalarQuantizer*>(
                     index)) {
         GpuIndexIVFScalarQuantizerConfig config;
         config.device = device;
@@ -181,7 +181,7 @@ Index* ToGpuCloner::clone_Index(const Index* index) {
 
         res->copyFrom(ifl);
         return res;
-    } else if (auto ipq = dynamic_cast<const faiss::IndexIVFPQ*>(index)) {
+    } else if (auto ipq = dynamic_cast<const knowherefaiss::IndexIVFPQ*>(index)) {
         if (verbose) {
             printf("  IndexIVFPQ size %ld -> GpuIndexIVFPQ "
                    "indicesOptions=%d "
@@ -213,10 +213,10 @@ Index* ToGpuCloner::clone_Index(const Index* index) {
     }
 }
 
-faiss::Index* index_cpu_to_gpu(
+knowherefaiss::Index* index_cpu_to_gpu(
         GpuResourcesProvider* provider,
         int device,
-        const faiss::Index* index,
+        const knowherefaiss::Index* index,
         const GpuClonerOptions* options) {
     GpuClonerOptions defaults;
     ToGpuCloner cl(provider, device, options ? *options : defaults);
@@ -268,18 +268,18 @@ void ToGpuClonerMultiple::copy_ivf_shard(
 Index* ToGpuClonerMultiple::clone_Index_to_shards(const Index* index) {
     long n = sub_cloners.size();
 
-    auto index_ivfpq = dynamic_cast<const faiss::IndexIVFPQ*>(index);
-    auto index_ivfflat = dynamic_cast<const faiss::IndexIVFFlat*>(index);
+    auto index_ivfpq = dynamic_cast<const knowherefaiss::IndexIVFPQ*>(index);
+    auto index_ivfflat = dynamic_cast<const knowherefaiss::IndexIVFFlat*>(index);
     auto index_ivfsq =
-            dynamic_cast<const faiss::IndexIVFScalarQuantizer*>(index);
-    auto index_flat = dynamic_cast<const faiss::IndexFlat*>(index);
+            dynamic_cast<const knowherefaiss::IndexIVFScalarQuantizer*>(index);
+    auto index_flat = dynamic_cast<const knowherefaiss::IndexFlat*>(index);
     FAISS_THROW_IF_NOT_MSG(
             index_ivfpq || index_ivfflat || index_flat || index_ivfsq,
             "IndexShards implemented only for "
             "IndexIVFFlat, IndexIVFScalarQuantizer, "
             "IndexFlat and IndexIVFPQ");
 
-    std::vector<faiss::Index*> shards(n);
+    std::vector<knowherefaiss::Index*> shards(n);
 
     for (long i = 0; i < n; i++) {
         // make a shallow copy
@@ -287,7 +287,7 @@ Index* ToGpuClonerMultiple::clone_Index_to_shards(const Index* index) {
             sub_cloners[i].reserveVecs = (reserveVecs + n - 1) / n;
 
         if (index_ivfpq) {
-            faiss::IndexIVFPQ idx2(
+            knowherefaiss::IndexIVFPQ idx2(
                     index_ivfpq->quantizer,
                     index_ivfpq->d,
                     index_ivfpq->nlist,
@@ -301,7 +301,7 @@ Index* ToGpuClonerMultiple::clone_Index_to_shards(const Index* index) {
             copy_ivf_shard(index_ivfpq, &idx2, n, i);
             shards[i] = sub_cloners[i].clone_Index(&idx2);
         } else if (index_ivfflat) {
-            faiss::IndexIVFFlat idx2(
+            knowherefaiss::IndexIVFFlat idx2(
                     index_ivfflat->quantizer,
                     index->d,
                     index_ivfflat->nlist,
@@ -311,7 +311,7 @@ Index* ToGpuClonerMultiple::clone_Index_to_shards(const Index* index) {
             copy_ivf_shard(index_ivfflat, &idx2, n, i);
             shards[i] = sub_cloners[i].clone_Index(&idx2);
         } else if (index_ivfsq) {
-            faiss::IndexIVFScalarQuantizer idx2(
+            knowherefaiss::IndexIVFScalarQuantizer idx2(
                     index_ivfsq->quantizer,
                     index->d,
                     index_ivfsq->nlist,
@@ -325,7 +325,7 @@ Index* ToGpuClonerMultiple::clone_Index_to_shards(const Index* index) {
             copy_ivf_shard(index_ivfsq, &idx2, n, i);
             shards[i] = sub_cloners[i].clone_Index(&idx2);
         } else if (index_flat) {
-            faiss::IndexFlat idx2(index->d, index->metric_type);
+            knowherefaiss::IndexFlat idx2(index->d, index->metric_type);
             shards[i] = sub_cloners[i].clone_Index(&idx2);
             if (index->ntotal > 0) {
                 long i0 = index->ntotal * i / n;
@@ -336,8 +336,8 @@ Index* ToGpuClonerMultiple::clone_Index_to_shards(const Index* index) {
     }
 
     bool successive_ids = index_flat != nullptr;
-    faiss::IndexShards* res =
-            new faiss::IndexShards(index->d, true, successive_ids);
+    knowherefaiss::IndexShards* res =
+            new knowherefaiss::IndexShards(index->d, true, successive_ids);
 
     for (int i = 0; i < n; i++) {
         res->add_shard(shards[i]);
@@ -353,9 +353,9 @@ Index* ToGpuClonerMultiple::clone_Index(const Index* index) {
         return sub_cloners[0].clone_Index(index);
 
     if (dynamic_cast<const IndexFlat*>(index) ||
-        dynamic_cast<const faiss::IndexIVFFlat*>(index) ||
-        dynamic_cast<const faiss::IndexIVFScalarQuantizer*>(index) ||
-        dynamic_cast<const faiss::IndexIVFPQ*>(index)) {
+        dynamic_cast<const knowherefaiss::IndexIVFFlat*>(index) ||
+        dynamic_cast<const knowherefaiss::IndexIVFScalarQuantizer*>(index) ||
+        dynamic_cast<const knowherefaiss::IndexIVFPQ*>(index)) {
         if (!shard) {
             IndexReplicas* res = new IndexReplicas();
             for (auto& sub_cloner : sub_cloners) {
@@ -397,10 +397,10 @@ Index* ToGpuClonerMultiple::clone_Index(const Index* index) {
     }
 }
 
-faiss::Index* index_cpu_to_gpu_multiple(
+knowherefaiss::Index* index_cpu_to_gpu_multiple(
         std::vector<GpuResourcesProvider*>& provider,
         std::vector<int>& devices,
-        const faiss::Index* index,
+        const knowherefaiss::Index* index,
         const GpuMultipleClonerOptions* options) {
     GpuMultipleClonerOptions defaults;
     ToGpuClonerMultiple cl(provider, devices, options ? *options : defaults);
@@ -432,4 +432,4 @@ Index* GpuProgressiveDimIndexFactory::operator()(int dim) {
 }
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/GpuCloner.h b/thirdparty/faiss/knowherefaiss/gpu/GpuCloner.h
similarity index 74%
rename from thirdparty/faiss/faiss/gpu/GpuCloner.h
rename to thirdparty/faiss/knowherefaiss/gpu/GpuCloner.h
index c692ec69..1fff31ba 100644
--- a/thirdparty/faiss/faiss/gpu/GpuCloner.h
+++ b/thirdparty/faiss/knowherefaiss/gpu/GpuCloner.h
@@ -9,25 +9,25 @@
 
 #include <vector>
 
-#include <faiss/Clustering.h>
-#include <faiss/Index.h>
-#include <faiss/clone_index.h>
-#include <faiss/gpu/GpuClonerOptions.h>
-#include <faiss/gpu/GpuIndex.h>
-#include <faiss/gpu/GpuIndicesOptions.h>
-namespace faiss {
+#include <knowherefaiss/Clustering.h>
+#include <knowherefaiss/Index.h>
+#include <knowherefaiss/clone_index.h>
+#include <knowherefaiss/gpu/GpuClonerOptions.h>
+#include <knowherefaiss/gpu/GpuIndex.h>
+#include <knowherefaiss/gpu/GpuIndicesOptions.h>
+namespace knowherefaiss {
 namespace gpu {
 
 class GpuResourcesProvider;
 
 /// Cloner specialized for GPU -> CPU
-struct ToCPUCloner : faiss::Cloner {
+struct ToCPUCloner : knowherefaiss::Cloner {
     void merge_index(Index* dst, Index* src, bool successive_ids);
     Index* clone_Index(const Index* index) override;
 };
 
 /// Cloner specialized for CPU -> 1 GPU
-struct ToGpuCloner : faiss::Cloner, GpuClonerOptions {
+struct ToGpuCloner : knowherefaiss::Cloner, GpuClonerOptions {
     GpuResourcesProvider* provider;
     int device;
 
@@ -40,7 +40,7 @@ struct ToGpuCloner : faiss::Cloner, GpuClonerOptions {
 };
 
 /// Cloner specialized for CPU -> multiple GPUs
-struct ToGpuClonerMultiple : faiss::Cloner, GpuMultipleClonerOptions {
+struct ToGpuClonerMultiple : knowherefaiss::Cloner, GpuMultipleClonerOptions {
     std::vector<ToGpuCloner> sub_cloners;
 
     ToGpuClonerMultiple(
@@ -65,19 +65,19 @@ struct ToGpuClonerMultiple : faiss::Cloner, GpuMultipleClonerOptions {
 };
 
 /// converts any GPU index inside gpu_index to a CPU index
-faiss::Index* index_gpu_to_cpu(const faiss::Index* gpu_index);
+knowherefaiss::Index* index_gpu_to_cpu(const knowherefaiss::Index* gpu_index);
 
 /// converts any CPU index that can be converted to GPU
-faiss::Index* index_cpu_to_gpu(
+knowherefaiss::Index* index_cpu_to_gpu(
         GpuResourcesProvider* provider,
         int device,
-        const faiss::Index* index,
+        const knowherefaiss::Index* index,
         const GpuClonerOptions* options = nullptr);
 
-faiss::Index* index_cpu_to_gpu_multiple(
+knowherefaiss::Index* index_cpu_to_gpu_multiple(
         std::vector<GpuResourcesProvider*>& provider,
         std::vector<int>& devices,
-        const faiss::Index* index,
+        const knowherefaiss::Index* index,
         const GpuMultipleClonerOptions* options = nullptr);
 
 /// index factory for the ProgressiveDimClustering object
@@ -96,4 +96,4 @@ struct GpuProgressiveDimIndexFactory : ProgressiveDimIndexFactory {
 };
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/GpuClonerOptions.cpp b/thirdparty/faiss/knowherefaiss/gpu/GpuClonerOptions.cpp
similarity index 86%
rename from thirdparty/faiss/faiss/gpu/GpuClonerOptions.cpp
rename to thirdparty/faiss/knowherefaiss/gpu/GpuClonerOptions.cpp
index f907df76..df5d4bf7 100644
--- a/thirdparty/faiss/faiss/gpu/GpuClonerOptions.cpp
+++ b/thirdparty/faiss/knowherefaiss/gpu/GpuClonerOptions.cpp
@@ -5,9 +5,9 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/gpu/GpuClonerOptions.h>
+#include <knowherefaiss/gpu/GpuClonerOptions.h>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 GpuClonerOptions::GpuClonerOptions()
@@ -25,4 +25,4 @@ GpuMultipleClonerOptions::GpuMultipleClonerOptions()
         : shard(false), shard_type(1) {}
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/GpuClonerOptions.h b/thirdparty/faiss/knowherefaiss/gpu/GpuClonerOptions.h
similarity index 92%
rename from thirdparty/faiss/faiss/gpu/GpuClonerOptions.h
rename to thirdparty/faiss/knowherefaiss/gpu/GpuClonerOptions.h
index bf070d16..5ea81365 100644
--- a/thirdparty/faiss/faiss/gpu/GpuClonerOptions.h
+++ b/thirdparty/faiss/knowherefaiss/gpu/GpuClonerOptions.h
@@ -7,9 +7,9 @@
 
 #pragma once
 
-#include <faiss/gpu/GpuIndicesOptions.h>
+#include <knowherefaiss/gpu/GpuIndicesOptions.h>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 /// set some options on how to copy to GPU
@@ -57,4 +57,4 @@ struct GpuMultipleClonerOptions : public GpuClonerOptions {
 };
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/GpuDistance.cu b/thirdparty/faiss/knowherefaiss/gpu/GpuDistance.cu
similarity index 94%
rename from thirdparty/faiss/faiss/gpu/GpuDistance.cu
rename to thirdparty/faiss/knowherefaiss/gpu/GpuDistance.cu
index 6f45a22b..16c2e14f 100644
--- a/thirdparty/faiss/faiss/gpu/GpuDistance.cu
+++ b/thirdparty/faiss/knowherefaiss/gpu/GpuDistance.cu
@@ -5,16 +5,16 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/gpu/GpuDistance.h>
-#include <faiss/gpu/GpuResources.h>
-#include <faiss/gpu/utils/DeviceUtils.h>
-#include <faiss/impl/FaissAssert.h>
-#include <faiss/gpu/impl/Distance.cuh>
-#include <faiss/gpu/utils/ConversionOperators.cuh>
-#include <faiss/gpu/utils/CopyUtils.cuh>
-#include <faiss/gpu/utils/DeviceTensor.cuh>
-
-namespace faiss {
+#include <knowherefaiss/gpu/GpuDistance.h>
+#include <knowherefaiss/gpu/GpuResources.h>
+#include <knowherefaiss/gpu/utils/DeviceUtils.h>
+#include <knowherefaiss/impl/FaissAssert.h>
+#include <knowherefaiss/gpu/impl/Distance.cuh>
+#include <knowherefaiss/gpu/utils/ConversionOperators.cuh>
+#include <knowherefaiss/gpu/utils/CopyUtils.cuh>
+#include <knowherefaiss/gpu/utils/DeviceTensor.cuh>
+
+namespace knowherefaiss {
 namespace gpu {
 
 template <typename T>
@@ -198,7 +198,7 @@ void bfKnn(GpuResourcesProvider* res, const GpuDistanceParams& args) {
 // legacy version
 void bruteForceKnn(
         GpuResourcesProvider* res,
-        faiss::MetricType metric,
+        knowherefaiss::MetricType metric,
         // A region of memory size numVectors x dims, with dims
         // innermost
         const float* vectors,
@@ -236,4 +236,4 @@ void bruteForceKnn(
 }
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/GpuDistance.h b/thirdparty/faiss/knowherefaiss/gpu/GpuDistance.h
similarity index 95%
rename from thirdparty/faiss/faiss/gpu/GpuDistance.h
rename to thirdparty/faiss/knowherefaiss/gpu/GpuDistance.h
index f33cf1ec..593859a6 100644
--- a/thirdparty/faiss/faiss/gpu/GpuDistance.h
+++ b/thirdparty/faiss/knowherefaiss/gpu/GpuDistance.h
@@ -7,9 +7,9 @@
 
 #pragma once
 
-#include <faiss/Index.h>
+#include <knowherefaiss/Index.h>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 class GpuResourcesProvider;
@@ -29,7 +29,7 @@ enum class IndicesDataType {
 /// Arguments to brute-force GPU k-nearest neighbor searching
 struct GpuDistanceParams {
     GpuDistanceParams()
-            : metric(faiss::MetricType::METRIC_L2),
+            : metric(knowherefaiss::MetricType::METRIC_L2),
               metricArg(0),
               k(0),
               dims(0),
@@ -52,7 +52,7 @@ struct GpuDistanceParams {
     //
 
     /// Search parameter: distance metric
-    faiss::MetricType metric;
+    knowherefaiss::MetricType metric;
 
     /// Search parameter: distance metric argument (if applicable)
     /// For metric == METRIC_Lp, this is the p-value
@@ -131,7 +131,7 @@ void bfKnn(GpuResourcesProvider* resources, const GpuDistanceParams& args);
 /// Deprecated legacy implementation
 void bruteForceKnn(
         GpuResourcesProvider* resources,
-        faiss::MetricType metric,
+        knowherefaiss::MetricType metric,
         // If vectorsRowMajor is true, this is
         // numVectors x dims, with dims innermost; otherwise,
         // dims x numVectors, with numVectors innermost
@@ -154,4 +154,4 @@ void bruteForceKnn(
         Index::idx_t* outIndices);
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/GpuFaissAssert.h b/thirdparty/faiss/knowherefaiss/gpu/GpuFaissAssert.h
similarity index 93%
rename from thirdparty/faiss/faiss/gpu/GpuFaissAssert.h
rename to thirdparty/faiss/knowherefaiss/gpu/GpuFaissAssert.h
index 2f03a8c2..7feb3297 100644
--- a/thirdparty/faiss/faiss/gpu/GpuFaissAssert.h
+++ b/thirdparty/faiss/knowherefaiss/gpu/GpuFaissAssert.h
@@ -9,7 +9,7 @@
 #define GPU_FAISS_ASSERT_INCLUDED
 
 #include <cuda.h>
-#include <faiss/impl/FaissAssert.h>
+#include <knowherefaiss/impl/FaissAssert.h>
 
 ///
 /// Assertions
diff --git a/thirdparty/faiss/faiss/gpu/GpuIcmEncoder.cu b/thirdparty/faiss/knowherefaiss/gpu/GpuIcmEncoder.cu
similarity index 93%
rename from thirdparty/faiss/faiss/gpu/GpuIcmEncoder.cu
rename to thirdparty/faiss/knowherefaiss/gpu/GpuIcmEncoder.cu
index 8bd60f91..5217debc 100644
--- a/thirdparty/faiss/faiss/gpu/GpuIcmEncoder.cu
+++ b/thirdparty/faiss/knowherefaiss/gpu/GpuIcmEncoder.cu
@@ -5,15 +5,15 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/gpu/GpuIcmEncoder.h>
+#include <knowherefaiss/gpu/GpuIcmEncoder.h>
 
-#include <faiss/gpu/StandardGpuResources.h>
-#include <faiss/utils/WorkerThread.h>
-#include <faiss/gpu/impl/IcmEncoder.cuh>
+#include <knowherefaiss/gpu/StandardGpuResources.h>
+#include <knowherefaiss/utils/WorkerThread.h>
+#include <knowherefaiss/gpu/impl/IcmEncoder.cuh>
 
 #include <algorithm>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 ///< A helper structure to support multi-GPU
@@ -123,4 +123,4 @@ lsq::IcmEncoder* GpuIcmEncoderFactory::get(const LocalSearchQuantizer* lsq) {
 }
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/GpuIcmEncoder.h b/thirdparty/faiss/knowherefaiss/gpu/GpuIcmEncoder.h
similarity index 92%
rename from thirdparty/faiss/faiss/gpu/GpuIcmEncoder.h
rename to thirdparty/faiss/knowherefaiss/gpu/GpuIcmEncoder.h
index 463027bb..758c8b31 100644
--- a/thirdparty/faiss/faiss/gpu/GpuIcmEncoder.h
+++ b/thirdparty/faiss/knowherefaiss/gpu/GpuIcmEncoder.h
@@ -7,11 +7,11 @@
 
 #pragma once
 
-#include <faiss/impl/LocalSearchQuantizer.h>
+#include <knowherefaiss/impl/LocalSearchQuantizer.h>
 
 #include <memory>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 class GpuResourcesProvider;
@@ -57,4 +57,4 @@ struct GpuIcmEncoderFactory : public lsq::IcmEncoderFactory {
 };
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/GpuIndex.cu b/thirdparty/faiss/knowherefaiss/gpu/GpuIndex.cu
similarity index 97%
rename from thirdparty/faiss/faiss/gpu/GpuIndex.cu
rename to thirdparty/faiss/knowherefaiss/gpu/GpuIndex.cu
index 6a9fbdc4..5475f77e 100644
--- a/thirdparty/faiss/faiss/gpu/GpuIndex.cu
+++ b/thirdparty/faiss/knowherefaiss/gpu/GpuIndex.cu
@@ -5,18 +5,18 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/gpu/GpuIndex.h>
-#include <faiss/gpu/GpuResources.h>
-#include <faiss/gpu/utils/DeviceUtils.h>
-#include <faiss/gpu/utils/StaticUtils.h>
-#include <faiss/impl/FaissAssert.h>
-#include <faiss/gpu/utils/CopyUtils.cuh>
+#include <knowherefaiss/gpu/GpuIndex.h>
+#include <knowherefaiss/gpu/GpuResources.h>
+#include <knowherefaiss/gpu/utils/DeviceUtils.h>
+#include <knowherefaiss/gpu/utils/StaticUtils.h>
+#include <knowherefaiss/impl/FaissAssert.h>
+#include <knowherefaiss/gpu/utils/CopyUtils.cuh>
 
 #include <algorithm>
 #include <limits>
 #include <memory>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 /// Default CPU search size for which we use paged copies
@@ -40,7 +40,7 @@ constexpr size_t kSearchVecSize = (size_t)32 * 1024;
 GpuIndex::GpuIndex(
         std::shared_ptr<GpuResources> resources,
         int dims,
-        faiss::MetricType metric,
+        knowherefaiss::MetricType metric,
         float metricArg,
         GpuIndexConfig config)
         : Index(dims, metric),
@@ -71,7 +71,7 @@ int GpuIndex::getDevice() const {
     return config_.device;
 }
 
-void GpuIndex::copyFrom(const faiss::Index* index) {
+void GpuIndex::copyFrom(const knowherefaiss::Index* index) {
     d = index->d;
     metric_type = index->metric_type;
     metric_arg = index->metric_arg;
@@ -79,7 +79,7 @@ void GpuIndex::copyFrom(const faiss::Index* index) {
     is_trained = index->is_trained;
 }
 
-void GpuIndex::copyTo(faiss::Index* index) const {
+void GpuIndex::copyTo(knowherefaiss::Index* index) const {
     index->d = d;
     index->metric_type = metric_type;
     index->metric_arg = metric_arg;
@@ -540,4 +540,4 @@ std::shared_ptr<GpuResources> GpuIndex::getResources() {
 }
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/GpuIndex.h b/thirdparty/faiss/knowherefaiss/gpu/GpuIndex.h
similarity index 94%
rename from thirdparty/faiss/faiss/gpu/GpuIndex.h
rename to thirdparty/faiss/knowherefaiss/gpu/GpuIndex.h
index 66def23a..8a740945 100644
--- a/thirdparty/faiss/faiss/gpu/GpuIndex.h
+++ b/thirdparty/faiss/knowherefaiss/gpu/GpuIndex.h
@@ -7,10 +7,10 @@
 
 #pragma once
 
-#include <faiss/Index.h>
-#include <faiss/gpu/GpuResources.h>
+#include <knowherefaiss/Index.h>
+#include <knowherefaiss/gpu/GpuResources.h>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 struct GpuIndexConfig {
@@ -25,12 +25,12 @@ struct GpuIndexConfig {
     MemorySpace memorySpace;
 };
 
-class GpuIndex : public faiss::Index {
+class GpuIndex : public knowherefaiss::Index {
    public:
     GpuIndex(
             std::shared_ptr<GpuResources> resources,
             int dims,
-            faiss::MetricType metric,
+            knowherefaiss::MetricType metric,
             float metricArg,
             GpuIndexConfig config);
 
@@ -101,10 +101,10 @@ class GpuIndex : public faiss::Index {
 
    protected:
     /// Copy what we need from the CPU equivalent
-    void copyFrom(const faiss::Index* index);
+    void copyFrom(const knowherefaiss::Index* index);
 
     /// Copy what we have to the CPU equivalent
-    void copyTo(faiss::Index* index) const;
+    void copyTo(knowherefaiss::Index* index) const;
 
     /// Does addImpl_ require IDs? If so, and no IDs are provided, we will
     /// generate them sequentially based on the order in which the IDs are added
@@ -190,4 +190,4 @@ class GpuIndex : public faiss::Index {
 };
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/GpuIndexBinaryFlat.cu b/thirdparty/faiss/knowherefaiss/gpu/GpuIndexBinaryFlat.cu
similarity index 91%
rename from thirdparty/faiss/faiss/gpu/GpuIndexBinaryFlat.cu
rename to thirdparty/faiss/knowherefaiss/gpu/GpuIndexBinaryFlat.cu
index b8f06e47..7aaee7a9 100644
--- a/thirdparty/faiss/faiss/gpu/GpuIndexBinaryFlat.cu
+++ b/thirdparty/faiss/knowherefaiss/gpu/GpuIndexBinaryFlat.cu
@@ -5,15 +5,15 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/gpu/GpuIndexBinaryFlat.h>
+#include <knowherefaiss/gpu/GpuIndexBinaryFlat.h>
 
-#include <faiss/gpu/GpuResources.h>
-#include <faiss/gpu/utils/DeviceUtils.h>
-#include <faiss/gpu/impl/BinaryFlatIndex.cuh>
-#include <faiss/gpu/utils/ConversionOperators.cuh>
-#include <faiss/gpu/utils/CopyUtils.cuh>
+#include <knowherefaiss/gpu/GpuResources.h>
+#include <knowherefaiss/gpu/utils/DeviceUtils.h>
+#include <knowherefaiss/gpu/impl/BinaryFlatIndex.cuh>
+#include <knowherefaiss/gpu/utils/ConversionOperators.cuh>
+#include <knowherefaiss/gpu/utils/CopyUtils.cuh>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 /// Default CPU search size for which we use paged copies
@@ -21,7 +21,7 @@ constexpr size_t kMinPageSize = (size_t)256 * 1024 * 1024;
 
 GpuIndexBinaryFlat::GpuIndexBinaryFlat(
         GpuResourcesProvider* provider,
-        const faiss::IndexBinaryFlat* index,
+        const knowherefaiss::IndexBinaryFlat* index,
         GpuIndexBinaryFlatConfig config)
         : IndexBinary(index->d),
           resources_(provider->getResources()),
@@ -70,7 +70,7 @@ std::shared_ptr<GpuResources> GpuIndexBinaryFlat::getResources() {
     return resources_;
 }
 
-void GpuIndexBinaryFlat::copyFrom(const faiss::IndexBinaryFlat* index) {
+void GpuIndexBinaryFlat::copyFrom(const knowherefaiss::IndexBinaryFlat* index) {
     DeviceScope scope(binaryFlatConfig_.device);
 
     this->d = index->d;
@@ -98,7 +98,7 @@ void GpuIndexBinaryFlat::copyFrom(const faiss::IndexBinaryFlat* index) {
     }
 }
 
-void GpuIndexBinaryFlat::copyTo(faiss::IndexBinaryFlat* index) const {
+void GpuIndexBinaryFlat::copyTo(knowherefaiss::IndexBinaryFlat* index) const {
     DeviceScope scope(binaryFlatConfig_.device);
 
     index->d = this->d;
@@ -116,7 +116,7 @@ void GpuIndexBinaryFlat::copyTo(faiss::IndexBinaryFlat* index) const {
     }
 }
 
-void GpuIndexBinaryFlat::add(faiss::IndexBinary::idx_t n, const uint8_t* x) {
+void GpuIndexBinaryFlat::add(knowherefaiss::IndexBinary::idx_t n, const uint8_t* x) {
     DeviceScope scope(binaryFlatConfig_.device);
 
     // To avoid multiple re-allocations, ensure we have enough storage
@@ -146,11 +146,11 @@ void GpuIndexBinaryFlat::reset() {
 }
 
 void GpuIndexBinaryFlat::search(
-        faiss::IndexBinary::idx_t n,
+        knowherefaiss::IndexBinary::idx_t n,
         const uint8_t* x,
-        faiss::IndexBinary::idx_t k,
+        knowherefaiss::IndexBinary::idx_t k,
         int32_t* distances,
-        faiss::IndexBinary::idx_t* labels,
+        knowherefaiss::IndexBinary::idx_t* labels,
         const BitsetView bitset) const {
     if (n == 0) {
         return;
@@ -283,7 +283,7 @@ void GpuIndexBinaryFlat::searchFromCpuPaged_(
 }
 
 void GpuIndexBinaryFlat::reconstruct(
-        faiss::IndexBinary::idx_t key,
+        knowherefaiss::IndexBinary::idx_t key,
         uint8_t* out) const {
     DeviceScope scope(binaryFlatConfig_.device);
 
@@ -297,4 +297,4 @@ void GpuIndexBinaryFlat::reconstruct(
 }
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/GpuIndexBinaryFlat.h b/thirdparty/faiss/knowherefaiss/gpu/GpuIndexBinaryFlat.h
similarity index 76%
rename from thirdparty/faiss/faiss/gpu/GpuIndexBinaryFlat.h
rename to thirdparty/faiss/knowherefaiss/gpu/GpuIndexBinaryFlat.h
index d07b3769..43c58bf5 100644
--- a/thirdparty/faiss/faiss/gpu/GpuIndexBinaryFlat.h
+++ b/thirdparty/faiss/knowherefaiss/gpu/GpuIndexBinaryFlat.h
@@ -7,12 +7,12 @@
 
 #pragma once
 
-#include <faiss/IndexBinaryFlat.h>
-#include <faiss/gpu/GpuIndex.h>
-#include <faiss/gpu/GpuResources.h>
+#include <knowherefaiss/IndexBinaryFlat.h>
+#include <knowherefaiss/gpu/GpuIndex.h>
+#include <knowherefaiss/gpu/GpuResources.h>
 #include <memory>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 class BinaryFlatIndex;
@@ -23,11 +23,11 @@ struct GpuIndexBinaryFlatConfig : public GpuIndexConfig {};
 /// via Hamming distance
 class GpuIndexBinaryFlat : public IndexBinary {
    public:
-    /// Construct from a pre-existing faiss::IndexBinaryFlat instance, copying
+    /// Construct from a pre-existing knowherefaiss::IndexBinaryFlat instance, copying
     /// data over to the given GPU
     GpuIndexBinaryFlat(
             GpuResourcesProvider* resources,
-            const faiss::IndexBinaryFlat* index,
+            const knowherefaiss::IndexBinaryFlat* index,
             GpuIndexBinaryFlatConfig config = GpuIndexBinaryFlatConfig());
 
     /// Construct an empty instance that can be added to
@@ -47,25 +47,25 @@ class GpuIndexBinaryFlat : public IndexBinary {
 
     /// Initialize ourselves from the given CPU index; will overwrite
     /// all data in ourselves
-    void copyFrom(const faiss::IndexBinaryFlat* index);
+    void copyFrom(const knowherefaiss::IndexBinaryFlat* index);
 
     /// Copy ourselves to the given CPU index; will overwrite all data
     /// in the index instance
-    void copyTo(faiss::IndexBinaryFlat* index) const;
+    void copyTo(knowherefaiss::IndexBinaryFlat* index) const;
 
-    void add(faiss::IndexBinary::idx_t n, const uint8_t* x) override;
+    void add(knowherefaiss::IndexBinary::idx_t n, const uint8_t* x) override;
 
     void reset() override;
 
     void search(
-            faiss::IndexBinary::idx_t n,
+            knowherefaiss::IndexBinary::idx_t n,
             const uint8_t* x,
-            faiss::IndexBinary::idx_t k,
+            knowherefaiss::IndexBinary::idx_t k,
             int32_t* distances,
-            faiss::IndexBinary::idx_t* labels,
+            knowherefaiss::IndexBinary::idx_t* labels,
             const BitsetView bitset = nullptr) const override;
 
-    void reconstruct(faiss::IndexBinary::idx_t key, uint8_t* recons)
+    void reconstruct(knowherefaiss::IndexBinary::idx_t key, uint8_t* recons)
             const override;
 
    protected:
@@ -97,4 +97,4 @@ class GpuIndexBinaryFlat : public IndexBinary {
 };
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/GpuIndexFlat.cu b/thirdparty/faiss/knowherefaiss/gpu/GpuIndexFlat.cu
similarity index 89%
rename from thirdparty/faiss/faiss/gpu/GpuIndexFlat.cu
rename to thirdparty/faiss/knowherefaiss/gpu/GpuIndexFlat.cu
index cfb9b922..da1c9493 100644
--- a/thirdparty/faiss/faiss/gpu/GpuIndexFlat.cu
+++ b/thirdparty/faiss/knowherefaiss/gpu/GpuIndexFlat.cu
@@ -5,23 +5,23 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/IndexFlat.h>
-#include <faiss/gpu/GpuIndexFlat.h>
-#include <faiss/gpu/GpuResources.h>
-#include <faiss/gpu/utils/DeviceUtils.h>
-#include <faiss/gpu/utils/StaticUtils.h>
-#include <faiss/gpu/impl/FlatIndex.cuh>
-#include <faiss/gpu/utils/ConversionOperators.cuh>
-#include <faiss/gpu/utils/CopyUtils.cuh>
-#include <faiss/gpu/utils/Float16.cuh>
+#include <knowherefaiss/IndexFlat.h>
+#include <knowherefaiss/gpu/GpuIndexFlat.h>
+#include <knowherefaiss/gpu/GpuResources.h>
+#include <knowherefaiss/gpu/utils/DeviceUtils.h>
+#include <knowherefaiss/gpu/utils/StaticUtils.h>
+#include <knowherefaiss/gpu/impl/FlatIndex.cuh>
+#include <knowherefaiss/gpu/utils/ConversionOperators.cuh>
+#include <knowherefaiss/gpu/utils/CopyUtils.cuh>
+#include <knowherefaiss/gpu/utils/Float16.cuh>
 #include <limits>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 GpuIndexFlat::GpuIndexFlat(
         GpuResourcesProvider* provider,
-        const faiss::IndexFlat* index,
+        const knowherefaiss::IndexFlat* index,
         GpuIndexFlatConfig config)
         : GpuIndex(
                   provider->getResources(),
@@ -38,7 +38,7 @@ GpuIndexFlat::GpuIndexFlat(
 
 GpuIndexFlat::GpuIndexFlat(
         std::shared_ptr<GpuResources> resources,
-        const faiss::IndexFlat* index,
+        const knowherefaiss::IndexFlat* index,
         GpuIndexFlatConfig config)
         : GpuIndex(
                   resources,
@@ -56,7 +56,7 @@ GpuIndexFlat::GpuIndexFlat(
 GpuIndexFlat::GpuIndexFlat(
         GpuResourcesProvider* provider,
         int dims,
-        faiss::MetricType metric,
+        knowherefaiss::MetricType metric,
         GpuIndexFlatConfig config)
         : GpuIndex(provider->getResources(), dims, metric, 0, config),
           flatConfig_(config) {
@@ -76,7 +76,7 @@ GpuIndexFlat::GpuIndexFlat(
 GpuIndexFlat::GpuIndexFlat(
         std::shared_ptr<GpuResources> resources,
         int dims,
-        faiss::MetricType metric,
+        knowherefaiss::MetricType metric,
         GpuIndexFlatConfig config)
         : GpuIndex(resources, dims, metric, 0, config), flatConfig_(config) {
     // Flat index doesn't need training
@@ -94,7 +94,7 @@ GpuIndexFlat::GpuIndexFlat(
 
 GpuIndexFlat::~GpuIndexFlat() {}
 
-void GpuIndexFlat::copyFrom(const faiss::IndexFlat* index) {
+void GpuIndexFlat::copyFrom(const knowherefaiss::IndexFlat* index) {
     DeviceScope scope(config_.device);
 
     GpuIndex::copyFrom(index);
@@ -131,7 +131,7 @@ void GpuIndexFlat::copyFrom(const faiss::IndexFlat* index) {
     }
 }
 
-void GpuIndexFlat::copyTo(faiss::IndexFlat* index) const {
+void GpuIndexFlat::copyTo(knowherefaiss::IndexFlat* index) const {
     DeviceScope scope(config_.device);
 
     GpuIndex::copyTo(index);
@@ -374,13 +374,13 @@ void GpuIndexFlat::compute_residual_n(
 
 GpuIndexFlatL2::GpuIndexFlatL2(
         GpuResourcesProvider* provider,
-        faiss::IndexFlatL2* index,
+        knowherefaiss::IndexFlatL2* index,
         GpuIndexFlatConfig config)
         : GpuIndexFlat(provider, index, config) {}
 
 GpuIndexFlatL2::GpuIndexFlatL2(
         std::shared_ptr<GpuResources> resources,
-        faiss::IndexFlatL2* index,
+        knowherefaiss::IndexFlatL2* index,
         GpuIndexFlatConfig config)
         : GpuIndexFlat(resources, index, config) {}
 
@@ -388,15 +388,15 @@ GpuIndexFlatL2::GpuIndexFlatL2(
         GpuResourcesProvider* provider,
         int dims,
         GpuIndexFlatConfig config)
-        : GpuIndexFlat(provider, dims, faiss::METRIC_L2, config) {}
+        : GpuIndexFlat(provider, dims, knowherefaiss::METRIC_L2, config) {}
 
 GpuIndexFlatL2::GpuIndexFlatL2(
         std::shared_ptr<GpuResources> resources,
         int dims,
         GpuIndexFlatConfig config)
-        : GpuIndexFlat(resources, dims, faiss::METRIC_L2, config) {}
+        : GpuIndexFlat(resources, dims, knowherefaiss::METRIC_L2, config) {}
 
-void GpuIndexFlatL2::copyFrom(faiss::IndexFlat* index) {
+void GpuIndexFlatL2::copyFrom(knowherefaiss::IndexFlat* index) {
     FAISS_THROW_IF_NOT_MSG(
             index->metric_type == metric_type,
             "Cannot copy a GpuIndexFlatL2 from an index of "
@@ -405,7 +405,7 @@ void GpuIndexFlatL2::copyFrom(faiss::IndexFlat* index) {
     GpuIndexFlat::copyFrom(index);
 }
 
-void GpuIndexFlatL2::copyTo(faiss::IndexFlat* index) {
+void GpuIndexFlatL2::copyTo(knowherefaiss::IndexFlat* index) {
     FAISS_THROW_IF_NOT_MSG(
             index->metric_type == metric_type,
             "Cannot copy a GpuIndexFlatL2 to an index of "
@@ -420,13 +420,13 @@ void GpuIndexFlatL2::copyTo(faiss::IndexFlat* index) {
 
 GpuIndexFlatIP::GpuIndexFlatIP(
         GpuResourcesProvider* provider,
-        faiss::IndexFlatIP* index,
+        knowherefaiss::IndexFlatIP* index,
         GpuIndexFlatConfig config)
         : GpuIndexFlat(provider, index, config) {}
 
 GpuIndexFlatIP::GpuIndexFlatIP(
         std::shared_ptr<GpuResources> resources,
-        faiss::IndexFlatIP* index,
+        knowherefaiss::IndexFlatIP* index,
         GpuIndexFlatConfig config)
         : GpuIndexFlat(resources, index, config) {}
 
@@ -434,15 +434,15 @@ GpuIndexFlatIP::GpuIndexFlatIP(
         GpuResourcesProvider* provider,
         int dims,
         GpuIndexFlatConfig config)
-        : GpuIndexFlat(provider, dims, faiss::METRIC_INNER_PRODUCT, config) {}
+        : GpuIndexFlat(provider, dims, knowherefaiss::METRIC_INNER_PRODUCT, config) {}
 
 GpuIndexFlatIP::GpuIndexFlatIP(
         std::shared_ptr<GpuResources> resources,
         int dims,
         GpuIndexFlatConfig config)
-        : GpuIndexFlat(resources, dims, faiss::METRIC_INNER_PRODUCT, config) {}
+        : GpuIndexFlat(resources, dims, knowherefaiss::METRIC_INNER_PRODUCT, config) {}
 
-void GpuIndexFlatIP::copyFrom(faiss::IndexFlat* index) {
+void GpuIndexFlatIP::copyFrom(knowherefaiss::IndexFlat* index) {
     FAISS_THROW_IF_NOT_MSG(
             index->metric_type == metric_type,
             "Cannot copy a GpuIndexFlatIP from an index of "
@@ -451,7 +451,7 @@ void GpuIndexFlatIP::copyFrom(faiss::IndexFlat* index) {
     GpuIndexFlat::copyFrom(index);
 }
 
-void GpuIndexFlatIP::copyTo(faiss::IndexFlat* index) {
+void GpuIndexFlatIP::copyTo(knowherefaiss::IndexFlat* index) {
     // The passed in index must be IP
     FAISS_THROW_IF_NOT_MSG(
             index->metric_type == metric_type,
@@ -462,4 +462,4 @@ void GpuIndexFlatIP::copyTo(faiss::IndexFlat* index) {
 }
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/GpuIndexFlat.h b/thirdparty/faiss/knowherefaiss/gpu/GpuIndexFlat.h
similarity index 81%
rename from thirdparty/faiss/faiss/gpu/GpuIndexFlat.h
rename to thirdparty/faiss/knowherefaiss/gpu/GpuIndexFlat.h
index 87008bf4..1892f2f4 100644
--- a/thirdparty/faiss/faiss/gpu/GpuIndexFlat.h
+++ b/thirdparty/faiss/knowherefaiss/gpu/GpuIndexFlat.h
@@ -7,18 +7,18 @@
 
 #pragma once
 
-#include <faiss/gpu/GpuIndex.h>
+#include <knowherefaiss/gpu/GpuIndex.h>
 #include <memory>
 
-namespace faiss {
+namespace knowherefaiss {
 
 struct IndexFlat;
 struct IndexFlatL2;
 struct IndexFlatIP;
 
-} // namespace faiss
+} // namespace knowherefaiss
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 class FlatIndex;
@@ -44,44 +44,44 @@ struct GpuIndexFlatConfig : public GpuIndexConfig {
 };
 
 /// Wrapper around the GPU implementation that looks like
-/// faiss::IndexFlat; copies over centroid data from a given
-/// faiss::IndexFlat
+/// knowherefaiss::IndexFlat; copies over centroid data from a given
+/// knowherefaiss::IndexFlat
 class GpuIndexFlat : public GpuIndex {
    public:
-    /// Construct from a pre-existing faiss::IndexFlat instance, copying
+    /// Construct from a pre-existing knowherefaiss::IndexFlat instance, copying
     /// data over to the given GPU
     GpuIndexFlat(
             GpuResourcesProvider* provider,
-            const faiss::IndexFlat* index,
+            const knowherefaiss::IndexFlat* index,
             GpuIndexFlatConfig config = GpuIndexFlatConfig());
 
     GpuIndexFlat(
             std::shared_ptr<GpuResources> resources,
-            const faiss::IndexFlat* index,
+            const knowherefaiss::IndexFlat* index,
             GpuIndexFlatConfig config = GpuIndexFlatConfig());
 
     /// Construct an empty instance that can be added to
     GpuIndexFlat(
             GpuResourcesProvider* provider,
             int dims,
-            faiss::MetricType metric,
+            knowherefaiss::MetricType metric,
             GpuIndexFlatConfig config = GpuIndexFlatConfig());
 
     GpuIndexFlat(
             std::shared_ptr<GpuResources> resources,
             int dims,
-            faiss::MetricType metric,
+            knowherefaiss::MetricType metric,
             GpuIndexFlatConfig config = GpuIndexFlatConfig());
 
     ~GpuIndexFlat() override;
 
     /// Initialize ourselves from the given CPU index; will overwrite
     /// all data in ourselves
-    void copyFrom(const faiss::IndexFlat* index);
+    void copyFrom(const knowherefaiss::IndexFlat* index);
 
     /// Copy ourselves to the given CPU index; will overwrite all data
     /// in the index instance
-    void copyTo(faiss::IndexFlat* index) const;
+    void copyTo(knowherefaiss::IndexFlat* index) const;
 
     /// Returns the number of vectors we contain
     size_t getNumVecs() const;
@@ -159,20 +159,20 @@ class GpuIndexFlat : public GpuIndex {
 };
 
 /// Wrapper around the GPU implementation that looks like
-/// faiss::IndexFlatL2; copies over centroid data from a given
-/// faiss::IndexFlat
+/// knowherefaiss::IndexFlatL2; copies over centroid data from a given
+/// knowherefaiss::IndexFlat
 class GpuIndexFlatL2 : public GpuIndexFlat {
    public:
-    /// Construct from a pre-existing faiss::IndexFlatL2 instance, copying
+    /// Construct from a pre-existing knowherefaiss::IndexFlatL2 instance, copying
     /// data over to the given GPU
     GpuIndexFlatL2(
             GpuResourcesProvider* provider,
-            faiss::IndexFlatL2* index,
+            knowherefaiss::IndexFlatL2* index,
             GpuIndexFlatConfig config = GpuIndexFlatConfig());
 
     GpuIndexFlatL2(
             std::shared_ptr<GpuResources> resources,
-            faiss::IndexFlatL2* index,
+            knowherefaiss::IndexFlatL2* index,
             GpuIndexFlatConfig config = GpuIndexFlatConfig());
 
     /// Construct an empty instance that can be added to
@@ -188,28 +188,28 @@ class GpuIndexFlatL2 : public GpuIndexFlat {
 
     /// Initialize ourselves from the given CPU index; will overwrite
     /// all data in ourselves
-    void copyFrom(faiss::IndexFlat* index);
+    void copyFrom(knowherefaiss::IndexFlat* index);
 
     /// Copy ourselves to the given CPU index; will overwrite all data
     /// in the index instance
-    void copyTo(faiss::IndexFlat* index);
+    void copyTo(knowherefaiss::IndexFlat* index);
 };
 
 /// Wrapper around the GPU implementation that looks like
-/// faiss::IndexFlatIP; copies over centroid data from a given
-/// faiss::IndexFlat
+/// knowherefaiss::IndexFlatIP; copies over centroid data from a given
+/// knowherefaiss::IndexFlat
 class GpuIndexFlatIP : public GpuIndexFlat {
    public:
-    /// Construct from a pre-existing faiss::IndexFlatIP instance, copying
+    /// Construct from a pre-existing knowherefaiss::IndexFlatIP instance, copying
     /// data over to the given GPU
     GpuIndexFlatIP(
             GpuResourcesProvider* provider,
-            faiss::IndexFlatIP* index,
+            knowherefaiss::IndexFlatIP* index,
             GpuIndexFlatConfig config = GpuIndexFlatConfig());
 
     GpuIndexFlatIP(
             std::shared_ptr<GpuResources> resources,
-            faiss::IndexFlatIP* index,
+            knowherefaiss::IndexFlatIP* index,
             GpuIndexFlatConfig config = GpuIndexFlatConfig());
 
     /// Construct an empty instance that can be added to
@@ -225,12 +225,12 @@ class GpuIndexFlatIP : public GpuIndexFlat {
 
     /// Initialize ourselves from the given CPU index; will overwrite
     /// all data in ourselves
-    void copyFrom(faiss::IndexFlat* index);
+    void copyFrom(knowherefaiss::IndexFlat* index);
 
     /// Copy ourselves to the given CPU index; will overwrite all data
     /// in the index instance
-    void copyTo(faiss::IndexFlat* index);
+    void copyTo(knowherefaiss::IndexFlat* index);
 };
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/GpuIndexIVF.cu b/thirdparty/faiss/knowherefaiss/gpu/GpuIndexIVF.cu
similarity index 83%
rename from thirdparty/faiss/faiss/gpu/GpuIndexIVF.cu
rename to thirdparty/faiss/knowherefaiss/gpu/GpuIndexIVF.cu
index 8b404b0f..5298813e 100644
--- a/thirdparty/faiss/faiss/gpu/GpuIndexIVF.cu
+++ b/thirdparty/faiss/knowherefaiss/gpu/GpuIndexIVF.cu
@@ -5,21 +5,21 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/IndexFlat.h>
-#include <faiss/IndexIVF.h>
-#include <faiss/gpu/GpuIndexFlat.h>
-#include <faiss/gpu/GpuIndexIVF.h>
-#include <faiss/gpu/utils/DeviceUtils.h>
-#include <faiss/impl/FaissAssert.h>
-#include <faiss/gpu/utils/Float16.cuh>
-
-namespace faiss {
+#include <knowherefaiss/IndexFlat.h>
+#include <knowherefaiss/IndexIVF.h>
+#include <knowherefaiss/gpu/GpuIndexFlat.h>
+#include <knowherefaiss/gpu/GpuIndexIVF.h>
+#include <knowherefaiss/gpu/utils/DeviceUtils.h>
+#include <knowherefaiss/impl/FaissAssert.h>
+#include <knowherefaiss/gpu/utils/Float16.cuh>
+
+namespace knowherefaiss {
 namespace gpu {
 
 GpuIndexIVF::GpuIndexIVF(
         GpuResourcesProvider* provider,
         int dims,
-        faiss::MetricType metric,
+        knowherefaiss::MetricType metric,
         float metricArg,
         int nlistIn,
         GpuIndexIVFConfig config)
@@ -31,8 +31,8 @@ GpuIndexIVF::GpuIndexIVF(
     init_();
 
     // Only IP and L2 are supported for now
-    if (!(metric_type == faiss::METRIC_L2 ||
-          metric_type == faiss::METRIC_INNER_PRODUCT)) {
+    if (!(metric_type == knowherefaiss::METRIC_L2 ||
+          metric_type == knowherefaiss::METRIC_INNER_PRODUCT)) {
         FAISS_THROW_FMT("unsupported metric type %d", (int)metric_type);
     }
 }
@@ -41,7 +41,7 @@ void GpuIndexIVF::init_() {
     FAISS_THROW_IF_NOT_MSG(nlist > 0, "nlist must be > 0");
 
     // Spherical by default if the metric is inner_product
-    if (metric_type == faiss::METRIC_INNER_PRODUCT) {
+    if (metric_type == knowherefaiss::METRIC_INNER_PRODUCT) {
         cp.spherical = true;
     }
 
@@ -56,9 +56,9 @@ void GpuIndexIVF::init_() {
         // FIXME: inherit our same device
         config.device = config_.device;
 
-        if (metric_type == faiss::METRIC_L2) {
+        if (metric_type == knowherefaiss::METRIC_L2) {
             quantizer = new GpuIndexFlatL2(resources_, d, config);
-        } else if (metric_type == faiss::METRIC_INNER_PRODUCT) {
+        } else if (metric_type == knowherefaiss::METRIC_INNER_PRODUCT) {
             quantizer = new GpuIndexFlatIP(resources_, d, config);
         } else {
             // unknown metric type
@@ -77,7 +77,7 @@ GpuIndexFlat* GpuIndexIVF::getQuantizer() {
     return quantizer;
 }
 
-void GpuIndexIVF::copyFrom(const faiss::IndexIVF* index) {
+void GpuIndexIVF::copyFrom(const knowherefaiss::IndexIVF* index) {
     DeviceScope scope(config_.device);
 
     GpuIndex::copyFrom(index);
@@ -106,10 +106,10 @@ void GpuIndexIVF::copyFrom(const faiss::IndexIVF* index) {
     // FIXME: inherit our same device
     config.device = config_.device;
 
-    if (index->metric_type == faiss::METRIC_L2) {
+    if (index->metric_type == knowherefaiss::METRIC_L2) {
         // FIXME: 2 different float16 options?
         quantizer = new GpuIndexFlatL2(resources_, this->d, config);
-    } else if (index->metric_type == faiss::METRIC_INNER_PRODUCT) {
+    } else if (index->metric_type == knowherefaiss::METRIC_INNER_PRODUCT) {
         // FIXME: 2 different float16 options?
         quantizer = new GpuIndexFlatIP(resources_, this->d, config);
     } else {
@@ -132,7 +132,7 @@ void GpuIndexIVF::copyFrom(const faiss::IndexIVF* index) {
     FAISS_ASSERT(index->quantizer->ntotal > 0);
 
     // Right now, we can only handle IndexFlat or derived classes
-    auto qFlat = dynamic_cast<faiss::IndexFlat*>(index->quantizer);
+    auto qFlat = dynamic_cast<knowherefaiss::IndexFlat*>(index->quantizer);
     FAISS_THROW_IF_NOT_MSG(
             qFlat,
             "Only IndexFlat is supported for the coarse quantizer "
@@ -142,7 +142,7 @@ void GpuIndexIVF::copyFrom(const faiss::IndexIVF* index) {
 }
 
 void GpuIndexIVF::copyFrom(
-        faiss::IndexIVF* index,
+        knowherefaiss::IndexIVF* index,
         gpu::GpuIndexFlat*& qt,
         int64_t mode) {
     DeviceScope scope(config_.device);
@@ -176,10 +176,10 @@ void GpuIndexIVF::copyFrom(
     config.storeInCpu = true;
 
     if (qt == nullptr) {
-        if (index->metric_type == faiss::METRIC_L2) {
+        if (index->metric_type == knowherefaiss::METRIC_L2) {
             // FIXME: 2 different float16 options?
             quantizer = new GpuIndexFlatL2(resources_, this->d, config);
-        } else if (index->metric_type == faiss::METRIC_INNER_PRODUCT) {
+        } else if (index->metric_type == knowherefaiss::METRIC_INNER_PRODUCT) {
             // FIXME: 2 different float16 options?
             quantizer = new GpuIndexFlatIP(resources_, this->d, config);
         } else {
@@ -209,7 +209,7 @@ void GpuIndexIVF::copyFrom(
 
     if (qt == nullptr) {
         // Right now, we can only handle IndexFlat or derived classes
-        auto qFlat = dynamic_cast<faiss::IndexFlat*>(index->quantizer);
+        auto qFlat = dynamic_cast<knowherefaiss::IndexFlat*>(index->quantizer);
         FAISS_THROW_IF_NOT_MSG(
                 qFlat,
                 "Only IndexFlat is supported for the coarse quantizer "
@@ -222,7 +222,7 @@ void GpuIndexIVF::copyFrom(
     remove_quantizer = 0;
 }
 
-void GpuIndexIVF::copyTo(faiss::IndexIVF* index) const {
+void GpuIndexIVF::copyTo(knowherefaiss::IndexIVF* index) const {
     DeviceScope scope(config_.device);
 
     //
@@ -237,13 +237,13 @@ void GpuIndexIVF::copyTo(faiss::IndexIVF* index) const {
     index->nprobe = nprobe;
 
     // Construct and copy the appropriate quantizer
-    faiss::IndexFlat* q = nullptr;
+    knowherefaiss::IndexFlat* q = nullptr;
 
-    if (this->metric_type == faiss::METRIC_L2) {
-        q = new faiss::IndexFlatL2(this->d);
+    if (this->metric_type == knowherefaiss::METRIC_L2) {
+        q = new knowherefaiss::IndexFlatL2(this->d);
 
-    } else if (this->metric_type == faiss::METRIC_INNER_PRODUCT) {
-        q = new faiss::IndexFlatIP(this->d);
+    } else if (this->metric_type == knowherefaiss::METRIC_INNER_PRODUCT) {
+        q = new knowherefaiss::IndexFlatIP(this->d);
 
     } else {
         // we should have one of the above metrics
@@ -318,4 +318,4 @@ void GpuIndexIVF::trainQuantizer_(Index::idx_t n, const float* x) {
 }
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/GpuIndexIVF.h b/thirdparty/faiss/knowherefaiss/gpu/GpuIndexIVF.h
similarity index 84%
rename from thirdparty/faiss/faiss/gpu/GpuIndexIVF.h
rename to thirdparty/faiss/knowherefaiss/gpu/GpuIndexIVF.h
index 2a3118da..d9bb50c3 100644
--- a/thirdparty/faiss/faiss/gpu/GpuIndexIVF.h
+++ b/thirdparty/faiss/knowherefaiss/gpu/GpuIndexIVF.h
@@ -7,16 +7,16 @@
 
 #pragma once
 
-#include <faiss/Clustering.h>
-#include <faiss/gpu/GpuIndex.h>
-#include <faiss/gpu/GpuIndexFlat.h>
-#include <faiss/gpu/GpuIndicesOptions.h>
+#include <knowherefaiss/Clustering.h>
+#include <knowherefaiss/gpu/GpuIndex.h>
+#include <knowherefaiss/gpu/GpuIndexFlat.h>
+#include <knowherefaiss/gpu/GpuIndicesOptions.h>
 
-namespace faiss {
+namespace knowherefaiss {
 struct IndexIVF;
 }
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 class GpuIndexFlat;
@@ -36,7 +36,7 @@ class GpuIndexIVF : public GpuIndex {
     GpuIndexIVF(
             GpuResourcesProvider* provider,
             int dims,
-            faiss::MetricType metric,
+            knowherefaiss::MetricType metric,
             float metricArg,
             int nlist,
             GpuIndexIVFConfig config = GpuIndexIVFConfig());
@@ -49,12 +49,12 @@ class GpuIndexIVF : public GpuIndex {
 
    public:
     /// Copy what we need from the CPU equivalent
-    void copyFrom(const faiss::IndexIVF* index);
+    void copyFrom(const knowherefaiss::IndexIVF* index);
 
-    void copyFrom(faiss::IndexIVF* index, gpu::GpuIndexFlat*& qt, int64_t mode);
+    void copyFrom(knowherefaiss::IndexIVF* index, gpu::GpuIndexFlat*& qt, int64_t mode);
 
     /// Copy what we have to the CPU equivalent
-    void copyTo(faiss::IndexIVF* index) const;
+    void copyTo(knowherefaiss::IndexIVF* index) const;
 
     /// Returns the number of inverted lists we're managing
     int getNumLists() const;
@@ -110,4 +110,4 @@ class GpuIndexIVF : public GpuIndex {
 };
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/GpuIndexIVFFlat.cu b/thirdparty/faiss/knowherefaiss/gpu/GpuIndexIVFFlat.cu
similarity index 92%
rename from thirdparty/faiss/faiss/gpu/GpuIndexIVFFlat.cu
rename to thirdparty/faiss/knowherefaiss/gpu/GpuIndexIVFFlat.cu
index 9bddb27e..bd025f5b 100644
--- a/thirdparty/faiss/faiss/gpu/GpuIndexIVFFlat.cu
+++ b/thirdparty/faiss/knowherefaiss/gpu/GpuIndexIVFFlat.cu
@@ -5,24 +5,24 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/IndexFlat.h>
-#include <faiss/IndexIVFFlat.h>
-#include <faiss/gpu/GpuIndexFlat.h>
-#include <faiss/gpu/GpuIndexIVFFlat.h>
-#include <faiss/gpu/GpuResources.h>
-#include <faiss/gpu/utils/DeviceUtils.h>
-#include <faiss/gpu/impl/IVFFlat.cuh>
-#include <faiss/gpu/utils/CopyUtils.cuh>
-#include <faiss/gpu/utils/Float16.cuh>
+#include <knowherefaiss/IndexFlat.h>
+#include <knowherefaiss/IndexIVFFlat.h>
+#include <knowherefaiss/gpu/GpuIndexFlat.h>
+#include <knowherefaiss/gpu/GpuIndexIVFFlat.h>
+#include <knowherefaiss/gpu/GpuResources.h>
+#include <knowherefaiss/gpu/utils/DeviceUtils.h>
+#include <knowherefaiss/gpu/impl/IVFFlat.cuh>
+#include <knowherefaiss/gpu/utils/CopyUtils.cuh>
+#include <knowherefaiss/gpu/utils/Float16.cuh>
 
 #include <limits>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 GpuIndexIVFFlat::GpuIndexIVFFlat(
         GpuResourcesProvider* provider,
-        const faiss::IndexIVFFlat* index,
+        const knowherefaiss::IndexIVFFlat* index,
         GpuIndexIVFFlatConfig config)
         : GpuIndexIVF(
                   provider,
@@ -40,12 +40,12 @@ GpuIndexIVFFlat::GpuIndexIVFFlat(
         GpuResourcesProvider* provider,
         int dims,
         int nlist,
-        faiss::MetricType metric,
+        knowherefaiss::MetricType metric,
         GpuIndexIVFFlatConfig config)
         : GpuIndexIVF(provider, dims, metric, 0, nlist, config),
           ivfFlatConfig_(config),
           reserveMemoryVecs_(0) {
-    // faiss::Index params
+    // knowherefaiss::Index params
     this->is_trained = false;
 
     // We haven't trained ourselves, so don't construct the IVFFlat
@@ -62,7 +62,7 @@ void GpuIndexIVFFlat::reserveMemory(size_t numVecs) {
     }
 }
 
-void GpuIndexIVFFlat::copyFrom(const faiss::IndexIVFFlat* index) {
+void GpuIndexIVFFlat::copyFrom(const knowherefaiss::IndexIVFFlat* index) {
     DeviceScope scope(config_.device);
 
     GpuIndexIVF::copyFrom(index);
@@ -103,7 +103,7 @@ void GpuIndexIVFFlat::copyFrom(const faiss::IndexIVFFlat* index) {
     }
 }
 
-void GpuIndexIVFFlat::copyTo(faiss::IndexIVFFlat* index) const {
+void GpuIndexIVFFlat::copyTo(knowherefaiss::IndexIVFFlat* index) const {
     DeviceScope scope(config_.device);
 
     // We must have the indices in order to copy to ourselves
@@ -339,4 +339,4 @@ void GpuIndexIVFFlat::searchThreadSafeImpl_(
 }
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/GpuIndexIVFFlat.h b/thirdparty/faiss/knowherefaiss/gpu/GpuIndexIVFFlat.h
similarity index 88%
rename from thirdparty/faiss/faiss/gpu/GpuIndexIVFFlat.h
rename to thirdparty/faiss/knowherefaiss/gpu/GpuIndexIVFFlat.h
index a78a92df..45d03a44 100644
--- a/thirdparty/faiss/faiss/gpu/GpuIndexIVFFlat.h
+++ b/thirdparty/faiss/knowherefaiss/gpu/GpuIndexIVFFlat.h
@@ -7,14 +7,14 @@
 
 #pragma once
 
-#include <faiss/gpu/GpuIndexIVF.h>
+#include <knowherefaiss/gpu/GpuIndexIVF.h>
 #include <memory>
 
-namespace faiss {
+namespace knowherefaiss {
 struct IndexIVFFlat;
 }
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 class IVFFlat;
@@ -29,14 +29,14 @@ struct GpuIndexIVFFlatConfig : public GpuIndexIVFConfig {
 };
 
 /// Wrapper around the GPU implementation that looks like
-/// faiss::IndexIVFFlat
+/// knowherefaiss::IndexIVFFlat
 class GpuIndexIVFFlat : public GpuIndexIVF {
    public:
-    /// Construct from a pre-existing faiss::IndexIVFFlat instance, copying
+    /// Construct from a pre-existing knowherefaiss::IndexIVFFlat instance, copying
     /// data over to the given GPU, if the input index is trained.
     GpuIndexIVFFlat(
             GpuResourcesProvider* provider,
-            const faiss::IndexIVFFlat* index,
+            const knowherefaiss::IndexIVFFlat* index,
             GpuIndexIVFFlatConfig config = GpuIndexIVFFlatConfig());
 
     /// Constructs a new instance with an empty flat quantizer; the user
@@ -45,7 +45,7 @@ class GpuIndexIVFFlat : public GpuIndexIVF {
             GpuResourcesProvider* provider,
             int dims,
             int nlist,
-            faiss::MetricType metric,
+            knowherefaiss::MetricType metric,
             GpuIndexIVFFlatConfig config = GpuIndexIVFFlatConfig());
 
     ~GpuIndexIVFFlat() override;
@@ -55,11 +55,11 @@ class GpuIndexIVFFlat : public GpuIndexIVF {
 
     /// Initialize ourselves from the given CPU index; will overwrite
     /// all data in ourselves
-    void copyFrom(const faiss::IndexIVFFlat* index);
+    void copyFrom(const knowherefaiss::IndexIVFFlat* index);
 
     /// Copy ourselves to the given CPU index; will overwrite all data
     /// in the index instance
-    void copyTo(faiss::IndexIVFFlat* index) const;
+    void copyTo(knowherefaiss::IndexIVFFlat* index) const;
 
     /// After adding vectors, one can call this to reclaim device memory
     /// to exactly the amount needed. Returns space reclaimed in bytes
@@ -122,4 +122,4 @@ class GpuIndexIVFFlat : public GpuIndexIVF {
 };
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/GpuIndexIVFPQ.cu b/thirdparty/faiss/knowherefaiss/gpu/GpuIndexIVFPQ.cu
similarity index 94%
rename from thirdparty/faiss/faiss/gpu/GpuIndexIVFPQ.cu
rename to thirdparty/faiss/knowherefaiss/gpu/GpuIndexIVFPQ.cu
index 49375f6f..b8d3900d 100644
--- a/thirdparty/faiss/faiss/gpu/GpuIndexIVFPQ.cu
+++ b/thirdparty/faiss/knowherefaiss/gpu/GpuIndexIVFPQ.cu
@@ -5,24 +5,24 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/IndexFlat.h>
-#include <faiss/IndexIVFPQ.h>
-#include <faiss/gpu/GpuIndexFlat.h>
-#include <faiss/gpu/GpuIndexIVFPQ.h>
-#include <faiss/gpu/GpuResources.h>
-#include <faiss/gpu/utils/DeviceUtils.h>
-#include <faiss/utils/utils.h>
-#include <faiss/gpu/impl/IVFPQ.cuh>
-#include <faiss/gpu/utils/CopyUtils.cuh>
+#include <knowherefaiss/IndexFlat.h>
+#include <knowherefaiss/IndexIVFPQ.h>
+#include <knowherefaiss/gpu/GpuIndexFlat.h>
+#include <knowherefaiss/gpu/GpuIndexIVFPQ.h>
+#include <knowherefaiss/gpu/GpuResources.h>
+#include <knowherefaiss/gpu/utils/DeviceUtils.h>
+#include <knowherefaiss/utils/utils.h>
+#include <knowherefaiss/gpu/impl/IVFPQ.cuh>
+#include <knowherefaiss/gpu/utils/CopyUtils.cuh>
 
 #include <limits>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 GpuIndexIVFPQ::GpuIndexIVFPQ(
         GpuResourcesProvider* provider,
-        const faiss::IndexIVFPQ* index,
+        const knowherefaiss::IndexIVFPQ* index,
         GpuIndexIVFPQConfig config)
         : GpuIndexIVF(
                   provider,
@@ -46,7 +46,7 @@ GpuIndexIVFPQ::GpuIndexIVFPQ(
         int nlist,
         int subQuantizers,
         int bitsPerCode,
-        faiss::MetricType metric,
+        knowherefaiss::MetricType metric,
         GpuIndexIVFPQConfig config)
         : GpuIndexIVF(provider, dims, metric, 0, nlist, config),
           pq(dims, subQuantizers, bitsPerCode),
@@ -63,7 +63,7 @@ GpuIndexIVFPQ::GpuIndexIVFPQ(
 
 GpuIndexIVFPQ::~GpuIndexIVFPQ() {}
 
-void GpuIndexIVFPQ::copyFrom(const faiss::IndexIVFPQ* index) {
+void GpuIndexIVFPQ::copyFrom(const knowherefaiss::IndexIVFPQ* index) {
     DeviceScope scope(config_.device);
 
     GpuIndexIVF::copyFrom(index);
@@ -116,7 +116,7 @@ void GpuIndexIVFPQ::copyFrom(const faiss::IndexIVFPQ* index) {
     index_->copyInvertedListsFrom(index->invlists);
 }
 
-void GpuIndexIVFPQ::copyTo(faiss::IndexIVFPQ* index) const {
+void GpuIndexIVFPQ::copyTo(knowherefaiss::IndexIVFPQ* index) const {
     DeviceScope scope(config_.device);
 
     // We must have the indices in order to copy to ourselves
@@ -133,7 +133,7 @@ void GpuIndexIVFPQ::copyTo(faiss::IndexIVFPQ* index) const {
     index->by_residual = true;
     index->use_precomputed_table = 0;
     index->code_size = subQuantizers_;
-    index->pq = faiss::ProductQuantizer(this->d, subQuantizers_, bitsPerCode_);
+    index->pq = knowherefaiss::ProductQuantizer(this->d, subQuantizers_, bitsPerCode_);
 
     index->do_polysemous_training = false;
     index->polysemous_training = nullptr;
@@ -220,7 +220,7 @@ void GpuIndexIVFPQ::reset() {
 }
 
 void GpuIndexIVFPQ::trainResidualQuantizer_(Index::idx_t n, const float* x) {
-    // Code largely copied from faiss::IndexIVFPQ
+    // Code largely copied from knowherefaiss::IndexIVFPQ
     auto x_in = x;
 
     x = fvecs_maybe_subsample(
@@ -537,4 +537,4 @@ void GpuIndexIVFPQ::verifySettings_() const {
 }
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/GpuIndexIVFPQ.h b/thirdparty/faiss/knowherefaiss/gpu/GpuIndexIVFPQ.h
similarity index 92%
rename from thirdparty/faiss/faiss/gpu/GpuIndexIVFPQ.h
rename to thirdparty/faiss/knowherefaiss/gpu/GpuIndexIVFPQ.h
index 035694a1..0449aed9 100644
--- a/thirdparty/faiss/faiss/gpu/GpuIndexIVFPQ.h
+++ b/thirdparty/faiss/knowherefaiss/gpu/GpuIndexIVFPQ.h
@@ -7,16 +7,16 @@
 
 #pragma once
 
-#include <faiss/gpu/GpuIndexIVF.h>
-#include <faiss/impl/ProductQuantizer.h>
+#include <knowherefaiss/gpu/GpuIndexIVF.h>
+#include <knowherefaiss/impl/ProductQuantizer.h>
 #include <memory>
 #include <vector>
 
-namespace faiss {
+namespace knowherefaiss {
 struct IndexIVFPQ;
 }
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 class GpuIndexFlat;
@@ -56,11 +56,11 @@ struct GpuIndexIVFPQConfig : public GpuIndexIVFConfig {
 /// IVFPQ index for the GPU
 class GpuIndexIVFPQ : public GpuIndexIVF {
    public:
-    /// Construct from a pre-existing faiss::IndexIVFPQ instance, copying
+    /// Construct from a pre-existing knowherefaiss::IndexIVFPQ instance, copying
     /// data over to the given GPU, if the input index is trained.
     GpuIndexIVFPQ(
             GpuResourcesProvider* provider,
-            const faiss::IndexIVFPQ* index,
+            const knowherefaiss::IndexIVFPQ* index,
             GpuIndexIVFPQConfig config = GpuIndexIVFPQConfig());
 
     /// Construct an empty index
@@ -70,7 +70,7 @@ class GpuIndexIVFPQ : public GpuIndexIVF {
             int nlist,
             int subQuantizers,
             int bitsPerCode,
-            faiss::MetricType metric,
+            knowherefaiss::MetricType metric,
             GpuIndexIVFPQConfig config = GpuIndexIVFPQConfig());
 
     ~GpuIndexIVFPQ() override;
@@ -80,11 +80,11 @@ class GpuIndexIVFPQ : public GpuIndexIVF {
 
     /// Initialize ourselves from the given CPU index; will overwrite
     /// all data in ourselves
-    void copyFrom(const faiss::IndexIVFPQ* index);
+    void copyFrom(const knowherefaiss::IndexIVFPQ* index);
 
     /// Copy ourselves to the given CPU index; will overwrite all data
     /// in the index instance
-    void copyTo(faiss::IndexIVFPQ* index) const;
+    void copyTo(knowherefaiss::IndexIVFPQ* index) const;
 
     /// Reserve GPU memory in our inverted lists for this number of vectors
     void reserveMemory(size_t numVecs);
@@ -186,4 +186,4 @@ class GpuIndexIVFPQ : public GpuIndexIVF {
 };
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/GpuIndexIVFScalarQuantizer.cu b/thirdparty/faiss/knowherefaiss/gpu/GpuIndexIVFScalarQuantizer.cu
similarity index 93%
rename from thirdparty/faiss/faiss/gpu/GpuIndexIVFScalarQuantizer.cu
rename to thirdparty/faiss/knowherefaiss/gpu/GpuIndexIVFScalarQuantizer.cu
index a6aa30ec..a3bda6d9 100644
--- a/thirdparty/faiss/faiss/gpu/GpuIndexIVFScalarQuantizer.cu
+++ b/thirdparty/faiss/knowherefaiss/gpu/GpuIndexIVFScalarQuantizer.cu
@@ -5,21 +5,21 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/gpu/GpuIndexFlat.h>
-#include <faiss/gpu/GpuIndexIVFScalarQuantizer.h>
-#include <faiss/gpu/GpuResources.h>
-#include <faiss/gpu/utils/DeviceUtils.h>
-#include <faiss/gpu/impl/GpuScalarQuantizer.cuh>
-#include <faiss/gpu/impl/IVFFlat.cuh>
-#include <faiss/gpu/utils/CopyUtils.cuh>
+#include <knowherefaiss/gpu/GpuIndexFlat.h>
+#include <knowherefaiss/gpu/GpuIndexIVFScalarQuantizer.h>
+#include <knowherefaiss/gpu/GpuResources.h>
+#include <knowherefaiss/gpu/utils/DeviceUtils.h>
+#include <knowherefaiss/gpu/impl/GpuScalarQuantizer.cuh>
+#include <knowherefaiss/gpu/impl/IVFFlat.cuh>
+#include <knowherefaiss/gpu/utils/CopyUtils.cuh>
 #include <limits>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 GpuIndexIVFScalarQuantizer::GpuIndexIVFScalarQuantizer(
         GpuResourcesProvider* provider,
-        const faiss::IndexIVFScalarQuantizer* index,
+        const knowherefaiss::IndexIVFScalarQuantizer* index,
         GpuIndexIVFScalarQuantizerConfig config)
         : GpuIndexIVF(
                   provider,
@@ -42,8 +42,8 @@ GpuIndexIVFScalarQuantizer::GpuIndexIVFScalarQuantizer(
         GpuResourcesProvider* provider,
         int dims,
         int nlist,
-        faiss::QuantizerType qtype,
-        faiss::MetricType metric,
+        knowherefaiss::QuantizerType qtype,
+        knowherefaiss::MetricType metric,
         bool encodeResidual,
         GpuIndexIVFScalarQuantizerConfig config)
         : GpuIndexIVF(provider, dims, metric, 0, nlist, config),
@@ -51,7 +51,7 @@ GpuIndexIVFScalarQuantizer::GpuIndexIVFScalarQuantizer(
           by_residual(encodeResidual),
           ivfSQConfig_(config),
           reserveMemoryVecs_(0) {
-    // faiss::Index params
+    // knowherefaiss::Index params
     this->is_trained = false;
 
     // We haven't trained ourselves, so don't construct the IVFFlat
@@ -71,7 +71,7 @@ void GpuIndexIVFScalarQuantizer::reserveMemory(size_t numVecs) {
 }
 
 void GpuIndexIVFScalarQuantizer::copyFrom(
-        const faiss::IndexIVFScalarQuantizer* index) {
+        const knowherefaiss::IndexIVFScalarQuantizer* index) {
     DeviceScope scope(config_.device);
 
     // Clear out our old data
@@ -116,7 +116,7 @@ void GpuIndexIVFScalarQuantizer::copyFrom(
 }
 
 void GpuIndexIVFScalarQuantizer::copyTo(
-        faiss::IndexIVFScalarQuantizer* index) const {
+        knowherefaiss::IndexIVFScalarQuantizer* index) const {
     DeviceScope scope(config_.device);
 
     // We must have the indices in order to copy to ourselves
@@ -339,4 +339,4 @@ void GpuIndexIVFScalarQuantizer::searchThreadSafeImpl_(
 }
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/GpuIndexIVFScalarQuantizer.h b/thirdparty/faiss/knowherefaiss/gpu/GpuIndexIVFScalarQuantizer.h
similarity index 86%
rename from thirdparty/faiss/faiss/gpu/GpuIndexIVFScalarQuantizer.h
rename to thirdparty/faiss/knowherefaiss/gpu/GpuIndexIVFScalarQuantizer.h
index 356dc5b7..3f9f80aa 100644
--- a/thirdparty/faiss/faiss/gpu/GpuIndexIVFScalarQuantizer.h
+++ b/thirdparty/faiss/knowherefaiss/gpu/GpuIndexIVFScalarQuantizer.h
@@ -7,11 +7,11 @@
 
 #pragma once
 
-#include <faiss/IndexScalarQuantizer.h>
-#include <faiss/gpu/GpuIndexIVF.h>
+#include <knowherefaiss/IndexScalarQuantizer.h>
+#include <knowherefaiss/gpu/GpuIndexIVF.h>
 #include <memory>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 class IVFFlat;
@@ -26,14 +26,14 @@ struct GpuIndexIVFScalarQuantizerConfig : public GpuIndexIVFConfig {
 };
 
 /// Wrapper around the GPU implementation that looks like
-/// faiss::IndexIVFScalarQuantizer
+/// knowherefaiss::IndexIVFScalarQuantizer
 class GpuIndexIVFScalarQuantizer : public GpuIndexIVF {
    public:
-    /// Construct from a pre-existing faiss::IndexIVFScalarQuantizer instance,
+    /// Construct from a pre-existing knowherefaiss::IndexIVFScalarQuantizer instance,
     /// copying data over to the given GPU, if the input index is trained.
     GpuIndexIVFScalarQuantizer(
             GpuResourcesProvider* provider,
-            const faiss::IndexIVFScalarQuantizer* index,
+            const knowherefaiss::IndexIVFScalarQuantizer* index,
             GpuIndexIVFScalarQuantizerConfig config =
                     GpuIndexIVFScalarQuantizerConfig());
 
@@ -43,8 +43,8 @@ class GpuIndexIVFScalarQuantizer : public GpuIndexIVF {
             GpuResourcesProvider* provider,
             int dims,
             int nlist,
-            faiss::QuantizerType qtype,
-            faiss::MetricType metric = MetricType::METRIC_L2,
+            knowherefaiss::QuantizerType qtype,
+            knowherefaiss::MetricType metric = MetricType::METRIC_L2,
             bool encodeResidual = true,
             GpuIndexIVFScalarQuantizerConfig config =
                     GpuIndexIVFScalarQuantizerConfig());
@@ -56,11 +56,11 @@ class GpuIndexIVFScalarQuantizer : public GpuIndexIVF {
 
     /// Initialize ourselves from the given CPU index; will overwrite
     /// all data in ourselves
-    void copyFrom(const faiss::IndexIVFScalarQuantizer* index);
+    void copyFrom(const knowherefaiss::IndexIVFScalarQuantizer* index);
 
     /// Copy ourselves to the given CPU index; will overwrite all data
     /// in the index instance
-    void copyTo(faiss::IndexIVFScalarQuantizer* index) const;
+    void copyTo(knowherefaiss::IndexIVFScalarQuantizer* index) const;
 
     /// After adding vectors, one can call this to reclaim device memory
     /// to exactly the amount needed. Returns space reclaimed in bytes
@@ -116,7 +116,7 @@ class GpuIndexIVFScalarQuantizer : public GpuIndexIVF {
 
    public:
     /// Exposed like the CPU version
-    faiss::ScalarQuantizer sq;
+    knowherefaiss::ScalarQuantizer sq;
 
     /// Exposed like the CPU version
     bool by_residual;
@@ -133,4 +133,4 @@ class GpuIndexIVFScalarQuantizer : public GpuIndexIVF {
 };
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/GpuIndexThreadSafe.cu b/thirdparty/faiss/knowherefaiss/gpu/GpuIndexThreadSafe.cu
similarity index 96%
rename from thirdparty/faiss/faiss/gpu/GpuIndexThreadSafe.cu
rename to thirdparty/faiss/knowherefaiss/gpu/GpuIndexThreadSafe.cu
index b21f16a4..bb2e2979 100644
--- a/thirdparty/faiss/faiss/gpu/GpuIndexThreadSafe.cu
+++ b/thirdparty/faiss/knowherefaiss/gpu/GpuIndexThreadSafe.cu
@@ -5,18 +5,18 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/gpu/GpuIndex.h>
-#include <faiss/gpu/GpuResources.h>
-#include <faiss/gpu/utils/DeviceUtils.h>
-#include <faiss/gpu/utils/StaticUtils.h>
-#include <faiss/impl/FaissAssert.h>
-#include <faiss/gpu/utils/CopyUtils.cuh>
+#include <knowherefaiss/gpu/GpuIndex.h>
+#include <knowherefaiss/gpu/GpuResources.h>
+#include <knowherefaiss/gpu/utils/DeviceUtils.h>
+#include <knowherefaiss/gpu/utils/StaticUtils.h>
+#include <knowherefaiss/impl/FaissAssert.h>
+#include <knowherefaiss/gpu/utils/CopyUtils.cuh>
 
 #include <algorithm>
 #include <limits>
 #include <memory>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 /// Size above which we page copies from the CPU to GPU (non-paged
@@ -322,4 +322,4 @@ void GpuIndex::searchThreadSafeFromCpuPaged_(
 }
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/GpuIndicesOptions.h b/thirdparty/faiss/knowherefaiss/gpu/GpuIndicesOptions.h
similarity index 94%
rename from thirdparty/faiss/faiss/gpu/GpuIndicesOptions.h
rename to thirdparty/faiss/knowherefaiss/gpu/GpuIndicesOptions.h
index 2f318ed2..5a1f77f3 100644
--- a/thirdparty/faiss/faiss/gpu/GpuIndicesOptions.h
+++ b/thirdparty/faiss/knowherefaiss/gpu/GpuIndicesOptions.h
@@ -7,7 +7,7 @@
 
 #pragma once
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 /// How user vector index data is stored on the GPU
@@ -28,4 +28,4 @@ enum IndicesOptions {
 };
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/GpuResources.cpp b/thirdparty/faiss/knowherefaiss/gpu/GpuResources.cpp
similarity index 96%
rename from thirdparty/faiss/faiss/gpu/GpuResources.cpp
rename to thirdparty/faiss/knowherefaiss/gpu/GpuResources.cpp
index d8756f4b..4bff9584 100644
--- a/thirdparty/faiss/faiss/gpu/GpuResources.cpp
+++ b/thirdparty/faiss/knowherefaiss/gpu/GpuResources.cpp
@@ -5,11 +5,11 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/gpu/GpuResources.h>
-#include <faiss/gpu/utils/DeviceUtils.h>
+#include <knowherefaiss/gpu/GpuResources.h>
+#include <knowherefaiss/gpu/utils/DeviceUtils.h>
 #include <sstream>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 std::string allocTypeToString(AllocType t) {
@@ -185,4 +185,4 @@ size_t GpuResources::getTempMemoryAvailableCurrentDevice() const {
 GpuResourcesProvider::~GpuResourcesProvider() {}
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/GpuResources.h b/thirdparty/faiss/knowherefaiss/gpu/GpuResources.h
similarity index 98%
rename from thirdparty/faiss/faiss/gpu/GpuResources.h
rename to thirdparty/faiss/knowherefaiss/gpu/GpuResources.h
index bf2f93b2..5f10a1b1 100644
--- a/thirdparty/faiss/faiss/gpu/GpuResources.h
+++ b/thirdparty/faiss/knowherefaiss/gpu/GpuResources.h
@@ -9,12 +9,12 @@
 
 #include <cublas_v2.h>
 #include <cuda_runtime.h>
-#include <faiss/impl/FaissAssert.h>
+#include <knowherefaiss/impl/FaissAssert.h>
 #include <memory>
 #include <utility>
 #include <vector>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 class GpuResources;
@@ -261,4 +261,4 @@ class GpuResourcesProvider {
 };
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/StandardGpuResources.cpp b/thirdparty/faiss/knowherefaiss/gpu/StandardGpuResources.cpp
similarity index 98%
rename from thirdparty/faiss/faiss/gpu/StandardGpuResources.cpp
rename to thirdparty/faiss/knowherefaiss/gpu/StandardGpuResources.cpp
index cdb5ed9f..f9741261 100644
--- a/thirdparty/faiss/faiss/gpu/StandardGpuResources.cpp
+++ b/thirdparty/faiss/knowherefaiss/gpu/StandardGpuResources.cpp
@@ -5,15 +5,15 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/gpu/StandardGpuResources.h>
-#include <faiss/gpu/utils/DeviceUtils.h>
-#include <faiss/gpu/utils/StaticUtils.h>
-#include <faiss/impl/FaissAssert.h>
+#include <knowherefaiss/gpu/StandardGpuResources.h>
+#include <knowherefaiss/gpu/utils/DeviceUtils.h>
+#include <knowherefaiss/gpu/utils/StaticUtils.h>
+#include <knowherefaiss/impl/FaissAssert.h>
 #include <iostream>
 #include <limits>
 #include <sstream>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 namespace {
@@ -613,4 +613,4 @@ void StandardGpuResources::setLogMemoryAllocations(bool enable) {
 }
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/StandardGpuResources.h b/thirdparty/faiss/knowherefaiss/gpu/StandardGpuResources.h
similarity index 97%
rename from thirdparty/faiss/faiss/gpu/StandardGpuResources.h
rename to thirdparty/faiss/knowherefaiss/gpu/StandardGpuResources.h
index d1edfb66..da5a63b2 100644
--- a/thirdparty/faiss/faiss/gpu/StandardGpuResources.h
+++ b/thirdparty/faiss/knowherefaiss/gpu/StandardGpuResources.h
@@ -7,15 +7,15 @@
 
 #pragma once
 
-#include <faiss/gpu/GpuResources.h>
-#include <faiss/gpu/utils/DeviceUtils.h>
-#include <faiss/gpu/utils/StackDeviceMemory.h>
+#include <knowherefaiss/gpu/GpuResources.h>
+#include <knowherefaiss/gpu/utils/DeviceUtils.h>
+#include <knowherefaiss/gpu/utils/StackDeviceMemory.h>
 #include <functional>
 #include <map>
 #include <unordered_map>
 #include <vector>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 /// Standard implementation of the GpuResources object that provides for a
@@ -202,4 +202,4 @@ class StandardGpuResources : public GpuResourcesProvider {
 };
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/impl/BinaryDistance.cu b/thirdparty/faiss/knowherefaiss/gpu/impl/BinaryDistance.cu
similarity index 97%
rename from thirdparty/faiss/faiss/gpu/impl/BinaryDistance.cu
rename to thirdparty/faiss/knowherefaiss/gpu/impl/BinaryDistance.cu
index c3d06ebd..ba30e048 100644
--- a/thirdparty/faiss/faiss/gpu/impl/BinaryDistance.cu
+++ b/thirdparty/faiss/knowherefaiss/gpu/impl/BinaryDistance.cu
@@ -5,12 +5,12 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/gpu/utils/DeviceUtils.h>
-#include <faiss/gpu/utils/DeviceDefs.cuh>
-#include <faiss/gpu/utils/DeviceTensor.cuh>
-#include <faiss/gpu/utils/Select.cuh>
+#include <knowherefaiss/gpu/utils/DeviceUtils.h>
+#include <knowherefaiss/gpu/utils/DeviceDefs.cuh>
+#include <knowherefaiss/gpu/utils/DeviceTensor.cuh>
+#include <knowherefaiss/gpu/utils/Select.cuh>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 // Number of warps that the kernel is instantiated with
@@ -313,4 +313,4 @@ void runBinaryDistance(
 }
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/impl/BinaryDistance.cuh b/thirdparty/faiss/knowherefaiss/gpu/impl/BinaryDistance.cuh
similarity index 84%
rename from thirdparty/faiss/faiss/gpu/impl/BinaryDistance.cuh
rename to thirdparty/faiss/knowherefaiss/gpu/impl/BinaryDistance.cuh
index 2174b481..078fda1d 100644
--- a/thirdparty/faiss/faiss/gpu/impl/BinaryDistance.cuh
+++ b/thirdparty/faiss/knowherefaiss/gpu/impl/BinaryDistance.cuh
@@ -5,9 +5,9 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/gpu/utils/DeviceTensor.cuh>
+#include <knowherefaiss/gpu/utils/DeviceTensor.cuh>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 // Performs brute-force k-NN comparison between `vecs` and `query`, where they
@@ -21,4 +21,4 @@ void runBinaryDistance(
         cudaStream_t stream);
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/impl/BinaryFlatIndex.cu b/thirdparty/faiss/knowherefaiss/gpu/impl/BinaryFlatIndex.cu
similarity index 88%
rename from thirdparty/faiss/faiss/gpu/impl/BinaryFlatIndex.cu
rename to thirdparty/faiss/knowherefaiss/gpu/impl/BinaryFlatIndex.cu
index 584707c8..495f4f62 100644
--- a/thirdparty/faiss/faiss/gpu/impl/BinaryFlatIndex.cu
+++ b/thirdparty/faiss/knowherefaiss/gpu/impl/BinaryFlatIndex.cu
@@ -5,12 +5,12 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/gpu/GpuResources.h>
-#include <faiss/gpu/utils/DeviceUtils.h>
-#include <faiss/gpu/impl/BinaryDistance.cuh>
-#include <faiss/gpu/impl/BinaryFlatIndex.cuh>
+#include <knowherefaiss/gpu/GpuResources.h>
+#include <knowherefaiss/gpu/utils/DeviceUtils.h>
+#include <knowherefaiss/gpu/impl/BinaryDistance.cuh>
+#include <knowherefaiss/gpu/impl/BinaryFlatIndex.cuh>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 BinaryFlatIndex::BinaryFlatIndex(GpuResources* res, int dim, MemorySpace space)
@@ -81,4 +81,4 @@ void BinaryFlatIndex::reset() {
 }
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/impl/BinaryFlatIndex.cuh b/thirdparty/faiss/knowherefaiss/gpu/impl/BinaryFlatIndex.cuh
similarity index 90%
rename from thirdparty/faiss/faiss/gpu/impl/BinaryFlatIndex.cuh
rename to thirdparty/faiss/knowherefaiss/gpu/impl/BinaryFlatIndex.cuh
index ddef54ef..bdea4030 100644
--- a/thirdparty/faiss/faiss/gpu/impl/BinaryFlatIndex.cuh
+++ b/thirdparty/faiss/knowherefaiss/gpu/impl/BinaryFlatIndex.cuh
@@ -7,10 +7,10 @@
 
 #pragma once
 
-#include <faiss/gpu/utils/DeviceTensor.cuh>
-#include <faiss/gpu/utils/DeviceVector.cuh>
+#include <knowherefaiss/gpu/utils/DeviceTensor.cuh>
+#include <knowherefaiss/gpu/utils/DeviceVector.cuh>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 class GpuResources;
@@ -62,4 +62,4 @@ class BinaryFlatIndex {
 };
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/impl/BroadcastSum.cu b/thirdparty/faiss/knowherefaiss/gpu/impl/BroadcastSum.cu
similarity index 97%
rename from thirdparty/faiss/faiss/gpu/impl/BroadcastSum.cu
rename to thirdparty/faiss/knowherefaiss/gpu/impl/BroadcastSum.cu
index 14ddf0ce..17f5488a 100644
--- a/thirdparty/faiss/faiss/gpu/impl/BroadcastSum.cu
+++ b/thirdparty/faiss/knowherefaiss/gpu/impl/BroadcastSum.cu
@@ -5,15 +5,15 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/impl/FaissAssert.h>
+#include <knowherefaiss/impl/FaissAssert.h>
 #include <algorithm>
 
-#include <faiss/gpu/utils/DeviceUtils.h>
-#include <faiss/gpu/utils/StaticUtils.h>
-#include <faiss/gpu/utils/MathOperators.cuh>
-#include <faiss/gpu/utils/Tensor.cuh>
+#include <knowherefaiss/gpu/utils/DeviceUtils.h>
+#include <knowherefaiss/gpu/utils/StaticUtils.h>
+#include <knowherefaiss/gpu/utils/MathOperators.cuh>
+#include <knowherefaiss/gpu/utils/Tensor.cuh>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 template <typename T, int kRowsPerBlock, int kRowUnroll, int kColLoad>
@@ -366,4 +366,4 @@ void runSumAlongRows(
 }
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/impl/BroadcastSum.cuh b/thirdparty/faiss/knowherefaiss/gpu/impl/BroadcastSum.cuh
similarity index 92%
rename from thirdparty/faiss/faiss/gpu/impl/BroadcastSum.cuh
rename to thirdparty/faiss/knowherefaiss/gpu/impl/BroadcastSum.cuh
index 6b62a4b9..0d8a6268 100644
--- a/thirdparty/faiss/faiss/gpu/impl/BroadcastSum.cuh
+++ b/thirdparty/faiss/knowherefaiss/gpu/impl/BroadcastSum.cuh
@@ -7,9 +7,9 @@
 
 #pragma once
 
-#include <faiss/gpu/utils/Tensor.cuh>
+#include <knowherefaiss/gpu/utils/Tensor.cuh>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 // output[x][i] += input[i] for all x
@@ -49,4 +49,4 @@ void runSumAlongRows(
         cudaStream_t stream);
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/impl/Distance.cu b/thirdparty/faiss/knowherefaiss/gpu/impl/Distance.cu
similarity index 96%
rename from thirdparty/faiss/faiss/gpu/impl/Distance.cu
rename to thirdparty/faiss/knowherefaiss/gpu/impl/Distance.cu
index 688b619d..61354fcf 100644
--- a/thirdparty/faiss/faiss/gpu/impl/Distance.cu
+++ b/thirdparty/faiss/knowherefaiss/gpu/impl/Distance.cu
@@ -5,19 +5,19 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/gpu/GpuResources.h>
-#include <faiss/gpu/utils/DeviceUtils.h>
-#include <faiss/impl/AuxIndexStructures.h>
-#include <faiss/impl/FaissAssert.h>
-#include <faiss/gpu/impl/BroadcastSum.cuh>
-#include <faiss/gpu/impl/Distance.cuh>
-#include <faiss/gpu/impl/DistanceUtils.cuh>
-#include <faiss/gpu/impl/L2Norm.cuh>
-#include <faiss/gpu/impl/L2Select.cuh>
-#include <faiss/gpu/utils/BlockSelectKernel.cuh>
-#include <faiss/gpu/utils/DeviceDefs.cuh>
-#include <faiss/gpu/utils/Limits.cuh>
-#include <faiss/gpu/utils/MatrixMult.cuh>
+#include <knowherefaiss/gpu/GpuResources.h>
+#include <knowherefaiss/gpu/utils/DeviceUtils.h>
+#include <knowherefaiss/impl/AuxIndexStructures.h>
+#include <knowherefaiss/impl/FaissAssert.h>
+#include <knowherefaiss/gpu/impl/BroadcastSum.cuh>
+#include <knowherefaiss/gpu/impl/Distance.cuh>
+#include <knowherefaiss/gpu/impl/DistanceUtils.cuh>
+#include <knowherefaiss/gpu/impl/L2Norm.cuh>
+#include <knowherefaiss/gpu/impl/L2Select.cuh>
+#include <knowherefaiss/gpu/utils/BlockSelectKernel.cuh>
+#include <knowherefaiss/gpu/utils/DeviceDefs.cuh>
+#include <knowherefaiss/gpu/utils/Limits.cuh>
+#include <knowherefaiss/gpu/utils/MatrixMult.cuh>
 
 #include <thrust/device_ptr.h>
 #include <thrust/execution_policy.h>
@@ -26,7 +26,7 @@
 #include <algorithm>
 #include <memory>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 template <typename T>
@@ -659,4 +659,4 @@ void runIPDistance(
 }
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/impl/Distance.cuh b/thirdparty/faiss/knowherefaiss/gpu/impl/Distance.cuh
similarity index 86%
rename from thirdparty/faiss/faiss/gpu/impl/Distance.cuh
rename to thirdparty/faiss/knowherefaiss/gpu/impl/Distance.cuh
index 4f040062..9b8c2b29 100644
--- a/thirdparty/faiss/faiss/gpu/impl/Distance.cuh
+++ b/thirdparty/faiss/knowherefaiss/gpu/impl/Distance.cuh
@@ -7,11 +7,11 @@
 
 #pragma once
 
-#include <faiss/gpu/impl/GeneralDistance.cuh>
-#include <faiss/gpu/utils/DeviceTensor.cuh>
-#include <faiss/gpu/utils/Float16.cuh>
+#include <knowherefaiss/gpu/impl/GeneralDistance.cuh>
+#include <knowherefaiss/gpu/utils/DeviceTensor.cuh>
+#include <knowherefaiss/gpu/utils/Float16.cuh>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 class GpuResources;
@@ -134,7 +134,7 @@ void allPairwiseDistanceOnDevice(
         Tensor<float, 1, true>* vectorNorms,
         Tensor<T, 2, true>& queries,
         bool queriesRowMajor,
-        faiss::MetricType metric,
+        knowherefaiss::MetricType metric,
         float metricArg,
         Tensor<float, 2, true>& outDistances) {
     DeviceScope ds(device);
@@ -143,8 +143,8 @@ void allPairwiseDistanceOnDevice(
 
     // L2 and IP are specialized to use GEMM and an optimized L2 + selection or
     // pure k-selection kernel.
-    if ((metric == faiss::MetricType::METRIC_L2) ||
-        (metric == faiss::MetricType::METRIC_Lp && metricArg == 2)) {
+    if ((metric == knowherefaiss::MetricType::METRIC_L2) ||
+        (metric == knowherefaiss::MetricType::METRIC_Lp && metricArg == 2)) {
         runAllPairwiseL2Distance(
                 resources,
                 stream,
@@ -154,7 +154,7 @@ void allPairwiseDistanceOnDevice(
                 queries,
                 queriesRowMajor,
                 outDistances);
-    } else if (metric == faiss::MetricType::METRIC_INNER_PRODUCT) {
+    } else if (metric == knowherefaiss::MetricType::METRIC_INNER_PRODUCT) {
         runAllPairwiseIPDistance(
                 resources,
                 stream,
@@ -181,15 +181,15 @@ void allPairwiseDistanceOnDevice(
                 ? queries.transposeInnermost(1)
                 : queries.transposeInnermost(0);
 
-        if ((metric == faiss::MetricType::METRIC_L1) ||
-            (metric == faiss::MetricType::METRIC_Lp && metricArg == 1)) {
+        if ((metric == knowherefaiss::MetricType::METRIC_L1) ||
+            (metric == knowherefaiss::MetricType::METRIC_Lp && metricArg == 1)) {
             runGeneralDistanceKernel(
                     tVectorsDimInnermost,
                     tQueriesDimInnermost,
                     outDistances,
                     L1Distance(),
                     stream);
-        } else if (metric == faiss::MetricType::METRIC_Lp && metricArg == -1) {
+        } else if (metric == knowherefaiss::MetricType::METRIC_Lp && metricArg == -1) {
             // A way to test L2 distance
             runGeneralDistanceKernel(
                     tVectorsDimInnermost,
@@ -197,35 +197,35 @@ void allPairwiseDistanceOnDevice(
                     outDistances,
                     L2Distance(),
                     stream);
-        } else if (metric == faiss::MetricType::METRIC_Lp) {
+        } else if (metric == knowherefaiss::MetricType::METRIC_Lp) {
             runGeneralDistanceKernel(
                     tVectorsDimInnermost,
                     tQueriesDimInnermost,
                     outDistances,
                     LpDistance(metricArg),
                     stream);
-        } else if (metric == faiss::MetricType::METRIC_Linf) {
+        } else if (metric == knowherefaiss::MetricType::METRIC_Linf) {
             runGeneralDistanceKernel(
                     tVectorsDimInnermost,
                     tQueriesDimInnermost,
                     outDistances,
                     LinfDistance(),
                     stream);
-        } else if (metric == faiss::MetricType::METRIC_Canberra) {
+        } else if (metric == knowherefaiss::MetricType::METRIC_Canberra) {
             runGeneralDistanceKernel(
                     tVectorsDimInnermost,
                     tQueriesDimInnermost,
                     outDistances,
                     CanberraDistance(),
                     stream);
-        } else if (metric == faiss::MetricType::METRIC_BrayCurtis) {
+        } else if (metric == knowherefaiss::MetricType::METRIC_BrayCurtis) {
             runGeneralDistanceKernel(
                     tVectorsDimInnermost,
                     tQueriesDimInnermost,
                     outDistances,
                     BrayCurtisDistance(),
                     stream);
-        } else if (metric == faiss::MetricType::METRIC_JensenShannon) {
+        } else if (metric == knowherefaiss::MetricType::METRIC_JensenShannon) {
             runGeneralDistanceKernel(
                     tVectorsDimInnermost,
                     tQueriesDimInnermost,
@@ -255,7 +255,7 @@ void bfKnnOnDevice(
         bool queriesRowMajor,
         Tensor<uint8_t, 1, true>& bitset,
         int k,
-        faiss::MetricType metric,
+        knowherefaiss::MetricType metric,
         float metricArg,
         Tensor<float, 2, true>& outDistances,
         Tensor<int, 2, true>& outIndices,
@@ -266,8 +266,8 @@ void bfKnnOnDevice(
 
     // L2 and IP are specialized to use GEMM and an optimized L2 + selection or
     // pure k-selection kernel.
-    if ((metric == faiss::MetricType::METRIC_L2) ||
-        (metric == faiss::MetricType::METRIC_Lp && metricArg == 2)) {
+    if ((metric == knowherefaiss::MetricType::METRIC_L2) ||
+        (metric == knowherefaiss::MetricType::METRIC_Lp && metricArg == 2)) {
         runL2Distance(
                 resources,
                 stream,
@@ -280,7 +280,7 @@ void bfKnnOnDevice(
                 k,
                 outDistances,
                 outIndices);
-    } else if (metric == faiss::MetricType::METRIC_INNER_PRODUCT) {
+    } else if (metric == knowherefaiss::MetricType::METRIC_INNER_PRODUCT) {
         runIPDistance(
                 resources,
                 stream,
@@ -310,8 +310,8 @@ void bfKnnOnDevice(
                 ? queries.transposeInnermost(1)
                 : queries.transposeInnermost(0);
 
-        if ((metric == faiss::MetricType::METRIC_L1) ||
-            (metric == faiss::MetricType::METRIC_Lp && metricArg == 1)) {
+        if ((metric == knowherefaiss::MetricType::METRIC_L1) ||
+            (metric == knowherefaiss::MetricType::METRIC_Lp && metricArg == 1)) {
             runGeneralDistance(
                     resources,
                     stream,
@@ -322,7 +322,7 @@ void bfKnnOnDevice(
                     L1Distance(),
                     outDistances,
                     outIndices);
-        } else if (metric == faiss::MetricType::METRIC_Lp && metricArg == -1) {
+        } else if (metric == knowherefaiss::MetricType::METRIC_Lp && metricArg == -1) {
             // A way to test L2 distance
             runGeneralDistance(
                     resources,
@@ -334,7 +334,7 @@ void bfKnnOnDevice(
                     L2Distance(),
                     outDistances,
                     outIndices);
-        } else if (metric == faiss::MetricType::METRIC_Lp) {
+        } else if (metric == knowherefaiss::MetricType::METRIC_Lp) {
             runGeneralDistance(
                     resources,
                     stream,
@@ -345,7 +345,7 @@ void bfKnnOnDevice(
                     LpDistance(metricArg),
                     outDistances,
                     outIndices);
-        } else if (metric == faiss::MetricType::METRIC_Linf) {
+        } else if (metric == knowherefaiss::MetricType::METRIC_Linf) {
             runGeneralDistance(
                     resources,
                     stream,
@@ -356,7 +356,7 @@ void bfKnnOnDevice(
                     LinfDistance(),
                     outDistances,
                     outIndices);
-        } else if (metric == faiss::MetricType::METRIC_Canberra) {
+        } else if (metric == knowherefaiss::MetricType::METRIC_Canberra) {
             runGeneralDistance(
                     resources,
                     stream,
@@ -367,7 +367,7 @@ void bfKnnOnDevice(
                     CanberraDistance(),
                     outDistances,
                     outIndices);
-        } else if (metric == faiss::MetricType::METRIC_BrayCurtis) {
+        } else if (metric == knowherefaiss::MetricType::METRIC_BrayCurtis) {
             runGeneralDistance(
                     resources,
                     stream,
@@ -378,7 +378,7 @@ void bfKnnOnDevice(
                     BrayCurtisDistance(),
                     outDistances,
                     outIndices);
-        } else if (metric == faiss::MetricType::METRIC_JensenShannon) {
+        } else if (metric == knowherefaiss::MetricType::METRIC_JensenShannon) {
             runGeneralDistance(
                     resources,
                     stream,
@@ -396,4 +396,4 @@ void bfKnnOnDevice(
 }
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/impl/DistanceUtils.cuh b/thirdparty/faiss/knowherefaiss/gpu/impl/DistanceUtils.cuh
similarity index 98%
rename from thirdparty/faiss/faiss/gpu/impl/DistanceUtils.cuh
rename to thirdparty/faiss/knowherefaiss/gpu/impl/DistanceUtils.cuh
index 894a37e0..b293c75b 100644
--- a/thirdparty/faiss/faiss/gpu/impl/DistanceUtils.cuh
+++ b/thirdparty/faiss/knowherefaiss/gpu/impl/DistanceUtils.cuh
@@ -9,13 +9,13 @@
 
 #include <algorithm>
 
-#include <faiss/gpu/utils/Tensor.cuh>
+#include <knowherefaiss/gpu/utils/Tensor.cuh>
 
 //
 // Shared utilities for brute-force distance calculations
 //
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 struct IPDistance {
@@ -342,4 +342,4 @@ inline void chooseTileSize(
 }
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/impl/FlatIndex.cu b/thirdparty/faiss/knowherefaiss/gpu/impl/FlatIndex.cu
similarity index 94%
rename from thirdparty/faiss/faiss/gpu/impl/FlatIndex.cu
rename to thirdparty/faiss/knowherefaiss/gpu/impl/FlatIndex.cu
index b3609e18..0044edab 100644
--- a/thirdparty/faiss/faiss/gpu/impl/FlatIndex.cu
+++ b/thirdparty/faiss/knowherefaiss/gpu/impl/FlatIndex.cu
@@ -5,16 +5,16 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/gpu/utils/DeviceUtils.h>
-#include <faiss/gpu/impl/Distance.cuh>
-#include <faiss/gpu/impl/FlatIndex.cuh>
-#include <faiss/gpu/impl/L2Norm.cuh>
-#include <faiss/gpu/impl/VectorResidual.cuh>
-#include <faiss/gpu/utils/ConversionOperators.cuh>
-#include <faiss/gpu/utils/CopyUtils.cuh>
-#include <faiss/gpu/utils/Transpose.cuh>
-
-namespace faiss {
+#include <knowherefaiss/gpu/utils/DeviceUtils.h>
+#include <knowherefaiss/gpu/impl/Distance.cuh>
+#include <knowherefaiss/gpu/impl/FlatIndex.cuh>
+#include <knowherefaiss/gpu/impl/L2Norm.cuh>
+#include <knowherefaiss/gpu/impl/VectorResidual.cuh>
+#include <knowherefaiss/gpu/utils/ConversionOperators.cuh>
+#include <knowherefaiss/gpu/utils/CopyUtils.cuh>
+#include <knowherefaiss/gpu/utils/Transpose.cuh>
+
+namespace knowherefaiss {
 namespace gpu {
 
 FlatIndex::FlatIndex(
@@ -120,7 +120,7 @@ void FlatIndex::query(
         Tensor<float, 2, true>& input,
         Tensor<uint8_t, 1, true>& bitset,
         int k,
-        faiss::MetricType metric,
+        knowherefaiss::MetricType metric,
         float metricArg,
         Tensor<float, 2, true>& outDistances,
         Tensor<int, 2, true>& outIndices,
@@ -164,7 +164,7 @@ void FlatIndex::query(
         Tensor<half, 2, true>& input,
         Tensor<uint8_t, 1, true>& bitset,
         int k,
-        faiss::MetricType metric,
+        knowherefaiss::MetricType metric,
         float metricArg,
         Tensor<float, 2, true>& outDistances,
         Tensor<int, 2, true>& outIndices,
@@ -325,4 +325,4 @@ void FlatIndex::reset() {
 }
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/impl/FlatIndex.cuh b/thirdparty/faiss/knowherefaiss/gpu/impl/FlatIndex.cuh
similarity index 91%
rename from thirdparty/faiss/faiss/gpu/impl/FlatIndex.cuh
rename to thirdparty/faiss/knowherefaiss/gpu/impl/FlatIndex.cuh
index 30b33148..3b863815 100644
--- a/thirdparty/faiss/faiss/gpu/impl/FlatIndex.cuh
+++ b/thirdparty/faiss/knowherefaiss/gpu/impl/FlatIndex.cuh
@@ -7,12 +7,12 @@
 
 #pragma once
 
-#include <faiss/MetricType.h>
-#include <faiss/gpu/GpuResources.h>
-#include <faiss/gpu/utils/DeviceTensor.cuh>
-#include <faiss/gpu/utils/DeviceVector.cuh>
+#include <knowherefaiss/MetricType.h>
+#include <knowherefaiss/gpu/GpuResources.h>
+#include <knowherefaiss/gpu/utils/DeviceTensor.cuh>
+#include <knowherefaiss/gpu/utils/DeviceVector.cuh>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 class GpuResources;
@@ -64,7 +64,7 @@ class FlatIndex {
             Tensor<float, 2, true>& vecs,
             Tensor<uint8_t, 1, true>& bitset,
             int k,
-            faiss::MetricType metric,
+            knowherefaiss::MetricType metric,
             float metricArg,
             Tensor<float, 2, true>& outDistances,
             Tensor<int, 2, true>& outIndices,
@@ -74,7 +74,7 @@ class FlatIndex {
             Tensor<half, 2, true>& vecs,
             Tensor<uint8_t, 1, true>& bitset,
             int k,
-            faiss::MetricType metric,
+            knowherefaiss::MetricType metric,
             float metricArg,
             Tensor<float, 2, true>& outDistances,
             Tensor<int, 2, true>& outIndices,
@@ -138,4 +138,4 @@ class FlatIndex {
 };
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/impl/GeneralDistance.cuh b/thirdparty/faiss/knowherefaiss/gpu/impl/GeneralDistance.cuh
similarity index 96%
rename from thirdparty/faiss/faiss/gpu/impl/GeneralDistance.cuh
rename to thirdparty/faiss/knowherefaiss/gpu/impl/GeneralDistance.cuh
index f1651f22..2f051fbe 100644
--- a/thirdparty/faiss/faiss/gpu/impl/GeneralDistance.cuh
+++ b/thirdparty/faiss/knowherefaiss/gpu/impl/GeneralDistance.cuh
@@ -5,15 +5,15 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/MetricType.h>
-#include <faiss/gpu/utils/DeviceUtils.h>
-#include <faiss/impl/AuxIndexStructures.h>
-#include <faiss/gpu/impl/DistanceUtils.cuh>
-#include <faiss/gpu/utils/BlockSelectKernel.cuh>
-#include <faiss/gpu/utils/ConversionOperators.cuh>
-#include <faiss/gpu/utils/DeviceDefs.cuh>
-#include <faiss/gpu/utils/DeviceTensor.cuh>
-#include <faiss/gpu/utils/Select.cuh>
+#include <knowherefaiss/MetricType.h>
+#include <knowherefaiss/gpu/utils/DeviceUtils.h>
+#include <knowherefaiss/impl/AuxIndexStructures.h>
+#include <knowherefaiss/gpu/impl/DistanceUtils.cuh>
+#include <knowherefaiss/gpu/utils/BlockSelectKernel.cuh>
+#include <knowherefaiss/gpu/utils/ConversionOperators.cuh>
+#include <knowherefaiss/gpu/utils/DeviceDefs.cuh>
+#include <knowherefaiss/gpu/utils/DeviceTensor.cuh>
+#include <knowherefaiss/gpu/utils/Select.cuh>
 
 #include <thrust/device_ptr.h>
 #include <thrust/execution_policy.h>
@@ -27,7 +27,7 @@
 // Kernels for non-L2 / inner product distances
 //
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 // Reduction tree operator
@@ -454,4 +454,4 @@ void runGeneralDistance(
 }
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/impl/GpuScalarQuantizer.cuh b/thirdparty/faiss/knowherefaiss/gpu/impl/GpuScalarQuantizer.cuh
similarity index 98%
rename from thirdparty/faiss/faiss/gpu/impl/GpuScalarQuantizer.cuh
rename to thirdparty/faiss/knowherefaiss/gpu/impl/GpuScalarQuantizer.cuh
index a8a14918..6a9a9cce 100644
--- a/thirdparty/faiss/faiss/gpu/impl/GpuScalarQuantizer.cuh
+++ b/thirdparty/faiss/knowherefaiss/gpu/impl/GpuScalarQuantizer.cuh
@@ -7,14 +7,14 @@
 
 #pragma once
 
-#include <faiss/IndexScalarQuantizer.h>
-#include <faiss/gpu/utils/ConversionOperators.cuh>
-#include <faiss/gpu/utils/DeviceTensor.cuh>
-#include <faiss/gpu/utils/HostTensor.cuh>
-#include <faiss/gpu/utils/PtxUtils.cuh>
-#include <faiss/gpu/utils/WarpShuffles.cuh>
-
-namespace faiss {
+#include <knowherefaiss/IndexScalarQuantizer.h>
+#include <knowherefaiss/gpu/utils/ConversionOperators.cuh>
+#include <knowherefaiss/gpu/utils/DeviceTensor.cuh>
+#include <knowherefaiss/gpu/utils/HostTensor.cuh>
+#include <knowherefaiss/gpu/utils/PtxUtils.cuh>
+#include <knowherefaiss/gpu/utils/WarpShuffles.cuh>
+
+namespace knowherefaiss {
 namespace gpu {
 
 inline bool isSQSupported(QuantizerType qtype) {
@@ -834,4 +834,4 @@ struct Codec<QuantizerType::QT_4bit, 1> {
 };
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/impl/IVFAppend.cu b/thirdparty/faiss/knowherefaiss/gpu/impl/IVFAppend.cu
similarity index 97%
rename from thirdparty/faiss/faiss/gpu/impl/IVFAppend.cu
rename to thirdparty/faiss/knowherefaiss/gpu/impl/IVFAppend.cu
index 4a319ed6..24b0bd5f 100644
--- a/thirdparty/faiss/faiss/gpu/impl/IVFAppend.cu
+++ b/thirdparty/faiss/knowherefaiss/gpu/impl/IVFAppend.cu
@@ -5,20 +5,20 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/gpu/utils/DeviceUtils.h>
-#include <faiss/gpu/utils/StaticUtils.h>
-#include <faiss/impl/FaissAssert.h>
-#include <faiss/gpu/impl/IVFAppend.cuh>
-#include <faiss/gpu/utils/DeviceDefs.cuh>
-#include <faiss/gpu/utils/Float16.cuh>
-#include <faiss/gpu/utils/PtxUtils.cuh>
-#include <faiss/gpu/utils/Tensor.cuh>
-#include <faiss/gpu/utils/WarpPackedBits.cuh>
-#include <faiss/gpu/utils/WarpShuffles.cuh>
+#include <knowherefaiss/gpu/utils/DeviceUtils.h>
+#include <knowherefaiss/gpu/utils/StaticUtils.h>
+#include <knowherefaiss/impl/FaissAssert.h>
+#include <knowherefaiss/gpu/impl/IVFAppend.cuh>
+#include <knowherefaiss/gpu/utils/DeviceDefs.cuh>
+#include <knowherefaiss/gpu/utils/Float16.cuh>
+#include <knowherefaiss/gpu/utils/PtxUtils.cuh>
+#include <knowherefaiss/gpu/utils/Tensor.cuh>
+#include <knowherefaiss/gpu/utils/WarpPackedBits.cuh>
+#include <knowherefaiss/gpu/utils/WarpShuffles.cuh>
 
 #include <algorithm>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 //
@@ -631,4 +631,4 @@ void runIVFPQInterleavedAppend(
 }
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/impl/IVFAppend.cuh b/thirdparty/faiss/knowherefaiss/gpu/impl/IVFAppend.cuh
similarity index 92%
rename from thirdparty/faiss/faiss/gpu/impl/IVFAppend.cuh
rename to thirdparty/faiss/knowherefaiss/gpu/impl/IVFAppend.cuh
index 9b17af1b..9675a51c 100644
--- a/thirdparty/faiss/faiss/gpu/impl/IVFAppend.cuh
+++ b/thirdparty/faiss/knowherefaiss/gpu/impl/IVFAppend.cuh
@@ -7,12 +7,12 @@
 
 #pragma once
 
-#include <faiss/gpu/GpuIndicesOptions.h>
+#include <knowherefaiss/gpu/GpuIndicesOptions.h>
 #include <thrust/device_vector.h>
-#include <faiss/gpu/impl/GpuScalarQuantizer.cuh>
-#include <faiss/gpu/utils/Tensor.cuh>
+#include <knowherefaiss/gpu/impl/GpuScalarQuantizer.cuh>
+#include <knowherefaiss/gpu/utils/Tensor.cuh>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 /// Append user indices to IVF lists
@@ -80,4 +80,4 @@ void runIVFFlatInterleavedAppend(
         cudaStream_t stream);
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/impl/IVFBase.cu b/thirdparty/faiss/knowherefaiss/gpu/impl/IVFBase.cu
similarity index 97%
rename from thirdparty/faiss/faiss/gpu/impl/IVFBase.cu
rename to thirdparty/faiss/knowherefaiss/gpu/impl/IVFBase.cu
index 6ed4204a..482d353b 100644
--- a/thirdparty/faiss/faiss/gpu/impl/IVFBase.cu
+++ b/thirdparty/faiss/knowherefaiss/gpu/impl/IVFBase.cu
@@ -5,22 +5,22 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/gpu/GpuResources.h>
-#include <faiss/gpu/impl/RemapIndices.h>
-#include <faiss/gpu/utils/DeviceUtils.h>
-#include <faiss/invlists/InvertedLists.h>
+#include <knowherefaiss/gpu/GpuResources.h>
+#include <knowherefaiss/gpu/impl/RemapIndices.h>
+#include <knowherefaiss/gpu/utils/DeviceUtils.h>
+#include <knowherefaiss/invlists/InvertedLists.h>
 #include <thrust/host_vector.h>
-#include <faiss/gpu/impl/FlatIndex.cuh>
-#include <faiss/gpu/impl/IVFAppend.cuh>
-#include <faiss/gpu/impl/IVFBase.cuh>
-#include <faiss/gpu/utils/CopyUtils.cuh>
-#include <faiss/gpu/utils/DeviceDefs.cuh>
-#include <faiss/gpu/utils/HostTensor.cuh>
+#include <knowherefaiss/gpu/impl/FlatIndex.cuh>
+#include <knowherefaiss/gpu/impl/IVFAppend.cuh>
+#include <knowherefaiss/gpu/impl/IVFBase.cuh>
+#include <knowherefaiss/gpu/utils/CopyUtils.cuh>
+#include <knowherefaiss/gpu/utils/DeviceDefs.cuh>
+#include <knowherefaiss/gpu/utils/HostTensor.cuh>
 #include <limits>
 #include <numeric>
 #include <unordered_map>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 IVFBase::DeviceIVFList::DeviceIVFList(GpuResources* res, const AllocInfo& info)
@@ -28,7 +28,7 @@ IVFBase::DeviceIVFList::DeviceIVFList(GpuResources* res, const AllocInfo& info)
 
 IVFBase::IVFBase(
         GpuResources* resources,
-        faiss::MetricType metric,
+        knowherefaiss::MetricType metric,
         float metricArg,
         FlatIndex* quantizer,
         bool interleavedLayout,
@@ -799,4 +799,4 @@ void IVFBase::addTrainedDataFromCpu_(
 }
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/impl/IVFBase.cuh b/thirdparty/faiss/knowherefaiss/gpu/impl/IVFBase.cuh
similarity index 95%
rename from thirdparty/faiss/faiss/gpu/impl/IVFBase.cuh
rename to thirdparty/faiss/knowherefaiss/gpu/impl/IVFBase.cuh
index 9afe962a..458c858e 100644
--- a/thirdparty/faiss/faiss/gpu/impl/IVFBase.cuh
+++ b/thirdparty/faiss/knowherefaiss/gpu/impl/IVFBase.cuh
@@ -7,20 +7,20 @@
 
 #pragma once
 
-#include <faiss/Index.h>
-#include <faiss/MetricType.h>
-#include <faiss/gpu/GpuIndicesOptions.h>
+#include <knowherefaiss/Index.h>
+#include <knowherefaiss/MetricType.h>
+#include <knowherefaiss/gpu/GpuIndicesOptions.h>
 #include <thrust/device_vector.h>
-#include <faiss/gpu/utils/DeviceTensor.cuh>
-#include <faiss/gpu/utils/DeviceVector.cuh>
+#include <knowherefaiss/gpu/utils/DeviceTensor.cuh>
+#include <knowherefaiss/gpu/utils/DeviceVector.cuh>
 #include <memory>
 #include <vector>
 
-namespace faiss {
+namespace knowherefaiss {
 struct InvertedLists;
 }
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 class GpuResources;
@@ -30,7 +30,7 @@ class FlatIndex;
 class IVFBase {
    public:
     IVFBase(GpuResources* resources,
-            faiss::MetricType metric,
+            knowherefaiss::MetricType metric,
             float metricArg,
             /// We do not own this reference
             FlatIndex* quantizer,
@@ -162,7 +162,7 @@ class IVFBase {
     GpuResources* resources_;
 
     /// Metric type of the index
-    faiss::MetricType metric_;
+    knowherefaiss::MetricType metric_;
 
     /// Metric arg
     float metricArg_;
@@ -237,4 +237,4 @@ class IVFBase {
 };
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/impl/IVFFlat.cu b/thirdparty/faiss/knowherefaiss/gpu/impl/IVFFlat.cu
similarity index 90%
rename from thirdparty/faiss/faiss/gpu/impl/IVFFlat.cu
rename to thirdparty/faiss/knowherefaiss/gpu/impl/IVFFlat.cu
index 3c389d90..668d51e0 100644
--- a/thirdparty/faiss/faiss/gpu/impl/IVFFlat.cu
+++ b/thirdparty/faiss/knowherefaiss/gpu/impl/IVFFlat.cu
@@ -5,35 +5,35 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/gpu/GpuResources.h>
-#include <faiss/gpu/impl/InterleavedCodes.h>
-#include <faiss/gpu/impl/RemapIndices.h>
-#include <faiss/gpu/utils/DeviceUtils.h>
+#include <knowherefaiss/gpu/GpuResources.h>
+#include <knowherefaiss/gpu/impl/InterleavedCodes.h>
+#include <knowherefaiss/gpu/impl/RemapIndices.h>
+#include <knowherefaiss/gpu/utils/DeviceUtils.h>
 #include <thrust/host_vector.h>
-#include <faiss/gpu/impl/FlatIndex.cuh>
-#include <faiss/gpu/impl/IVFAppend.cuh>
-#include <faiss/gpu/impl/IVFFlat.cuh>
-#include <faiss/gpu/impl/IVFFlatScan.cuh>
-#include <faiss/gpu/impl/IVFInterleaved.cuh>
-#include <faiss/gpu/utils/ConversionOperators.cuh>
-#include <faiss/gpu/utils/CopyUtils.cuh>
-#include <faiss/gpu/utils/DeviceDefs.cuh>
-#include <faiss/gpu/utils/Float16.cuh>
-#include <faiss/gpu/utils/HostTensor.cuh>
-#include <faiss/gpu/utils/Transpose.cuh>
+#include <knowherefaiss/gpu/impl/FlatIndex.cuh>
+#include <knowherefaiss/gpu/impl/IVFAppend.cuh>
+#include <knowherefaiss/gpu/impl/IVFFlat.cuh>
+#include <knowherefaiss/gpu/impl/IVFFlatScan.cuh>
+#include <knowherefaiss/gpu/impl/IVFInterleaved.cuh>
+#include <knowherefaiss/gpu/utils/ConversionOperators.cuh>
+#include <knowherefaiss/gpu/utils/CopyUtils.cuh>
+#include <knowherefaiss/gpu/utils/DeviceDefs.cuh>
+#include <knowherefaiss/gpu/utils/Float16.cuh>
+#include <knowherefaiss/gpu/utils/HostTensor.cuh>
+#include <knowherefaiss/gpu/utils/Transpose.cuh>
 #include <limits>
 #include <unordered_map>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 IVFFlat::IVFFlat(
         GpuResources* res,
         FlatIndex* quantizer,
-        faiss::MetricType metric,
+        knowherefaiss::MetricType metric,
         float metricArg,
         bool useResidual,
-        faiss::ScalarQuantizer* scalarQ,
+        knowherefaiss::ScalarQuantizer* scalarQ,
         bool interleavedLayout,
         IndicesOptions indicesOptions,
         MemorySpace space)
@@ -279,4 +279,4 @@ void IVFFlat::query(
 }
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/impl/IVFFlat.cuh b/thirdparty/faiss/knowherefaiss/gpu/impl/IVFFlat.cuh
similarity index 91%
rename from thirdparty/faiss/faiss/gpu/impl/IVFFlat.cuh
rename to thirdparty/faiss/knowherefaiss/gpu/impl/IVFFlat.cuh
index 694b3701..57fda978 100644
--- a/thirdparty/faiss/faiss/gpu/impl/IVFFlat.cuh
+++ b/thirdparty/faiss/knowherefaiss/gpu/impl/IVFFlat.cuh
@@ -7,10 +7,10 @@
 
 #pragma once
 
-#include <faiss/gpu/impl/GpuScalarQuantizer.cuh>
-#include <faiss/gpu/impl/IVFBase.cuh>
+#include <knowherefaiss/gpu/impl/GpuScalarQuantizer.cuh>
+#include <knowherefaiss/gpu/impl/IVFBase.cuh>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 class IVFFlat : public IVFBase {
@@ -19,11 +19,11 @@ class IVFFlat : public IVFBase {
     IVFFlat(GpuResources* resources,
             /// We do not own this reference
             FlatIndex* quantizer,
-            faiss::MetricType metric,
+            knowherefaiss::MetricType metric,
             float metricArg,
             bool useResidual,
             /// Optional ScalarQuantizer
-            faiss::ScalarQuantizer* scalarQ,
+            knowherefaiss::ScalarQuantizer* scalarQ,
             bool interleavedLayout,
             IndicesOptions indicesOptions,
             MemorySpace space);
@@ -80,4 +80,4 @@ class IVFFlat : public IVFBase {
 };
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/impl/IVFFlatScan.cu b/thirdparty/faiss/knowherefaiss/gpu/impl/IVFFlatScan.cu
similarity index 95%
rename from thirdparty/faiss/faiss/gpu/impl/IVFFlatScan.cu
rename to thirdparty/faiss/knowherefaiss/gpu/impl/IVFFlatScan.cu
index b9323d59..4192e2b3 100644
--- a/thirdparty/faiss/faiss/gpu/impl/IVFFlatScan.cu
+++ b/thirdparty/faiss/knowherefaiss/gpu/impl/IVFFlatScan.cu
@@ -5,25 +5,25 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/gpu/GpuResources.h>
-#include <faiss/gpu/utils/DeviceUtils.h>
-#include <faiss/gpu/utils/StaticUtils.h>
-#include <faiss/gpu/impl/DistanceUtils.cuh>
-#include <faiss/gpu/impl/IVFFlatScan.cuh>
-#include <faiss/gpu/impl/IVFUtils.cuh>
-#include <faiss/gpu/utils/Comparators.cuh>
-#include <faiss/gpu/utils/ConversionOperators.cuh>
-#include <faiss/gpu/utils/DeviceDefs.cuh>
-#include <faiss/gpu/utils/DeviceTensor.cuh>
-#include <faiss/gpu/utils/Float16.cuh>
-#include <faiss/gpu/utils/MathOperators.cuh>
-#include <faiss/gpu/utils/PtxUtils.cuh>
-#include <faiss/gpu/utils/Reductions.cuh>
-#include <faiss/impl/ScalarQuantizerOp.h>
+#include <knowherefaiss/gpu/GpuResources.h>
+#include <knowherefaiss/gpu/utils/DeviceUtils.h>
+#include <knowherefaiss/gpu/utils/StaticUtils.h>
+#include <knowherefaiss/gpu/impl/DistanceUtils.cuh>
+#include <knowherefaiss/gpu/impl/IVFFlatScan.cuh>
+#include <knowherefaiss/gpu/impl/IVFUtils.cuh>
+#include <knowherefaiss/gpu/utils/Comparators.cuh>
+#include <knowherefaiss/gpu/utils/ConversionOperators.cuh>
+#include <knowherefaiss/gpu/utils/DeviceDefs.cuh>
+#include <knowherefaiss/gpu/utils/DeviceTensor.cuh>
+#include <knowherefaiss/gpu/utils/Float16.cuh>
+#include <knowherefaiss/gpu/utils/MathOperators.cuh>
+#include <knowherefaiss/gpu/utils/PtxUtils.cuh>
+#include <knowherefaiss/gpu/utils/Reductions.cuh>
+#include <knowherefaiss/impl/ScalarQuantizerOp.h>
 
 #include <algorithm>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 namespace {
@@ -198,7 +198,7 @@ void runIVFFlatScanTile(
         Tensor<float, 3, true>& heapDistances,
         Tensor<int, 3, true>& heapIndices,
         int k,
-        faiss::MetricType metricType,
+        knowherefaiss::MetricType metricType,
         bool useResidual,
         Tensor<float, 3, true>& residualBase,
         GpuScalarQuantizer* scalarQ,
@@ -354,7 +354,7 @@ void runIVFFlatScan(
         thrust::device_vector<int>& listLengths,
         int maxListLength,
         int k,
-        faiss::MetricType metric,
+        knowherefaiss::MetricType metric,
         bool useResidual,
         Tensor<float, 3, true>& residualBase,
         GpuScalarQuantizer* scalarQ,
@@ -526,4 +526,4 @@ void runIVFFlatScan(
 }
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/impl/IVFFlatScan.cuh b/thirdparty/faiss/knowherefaiss/gpu/impl/IVFFlatScan.cuh
similarity index 76%
rename from thirdparty/faiss/faiss/gpu/impl/IVFFlatScan.cuh
rename to thirdparty/faiss/knowherefaiss/gpu/impl/IVFFlatScan.cuh
index 59c1d086..f40b7d63 100644
--- a/thirdparty/faiss/faiss/gpu/impl/IVFFlatScan.cuh
+++ b/thirdparty/faiss/knowherefaiss/gpu/impl/IVFFlatScan.cuh
@@ -7,13 +7,13 @@
 
 #pragma once
 
-#include <faiss/MetricType.h>
-#include <faiss/gpu/GpuIndicesOptions.h>
+#include <knowherefaiss/MetricType.h>
+#include <knowherefaiss/gpu/GpuIndicesOptions.h>
 #include <thrust/device_vector.h>
-#include <faiss/gpu/impl/GpuScalarQuantizer.cuh>
-#include <faiss/gpu/utils/Tensor.cuh>
+#include <knowherefaiss/gpu/impl/GpuScalarQuantizer.cuh>
+#include <knowherefaiss/gpu/utils/Tensor.cuh>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 class GpuResources;
@@ -28,7 +28,7 @@ void runIVFFlatScan(
         thrust::device_vector<int>& listLengths,
         int maxListLength,
         int k,
-        faiss::MetricType metric,
+        knowherefaiss::MetricType metric,
         bool useResidual,
         Tensor<float, 3, true>& residualBase,
         GpuScalarQuantizer* scalarQ,
@@ -39,4 +39,4 @@ void runIVFFlatScan(
         GpuResources* res);
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/impl/IVFInterleaved.cu b/thirdparty/faiss/knowherefaiss/gpu/impl/IVFInterleaved.cu
similarity index 97%
rename from thirdparty/faiss/faiss/gpu/impl/IVFInterleaved.cu
rename to thirdparty/faiss/knowherefaiss/gpu/impl/IVFInterleaved.cu
index 330c3a2c..cc0c697a 100644
--- a/thirdparty/faiss/faiss/gpu/impl/IVFInterleaved.cu
+++ b/thirdparty/faiss/knowherefaiss/gpu/impl/IVFInterleaved.cu
@@ -5,10 +5,10 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/gpu/impl/IVFInterleaved.cuh>
-#include <faiss/gpu/impl/scan/IVFInterleavedImpl.cuh>
+#include <knowherefaiss/gpu/impl/IVFInterleaved.cuh>
+#include <knowherefaiss/gpu/impl/scan/IVFInterleavedImpl.cuh>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 constexpr uint32_t kMaxUInt32 = std::numeric_limits<uint32_t>::max();
@@ -175,7 +175,7 @@ void runIVFInterleavedScan(
         IndicesOptions indicesOptions,
         thrust::device_vector<int>& listLengths,
         int k,
-        faiss::MetricType metric,
+        knowherefaiss::MetricType metric,
         bool useResidual,
         Tensor<float, 3, true>& residualBase,
         GpuScalarQuantizer* scalarQ,
@@ -210,4 +210,4 @@ void runIVFInterleavedScan(
 }
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/impl/IVFInterleaved.cuh b/thirdparty/faiss/knowherefaiss/gpu/impl/IVFInterleaved.cuh
similarity index 95%
rename from thirdparty/faiss/faiss/gpu/impl/IVFInterleaved.cuh
rename to thirdparty/faiss/knowherefaiss/gpu/impl/IVFInterleaved.cuh
index bb081c91..93e4d000 100644
--- a/thirdparty/faiss/faiss/gpu/impl/IVFInterleaved.cuh
+++ b/thirdparty/faiss/knowherefaiss/gpu/impl/IVFInterleaved.cuh
@@ -7,26 +7,26 @@
 
 #pragma once
 
-#include <faiss/MetricType.h>
-#include <faiss/gpu/GpuIndicesOptions.h>
-#include <faiss/gpu/GpuResources.h>
-#include <faiss/gpu/utils/DeviceUtils.h>
-#include <faiss/gpu/utils/StaticUtils.h>
+#include <knowherefaiss/MetricType.h>
+#include <knowherefaiss/gpu/GpuIndicesOptions.h>
+#include <knowherefaiss/gpu/GpuResources.h>
+#include <knowherefaiss/gpu/utils/DeviceUtils.h>
+#include <knowherefaiss/gpu/utils/StaticUtils.h>
 #include <thrust/device_vector.h>
-#include <faiss/gpu/impl/DistanceUtils.cuh>
-#include <faiss/gpu/impl/GpuScalarQuantizer.cuh>
-#include <faiss/gpu/impl/IVFUtils.cuh>
-#include <faiss/gpu/utils/Comparators.cuh>
-#include <faiss/gpu/utils/ConversionOperators.cuh>
-#include <faiss/gpu/utils/DeviceDefs.cuh>
-#include <faiss/gpu/utils/DeviceTensor.cuh>
-#include <faiss/gpu/utils/Float16.cuh>
-#include <faiss/gpu/utils/MathOperators.cuh>
-#include <faiss/gpu/utils/PtxUtils.cuh>
-#include <faiss/gpu/utils/Select.cuh>
-#include <faiss/gpu/utils/WarpPackedBits.cuh>
-
-namespace faiss {
+#include <knowherefaiss/gpu/impl/DistanceUtils.cuh>
+#include <knowherefaiss/gpu/impl/GpuScalarQuantizer.cuh>
+#include <knowherefaiss/gpu/impl/IVFUtils.cuh>
+#include <knowherefaiss/gpu/utils/Comparators.cuh>
+#include <knowherefaiss/gpu/utils/ConversionOperators.cuh>
+#include <knowherefaiss/gpu/utils/DeviceDefs.cuh>
+#include <knowherefaiss/gpu/utils/DeviceTensor.cuh>
+#include <knowherefaiss/gpu/utils/Float16.cuh>
+#include <knowherefaiss/gpu/utils/MathOperators.cuh>
+#include <knowherefaiss/gpu/utils/PtxUtils.cuh>
+#include <knowherefaiss/gpu/utils/Select.cuh>
+#include <knowherefaiss/gpu/utils/WarpPackedBits.cuh>
+
+namespace knowherefaiss {
 namespace gpu {
 
 /// First pass kernel to perform scanning of IVF lists to produce top-k
@@ -417,7 +417,7 @@ void runIVFInterleavedScan(
         IndicesOptions indicesOptions,
         thrust::device_vector<int>& listLengths,
         int k,
-        faiss::MetricType metric,
+        knowherefaiss::MetricType metric,
         bool useResidual,
         Tensor<float, 3, true>& residualBase,
         GpuScalarQuantizer* scalarQ,
@@ -442,4 +442,4 @@ void runIVFInterleavedScan2(
         cudaStream_t stream);
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/impl/IVFPQ.cu b/thirdparty/faiss/knowherefaiss/gpu/impl/IVFPQ.cu
similarity index 95%
rename from thirdparty/faiss/faiss/gpu/impl/IVFPQ.cu
rename to thirdparty/faiss/knowherefaiss/gpu/impl/IVFPQ.cu
index 4971e4fd..07e1b111 100644
--- a/thirdparty/faiss/faiss/gpu/impl/IVFPQ.cu
+++ b/thirdparty/faiss/knowherefaiss/gpu/impl/IVFPQ.cu
@@ -5,37 +5,37 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/gpu/GpuResources.h>
-#include <faiss/gpu/impl/InterleavedCodes.h>
-#include <faiss/gpu/impl/RemapIndices.h>
-#include <faiss/gpu/utils/DeviceUtils.h>
+#include <knowherefaiss/gpu/GpuResources.h>
+#include <knowherefaiss/gpu/impl/InterleavedCodes.h>
+#include <knowherefaiss/gpu/impl/RemapIndices.h>
+#include <knowherefaiss/gpu/utils/DeviceUtils.h>
 #include <thrust/host_vector.h>
-#include <faiss/gpu/impl/BroadcastSum.cuh>
-#include <faiss/gpu/impl/Distance.cuh>
-#include <faiss/gpu/impl/FlatIndex.cuh>
-#include <faiss/gpu/impl/IVFAppend.cuh>
-#include <faiss/gpu/impl/IVFPQ.cuh>
-#include <faiss/gpu/impl/L2Norm.cuh>
-#include <faiss/gpu/impl/PQCodeDistances.cuh>
-#include <faiss/gpu/impl/PQScanMultiPassNoPrecomputed.cuh>
-#include <faiss/gpu/impl/PQScanMultiPassPrecomputed.cuh>
-#include <faiss/gpu/impl/VectorResidual.cuh>
-#include <faiss/gpu/utils/ConversionOperators.cuh>
-#include <faiss/gpu/utils/DeviceDefs.cuh>
-#include <faiss/gpu/utils/HostTensor.cuh>
-#include <faiss/gpu/utils/MatrixMult.cuh>
-#include <faiss/gpu/utils/NoTypeTensor.cuh>
-#include <faiss/gpu/utils/Transpose.cuh>
+#include <knowherefaiss/gpu/impl/BroadcastSum.cuh>
+#include <knowherefaiss/gpu/impl/Distance.cuh>
+#include <knowherefaiss/gpu/impl/FlatIndex.cuh>
+#include <knowherefaiss/gpu/impl/IVFAppend.cuh>
+#include <knowherefaiss/gpu/impl/IVFPQ.cuh>
+#include <knowherefaiss/gpu/impl/L2Norm.cuh>
+#include <knowherefaiss/gpu/impl/PQCodeDistances.cuh>
+#include <knowherefaiss/gpu/impl/PQScanMultiPassNoPrecomputed.cuh>
+#include <knowherefaiss/gpu/impl/PQScanMultiPassPrecomputed.cuh>
+#include <knowherefaiss/gpu/impl/VectorResidual.cuh>
+#include <knowherefaiss/gpu/utils/ConversionOperators.cuh>
+#include <knowherefaiss/gpu/utils/DeviceDefs.cuh>
+#include <knowherefaiss/gpu/utils/HostTensor.cuh>
+#include <knowherefaiss/gpu/utils/MatrixMult.cuh>
+#include <knowherefaiss/gpu/utils/NoTypeTensor.cuh>
+#include <knowherefaiss/gpu/utils/Transpose.cuh>
 #include <limits>
 #include <type_traits>
 #include <unordered_map>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 IVFPQ::IVFPQ(
         GpuResources* resources,
-        faiss::MetricType metric,
+        knowherefaiss::MetricType metric,
         float metricArg,
         FlatIndex* quantizer,
         int numSubQuantizers,
@@ -758,4 +758,4 @@ void IVFPQ::runPQNoPrecomputedCodes_(
 }
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/impl/IVFPQ.cuh b/thirdparty/faiss/knowherefaiss/gpu/impl/IVFPQ.cuh
similarity index 95%
rename from thirdparty/faiss/faiss/gpu/impl/IVFPQ.cuh
rename to thirdparty/faiss/knowherefaiss/gpu/impl/IVFPQ.cuh
index ec532d93..4e2687e2 100644
--- a/thirdparty/faiss/faiss/gpu/impl/IVFPQ.cuh
+++ b/thirdparty/faiss/knowherefaiss/gpu/impl/IVFPQ.cuh
@@ -7,19 +7,19 @@
 
 #pragma once
 
-#include <faiss/Index.h>
-#include <faiss/MetricType.h>
-#include <faiss/gpu/impl/IVFBase.cuh>
-#include <faiss/gpu/utils/Float16.cuh>
+#include <knowherefaiss/Index.h>
+#include <knowherefaiss/MetricType.h>
+#include <knowherefaiss/gpu/impl/IVFBase.cuh>
+#include <knowherefaiss/gpu/utils/Float16.cuh>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 /// Implementing class for IVFPQ on the GPU
 class IVFPQ : public IVFBase {
    public:
     IVFPQ(GpuResources* resources,
-          faiss::MetricType metric,
+          knowherefaiss::MetricType metric,
           float metricArg,
           /// We do not own this reference
           FlatIndex* quantizer,
@@ -173,4 +173,4 @@ class IVFPQ : public IVFBase {
 };
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/impl/IVFUtils.cu b/thirdparty/faiss/knowherefaiss/gpu/impl/IVFUtils.cu
similarity index 89%
rename from thirdparty/faiss/faiss/gpu/impl/IVFUtils.cu
rename to thirdparty/faiss/knowherefaiss/gpu/impl/IVFUtils.cu
index bdc6e891..d27dd92c 100644
--- a/thirdparty/faiss/faiss/gpu/impl/IVFUtils.cu
+++ b/thirdparty/faiss/knowherefaiss/gpu/impl/IVFUtils.cu
@@ -5,17 +5,17 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/gpu/utils/DeviceUtils.h>
-#include <faiss/gpu/utils/StaticUtils.h>
+#include <knowherefaiss/gpu/utils/DeviceUtils.h>
+#include <knowherefaiss/gpu/utils/StaticUtils.h>
 #include <thrust/execution_policy.h>
 #include <thrust/scan.h>
-#include <faiss/gpu/impl/IVFUtils.cuh>
-#include <faiss/gpu/utils/Tensor.cuh>
-#include <faiss/gpu/utils/ThrustAllocator.cuh>
+#include <knowherefaiss/gpu/impl/IVFUtils.cuh>
+#include <knowherefaiss/gpu/utils/Tensor.cuh>
+#include <knowherefaiss/gpu/utils/ThrustAllocator.cuh>
 
 #include <algorithm>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 // Calculates the total number of intermediate distances to consider
@@ -81,4 +81,4 @@ void runCalcListOffsets(
 }
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/impl/IVFUtils.cuh b/thirdparty/faiss/knowherefaiss/gpu/impl/IVFUtils.cuh
similarity index 95%
rename from thirdparty/faiss/faiss/gpu/impl/IVFUtils.cuh
rename to thirdparty/faiss/knowherefaiss/gpu/impl/IVFUtils.cuh
index 1ba2894a..af7e28d0 100644
--- a/thirdparty/faiss/faiss/gpu/impl/IVFUtils.cuh
+++ b/thirdparty/faiss/knowherefaiss/gpu/impl/IVFUtils.cuh
@@ -7,14 +7,14 @@
 
 #pragma once
 
-#include <faiss/Index.h>
-#include <faiss/gpu/GpuIndicesOptions.h>
+#include <knowherefaiss/Index.h>
+#include <knowherefaiss/gpu/GpuIndicesOptions.h>
 #include <thrust/device_vector.h>
-#include <faiss/gpu/utils/Tensor.cuh>
+#include <knowherefaiss/gpu/utils/Tensor.cuh>
 
 // A collection of utility functions for IVFPQ and IVFFlat, for
 // post-processing and k-selecting the results
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 class GpuResources;
@@ -133,4 +133,4 @@ void runPass2SelectLists(
         cudaStream_t stream);
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/impl/IVFUtilsSelect1.cu b/thirdparty/faiss/knowherefaiss/gpu/impl/IVFUtilsSelect1.cu
similarity index 94%
rename from thirdparty/faiss/faiss/gpu/impl/IVFUtilsSelect1.cu
rename to thirdparty/faiss/knowherefaiss/gpu/impl/IVFUtilsSelect1.cu
index d36faeb9..d6fb7ede 100644
--- a/thirdparty/faiss/faiss/gpu/impl/IVFUtilsSelect1.cu
+++ b/thirdparty/faiss/knowherefaiss/gpu/impl/IVFUtilsSelect1.cu
@@ -5,20 +5,20 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/gpu/utils/DeviceUtils.h>
-#include <faiss/gpu/utils/StaticUtils.h>
-#include <faiss/gpu/impl/IVFUtils.cuh>
-#include <faiss/gpu/utils/DeviceDefs.cuh>
-#include <faiss/gpu/utils/Limits.cuh>
-#include <faiss/gpu/utils/Select.cuh>
-#include <faiss/gpu/utils/Tensor.cuh>
+#include <knowherefaiss/gpu/utils/DeviceUtils.h>
+#include <knowherefaiss/gpu/utils/StaticUtils.h>
+#include <knowherefaiss/gpu/impl/IVFUtils.cuh>
+#include <knowherefaiss/gpu/utils/DeviceDefs.cuh>
+#include <knowherefaiss/gpu/utils/Limits.cuh>
+#include <knowherefaiss/gpu/utils/Select.cuh>
+#include <knowherefaiss/gpu/utils/Tensor.cuh>
 
 //
 // This kernel is split into a separate compilation unit to cut down
 // on compile time
 //
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 template <int ThreadsPerBlock, int NumWarpQ, int NumThreadQ, bool Dir>
@@ -213,4 +213,4 @@ void runPass1SelectLists(
 }
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/impl/IVFUtilsSelect2.cu b/thirdparty/faiss/knowherefaiss/gpu/impl/IVFUtilsSelect2.cu
similarity index 94%
rename from thirdparty/faiss/faiss/gpu/impl/IVFUtilsSelect2.cu
rename to thirdparty/faiss/knowherefaiss/gpu/impl/IVFUtilsSelect2.cu
index 7b6ea707..4705c4c4 100644
--- a/thirdparty/faiss/faiss/gpu/impl/IVFUtilsSelect2.cu
+++ b/thirdparty/faiss/knowherefaiss/gpu/impl/IVFUtilsSelect2.cu
@@ -5,20 +5,20 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/gpu/utils/DeviceUtils.h>
-#include <faiss/gpu/utils/StaticUtils.h>
-#include <faiss/gpu/impl/IVFUtils.cuh>
-#include <faiss/gpu/utils/DeviceDefs.cuh>
-#include <faiss/gpu/utils/Limits.cuh>
-#include <faiss/gpu/utils/Select.cuh>
-#include <faiss/gpu/utils/Tensor.cuh>
+#include <knowherefaiss/gpu/utils/DeviceUtils.h>
+#include <knowherefaiss/gpu/utils/StaticUtils.h>
+#include <knowherefaiss/gpu/impl/IVFUtils.cuh>
+#include <knowherefaiss/gpu/utils/DeviceDefs.cuh>
+#include <knowherefaiss/gpu/utils/Limits.cuh>
+#include <knowherefaiss/gpu/utils/Select.cuh>
+#include <knowherefaiss/gpu/utils/Tensor.cuh>
 
 //
 // This kernel is split into a separate compilation unit to cut down
 // on compile time
 //
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 // This is warp divergence central, but this is really a final step
@@ -221,4 +221,4 @@ void runPass2SelectLists(
 }
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/impl/IcmEncoder.cu b/thirdparty/faiss/knowherefaiss/gpu/impl/IcmEncoder.cu
similarity index 95%
rename from thirdparty/faiss/faiss/gpu/impl/IcmEncoder.cu
rename to thirdparty/faiss/knowherefaiss/gpu/impl/IcmEncoder.cu
index 81f234f2..94aee39a 100644
--- a/thirdparty/faiss/faiss/gpu/impl/IcmEncoder.cu
+++ b/thirdparty/faiss/knowherefaiss/gpu/impl/IcmEncoder.cu
@@ -5,21 +5,21 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/gpu/impl/IcmEncoder.cuh>
-
-#include <faiss/gpu/GpuResources.h>
-#include <faiss/impl/FaissAssert.h>
-#include <faiss/gpu/impl/L2Norm.cuh>
-#include <faiss/gpu/utils/CopyUtils.cuh>
-#include <faiss/gpu/utils/DeviceDefs.cuh>
-#include <faiss/gpu/utils/DeviceTensor.cuh>
-#include <faiss/gpu/utils/MatrixMult.cuh>
-#include <faiss/gpu/utils/Pair.cuh>
-#include <faiss/gpu/utils/Reductions.cuh>
+#include <knowherefaiss/gpu/impl/IcmEncoder.cuh>
+
+#include <knowherefaiss/gpu/GpuResources.h>
+#include <knowherefaiss/impl/FaissAssert.h>
+#include <knowherefaiss/gpu/impl/L2Norm.cuh>
+#include <knowherefaiss/gpu/utils/CopyUtils.cuh>
+#include <knowherefaiss/gpu/utils/DeviceDefs.cuh>
+#include <knowherefaiss/gpu/utils/DeviceTensor.cuh>
+#include <knowherefaiss/gpu/utils/MatrixMult.cuh>
+#include <knowherefaiss/gpu/utils/Pair.cuh>
+#include <knowherefaiss/gpu/utils/Reductions.cuh>
 
 #include <curand_kernel.h>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 extern __shared__ char smem[];
@@ -376,4 +376,4 @@ void IcmEncoderImpl::encode(
 }
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/impl/IcmEncoder.cuh b/thirdparty/faiss/knowherefaiss/gpu/impl/IcmEncoder.cuh
similarity index 92%
rename from thirdparty/faiss/faiss/gpu/impl/IcmEncoder.cuh
rename to thirdparty/faiss/knowherefaiss/gpu/impl/IcmEncoder.cuh
index dbbd27cf..79a73822 100644
--- a/thirdparty/faiss/faiss/gpu/impl/IcmEncoder.cuh
+++ b/thirdparty/faiss/knowherefaiss/gpu/impl/IcmEncoder.cuh
@@ -7,12 +7,12 @@
 
 #pragma once
 
-#include <faiss/gpu/GpuResources.h>
-#include <faiss/gpu/utils/DeviceTensor.cuh>
+#include <knowherefaiss/gpu/GpuResources.h>
+#include <knowherefaiss/gpu/utils/DeviceTensor.cuh>
 
 #include <random>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 struct IcmEncoderImpl {
@@ -76,4 +76,4 @@ struct IcmEncoderImpl {
 };
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/impl/InterleavedCodes.cpp b/thirdparty/faiss/knowherefaiss/gpu/impl/InterleavedCodes.cpp
similarity index 98%
rename from thirdparty/faiss/faiss/gpu/impl/InterleavedCodes.cpp
rename to thirdparty/faiss/knowherefaiss/gpu/impl/InterleavedCodes.cpp
index 801ff721..b969e89c 100644
--- a/thirdparty/faiss/faiss/gpu/impl/InterleavedCodes.cpp
+++ b/thirdparty/faiss/knowherefaiss/gpu/impl/InterleavedCodes.cpp
@@ -5,11 +5,11 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/gpu/impl/InterleavedCodes.h>
-#include <faiss/gpu/utils/StaticUtils.h>
-#include <faiss/impl/FaissAssert.h>
+#include <knowherefaiss/gpu/impl/InterleavedCodes.h>
+#include <knowherefaiss/gpu/utils/StaticUtils.h>
+#include <knowherefaiss/impl/FaissAssert.h>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 inline uint8_t unpack5(int i, uint8_t vLower, uint8_t vUpper) {
@@ -556,4 +556,4 @@ std::vector<uint8_t> packInterleaved(
 }
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/impl/InterleavedCodes.h b/thirdparty/faiss/knowherefaiss/gpu/impl/InterleavedCodes.h
similarity index 96%
rename from thirdparty/faiss/faiss/gpu/impl/InterleavedCodes.h
rename to thirdparty/faiss/knowherefaiss/gpu/impl/InterleavedCodes.h
index 2014f7ec..7c46d403 100644
--- a/thirdparty/faiss/faiss/gpu/impl/InterleavedCodes.h
+++ b/thirdparty/faiss/knowherefaiss/gpu/impl/InterleavedCodes.h
@@ -12,7 +12,7 @@
 
 // Utilities for bit packing and unpacking CPU non-interleaved and GPU
 // interleaved by 32 encodings
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 // Unpacks arbitrary bitwidth codes to a whole number of bytes per code
@@ -54,4 +54,4 @@ std::vector<uint8_t> packInterleaved(
         int bitsPerCode);
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/impl/L2Norm.cu b/thirdparty/faiss/knowherefaiss/gpu/impl/L2Norm.cu
similarity index 95%
rename from thirdparty/faiss/faiss/gpu/impl/L2Norm.cu
rename to thirdparty/faiss/knowherefaiss/gpu/impl/L2Norm.cu
index 4341a6d0..49da31e3 100644
--- a/thirdparty/faiss/faiss/gpu/impl/L2Norm.cu
+++ b/thirdparty/faiss/knowherefaiss/gpu/impl/L2Norm.cu
@@ -5,20 +5,20 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/gpu/utils/DeviceUtils.h>
-#include <faiss/gpu/utils/StaticUtils.h>
-#include <faiss/impl/FaissAssert.h>
-#include <faiss/gpu/impl/L2Norm.cuh>
-#include <faiss/gpu/utils/ConversionOperators.cuh>
-#include <faiss/gpu/utils/DeviceDefs.cuh>
-#include <faiss/gpu/utils/Float16.cuh>
-#include <faiss/gpu/utils/MathOperators.cuh>
-#include <faiss/gpu/utils/PtxUtils.cuh>
-#include <faiss/gpu/utils/Reductions.cuh>
+#include <knowherefaiss/gpu/utils/DeviceUtils.h>
+#include <knowherefaiss/gpu/utils/StaticUtils.h>
+#include <knowherefaiss/impl/FaissAssert.h>
+#include <knowherefaiss/gpu/impl/L2Norm.cuh>
+#include <knowherefaiss/gpu/utils/ConversionOperators.cuh>
+#include <knowherefaiss/gpu/utils/DeviceDefs.cuh>
+#include <knowherefaiss/gpu/utils/Float16.cuh>
+#include <knowherefaiss/gpu/utils/MathOperators.cuh>
+#include <knowherefaiss/gpu/utils/PtxUtils.cuh>
+#include <knowherefaiss/gpu/utils/Reductions.cuh>
 
 #include <algorithm>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 // Input: (batch x dim)
@@ -360,4 +360,4 @@ void runL2Norm(
 }
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/impl/L2Norm.cuh b/thirdparty/faiss/knowherefaiss/gpu/impl/L2Norm.cuh
similarity index 85%
rename from thirdparty/faiss/faiss/gpu/impl/L2Norm.cuh
rename to thirdparty/faiss/knowherefaiss/gpu/impl/L2Norm.cuh
index db4b3dd1..2f58ac6b 100644
--- a/thirdparty/faiss/faiss/gpu/impl/L2Norm.cuh
+++ b/thirdparty/faiss/knowherefaiss/gpu/impl/L2Norm.cuh
@@ -7,9 +7,9 @@
 
 #pragma once
 
-#include <faiss/gpu/utils/Tensor.cuh>
+#include <knowherefaiss/gpu/utils/Tensor.cuh>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 void runL2Norm(
@@ -27,4 +27,4 @@ void runL2Norm(
         cudaStream_t stream);
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/impl/L2Select.cu b/thirdparty/faiss/knowherefaiss/gpu/impl/L2Select.cu
similarity index 94%
rename from thirdparty/faiss/faiss/gpu/impl/L2Select.cu
rename to thirdparty/faiss/knowherefaiss/gpu/impl/L2Select.cu
index be467eb0..6ea02daa 100644
--- a/thirdparty/faiss/faiss/gpu/impl/L2Select.cu
+++ b/thirdparty/faiss/knowherefaiss/gpu/impl/L2Select.cu
@@ -5,19 +5,19 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/impl/FaissAssert.h>
-#include <faiss/gpu/impl/L2Select.cuh>
-
-#include <faiss/gpu/utils/DeviceUtils.h>
-#include <faiss/gpu/utils/StaticUtils.h>
-#include <faiss/gpu/utils/DeviceDefs.cuh>
-#include <faiss/gpu/utils/MathOperators.cuh>
-#include <faiss/gpu/utils/Pair.cuh>
-#include <faiss/gpu/utils/Reductions.cuh>
-#include <faiss/gpu/utils/Select.cuh>
-#include <faiss/gpu/utils/Tensor.cuh>
-
-namespace faiss {
+#include <knowherefaiss/impl/FaissAssert.h>
+#include <knowherefaiss/gpu/impl/L2Select.cuh>
+
+#include <knowherefaiss/gpu/utils/DeviceUtils.h>
+#include <knowherefaiss/gpu/utils/StaticUtils.h>
+#include <knowherefaiss/gpu/utils/DeviceDefs.cuh>
+#include <knowherefaiss/gpu/utils/MathOperators.cuh>
+#include <knowherefaiss/gpu/utils/Pair.cuh>
+#include <knowherefaiss/gpu/utils/Reductions.cuh>
+#include <knowherefaiss/gpu/utils/Select.cuh>
+#include <knowherefaiss/gpu/utils/Tensor.cuh>
+
+namespace knowherefaiss {
 namespace gpu {
 
 // L2 + select kernel for k == 1, implements re-use of ||c||^2
@@ -282,4 +282,4 @@ void runL2SelectMin(
 }
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/impl/L2Select.cuh b/thirdparty/faiss/knowherefaiss/gpu/impl/L2Select.cuh
similarity index 83%
rename from thirdparty/faiss/faiss/gpu/impl/L2Select.cuh
rename to thirdparty/faiss/knowherefaiss/gpu/impl/L2Select.cuh
index fb6e00f5..a4b61dbd 100644
--- a/thirdparty/faiss/faiss/gpu/impl/L2Select.cuh
+++ b/thirdparty/faiss/knowherefaiss/gpu/impl/L2Select.cuh
@@ -7,9 +7,9 @@
 
 #pragma once
 
-#include <faiss/gpu/utils/Tensor.cuh>
+#include <knowherefaiss/gpu/utils/Tensor.cuh>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 void runL2SelectMin(
@@ -22,4 +22,4 @@ void runL2SelectMin(
         cudaStream_t stream);
 
 }
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/impl/PQCodeDistances-inl.cuh b/thirdparty/faiss/knowherefaiss/gpu/impl/PQCodeDistances-inl.cuh
similarity index 97%
rename from thirdparty/faiss/faiss/gpu/impl/PQCodeDistances-inl.cuh
rename to thirdparty/faiss/knowherefaiss/gpu/impl/PQCodeDistances-inl.cuh
index 63919e84..56924a25 100644
--- a/thirdparty/faiss/faiss/gpu/impl/PQCodeDistances-inl.cuh
+++ b/thirdparty/faiss/knowherefaiss/gpu/impl/PQCodeDistances-inl.cuh
@@ -5,19 +5,19 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/gpu/utils/DeviceUtils.h>
-#include <faiss/gpu/utils/StaticUtils.h>
-#include <faiss/gpu/impl/BroadcastSum.cuh>
-#include <faiss/gpu/impl/Distance.cuh>
-#include <faiss/gpu/impl/L2Norm.cuh>
-#include <faiss/gpu/utils/ConversionOperators.cuh>
-#include <faiss/gpu/utils/DeviceDefs.cuh>
-#include <faiss/gpu/utils/Float16.cuh>
-#include <faiss/gpu/utils/MatrixMult.cuh>
-#include <faiss/gpu/utils/PtxUtils.cuh>
-#include <faiss/gpu/utils/Transpose.cuh>
-
-namespace faiss {
+#include <knowherefaiss/gpu/utils/DeviceUtils.h>
+#include <knowherefaiss/gpu/utils/StaticUtils.h>
+#include <knowherefaiss/gpu/impl/BroadcastSum.cuh>
+#include <knowherefaiss/gpu/impl/Distance.cuh>
+#include <knowherefaiss/gpu/impl/L2Norm.cuh>
+#include <knowherefaiss/gpu/utils/ConversionOperators.cuh>
+#include <knowherefaiss/gpu/utils/DeviceDefs.cuh>
+#include <knowherefaiss/gpu/utils/Float16.cuh>
+#include <knowherefaiss/gpu/utils/MatrixMult.cuh>
+#include <knowherefaiss/gpu/utils/PtxUtils.cuh>
+#include <knowherefaiss/gpu/utils/Transpose.cuh>
+
+namespace knowherefaiss {
 namespace gpu {
 
 // Kernel responsible for calculating distance from residual vector to
@@ -728,4 +728,4 @@ void runPQCodeDistances(
 }
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/impl/PQCodeDistances.cuh b/thirdparty/faiss/knowherefaiss/gpu/impl/PQCodeDistances.cuh
similarity index 81%
rename from thirdparty/faiss/faiss/gpu/impl/PQCodeDistances.cuh
rename to thirdparty/faiss/knowherefaiss/gpu/impl/PQCodeDistances.cuh
index 2edfe463..97028764 100644
--- a/thirdparty/faiss/faiss/gpu/impl/PQCodeDistances.cuh
+++ b/thirdparty/faiss/knowherefaiss/gpu/impl/PQCodeDistances.cuh
@@ -8,10 +8,10 @@
 #pragma once
 
 #include <cublas_v2.h>
-#include <faiss/gpu/utils/NoTypeTensor.cuh>
-#include <faiss/gpu/utils/Tensor.cuh>
+#include <knowherefaiss/gpu/utils/NoTypeTensor.cuh>
+#include <knowherefaiss/gpu/utils/Tensor.cuh>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 class DeviceMemory;
@@ -34,6 +34,6 @@ void runPQCodeDistances(
         bool useFloat16Lookup);
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
 
-#include <faiss/gpu/impl/PQCodeDistances-inl.cuh>
+#include <knowherefaiss/gpu/impl/PQCodeDistances-inl.cuh>
diff --git a/thirdparty/faiss/faiss/gpu/impl/PQCodeLoad.cuh b/thirdparty/faiss/knowherefaiss/gpu/impl/PQCodeLoad.cuh
similarity index 99%
rename from thirdparty/faiss/faiss/gpu/impl/PQCodeLoad.cuh
rename to thirdparty/faiss/knowherefaiss/gpu/impl/PQCodeLoad.cuh
index e9b8fc9c..e04123e7 100644
--- a/thirdparty/faiss/faiss/gpu/impl/PQCodeLoad.cuh
+++ b/thirdparty/faiss/knowherefaiss/gpu/impl/PQCodeLoad.cuh
@@ -7,9 +7,9 @@
 
 #pragma once
 
-#include <faiss/gpu/utils/PtxUtils.cuh>
+#include <knowherefaiss/gpu/utils/PtxUtils.cuh>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 #if __CUDA_ARCH__ >= 350
@@ -379,4 +379,4 @@ struct LoadCode32<96> {
 };
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/impl/PQScanMultiPassNoPrecomputed-inl.cuh b/thirdparty/faiss/knowherefaiss/gpu/impl/PQScanMultiPassNoPrecomputed-inl.cuh
similarity index 97%
rename from thirdparty/faiss/faiss/gpu/impl/PQScanMultiPassNoPrecomputed-inl.cuh
rename to thirdparty/faiss/knowherefaiss/gpu/impl/PQScanMultiPassNoPrecomputed-inl.cuh
index 2689c981..260bfd0b 100644
--- a/thirdparty/faiss/faiss/gpu/impl/PQScanMultiPassNoPrecomputed-inl.cuh
+++ b/thirdparty/faiss/knowherefaiss/gpu/impl/PQScanMultiPassNoPrecomputed-inl.cuh
@@ -5,21 +5,21 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/gpu/GpuResources.h>
-#include <faiss/gpu/utils/DeviceUtils.h>
-#include <faiss/gpu/utils/StaticUtils.h>
-#include <faiss/gpu/impl/IVFUtils.cuh>
-#include <faiss/gpu/impl/PQCodeDistances.cuh>
-#include <faiss/gpu/impl/PQCodeLoad.cuh>
-#include <faiss/gpu/utils/ConversionOperators.cuh>
-#include <faiss/gpu/utils/DeviceTensor.cuh>
-#include <faiss/gpu/utils/Float16.cuh>
-#include <faiss/gpu/utils/HostTensor.cuh>
-#include <faiss/gpu/utils/LoadStoreOperators.cuh>
-#include <faiss/gpu/utils/NoTypeTensor.cuh>
-#include <faiss/gpu/utils/WarpPackedBits.cuh>
-
-namespace faiss {
+#include <knowherefaiss/gpu/GpuResources.h>
+#include <knowherefaiss/gpu/utils/DeviceUtils.h>
+#include <knowherefaiss/gpu/utils/StaticUtils.h>
+#include <knowherefaiss/gpu/impl/IVFUtils.cuh>
+#include <knowherefaiss/gpu/impl/PQCodeDistances.cuh>
+#include <knowherefaiss/gpu/impl/PQCodeLoad.cuh>
+#include <knowherefaiss/gpu/utils/ConversionOperators.cuh>
+#include <knowherefaiss/gpu/utils/DeviceTensor.cuh>
+#include <knowherefaiss/gpu/utils/Float16.cuh>
+#include <knowherefaiss/gpu/utils/HostTensor.cuh>
+#include <knowherefaiss/gpu/utils/LoadStoreOperators.cuh>
+#include <knowherefaiss/gpu/utils/NoTypeTensor.cuh>
+#include <knowherefaiss/gpu/utils/WarpPackedBits.cuh>
+
+namespace knowherefaiss {
 namespace gpu {
 
 // A basic implementation that works for the interleaved by vector layout for
@@ -295,7 +295,7 @@ void runMultiPassTile(
         Tensor<float, 3, true>& heapDistances,
         Tensor<int, 3, true>& heapIndices,
         int k,
-        faiss::MetricType metric,
+        knowherefaiss::MetricType metric,
         Tensor<float, 2, true>& outDistances,
         Tensor<Index::idx_t, 2, true>& outIndices,
         cudaStream_t stream) {
@@ -545,7 +545,7 @@ void runPQScanMultiPassNoPrecomputed(
         thrust::device_vector<int>& listLengths,
         int maxListLength,
         int k,
-        faiss::MetricType metric,
+        knowherefaiss::MetricType metric,
         // output
         Tensor<float, 2, true>& outDistances,
         // output
@@ -753,4 +753,4 @@ void runPQScanMultiPassNoPrecomputed(
 }
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/impl/PQScanMultiPassNoPrecomputed.cuh b/thirdparty/faiss/knowherefaiss/gpu/impl/PQScanMultiPassNoPrecomputed.cuh
similarity index 78%
rename from thirdparty/faiss/faiss/gpu/impl/PQScanMultiPassNoPrecomputed.cuh
rename to thirdparty/faiss/knowherefaiss/gpu/impl/PQScanMultiPassNoPrecomputed.cuh
index 7b364dbc..fef60bb2 100644
--- a/thirdparty/faiss/faiss/gpu/impl/PQScanMultiPassNoPrecomputed.cuh
+++ b/thirdparty/faiss/knowherefaiss/gpu/impl/PQScanMultiPassNoPrecomputed.cuh
@@ -7,13 +7,13 @@
 
 #pragma once
 
-#include <faiss/Index.h>
-#include <faiss/MetricType.h>
-#include <faiss/gpu/GpuIndicesOptions.h>
+#include <knowherefaiss/Index.h>
+#include <knowherefaiss/MetricType.h>
+#include <knowherefaiss/gpu/GpuIndicesOptions.h>
 #include <thrust/device_vector.h>
-#include <faiss/gpu/utils/Tensor.cuh>
+#include <knowherefaiss/gpu/utils/Tensor.cuh>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 class GpuResources;
@@ -38,7 +38,7 @@ void runPQScanMultiPassNoPrecomputed(
         thrust::device_vector<int>& listLengths,
         int maxListLength,
         int k,
-        faiss::MetricType metric,
+        knowherefaiss::MetricType metric,
         // output
         Tensor<float, 2, true>& outDistances,
         // output
@@ -46,6 +46,6 @@ void runPQScanMultiPassNoPrecomputed(
         GpuResources* res);
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
 
-#include <faiss/gpu/impl/PQScanMultiPassNoPrecomputed-inl.cuh>
+#include <knowherefaiss/gpu/impl/PQScanMultiPassNoPrecomputed-inl.cuh>
diff --git a/thirdparty/faiss/faiss/gpu/impl/PQScanMultiPassPrecomputed.cu b/thirdparty/faiss/knowherefaiss/gpu/impl/PQScanMultiPassPrecomputed.cu
similarity index 97%
rename from thirdparty/faiss/faiss/gpu/impl/PQScanMultiPassPrecomputed.cu
rename to thirdparty/faiss/knowherefaiss/gpu/impl/PQScanMultiPassPrecomputed.cu
index be8da5c0..cf985d80 100644
--- a/thirdparty/faiss/faiss/gpu/impl/PQScanMultiPassPrecomputed.cu
+++ b/thirdparty/faiss/knowherefaiss/gpu/impl/PQScanMultiPassPrecomputed.cu
@@ -5,23 +5,23 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/gpu/GpuResources.h>
-#include <faiss/gpu/utils/DeviceUtils.h>
-#include <faiss/gpu/utils/StaticUtils.h>
-#include <faiss/gpu/impl/IVFUtils.cuh>
-#include <faiss/gpu/impl/PQCodeLoad.cuh>
-#include <faiss/gpu/impl/PQScanMultiPassPrecomputed.cuh>
-#include <faiss/gpu/utils/ConversionOperators.cuh>
-#include <faiss/gpu/utils/DeviceTensor.cuh>
-#include <faiss/gpu/utils/Float16.cuh>
-#include <faiss/gpu/utils/LoadStoreOperators.cuh>
-#include <faiss/gpu/utils/MathOperators.cuh>
-#include <faiss/gpu/utils/WarpPackedBits.cuh>
+#include <knowherefaiss/gpu/GpuResources.h>
+#include <knowherefaiss/gpu/utils/DeviceUtils.h>
+#include <knowherefaiss/gpu/utils/StaticUtils.h>
+#include <knowherefaiss/gpu/impl/IVFUtils.cuh>
+#include <knowherefaiss/gpu/impl/PQCodeLoad.cuh>
+#include <knowherefaiss/gpu/impl/PQScanMultiPassPrecomputed.cuh>
+#include <knowherefaiss/gpu/utils/ConversionOperators.cuh>
+#include <knowherefaiss/gpu/utils/DeviceTensor.cuh>
+#include <knowherefaiss/gpu/utils/Float16.cuh>
+#include <knowherefaiss/gpu/utils/LoadStoreOperators.cuh>
+#include <knowherefaiss/gpu/utils/MathOperators.cuh>
+#include <knowherefaiss/gpu/utils/WarpPackedBits.cuh>
 
 #include <algorithm>
 #include <limits>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 // A basic implementation that works for the interleaved by vector layout for
@@ -739,4 +739,4 @@ void runPQScanMultiPassPrecomputed(
 }
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/impl/PQScanMultiPassPrecomputed.cuh b/thirdparty/faiss/knowherefaiss/gpu/impl/PQScanMultiPassPrecomputed.cuh
similarity index 83%
rename from thirdparty/faiss/faiss/gpu/impl/PQScanMultiPassPrecomputed.cuh
rename to thirdparty/faiss/knowherefaiss/gpu/impl/PQScanMultiPassPrecomputed.cuh
index 1f2355df..8f0612df 100644
--- a/thirdparty/faiss/faiss/gpu/impl/PQScanMultiPassPrecomputed.cuh
+++ b/thirdparty/faiss/knowherefaiss/gpu/impl/PQScanMultiPassPrecomputed.cuh
@@ -7,13 +7,13 @@
 
 #pragma once
 
-#include <faiss/Index.h>
-#include <faiss/gpu/GpuIndicesOptions.h>
+#include <knowherefaiss/Index.h>
+#include <knowherefaiss/gpu/GpuIndicesOptions.h>
 #include <thrust/device_vector.h>
-#include <faiss/gpu/utils/NoTypeTensor.cuh>
-#include <faiss/gpu/utils/Tensor.cuh>
+#include <knowherefaiss/gpu/utils/NoTypeTensor.cuh>
+#include <knowherefaiss/gpu/utils/Tensor.cuh>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 class GpuResources;
@@ -43,4 +43,4 @@ void runPQScanMultiPassPrecomputed(
         GpuResources* res);
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/impl/RemapIndices.cpp b/thirdparty/faiss/knowherefaiss/gpu/impl/RemapIndices.cpp
similarity index 88%
rename from thirdparty/faiss/faiss/gpu/impl/RemapIndices.cpp
rename to thirdparty/faiss/knowherefaiss/gpu/impl/RemapIndices.cpp
index 321400c6..f77d7ef4 100644
--- a/thirdparty/faiss/faiss/gpu/impl/RemapIndices.cpp
+++ b/thirdparty/faiss/knowherefaiss/gpu/impl/RemapIndices.cpp
@@ -5,10 +5,10 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/gpu/impl/RemapIndices.h>
-#include <faiss/impl/FaissAssert.h>
+#include <knowherefaiss/gpu/impl/RemapIndices.h>
+#include <knowherefaiss/impl/FaissAssert.h>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 // Utility function to translate (list id, offset) to a user index on
@@ -42,4 +42,4 @@ void ivfOffsetToUserIndex(
 }
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/impl/RemapIndices.h b/thirdparty/faiss/knowherefaiss/gpu/impl/RemapIndices.h
similarity index 86%
rename from thirdparty/faiss/faiss/gpu/impl/RemapIndices.h
rename to thirdparty/faiss/knowherefaiss/gpu/impl/RemapIndices.h
index db833959..9a876722 100644
--- a/thirdparty/faiss/faiss/gpu/impl/RemapIndices.h
+++ b/thirdparty/faiss/knowherefaiss/gpu/impl/RemapIndices.h
@@ -7,10 +7,10 @@
 
 #pragma once
 
-#include <faiss/Index.h>
+#include <knowherefaiss/Index.h>
 #include <vector>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 /// Utility function to translate (list id, offset) to a user index on
@@ -23,4 +23,4 @@ void ivfOffsetToUserIndex(
         const std::vector<std::vector<Index::idx_t>>& listOffsetToUserIndex);
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/impl/VectorResidual.cu b/thirdparty/faiss/knowherefaiss/gpu/impl/VectorResidual.cu
similarity index 92%
rename from thirdparty/faiss/faiss/gpu/impl/VectorResidual.cu
rename to thirdparty/faiss/knowherefaiss/gpu/impl/VectorResidual.cu
index 2e51677d..d8554a38 100644
--- a/thirdparty/faiss/faiss/gpu/impl/VectorResidual.cu
+++ b/thirdparty/faiss/knowherefaiss/gpu/impl/VectorResidual.cu
@@ -5,17 +5,17 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/gpu/utils/DeviceUtils.h>
-#include <faiss/gpu/utils/StaticUtils.h>
-#include <faiss/impl/FaissAssert.h>
+#include <knowherefaiss/gpu/utils/DeviceUtils.h>
+#include <knowherefaiss/gpu/utils/StaticUtils.h>
+#include <knowherefaiss/impl/FaissAssert.h>
 #include <math_constants.h> // in CUDA SDK, for CUDART_NAN_F
-#include <faiss/gpu/impl/VectorResidual.cuh>
-#include <faiss/gpu/utils/ConversionOperators.cuh>
-#include <faiss/gpu/utils/Tensor.cuh>
+#include <knowherefaiss/gpu/impl/VectorResidual.cuh>
+#include <knowherefaiss/gpu/utils/ConversionOperators.cuh>
+#include <knowherefaiss/gpu/utils/Tensor.cuh>
 
 #include <algorithm>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 template <typename CentroidT, bool LargeDim>
@@ -153,4 +153,4 @@ void runReconstruct(
 }
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/impl/VectorResidual.cuh b/thirdparty/faiss/knowherefaiss/gpu/impl/VectorResidual.cuh
similarity index 91%
rename from thirdparty/faiss/faiss/gpu/impl/VectorResidual.cuh
rename to thirdparty/faiss/knowherefaiss/gpu/impl/VectorResidual.cuh
index 7c9b9c9a..e4d53888 100644
--- a/thirdparty/faiss/faiss/gpu/impl/VectorResidual.cuh
+++ b/thirdparty/faiss/knowherefaiss/gpu/impl/VectorResidual.cuh
@@ -7,9 +7,9 @@
 
 #pragma once
 
-#include <faiss/gpu/utils/Tensor.cuh>
+#include <knowherefaiss/gpu/utils/Tensor.cuh>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 // Calculates residual v_i - c_j for all v_i in vecs where j = vecToCentroid[i]
@@ -41,4 +41,4 @@ void runReconstruct(
         cudaStream_t stream);
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/impl/scan/IVFInterleaved1.cu b/thirdparty/faiss/knowherefaiss/gpu/impl/scan/IVFInterleaved1.cu
similarity index 67%
rename from thirdparty/faiss/faiss/gpu/impl/scan/IVFInterleaved1.cu
rename to thirdparty/faiss/knowherefaiss/gpu/impl/scan/IVFInterleaved1.cu
index 01c94a64..ceae4359 100644
--- a/thirdparty/faiss/faiss/gpu/impl/scan/IVFInterleaved1.cu
+++ b/thirdparty/faiss/knowherefaiss/gpu/impl/scan/IVFInterleaved1.cu
@@ -5,12 +5,12 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/gpu/impl/scan/IVFInterleavedImpl.cuh>
+#include <knowherefaiss/gpu/impl/scan/IVFInterleavedImpl.cuh>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 IVF_INTERLEAVED_IMPL(128, 1, 1)
 
 }
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/impl/scan/IVFInterleaved1024.cu b/thirdparty/faiss/knowherefaiss/gpu/impl/scan/IVFInterleaved1024.cu
similarity index 67%
rename from thirdparty/faiss/faiss/gpu/impl/scan/IVFInterleaved1024.cu
rename to thirdparty/faiss/knowherefaiss/gpu/impl/scan/IVFInterleaved1024.cu
index dc62d9f5..da07f52d 100644
--- a/thirdparty/faiss/faiss/gpu/impl/scan/IVFInterleaved1024.cu
+++ b/thirdparty/faiss/knowherefaiss/gpu/impl/scan/IVFInterleaved1024.cu
@@ -5,12 +5,12 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/gpu/impl/scan/IVFInterleavedImpl.cuh>
+#include <knowherefaiss/gpu/impl/scan/IVFInterleavedImpl.cuh>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 IVF_INTERLEAVED_IMPL(128, 1024, 8)
 
 }
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/impl/scan/IVFInterleaved128.cu b/thirdparty/faiss/knowherefaiss/gpu/impl/scan/IVFInterleaved128.cu
similarity index 67%
rename from thirdparty/faiss/faiss/gpu/impl/scan/IVFInterleaved128.cu
rename to thirdparty/faiss/knowherefaiss/gpu/impl/scan/IVFInterleaved128.cu
index 18e0c514..82d63359 100644
--- a/thirdparty/faiss/faiss/gpu/impl/scan/IVFInterleaved128.cu
+++ b/thirdparty/faiss/knowherefaiss/gpu/impl/scan/IVFInterleaved128.cu
@@ -5,12 +5,12 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/gpu/impl/scan/IVFInterleavedImpl.cuh>
+#include <knowherefaiss/gpu/impl/scan/IVFInterleavedImpl.cuh>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 IVF_INTERLEAVED_IMPL(128, 128, 3)
 
 }
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/impl/scan/IVFInterleaved2048.cu b/thirdparty/faiss/knowherefaiss/gpu/impl/scan/IVFInterleaved2048.cu
similarity index 72%
rename from thirdparty/faiss/faiss/gpu/impl/scan/IVFInterleaved2048.cu
rename to thirdparty/faiss/knowherefaiss/gpu/impl/scan/IVFInterleaved2048.cu
index e7b83981..5dc41df7 100644
--- a/thirdparty/faiss/faiss/gpu/impl/scan/IVFInterleaved2048.cu
+++ b/thirdparty/faiss/knowherefaiss/gpu/impl/scan/IVFInterleaved2048.cu
@@ -5,9 +5,9 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/gpu/impl/scan/IVFInterleavedImpl.cuh>
+#include <knowherefaiss/gpu/impl/scan/IVFInterleavedImpl.cuh>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 #if GPU_MAX_SELECTION_K >= 2048
@@ -15,4 +15,4 @@ IVF_INTERLEAVED_IMPL(64, 2048, 8)
 #endif
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/impl/scan/IVFInterleaved256.cu b/thirdparty/faiss/knowherefaiss/gpu/impl/scan/IVFInterleaved256.cu
similarity index 67%
rename from thirdparty/faiss/faiss/gpu/impl/scan/IVFInterleaved256.cu
rename to thirdparty/faiss/knowherefaiss/gpu/impl/scan/IVFInterleaved256.cu
index ecfe8693..2e6ab6fc 100644
--- a/thirdparty/faiss/faiss/gpu/impl/scan/IVFInterleaved256.cu
+++ b/thirdparty/faiss/knowherefaiss/gpu/impl/scan/IVFInterleaved256.cu
@@ -5,12 +5,12 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/gpu/impl/scan/IVFInterleavedImpl.cuh>
+#include <knowherefaiss/gpu/impl/scan/IVFInterleavedImpl.cuh>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 IVF_INTERLEAVED_IMPL(128, 256, 4)
 
 }
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/impl/scan/IVFInterleaved32.cu b/thirdparty/faiss/knowherefaiss/gpu/impl/scan/IVFInterleaved32.cu
similarity index 67%
rename from thirdparty/faiss/faiss/gpu/impl/scan/IVFInterleaved32.cu
rename to thirdparty/faiss/knowherefaiss/gpu/impl/scan/IVFInterleaved32.cu
index 3b19a890..5f29da8a 100644
--- a/thirdparty/faiss/faiss/gpu/impl/scan/IVFInterleaved32.cu
+++ b/thirdparty/faiss/knowherefaiss/gpu/impl/scan/IVFInterleaved32.cu
@@ -5,12 +5,12 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/gpu/impl/scan/IVFInterleavedImpl.cuh>
+#include <knowherefaiss/gpu/impl/scan/IVFInterleavedImpl.cuh>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 IVF_INTERLEAVED_IMPL(128, 32, 2)
 
 }
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/impl/scan/IVFInterleaved512.cu b/thirdparty/faiss/knowherefaiss/gpu/impl/scan/IVFInterleaved512.cu
similarity index 67%
rename from thirdparty/faiss/faiss/gpu/impl/scan/IVFInterleaved512.cu
rename to thirdparty/faiss/knowherefaiss/gpu/impl/scan/IVFInterleaved512.cu
index 27bb8c83..40692ffc 100644
--- a/thirdparty/faiss/faiss/gpu/impl/scan/IVFInterleaved512.cu
+++ b/thirdparty/faiss/knowherefaiss/gpu/impl/scan/IVFInterleaved512.cu
@@ -5,12 +5,12 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/gpu/impl/scan/IVFInterleavedImpl.cuh>
+#include <knowherefaiss/gpu/impl/scan/IVFInterleavedImpl.cuh>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 IVF_INTERLEAVED_IMPL(128, 512, 8)
 
 }
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/impl/scan/IVFInterleaved64.cu b/thirdparty/faiss/knowherefaiss/gpu/impl/scan/IVFInterleaved64.cu
similarity index 67%
rename from thirdparty/faiss/faiss/gpu/impl/scan/IVFInterleaved64.cu
rename to thirdparty/faiss/knowherefaiss/gpu/impl/scan/IVFInterleaved64.cu
index 0788f844..9b6f9278 100644
--- a/thirdparty/faiss/faiss/gpu/impl/scan/IVFInterleaved64.cu
+++ b/thirdparty/faiss/knowherefaiss/gpu/impl/scan/IVFInterleaved64.cu
@@ -5,12 +5,12 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/gpu/impl/scan/IVFInterleavedImpl.cuh>
+#include <knowherefaiss/gpu/impl/scan/IVFInterleavedImpl.cuh>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 IVF_INTERLEAVED_IMPL(128, 64, 3)
 
 }
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/impl/scan/IVFInterleavedImpl.cuh b/thirdparty/faiss/knowherefaiss/gpu/impl/scan/IVFInterleavedImpl.cuh
similarity index 92%
rename from thirdparty/faiss/faiss/gpu/impl/scan/IVFInterleavedImpl.cuh
rename to thirdparty/faiss/knowherefaiss/gpu/impl/scan/IVFInterleavedImpl.cuh
index 84a94a0a..3f0249e9 100644
--- a/thirdparty/faiss/faiss/gpu/impl/scan/IVFInterleavedImpl.cuh
+++ b/thirdparty/faiss/knowherefaiss/gpu/impl/scan/IVFInterleavedImpl.cuh
@@ -7,8 +7,8 @@
 
 #pragma once
 
-#include <faiss/gpu/impl/IVFInterleaved.cuh>
-#include <faiss/gpu/utils/DeviceDefs.cuh>
+#include <knowherefaiss/gpu/impl/IVFInterleaved.cuh>
+#include <knowherefaiss/gpu/utils/DeviceDefs.cuh>
 
 #define IVF_INTERLEAVED_IMPL(THREADS, WARP_Q, THREAD_Q) \
                                                         \
@@ -21,7 +21,7 @@
             IndicesOptions indicesOptions,              \
             thrust::device_vector<int>& listLengths,    \
             int k,                                      \
-            faiss::MetricType metric,                   \
+            knowherefaiss::MetricType metric,                   \
             bool useResidual,                           \
             Tensor<float, 3, true>& residualBase,       \
             GpuScalarQuantizer* scalarQ,                \
@@ -46,7 +46,7 @@
             IndicesOptions indicesOptions,             \
             thrust::device_vector<int>& listLengths,   \
             int k,                                     \
-            faiss::MetricType metric,                  \
+            knowherefaiss::MetricType metric,                  \
             bool useResidual,                          \
             Tensor<float, 3, true>& residualBase,      \
             GpuScalarQuantizer* scalarQ,               \
@@ -72,7 +72,7 @@
             outIndices,                 \
             res)
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 IVF_INTERLEAVED_DECL(1);
@@ -88,4 +88,4 @@ IVF_INTERLEAVED_DECL(2048);
 #endif
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/perf/IndexWrapper-inl.h b/thirdparty/faiss/knowherefaiss/gpu/perf/IndexWrapper-inl.h
similarity index 75%
rename from thirdparty/faiss/faiss/gpu/perf/IndexWrapper-inl.h
rename to thirdparty/faiss/knowherefaiss/gpu/perf/IndexWrapper-inl.h
index f3980cec..6cbdcc92 100644
--- a/thirdparty/faiss/faiss/gpu/perf/IndexWrapper-inl.h
+++ b/thirdparty/faiss/knowherefaiss/gpu/perf/IndexWrapper-inl.h
@@ -5,9 +5,9 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/impl/FaissAssert.h>
+#include <knowherefaiss/impl/FaissAssert.h>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 template <typename GpuIndex>
@@ -15,9 +15,9 @@ IndexWrapper<GpuIndex>::IndexWrapper(
         int numGpus,
         std::function<std::unique_ptr<GpuIndex>(GpuResourcesProvider*, int)>
                 init) {
-    FAISS_ASSERT(numGpus <= faiss::gpu::getNumDevices());
+    FAISS_ASSERT(numGpus <= knowherefaiss::gpu::getNumDevices());
     for (int i = 0; i < numGpus; ++i) {
-        auto res = std::unique_ptr<faiss::gpu::StandardGpuResources>(
+        auto res = std::unique_ptr<knowherefaiss::gpu::StandardGpuResources>(
                 new StandardGpuResources);
 
         subIndex.emplace_back(init(res.get(), i));
@@ -27,7 +27,7 @@ IndexWrapper<GpuIndex>::IndexWrapper(
     if (numGpus > 1) {
         // create proxy
         replicaIndex =
-                std::unique_ptr<faiss::IndexReplicas>(new faiss::IndexReplicas);
+                std::unique_ptr<knowherefaiss::IndexReplicas>(new knowherefaiss::IndexReplicas);
 
         for (auto& index : subIndex) {
             replicaIndex->addIndex(index.get());
@@ -36,7 +36,7 @@ IndexWrapper<GpuIndex>::IndexWrapper(
 }
 
 template <typename GpuIndex>
-faiss::Index* IndexWrapper<GpuIndex>::getIndex() {
+knowherefaiss::Index* IndexWrapper<GpuIndex>::getIndex() {
     if ((bool)replicaIndex) {
         return replicaIndex.get();
     } else {
@@ -48,7 +48,7 @@ faiss::Index* IndexWrapper<GpuIndex>::getIndex() {
 template <typename GpuIndex>
 void IndexWrapper<GpuIndex>::runOnIndices(std::function<void(GpuIndex*)> f) {
     if ((bool)replicaIndex) {
-        replicaIndex->runOnIndex([f](int, faiss::Index* index) {
+        replicaIndex->runOnIndex([f](int, knowherefaiss::Index* index) {
             f(dynamic_cast<GpuIndex*>(index));
         });
     } else {
@@ -63,4 +63,4 @@ void IndexWrapper<GpuIndex>::setNumProbes(int nprobe) {
 }
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/perf/IndexWrapper.h b/thirdparty/faiss/knowherefaiss/gpu/perf/IndexWrapper.h
similarity index 67%
rename from thirdparty/faiss/faiss/gpu/perf/IndexWrapper.h
rename to thirdparty/faiss/knowherefaiss/gpu/perf/IndexWrapper.h
index b9a22e84..f3d40f4a 100644
--- a/thirdparty/faiss/faiss/gpu/perf/IndexWrapper.h
+++ b/thirdparty/faiss/knowherefaiss/gpu/perf/IndexWrapper.h
@@ -7,13 +7,13 @@
 
 #pragma once
 
-#include <faiss/IndexReplicas.h>
-#include <faiss/gpu/StandardGpuResources.h>
+#include <knowherefaiss/IndexReplicas.h>
+#include <knowherefaiss/gpu/StandardGpuResources.h>
 #include <functional>
 #include <memory>
 #include <vector>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 // If we want to run multi-GPU, create a proxy to wrap the indices.
@@ -21,21 +21,21 @@ namespace gpu {
 // affect the timings.
 template <typename GpuIndex>
 struct IndexWrapper {
-    std::vector<std::unique_ptr<faiss::gpu::StandardGpuResources>> resources;
+    std::vector<std::unique_ptr<knowherefaiss::gpu::StandardGpuResources>> resources;
     std::vector<std::unique_ptr<GpuIndex>> subIndex;
-    std::unique_ptr<faiss::IndexReplicas> replicaIndex;
+    std::unique_ptr<knowherefaiss::IndexReplicas> replicaIndex;
 
     IndexWrapper(
             int numGpus,
             std::function<std::unique_ptr<GpuIndex>(GpuResourcesProvider*, int)>
                     init);
-    faiss::Index* getIndex();
+    knowherefaiss::Index* getIndex();
 
     void runOnIndices(std::function<void(GpuIndex*)> f);
     void setNumProbes(int nprobe);
 };
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
 
-#include <faiss/gpu/perf/IndexWrapper-inl.h>
+#include <knowherefaiss/gpu/perf/IndexWrapper-inl.h>
diff --git a/thirdparty/faiss/faiss/gpu/perf/PerfBinaryFlat.cu b/thirdparty/faiss/knowherefaiss/gpu/perf/PerfBinaryFlat.cu
similarity index 72%
rename from thirdparty/faiss/faiss/gpu/perf/PerfBinaryFlat.cu
rename to thirdparty/faiss/knowherefaiss/gpu/perf/PerfBinaryFlat.cu
index fae7c101..444cd204 100644
--- a/thirdparty/faiss/faiss/gpu/perf/PerfBinaryFlat.cu
+++ b/thirdparty/faiss/knowherefaiss/gpu/perf/PerfBinaryFlat.cu
@@ -5,16 +5,16 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/IndexBinaryFlat.h>
-#include <faiss/gpu/GpuIndexBinaryFlat.h>
-#include <faiss/gpu/StandardGpuResources.h>
-#include <faiss/gpu/test/TestUtils.h>
-#include <faiss/gpu/utils/DeviceUtils.h>
-#include <faiss/gpu/utils/Timer.h>
-#include <faiss/utils/random.h>
+#include <knowherefaiss/IndexBinaryFlat.h>
+#include <knowherefaiss/gpu/GpuIndexBinaryFlat.h>
+#include <knowherefaiss/gpu/StandardGpuResources.h>
+#include <knowherefaiss/gpu/test/TestUtils.h>
+#include <knowherefaiss/gpu/utils/DeviceUtils.h>
+#include <knowherefaiss/gpu/utils/Timer.h>
+#include <knowherefaiss/utils/random.h>
 #include <gflags/gflags.h>
-#include <faiss/gpu/utils/DeviceTensor.cuh>
-#include <faiss/gpu/utils/HostTensor.cuh>
+#include <knowherefaiss/gpu/utils/DeviceTensor.cuh>
+#include <knowherefaiss/gpu/utils/HostTensor.cuh>
 #include <map>
 #include <memory>
 #include <vector>
@@ -30,7 +30,7 @@ DEFINE_int64(pinned_mem, 0, "pinned memory allocation to use");
 DEFINE_bool(cpu, true, "run the CPU code for timing and comparison");
 DEFINE_bool(use_unified_mem, false, "use Pascal unified memory for the index");
 
-using namespace faiss::gpu;
+using namespace knowherefaiss::gpu;
 
 int main(int argc, char** argv) {
     gflags::ParseCommandLineFlags(&argc, &argv, true);
@@ -42,11 +42,11 @@ int main(int argc, char** argv) {
 
     auto numQueries = FLAGS_num_queries;
 
-    auto index = std::unique_ptr<faiss::IndexBinaryFlat>(
-            new faiss::IndexBinaryFlat(FLAGS_dim));
+    auto index = std::unique_ptr<knowherefaiss::IndexBinaryFlat>(
+            new knowherefaiss::IndexBinaryFlat(FLAGS_dim));
 
     HostTensor<unsigned char, 2, true> vecs({FLAGS_num, FLAGS_dim / 8});
-    faiss::byte_rand(vecs.data(), vecs.numElements(), seed);
+    knowherefaiss::byte_rand(vecs.data(), vecs.numElements(), seed);
 
     index->add(FLAGS_num, vecs.data());
 
@@ -60,18 +60,18 @@ int main(int argc, char** argv) {
     config.memorySpace =
             FLAGS_use_unified_mem ? MemorySpace::Unified : MemorySpace::Device;
 
-    faiss::gpu::StandardGpuResources res;
+    knowherefaiss::gpu::StandardGpuResources res;
 
-    faiss::gpu::GpuIndexBinaryFlat gpuIndex(&res, index.get(), config);
+    knowherefaiss::gpu::GpuIndexBinaryFlat gpuIndex(&res, index.get(), config);
     printf("copy done\n");
 
     // Build query vectors
     HostTensor<unsigned char, 2, true> cpuQuery({numQueries, FLAGS_dim / 8});
-    faiss::byte_rand(cpuQuery.data(), cpuQuery.numElements(), seed);
+    knowherefaiss::byte_rand(cpuQuery.data(), cpuQuery.numElements(), seed);
 
     // Time faiss CPU
     HostTensor<int, 2, true> cpuDistances({numQueries, FLAGS_k});
-    HostTensor<faiss::IndexBinary::idx_t, 2, true> cpuIndices(
+    HostTensor<knowherefaiss::IndexBinary::idx_t, 2, true> cpuIndices(
             {numQueries, FLAGS_k});
 
     if (FLAGS_cpu) {
@@ -90,10 +90,10 @@ int main(int argc, char** argv) {
     }
 
     HostTensor<int, 2, true> gpuDistances({numQueries, FLAGS_k});
-    HostTensor<faiss::Index::idx_t, 2, true> gpuIndices({numQueries, FLAGS_k});
+    HostTensor<knowherefaiss::Index::idx_t, 2, true> gpuIndices({numQueries, FLAGS_k});
 
     CUDA_VERIFY(cudaProfilerStart());
-    faiss::gpu::synchronizeAllDevices();
+    knowherefaiss::gpu::synchronizeAllDevices();
 
     float gpuTime = 0.0f;
 
diff --git a/thirdparty/faiss/faiss/gpu/perf/PerfClustering.cpp b/thirdparty/faiss/knowherefaiss/gpu/perf/PerfClustering.cpp
similarity index 73%
rename from thirdparty/faiss/faiss/gpu/perf/PerfClustering.cpp
rename to thirdparty/faiss/knowherefaiss/gpu/perf/PerfClustering.cpp
index 7586b435..b15575af 100644
--- a/thirdparty/faiss/faiss/gpu/perf/PerfClustering.cpp
+++ b/thirdparty/faiss/knowherefaiss/gpu/perf/PerfClustering.cpp
@@ -5,13 +5,13 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/Clustering.h>
-#include <faiss/gpu/GpuIndexFlat.h>
-#include <faiss/gpu/StandardGpuResources.h>
-#include <faiss/gpu/perf/IndexWrapper.h>
-#include <faiss/gpu/utils/DeviceUtils.h>
-#include <faiss/gpu/utils/Timer.h>
-#include <faiss/utils/random.h>
+#include <knowherefaiss/Clustering.h>
+#include <knowherefaiss/gpu/GpuIndexFlat.h>
+#include <knowherefaiss/gpu/StandardGpuResources.h>
+#include <knowherefaiss/gpu/perf/IndexWrapper.h>
+#include <knowherefaiss/gpu/utils/DeviceUtils.h>
+#include <knowherefaiss/gpu/utils/Timer.h>
+#include <knowherefaiss/utils/random.h>
 #include <gflags/gflags.h>
 #include <memory>
 #include <vector>
@@ -35,7 +35,7 @@ DEFINE_int64(
 DEFINE_int64(pinned_mem, -1, "pinned memory allocation to use");
 DEFINE_int32(max_points, -1, "max points per centroid");
 
-using namespace faiss::gpu;
+using namespace knowherefaiss::gpu;
 
 int main(int argc, char** argv) {
     gflags::ParseCommandLineFlags(&argc, &argv, true);
@@ -46,7 +46,7 @@ int main(int argc, char** argv) {
     printf("using seed %ld\n", seed);
 
     std::vector<float> vecs((size_t)FLAGS_num * FLAGS_dim);
-    faiss::float_rand(vecs.data(), vecs.size(), seed);
+    knowherefaiss::float_rand(vecs.data(), vecs.size(), seed);
 
     printf("K-means metric %s dim %d centroids %d num train %d niter %d\n",
            FLAGS_L2_metric ? "L2" : "IP",
@@ -59,10 +59,10 @@ int main(int argc, char** argv) {
            FLAGS_transposed ? "enabled" : "disabled");
     printf("verbose %s\n", FLAGS_verbose ? "enabled" : "disabled");
 
-    auto initFn = [](faiss::gpu::GpuResourcesProvider* res,
-                     int dev) -> std::unique_ptr<faiss::gpu::GpuIndexFlat> {
+    auto initFn = [](knowherefaiss::gpu::GpuResourcesProvider* res,
+                     int dev) -> std::unique_ptr<knowherefaiss::gpu::GpuIndexFlat> {
         if (FLAGS_pinned_mem >= 0) {
-            ((faiss::gpu::StandardGpuResources*)res)
+            ((knowherefaiss::gpu::StandardGpuResources*)res)
                     ->setPinnedMemory(FLAGS_pinned_mem);
         }
 
@@ -71,11 +71,11 @@ int main(int argc, char** argv) {
         config.useFloat16 = FLAGS_use_float16;
         config.storeTransposed = FLAGS_transposed;
 
-        auto p = std::unique_ptr<faiss::gpu::GpuIndexFlat>(
+        auto p = std::unique_ptr<knowherefaiss::gpu::GpuIndexFlat>(
                 FLAGS_L2_metric
-                        ? (faiss::gpu::GpuIndexFlat*)new faiss::gpu::
+                        ? (knowherefaiss::gpu::GpuIndexFlat*)new knowherefaiss::gpu::
                                   GpuIndexFlatL2(res, FLAGS_dim, config)
-                        : (faiss::gpu::GpuIndexFlat*)new faiss::gpu::
+                        : (knowherefaiss::gpu::GpuIndexFlat*)new knowherefaiss::gpu::
                                   GpuIndexFlatIP(res, FLAGS_dim, config));
 
         if (FLAGS_min_paging_size >= 0) {
@@ -84,14 +84,14 @@ int main(int argc, char** argv) {
         return p;
     };
 
-    IndexWrapper<faiss::gpu::GpuIndexFlat> gpuIndex(FLAGS_num_gpus, initFn);
+    IndexWrapper<knowherefaiss::gpu::GpuIndexFlat> gpuIndex(FLAGS_num_gpus, initFn);
 
     CUDA_VERIFY(cudaProfilerStart());
-    faiss::gpu::synchronizeAllDevices();
+    knowherefaiss::gpu::synchronizeAllDevices();
 
     float gpuTime = 0.0f;
 
-    faiss::ClusteringParameters cp;
+    knowherefaiss::ClusteringParameters cp;
     cp.niter = FLAGS_niter;
     cp.verbose = FLAGS_verbose;
 
@@ -99,7 +99,7 @@ int main(int argc, char** argv) {
         cp.max_points_per_centroid = FLAGS_max_points;
     }
 
-    faiss::Clustering kmeans(FLAGS_dim, FLAGS_k, cp);
+    knowherefaiss::Clustering kmeans(FLAGS_dim, FLAGS_k, cp);
 
     // Time k-means
     {
diff --git a/thirdparty/faiss/faiss/gpu/perf/PerfFlat.cu b/thirdparty/faiss/knowherefaiss/gpu/perf/PerfFlat.cu
similarity index 73%
rename from thirdparty/faiss/faiss/gpu/perf/PerfFlat.cu
rename to thirdparty/faiss/knowherefaiss/gpu/perf/PerfFlat.cu
index bf71a5b9..7cc9ee82 100644
--- a/thirdparty/faiss/faiss/gpu/perf/PerfFlat.cu
+++ b/thirdparty/faiss/knowherefaiss/gpu/perf/PerfFlat.cu
@@ -5,16 +5,16 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/IndexFlat.h>
-#include <faiss/gpu/GpuIndexFlat.h>
-#include <faiss/gpu/perf/IndexWrapper.h>
-#include <faiss/gpu/test/TestUtils.h>
-#include <faiss/gpu/utils/DeviceUtils.h>
-#include <faiss/gpu/utils/Timer.h>
-#include <faiss/utils/random.h>
+#include <knowherefaiss/IndexFlat.h>
+#include <knowherefaiss/gpu/GpuIndexFlat.h>
+#include <knowherefaiss/gpu/perf/IndexWrapper.h>
+#include <knowherefaiss/gpu/test/TestUtils.h>
+#include <knowherefaiss/gpu/utils/DeviceUtils.h>
+#include <knowherefaiss/gpu/utils/Timer.h>
+#include <knowherefaiss/utils/random.h>
 #include <gflags/gflags.h>
-#include <faiss/gpu/utils/DeviceTensor.cuh>
-#include <faiss/gpu/utils/HostTensor.cuh>
+#include <knowherefaiss/gpu/utils/DeviceTensor.cuh>
+#include <knowherefaiss/gpu/utils/HostTensor.cuh>
 #include <map>
 #include <memory>
 #include <vector>
@@ -36,7 +36,7 @@ DEFINE_int64(pinned_mem, 0, "pinned memory allocation to use");
 DEFINE_bool(cpu, true, "run the CPU code for timing and comparison");
 DEFINE_bool(use_unified_mem, false, "use Pascal unified memory for the index");
 
-using namespace faiss::gpu;
+using namespace knowherefaiss::gpu;
 
 int main(int argc, char** argv) {
     gflags::ParseCommandLineFlags(&argc, &argv, true);
@@ -48,12 +48,12 @@ int main(int argc, char** argv) {
 
     auto numQueries = FLAGS_num_queries;
 
-    auto index = std::unique_ptr<faiss::IndexFlat>(new faiss::IndexFlat(
+    auto index = std::unique_ptr<knowherefaiss::IndexFlat>(new knowherefaiss::IndexFlat(
             FLAGS_dim,
-            FLAGS_l2 ? faiss::METRIC_L2 : faiss::METRIC_INNER_PRODUCT));
+            FLAGS_l2 ? knowherefaiss::METRIC_L2 : knowherefaiss::METRIC_INNER_PRODUCT));
 
     HostTensor<float, 2, true> vecs({FLAGS_num, FLAGS_dim});
-    faiss::float_rand(vecs.data(), vecs.numElements(), seed);
+    knowherefaiss::float_rand(vecs.data(), vecs.numElements(), seed);
 
     index->add(FLAGS_num, vecs.data());
 
@@ -69,9 +69,9 @@ int main(int argc, char** argv) {
     // Convert to GPU index
     printf("Copying index to %d GPU(s)...\n", FLAGS_num_gpus);
 
-    auto initFn = [&index](faiss::gpu::GpuResourcesProvider* res, int dev)
-            -> std::unique_ptr<faiss::gpu::GpuIndexFlat> {
-        ((faiss::gpu::StandardGpuResources*)res)
+    auto initFn = [&index](knowherefaiss::gpu::GpuResourcesProvider* res, int dev)
+            -> std::unique_ptr<knowherefaiss::gpu::GpuIndexFlat> {
+        ((knowherefaiss::gpu::StandardGpuResources*)res)
                 ->setPinnedMemory(FLAGS_pinned_mem);
 
         GpuIndexFlatConfig config;
@@ -81,21 +81,21 @@ int main(int argc, char** argv) {
         config.memorySpace = FLAGS_use_unified_mem ? MemorySpace::Unified
                                                    : MemorySpace::Device;
 
-        auto p = std::unique_ptr<faiss::gpu::GpuIndexFlat>(
-                new faiss::gpu::GpuIndexFlat(res, index.get(), config));
+        auto p = std::unique_ptr<knowherefaiss::gpu::GpuIndexFlat>(
+                new knowherefaiss::gpu::GpuIndexFlat(res, index.get(), config));
         return p;
     };
 
-    IndexWrapper<faiss::gpu::GpuIndexFlat> gpuIndex(FLAGS_num_gpus, initFn);
+    IndexWrapper<knowherefaiss::gpu::GpuIndexFlat> gpuIndex(FLAGS_num_gpus, initFn);
     printf("copy done\n");
 
     // Build query vectors
     HostTensor<float, 2, true> cpuQuery({numQueries, FLAGS_dim});
-    faiss::float_rand(cpuQuery.data(), cpuQuery.numElements(), seed);
+    knowherefaiss::float_rand(cpuQuery.data(), cpuQuery.numElements(), seed);
 
     // Time faiss CPU
     HostTensor<float, 2, true> cpuDistances({numQueries, FLAGS_k});
-    HostTensor<faiss::Index::idx_t, 2, true> cpuIndices({numQueries, FLAGS_k});
+    HostTensor<knowherefaiss::Index::idx_t, 2, true> cpuIndices({numQueries, FLAGS_k});
 
     if (FLAGS_cpu) {
         float cpuTime = 0.0f;
@@ -113,10 +113,10 @@ int main(int argc, char** argv) {
     }
 
     HostTensor<float, 2, true> gpuDistances({numQueries, FLAGS_k});
-    HostTensor<faiss::Index::idx_t, 2, true> gpuIndices({numQueries, FLAGS_k});
+    HostTensor<knowherefaiss::Index::idx_t, 2, true> gpuIndices({numQueries, FLAGS_k});
 
     CUDA_VERIFY(cudaProfilerStart());
-    faiss::gpu::synchronizeAllDevices();
+    knowherefaiss::gpu::synchronizeAllDevices();
 
     float gpuTime = 0.0f;
 
diff --git a/thirdparty/faiss/faiss/gpu/perf/PerfIVFFlat.cu b/thirdparty/faiss/knowherefaiss/gpu/perf/PerfIVFFlat.cu
similarity index 71%
rename from thirdparty/faiss/faiss/gpu/perf/PerfIVFFlat.cu
rename to thirdparty/faiss/knowherefaiss/gpu/perf/PerfIVFFlat.cu
index 1b83d4f8..cff9bde9 100644
--- a/thirdparty/faiss/faiss/gpu/perf/PerfIVFFlat.cu
+++ b/thirdparty/faiss/knowherefaiss/gpu/perf/PerfIVFFlat.cu
@@ -5,18 +5,18 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/IndexIVFFlat.h>
-#include <faiss/index_io.h>
-#include <faiss/utils/random.h>
-
-#include <faiss/gpu/GpuIndexIVFFlat.h>
-#include <faiss/gpu/perf/IndexWrapper.h>
-#include <faiss/gpu/test/TestUtils.h>
-#include <faiss/gpu/utils/DeviceUtils.h>
-#include <faiss/gpu/utils/Timer.h>
+#include <knowherefaiss/IndexIVFFlat.h>
+#include <knowherefaiss/index_io.h>
+#include <knowherefaiss/utils/random.h>
+
+#include <knowherefaiss/gpu/GpuIndexIVFFlat.h>
+#include <knowherefaiss/gpu/perf/IndexWrapper.h>
+#include <knowherefaiss/gpu/test/TestUtils.h>
+#include <knowherefaiss/gpu/utils/DeviceUtils.h>
+#include <knowherefaiss/gpu/utils/Timer.h>
 #include <gflags/gflags.h>
-#include <faiss/gpu/utils/DeviceTensor.cuh>
-#include <faiss/gpu/utils/HostTensor.cuh>
+#include <knowherefaiss/gpu/utils/DeviceTensor.cuh>
+#include <knowherefaiss/gpu/utils/HostTensor.cuh>
 #include <map>
 #include <memory>
 #include <vector>
@@ -33,7 +33,7 @@ DEFINE_int64(seed, -1, "specify random seed");
 DEFINE_int32(num_gpus, 1, "number of gpus to use");
 DEFINE_int32(index, 2, "0 = no indices on GPU; 1 = 32 bit, 2 = 64 bit on GPU");
 
-using namespace faiss::gpu;
+using namespace knowherefaiss::gpu;
 
 int main(int argc, char** argv) {
     gflags::ParseCommandLineFlags(&argc, &argv, true);
@@ -45,9 +45,9 @@ int main(int argc, char** argv) {
 
     auto numQueries = FLAGS_num_queries;
 
-    auto index = std::unique_ptr<faiss::IndexIVFFlat>(
-            dynamic_cast<faiss::IndexIVFFlat*>(
-                    faiss::read_index(FLAGS_in.c_str())));
+    auto index = std::unique_ptr<knowherefaiss::IndexIVFFlat>(
+            dynamic_cast<knowherefaiss::IndexIVFFlat*>(
+                    knowherefaiss::read_index(FLAGS_in.c_str())));
     FAISS_ASSERT((bool)index);
     index->nprobe = FLAGS_nprobe;
 
@@ -65,15 +65,15 @@ int main(int argc, char** argv) {
     // Convert to GPU index
     printf("Copying index to %d GPU(s)...\n", FLAGS_num_gpus);
 
-    auto initFn = [&index](faiss::gpu::GpuResourcesProvider* res, int dev)
-            -> std::unique_ptr<faiss::gpu::GpuIndexIVFFlat> {
+    auto initFn = [&index](knowherefaiss::gpu::GpuResourcesProvider* res, int dev)
+            -> std::unique_ptr<knowherefaiss::gpu::GpuIndexIVFFlat> {
         GpuIndexIVFFlatConfig config;
         config.device = dev;
-        config.indicesOptions = (faiss::gpu::IndicesOptions)FLAGS_index;
+        config.indicesOptions = (knowherefaiss::gpu::IndicesOptions)FLAGS_index;
         config.flatConfig.useFloat16 = FLAGS_use_float16_coarse;
 
-        auto p = std::unique_ptr<faiss::gpu::GpuIndexIVFFlat>(
-                new faiss::gpu::GpuIndexIVFFlat(
+        auto p = std::unique_ptr<knowherefaiss::gpu::GpuIndexIVFFlat>(
+                new knowherefaiss::gpu::GpuIndexIVFFlat(
                         res,
                         index->d,
                         index->nlist,
@@ -83,17 +83,17 @@ int main(int argc, char** argv) {
         return p;
     };
 
-    IndexWrapper<faiss::gpu::GpuIndexIVFFlat> gpuIndex(FLAGS_num_gpus, initFn);
+    IndexWrapper<knowherefaiss::gpu::GpuIndexIVFFlat> gpuIndex(FLAGS_num_gpus, initFn);
     gpuIndex.setNumProbes(FLAGS_nprobe);
     printf("copy done\n");
 
     // Build query vectors
     HostTensor<float, 2, true> cpuQuery({numQueries, dim});
-    faiss::float_rand(cpuQuery.data(), cpuQuery.numElements(), seed);
+    knowherefaiss::float_rand(cpuQuery.data(), cpuQuery.numElements(), seed);
 
     // Time faiss CPU
     HostTensor<float, 2, true> cpuDistances({numQueries, FLAGS_k});
-    HostTensor<faiss::Index::idx_t, 2, true> cpuIndices({numQueries, FLAGS_k});
+    HostTensor<knowherefaiss::Index::idx_t, 2, true> cpuIndices({numQueries, FLAGS_k});
 
     float cpuTime = 0.0f;
 
@@ -112,10 +112,10 @@ int main(int argc, char** argv) {
     printf("CPU time %.3f ms\n", cpuTime);
 
     HostTensor<float, 2, true> gpuDistances({numQueries, FLAGS_k});
-    HostTensor<faiss::Index::idx_t, 2, true> gpuIndices({numQueries, FLAGS_k});
+    HostTensor<knowherefaiss::Index::idx_t, 2, true> gpuIndices({numQueries, FLAGS_k});
 
     CUDA_VERIFY(cudaProfilerStart());
-    faiss::gpu::synchronizeAllDevices();
+    knowherefaiss::gpu::synchronizeAllDevices();
 
     float gpuTime = 0.0f;
 
diff --git a/thirdparty/faiss/faiss/gpu/perf/PerfIVFPQ.cu b/thirdparty/faiss/knowherefaiss/gpu/perf/PerfIVFPQ.cu
similarity index 72%
rename from thirdparty/faiss/faiss/gpu/perf/PerfIVFPQ.cu
rename to thirdparty/faiss/knowherefaiss/gpu/perf/PerfIVFPQ.cu
index 3665c1e1..0a989793 100644
--- a/thirdparty/faiss/faiss/gpu/perf/PerfIVFPQ.cu
+++ b/thirdparty/faiss/knowherefaiss/gpu/perf/PerfIVFPQ.cu
@@ -5,17 +5,17 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/IndexIVFPQ.h>
-#include <faiss/index_io.h>
-#include <faiss/utils/random.h>
-
-#include <faiss/gpu/GpuIndexIVFPQ.h>
-#include <faiss/gpu/perf/IndexWrapper.h>
-#include <faiss/gpu/test/TestUtils.h>
-#include <faiss/gpu/utils/DeviceUtils.h>
-#include <faiss/gpu/utils/Timer.h>
-#include <faiss/gpu/utils/DeviceTensor.cuh>
-#include <faiss/gpu/utils/HostTensor.cuh>
+#include <knowherefaiss/IndexIVFPQ.h>
+#include <knowherefaiss/index_io.h>
+#include <knowherefaiss/utils/random.h>
+
+#include <knowherefaiss/gpu/GpuIndexIVFPQ.h>
+#include <knowherefaiss/gpu/perf/IndexWrapper.h>
+#include <knowherefaiss/gpu/test/TestUtils.h>
+#include <knowherefaiss/gpu/utils/DeviceUtils.h>
+#include <knowherefaiss/gpu/utils/Timer.h>
+#include <knowherefaiss/gpu/utils/DeviceTensor.cuh>
+#include <knowherefaiss/gpu/utils/HostTensor.cuh>
 
 #include <cuda_profiler_api.h>
 #include <gflags/gflags.h>
@@ -34,7 +34,7 @@ DEFINE_int64(seed, -1, "specify random seed");
 DEFINE_int32(num_gpus, 1, "number of gpus to use");
 DEFINE_int32(index, 2, "0 = no indices on GPU; 1 = 32 bit, 2 = 64 bit on GPU");
 
-using namespace faiss::gpu;
+using namespace knowherefaiss::gpu;
 
 int main(int argc, char** argv) {
     gflags::ParseCommandLineFlags(&argc, &argv, true);
@@ -47,8 +47,8 @@ int main(int argc, char** argv) {
     auto numQueries = FLAGS_num_queries;
 
     auto index =
-            std::unique_ptr<faiss::IndexIVFPQ>(dynamic_cast<faiss::IndexIVFPQ*>(
-                    faiss::read_index(FLAGS_in.c_str())));
+            std::unique_ptr<knowherefaiss::IndexIVFPQ>(dynamic_cast<knowherefaiss::IndexIVFPQ*>(
+                    knowherefaiss::read_index(FLAGS_in.c_str())));
     FAISS_ASSERT((bool)index);
     index->nprobe = FLAGS_nprobe;
 
@@ -74,36 +74,36 @@ int main(int argc, char** argv) {
     printf("Copying index to %d GPU(s)...\n", FLAGS_num_gpus);
 
     auto precomp = FLAGS_use_precomputed;
-    auto indicesOpt = (faiss::gpu::IndicesOptions)FLAGS_index;
+    auto indicesOpt = (knowherefaiss::gpu::IndicesOptions)FLAGS_index;
     auto useFloat16Lookup = FLAGS_float16_lookup;
 
     auto initFn =
             [precomp, indicesOpt, useFloat16Lookup, &index](
-                    faiss::gpu::GpuResourcesProvider* res,
-                    int dev) -> std::unique_ptr<faiss::gpu::GpuIndexIVFPQ> {
-        faiss::gpu::GpuIndexIVFPQConfig config;
+                    knowherefaiss::gpu::GpuResourcesProvider* res,
+                    int dev) -> std::unique_ptr<knowherefaiss::gpu::GpuIndexIVFPQ> {
+        knowherefaiss::gpu::GpuIndexIVFPQConfig config;
         config.device = dev;
         config.usePrecomputedTables = precomp;
         config.indicesOptions = indicesOpt;
         config.useFloat16LookupTables = useFloat16Lookup;
 
-        auto p = std::unique_ptr<faiss::gpu::GpuIndexIVFPQ>(
-                new faiss::gpu::GpuIndexIVFPQ(res, index.get(), config));
+        auto p = std::unique_ptr<knowherefaiss::gpu::GpuIndexIVFPQ>(
+                new knowherefaiss::gpu::GpuIndexIVFPQ(res, index.get(), config));
 
         return p;
     };
 
-    IndexWrapper<faiss::gpu::GpuIndexIVFPQ> gpuIndex(FLAGS_num_gpus, initFn);
+    IndexWrapper<knowherefaiss::gpu::GpuIndexIVFPQ> gpuIndex(FLAGS_num_gpus, initFn);
     gpuIndex.setNumProbes(FLAGS_nprobe);
     printf("copy done\n");
 
     // Build query vectors
     HostTensor<float, 2, true> cpuQuery({numQueries, dim});
-    faiss::float_rand(cpuQuery.data(), cpuQuery.numElements(), seed);
+    knowherefaiss::float_rand(cpuQuery.data(), cpuQuery.numElements(), seed);
 
     // Time faiss CPU
     HostTensor<float, 2, true> cpuDistances({numQueries, FLAGS_k});
-    HostTensor<faiss::Index::idx_t, 2, true> cpuIndices({numQueries, FLAGS_k});
+    HostTensor<knowherefaiss::Index::idx_t, 2, true> cpuIndices({numQueries, FLAGS_k});
 
     float cpuTime = 0.0f;
 
@@ -122,10 +122,10 @@ int main(int argc, char** argv) {
     printf("CPU time %.3f ms\n", cpuTime);
 
     HostTensor<float, 2, true> gpuDistances({numQueries, FLAGS_k});
-    HostTensor<faiss::Index::idx_t, 2, true> gpuIndices({numQueries, FLAGS_k});
+    HostTensor<knowherefaiss::Index::idx_t, 2, true> gpuIndices({numQueries, FLAGS_k});
 
     CUDA_VERIFY(cudaProfilerStart());
-    faiss::gpu::synchronizeAllDevices();
+    knowherefaiss::gpu::synchronizeAllDevices();
 
     float gpuTime = 0.0f;
 
diff --git a/thirdparty/faiss/faiss/gpu/perf/PerfIVFPQAdd.cpp b/thirdparty/faiss/knowherefaiss/gpu/perf/PerfIVFPQAdd.cpp
similarity index 82%
rename from thirdparty/faiss/faiss/gpu/perf/PerfIVFPQAdd.cpp
rename to thirdparty/faiss/knowherefaiss/gpu/perf/PerfIVFPQAdd.cpp
index 9842a527..dc04283f 100644
--- a/thirdparty/faiss/faiss/gpu/perf/PerfIVFPQAdd.cpp
+++ b/thirdparty/faiss/knowherefaiss/gpu/perf/PerfIVFPQAdd.cpp
@@ -6,13 +6,13 @@
  */
 
 #include <cuda_profiler_api.h>
-#include <faiss/IndexFlat.h>
-#include <faiss/IndexIVFPQ.h>
-#include <faiss/gpu/GpuIndexIVFPQ.h>
-#include <faiss/gpu/StandardGpuResources.h>
-#include <faiss/gpu/test/TestUtils.h>
-#include <faiss/gpu/utils/DeviceUtils.h>
-#include <faiss/gpu/utils/Timer.h>
+#include <knowherefaiss/IndexFlat.h>
+#include <knowherefaiss/IndexIVFPQ.h>
+#include <knowherefaiss/gpu/GpuIndexIVFPQ.h>
+#include <knowherefaiss/gpu/StandardGpuResources.h>
+#include <knowherefaiss/gpu/test/TestUtils.h>
+#include <knowherefaiss/gpu/utils/DeviceUtils.h>
+#include <knowherefaiss/gpu/utils/Timer.h>
 #include <gflags/gflags.h>
 #include <map>
 #include <vector>
@@ -39,30 +39,30 @@ int main(int argc, char** argv) {
     int bytesPerVec = FLAGS_bytes_per_vec;
     int bitsPerCode = FLAGS_bits_per_code;
 
-    faiss::gpu::StandardGpuResources res;
+    knowherefaiss::gpu::StandardGpuResources res;
 
     // IndexIVFPQ will complain, but just give us enough to get through this
     int numTrain = 4 * numCentroids;
-    std::vector<float> trainVecs = faiss::gpu::randVecs(numTrain, dim);
+    std::vector<float> trainVecs = knowherefaiss::gpu::randVecs(numTrain, dim);
 
-    faiss::IndexFlatL2 coarseQuantizer(dim);
-    faiss::IndexIVFPQ cpuIndex(
+    knowherefaiss::IndexFlatL2 coarseQuantizer(dim);
+    knowherefaiss::IndexIVFPQ cpuIndex(
             &coarseQuantizer, dim, numCentroids, bytesPerVec, bitsPerCode);
     if (FLAGS_time_cpu) {
         cpuIndex.train(numTrain, trainVecs.data());
     }
 
-    faiss::gpu::GpuIndexIVFPQConfig config;
+    knowherefaiss::gpu::GpuIndexIVFPQConfig config;
     config.device = 0;
-    config.indicesOptions = (faiss::gpu::IndicesOptions)FLAGS_index;
+    config.indicesOptions = (knowherefaiss::gpu::IndicesOptions)FLAGS_index;
 
-    faiss::gpu::GpuIndexIVFPQ gpuIndex(
+    knowherefaiss::gpu::GpuIndexIVFPQ gpuIndex(
             &res,
             dim,
             numCentroids,
             bytesPerVec,
             bitsPerCode,
-            faiss::METRIC_L2,
+            knowherefaiss::METRIC_L2,
             config);
 
     if (FLAGS_time_gpu) {
@@ -86,10 +86,10 @@ int main(int argc, char** argv) {
             }
         }
 
-        auto addVecs = faiss::gpu::randVecs(FLAGS_batch_size, dim);
+        auto addVecs = knowherefaiss::gpu::randVecs(FLAGS_batch_size, dim);
 
         if (FLAGS_time_gpu) {
-            faiss::gpu::CpuTimer timer;
+            knowherefaiss::gpu::CpuTimer timer;
             gpuIndex.add(FLAGS_batch_size, addVecs.data());
             CUDA_VERIFY(cudaDeviceSynchronize());
             auto time = timer.elapsedMilliseconds();
@@ -106,7 +106,7 @@ int main(int argc, char** argv) {
         }
 
         if (FLAGS_time_cpu) {
-            faiss::gpu::CpuTimer timer;
+            knowherefaiss::gpu::CpuTimer timer;
             cpuIndex.add(FLAGS_batch_size, addVecs.data());
             auto time = timer.elapsedMilliseconds();
 
diff --git a/thirdparty/faiss/faiss/gpu/perf/PerfSelect.cu b/thirdparty/faiss/knowherefaiss/gpu/perf/PerfSelect.cu
similarity index 79%
rename from thirdparty/faiss/faiss/gpu/perf/PerfSelect.cu
rename to thirdparty/faiss/knowherefaiss/gpu/perf/PerfSelect.cu
index 06ed3ebc..576c37c6 100644
--- a/thirdparty/faiss/faiss/gpu/perf/PerfSelect.cu
+++ b/thirdparty/faiss/knowherefaiss/gpu/perf/PerfSelect.cu
@@ -5,17 +5,17 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/gpu/StandardGpuResources.h>
-#include <faiss/gpu/test/TestUtils.h>
-#include <faiss/gpu/utils/DeviceUtils.h>
+#include <knowherefaiss/gpu/StandardGpuResources.h>
+#include <knowherefaiss/gpu/test/TestUtils.h>
+#include <knowherefaiss/gpu/utils/DeviceUtils.h>
 #include <gflags/gflags.h>
 #include <gtest/gtest.h>
 #include <algorithm>
-#include <faiss/gpu/utils/BlockSelectKernel.cuh>
-#include <faiss/gpu/utils/DeviceDefs.cuh>
-#include <faiss/gpu/utils/DeviceTensor.cuh>
-#include <faiss/gpu/utils/HostTensor.cuh>
-#include <faiss/gpu/utils/WarpSelectKernel.cuh>
+#include <knowherefaiss/gpu/utils/BlockSelectKernel.cuh>
+#include <knowherefaiss/gpu/utils/DeviceDefs.cuh>
+#include <knowherefaiss/gpu/utils/DeviceTensor.cuh>
+#include <knowherefaiss/gpu/utils/HostTensor.cuh>
+#include <knowherefaiss/gpu/utils/WarpSelectKernel.cuh>
 #include <sstream>
 #include <unordered_map>
 #include <vector>
@@ -29,7 +29,7 @@ DEFINE_int32(iter, 5, "iterations to run");
 DEFINE_bool(k_powers, false, "test k powers of 2 from 1 -> max k");
 
 int main(int argc, char** argv) {
-    using namespace faiss::gpu;
+    using namespace knowherefaiss::gpu;
 
     gflags::ParseCommandLineFlags(&argc, &argv, true);
 
@@ -59,7 +59,7 @@ int main(int argc, char** argv) {
         limitK = GPU_MAX_SELECTION_K;
     }
 
-    faiss::gpu::DeviceTensor<uint8_t, 1, true> bitset(nullptr, {0});
+    knowherefaiss::gpu::DeviceTensor<uint8_t, 1, true> bitset(nullptr, {0});
     for (int k = startK; k <= limitK; k *= 2) {
         DeviceTensor<float, 2, true> gpuOutVal(
                 resUse.get(),
diff --git a/thirdparty/faiss/faiss/gpu/perf/WriteIndex.cpp b/thirdparty/faiss/knowherefaiss/gpu/perf/WriteIndex.cpp
similarity index 76%
rename from thirdparty/faiss/faiss/gpu/perf/WriteIndex.cpp
rename to thirdparty/faiss/knowherefaiss/gpu/perf/WriteIndex.cpp
index 7dab8fa7..8c55056a 100644
--- a/thirdparty/faiss/faiss/gpu/perf/WriteIndex.cpp
+++ b/thirdparty/faiss/knowherefaiss/gpu/perf/WriteIndex.cpp
@@ -5,11 +5,11 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/IndexFlat.h>
-#include <faiss/IndexIVFFlat.h>
-#include <faiss/IndexIVFPQ.h>
-#include <faiss/gpu/test/TestUtils.h>
-#include <faiss/index_io.h>
+#include <knowherefaiss/IndexFlat.h>
+#include <knowherefaiss/IndexIVFFlat.h>
+#include <knowherefaiss/IndexIVFPQ.h>
+#include <knowherefaiss/gpu/test/TestUtils.h>
+#include <knowherefaiss/index_io.h>
 #include <gflags/gflags.h>
 #include <vector>
 
@@ -31,20 +31,20 @@ DEFINE_int32(num_train, -1, "number of database vecs to train on");
 
 template <typename T>
 void fillAndSave(T& index, int numTrain, int num, int dim) {
-    auto trainVecs = faiss::gpu::randVecs(numTrain, dim);
+    auto trainVecs = knowherefaiss::gpu::randVecs(numTrain, dim);
     index.train(numTrain, trainVecs.data());
 
     constexpr int kAddChunk = 1000000;
 
     for (int i = 0; i < num; i += kAddChunk) {
         int numRemaining = (num - i) < kAddChunk ? (num - i) : kAddChunk;
-        auto vecs = faiss::gpu::randVecs(numRemaining, dim);
+        auto vecs = knowherefaiss::gpu::randVecs(numRemaining, dim);
 
         printf("adding at %d: %d\n", i, numRemaining);
         index.add(numRemaining, vecs.data());
     }
 
-    faiss::write_index(&index, FLAGS_out.c_str());
+    knowherefaiss::write_index(&index, FLAGS_out.c_str());
 }
 
 int main(int argc, char** argv) {
@@ -64,8 +64,8 @@ int main(int argc, char** argv) {
     numTrain = std::min(num, numTrain);
 
     if (FLAGS_ivfpq) {
-        faiss::IndexFlatL2 quantizer(dim);
-        faiss::IndexIVFPQ index(
+        knowherefaiss::IndexFlatL2 quantizer(dim);
+        knowherefaiss::IndexIVFPQ index(
                 &quantizer,
                 dim,
                 numCentroids,
@@ -85,18 +85,18 @@ int main(int argc, char** argv) {
 
         fillAndSave(index, numTrain, num, dim);
     } else if (FLAGS_ivfflat) {
-        faiss::IndexFlatL2 quantizerL2(dim);
-        faiss::IndexFlatIP quantizerIP(dim);
+        knowherefaiss::IndexFlatL2 quantizerL2(dim);
+        knowherefaiss::IndexFlatIP quantizerIP(dim);
 
-        faiss::IndexFlat* quantizer = FLAGS_l2
-                ? (faiss::IndexFlat*)&quantizerL2
-                : (faiss::IndexFlat*)&quantizerIP;
+        knowherefaiss::IndexFlat* quantizer = FLAGS_l2
+                ? (knowherefaiss::IndexFlat*)&quantizerL2
+                : (knowherefaiss::IndexFlat*)&quantizerIP;
 
-        faiss::IndexIVFFlat index(
+        knowherefaiss::IndexIVFFlat index(
                 quantizer,
                 dim,
                 numCentroids,
-                FLAGS_l2 ? faiss::METRIC_L2 : faiss::METRIC_INNER_PRODUCT);
+                FLAGS_l2 ? knowherefaiss::METRIC_L2 : knowherefaiss::METRIC_INNER_PRODUCT);
 
         printf("IVFFlat: metric %s\n", FLAGS_l2 ? "L2" : "IP");
         printf("Lists: %d\n", numCentroids);
diff --git a/thirdparty/faiss/faiss/gpu/perf/slow.py b/thirdparty/faiss/knowherefaiss/gpu/perf/slow.py
old mode 100755
new mode 100644
similarity index 100%
rename from thirdparty/faiss/faiss/gpu/perf/slow.py
rename to thirdparty/faiss/knowherefaiss/gpu/perf/slow.py
diff --git a/thirdparty/faiss/faiss/gpu/test/CMakeLists.txt b/thirdparty/faiss/knowherefaiss/gpu/test/CMakeLists.txt
similarity index 100%
rename from thirdparty/faiss/faiss/gpu/test/CMakeLists.txt
rename to thirdparty/faiss/knowherefaiss/gpu/test/CMakeLists.txt
diff --git a/thirdparty/faiss/faiss/gpu/test/TestCodePacking.cpp b/thirdparty/faiss/knowherefaiss/gpu/test/TestCodePacking.cpp
similarity index 97%
rename from thirdparty/faiss/faiss/gpu/test/TestCodePacking.cpp
rename to thirdparty/faiss/knowherefaiss/gpu/test/TestCodePacking.cpp
index 44720aeb..71a58025 100644
--- a/thirdparty/faiss/faiss/gpu/test/TestCodePacking.cpp
+++ b/thirdparty/faiss/knowherefaiss/gpu/test/TestCodePacking.cpp
@@ -5,9 +5,9 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/gpu/impl/InterleavedCodes.h>
-#include <faiss/gpu/test/TestUtils.h>
-#include <faiss/gpu/utils/StaticUtils.h>
+#include <knowherefaiss/gpu/impl/InterleavedCodes.h>
+#include <knowherefaiss/gpu/test/TestUtils.h>
+#include <knowherefaiss/gpu/utils/StaticUtils.h>
 #include <gtest/gtest.h>
 #include <cmath>
 #include <random>
@@ -15,7 +15,7 @@
 #include <vector>
 
 TEST(TestCodePacking, NonInterleavedCodes_UnpackPack) {
-    using namespace faiss::gpu;
+    using namespace knowherefaiss::gpu;
 
     // We are fine using non-fixed seeds here, the results should be fully
     // deterministic
@@ -67,7 +67,7 @@ TEST(TestCodePacking, NonInterleavedCodes_UnpackPack) {
 }
 
 TEST(TestCodePacking, NonInterleavedCodes_PackUnpack) {
-    using namespace faiss::gpu;
+    using namespace knowherefaiss::gpu;
 
     // We are fine using non-fixed seeds here, the results should be fully
     // deterministic
@@ -105,7 +105,7 @@ TEST(TestCodePacking, NonInterleavedCodes_PackUnpack) {
 }
 
 TEST(TestCodePacking, InterleavedCodes_UnpackPack) {
-    using namespace faiss::gpu;
+    using namespace knowherefaiss::gpu;
 
     // We are fine using non-fixed seeds here, the results should be fully
     // deterministic
@@ -240,7 +240,7 @@ TEST(TestCodePacking, InterleavedCodes_UnpackPack) {
 }
 
 TEST(TestCodePacking, InterleavedCodes_PackUnpack) {
-    using namespace faiss::gpu;
+    using namespace knowherefaiss::gpu;
 
     // We are fine using non-fixed seeds here, the results should be fully
     // deterministic
diff --git a/thirdparty/faiss/faiss/gpu/test/TestGpuDistance.cu b/thirdparty/faiss/knowherefaiss/gpu/test/TestGpuDistance.cu
similarity index 70%
rename from thirdparty/faiss/faiss/gpu/test/TestGpuDistance.cu
rename to thirdparty/faiss/knowherefaiss/gpu/test/TestGpuDistance.cu
index 1d97e6ca..be447454 100644
--- a/thirdparty/faiss/faiss/gpu/test/TestGpuDistance.cu
+++ b/thirdparty/faiss/knowherefaiss/gpu/test/TestGpuDistance.cu
@@ -5,23 +5,23 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/IndexFlat.h>
-#include <faiss/gpu/GpuDistance.h>
-#include <faiss/gpu/StandardGpuResources.h>
-#include <faiss/gpu/test/TestUtils.h>
-#include <faiss/gpu/utils/DeviceUtils.h>
+#include <knowherefaiss/IndexFlat.h>
+#include <knowherefaiss/gpu/GpuDistance.h>
+#include <knowherefaiss/gpu/StandardGpuResources.h>
+#include <knowherefaiss/gpu/test/TestUtils.h>
+#include <knowherefaiss/gpu/utils/DeviceUtils.h>
 #include <gtest/gtest.h>
-#include <faiss/gpu/utils/CopyUtils.cuh>
-#include <faiss/gpu/utils/Transpose.cuh>
+#include <knowherefaiss/gpu/utils/CopyUtils.cuh>
+#include <knowherefaiss/gpu/utils/Transpose.cuh>
 #include <sstream>
 #include <vector>
 
 void testTransposition(
         bool colMajorVecs,
         bool colMajorQueries,
-        faiss::MetricType metric,
+        knowherefaiss::MetricType metric,
         float metricArg = 0) {
-    using namespace faiss::gpu;
+    using namespace knowherefaiss::gpu;
 
     int device = randVal(0, getNumDevices() - 1);
 
@@ -37,7 +37,7 @@ void testTransposition(
     std::vector<float> vecs = randVecs(numVecs, dim);
     std::vector<float> queries = randVecs(numQuery, dim);
 
-    if (metric == faiss::MetricType::METRIC_JensenShannon) {
+    if (metric == knowherefaiss::MetricType::METRIC_JensenShannon) {
         // make values positive
         for (auto& v : vecs) {
             v = std::abs(v);
@@ -55,12 +55,12 @@ void testTransposition(
     }
 
     // The CPU index is our reference for the results
-    faiss::IndexFlat cpuIndex(dim, metric);
+    knowherefaiss::IndexFlat cpuIndex(dim, metric);
     cpuIndex.metric_arg = metricArg;
     cpuIndex.add(numVecs, vecs.data());
 
     std::vector<float> cpuDistance(numQuery * k, 0);
-    std::vector<faiss::Index::idx_t> cpuIndices(numQuery * k, -1);
+    std::vector<knowherefaiss::Index::idx_t> cpuIndices(numQuery * k, -1);
 
     cpuIndex.search(
             numQuery, queries.data(), k, cpuDistance.data(), cpuIndices.data());
@@ -97,7 +97,7 @@ void testTransposition(
     runTransposeAny(gpuQueries, 0, 1, queriesT, stream);
 
     std::vector<float> gpuDistance(numQuery * k, 0);
-    std::vector<faiss::Index::idx_t> gpuIndices(numQuery * k, -1);
+    std::vector<knowherefaiss::Index::idx_t> gpuIndices(numQuery * k, -1);
 
     GpuDistanceParams args;
     args.metric = metric;
@@ -137,65 +137,65 @@ void testTransposition(
 
 // Test different memory layouts for brute-force k-NN
 TEST(TestGpuDistance, Transposition_RR) {
-    testTransposition(false, false, faiss::MetricType::METRIC_L2);
-    testTransposition(false, false, faiss::MetricType::METRIC_INNER_PRODUCT);
+    testTransposition(false, false, knowherefaiss::MetricType::METRIC_L2);
+    testTransposition(false, false, knowherefaiss::MetricType::METRIC_INNER_PRODUCT);
 }
 
 TEST(TestGpuDistance, Transposition_RC) {
-    testTransposition(false, true, faiss::MetricType::METRIC_L2);
+    testTransposition(false, true, knowherefaiss::MetricType::METRIC_L2);
 }
 
 TEST(TestGpuDistance, Transposition_CR) {
-    testTransposition(true, false, faiss::MetricType::METRIC_L2);
+    testTransposition(true, false, knowherefaiss::MetricType::METRIC_L2);
 }
 
 TEST(TestGpuDistance, Transposition_CC) {
-    testTransposition(true, true, faiss::MetricType::METRIC_L2);
+    testTransposition(true, true, knowherefaiss::MetricType::METRIC_L2);
 }
 
 TEST(TestGpuDistance, L1) {
-    testTransposition(false, false, faiss::MetricType::METRIC_L1);
+    testTransposition(false, false, knowherefaiss::MetricType::METRIC_L1);
 }
 
 // Test other transpositions with the general distance kernel
 TEST(TestGpuDistance, L1_RC) {
-    testTransposition(false, true, faiss::MetricType::METRIC_L1);
+    testTransposition(false, true, knowherefaiss::MetricType::METRIC_L1);
 }
 
 TEST(TestGpuDistance, L1_CR) {
-    testTransposition(true, false, faiss::MetricType::METRIC_L1);
+    testTransposition(true, false, knowherefaiss::MetricType::METRIC_L1);
 }
 
 TEST(TestGpuDistance, L1_CC) {
-    testTransposition(true, true, faiss::MetricType::METRIC_L1);
+    testTransposition(true, true, knowherefaiss::MetricType::METRIC_L1);
 }
 
 // Test remainder of metric types
 TEST(TestGpuDistance, Linf) {
-    testTransposition(false, false, faiss::MetricType::METRIC_Linf);
+    testTransposition(false, false, knowherefaiss::MetricType::METRIC_Linf);
 }
 
 TEST(TestGpuDistance, Lp) {
-    testTransposition(false, false, faiss::MetricType::METRIC_Lp, 3);
+    testTransposition(false, false, knowherefaiss::MetricType::METRIC_Lp, 3);
 }
 
 TEST(TestGpuDistance, Canberra) {
-    testTransposition(false, false, faiss::MetricType::METRIC_Canberra);
+    testTransposition(false, false, knowherefaiss::MetricType::METRIC_Canberra);
 }
 
 TEST(TestGpuDistance, BrayCurtis) {
-    testTransposition(false, false, faiss::MetricType::METRIC_BrayCurtis);
+    testTransposition(false, false, knowherefaiss::MetricType::METRIC_BrayCurtis);
 }
 
 TEST(TestGpuDistance, JensenShannon) {
-    testTransposition(false, false, faiss::MetricType::METRIC_JensenShannon);
+    testTransposition(false, false, knowherefaiss::MetricType::METRIC_JensenShannon);
 }
 
 int main(int argc, char** argv) {
     testing::InitGoogleTest(&argc, argv);
 
     // just run with a fixed test seed
-    faiss::gpu::setTestSeed(100);
+    knowherefaiss::gpu::setTestSeed(100);
 
     return RUN_ALL_TESTS();
 }
diff --git a/thirdparty/faiss/faiss/gpu/test/TestGpuIndexBinaryFlat.cpp b/thirdparty/faiss/knowherefaiss/gpu/test/TestGpuIndexBinaryFlat.cpp
similarity index 64%
rename from thirdparty/faiss/faiss/gpu/test/TestGpuIndexBinaryFlat.cpp
rename to thirdparty/faiss/knowherefaiss/gpu/test/TestGpuIndexBinaryFlat.cpp
index 6c44b911..961d3e06 100644
--- a/thirdparty/faiss/faiss/gpu/test/TestGpuIndexBinaryFlat.cpp
+++ b/thirdparty/faiss/knowherefaiss/gpu/test/TestGpuIndexBinaryFlat.cpp
@@ -5,21 +5,21 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/IndexBinaryFlat.h>
-#include <faiss/gpu/GpuIndexBinaryFlat.h>
-#include <faiss/gpu/StandardGpuResources.h>
-#include <faiss/gpu/test/TestUtils.h>
-#include <faiss/gpu/utils/DeviceUtils.h>
-#include <faiss/utils/utils.h>
+#include <knowherefaiss/IndexBinaryFlat.h>
+#include <knowherefaiss/gpu/GpuIndexBinaryFlat.h>
+#include <knowherefaiss/gpu/StandardGpuResources.h>
+#include <knowherefaiss/gpu/test/TestUtils.h>
+#include <knowherefaiss/gpu/utils/DeviceUtils.h>
+#include <knowherefaiss/utils/utils.h>
 #include <gtest/gtest.h>
 #include <sstream>
 #include <vector>
 
 void compareBinaryDist(
         const std::vector<int>& cpuDist,
-        const std::vector<faiss::IndexBinary::idx_t>& cpuLabels,
+        const std::vector<knowherefaiss::IndexBinary::idx_t>& cpuLabels,
         const std::vector<int>& gpuDist,
-        const std::vector<faiss::IndexBinary::idx_t>& gpuLabels,
+        const std::vector<knowherefaiss::IndexBinary::idx_t>& gpuLabels,
         int numQuery,
         int k) {
     for (int i = 0; i < numQuery; ++i) {
@@ -28,8 +28,8 @@ void compareBinaryDist(
         // encounters the values. The last set of equivalent distances seen in
         // the min-k might be truncated, so we can't check that set, but all
         // others we can check.
-        std::set<faiss::IndexBinary::idx_t> cpuLabelSet;
-        std::set<faiss::IndexBinary::idx_t> gpuLabelSet;
+        std::set<knowherefaiss::IndexBinary::idx_t> cpuLabelSet;
+        std::set<knowherefaiss::IndexBinary::idx_t> gpuLabelSet;
 
         int curDist = -1;
 
@@ -63,38 +63,38 @@ void compareBinaryDist(
 
 template <int DimMultiple>
 void testGpuIndexBinaryFlat(int kOverride = -1) {
-    faiss::gpu::StandardGpuResources res;
+    knowherefaiss::gpu::StandardGpuResources res;
     res.noTempMemory();
 
-    faiss::gpu::GpuIndexBinaryFlatConfig config;
-    config.device = faiss::gpu::randVal(0, faiss::gpu::getNumDevices() - 1);
+    knowherefaiss::gpu::GpuIndexBinaryFlatConfig config;
+    config.device = knowherefaiss::gpu::randVal(0, knowherefaiss::gpu::getNumDevices() - 1);
 
     // multiples of 8 and multiples of 32 use different implementations
-    int dims = faiss::gpu::randVal(1, 20) * DimMultiple;
-    faiss::gpu::GpuIndexBinaryFlat gpuIndex(&res, dims, config);
+    int dims = knowherefaiss::gpu::randVal(1, 20) * DimMultiple;
+    knowherefaiss::gpu::GpuIndexBinaryFlat gpuIndex(&res, dims, config);
 
-    faiss::IndexBinaryFlat cpuIndex(dims);
+    knowherefaiss::IndexBinaryFlat cpuIndex(dims);
 
     int k = kOverride > 0
             ? kOverride
-            : faiss::gpu::randVal(1, faiss::gpu::getMaxKSelection());
-    int numVecs = faiss::gpu::randVal(k + 1, 20000);
-    int numQuery = faiss::gpu::randVal(1, 1000);
+            : knowherefaiss::gpu::randVal(1, knowherefaiss::gpu::getMaxKSelection());
+    int numVecs = knowherefaiss::gpu::randVal(k + 1, 20000);
+    int numQuery = knowherefaiss::gpu::randVal(1, 1000);
 
-    auto data = faiss::gpu::randBinaryVecs(numVecs, dims);
+    auto data = knowherefaiss::gpu::randBinaryVecs(numVecs, dims);
     gpuIndex.add(numVecs, data.data());
     cpuIndex.add(numVecs, data.data());
 
-    auto query = faiss::gpu::randBinaryVecs(numQuery, dims);
+    auto query = knowherefaiss::gpu::randBinaryVecs(numQuery, dims);
 
     std::vector<int> cpuDist(numQuery * k);
-    std::vector<faiss::IndexBinary::idx_t> cpuLabels(numQuery * k);
+    std::vector<knowherefaiss::IndexBinary::idx_t> cpuLabels(numQuery * k);
 
     cpuIndex.search(
             numQuery, query.data(), k, cpuDist.data(), cpuLabels.data());
 
     std::vector<int> gpuDist(numQuery * k);
-    std::vector<faiss::IndexBinary::idx_t> gpuLabels(numQuery * k);
+    std::vector<knowherefaiss::IndexBinary::idx_t> gpuLabels(numQuery * k);
 
     gpuIndex.search(
             numQuery, query.data(), k, gpuDist.data(), gpuLabels.data());
@@ -118,7 +118,7 @@ int main(int argc, char** argv) {
     testing::InitGoogleTest(&argc, argv);
 
     // just run with a fixed test seed
-    faiss::gpu::setTestSeed(100);
+    knowherefaiss::gpu::setTestSeed(100);
 
     return RUN_ALL_TESTS();
 }
diff --git a/thirdparty/faiss/faiss/gpu/test/TestGpuIndexFlat.cpp b/thirdparty/faiss/knowherefaiss/gpu/test/TestGpuIndexFlat.cpp
similarity index 68%
rename from thirdparty/faiss/faiss/gpu/test/TestGpuIndexFlat.cpp
rename to thirdparty/faiss/knowherefaiss/gpu/test/TestGpuIndexFlat.cpp
index 5c3c4858..f77711ab 100644
--- a/thirdparty/faiss/faiss/gpu/test/TestGpuIndexFlat.cpp
+++ b/thirdparty/faiss/knowherefaiss/gpu/test/TestGpuIndexFlat.cpp
@@ -5,11 +5,11 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/IndexFlat.h>
-#include <faiss/gpu/GpuIndexFlat.h>
-#include <faiss/gpu/StandardGpuResources.h>
-#include <faiss/gpu/test/TestUtils.h>
-#include <faiss/gpu/utils/DeviceUtils.h>
+#include <knowherefaiss/IndexFlat.h>
+#include <knowherefaiss/gpu/GpuIndexFlat.h>
+#include <knowherefaiss/gpu/StandardGpuResources.h>
+#include <knowherefaiss/gpu/test/TestUtils.h>
+#include <knowherefaiss/gpu/utils/DeviceUtils.h>
 #include <gtest/gtest.h>
 #include <sstream>
 #include <vector>
@@ -20,7 +20,7 @@ constexpr float kF32MaxRelErr = 6e-3f;
 
 struct TestFlatOptions {
     TestFlatOptions()
-            : metric(faiss::MetricType::METRIC_L2),
+            : metric(knowherefaiss::MetricType::METRIC_L2),
               metricArg(0),
               useFloat16(false),
               useTransposed(false),
@@ -29,7 +29,7 @@ struct TestFlatOptions {
               kOverride(-1),
               dimOverride(-1) {}
 
-    faiss::MetricType metric;
+    knowherefaiss::MetricType metric;
     float metricArg;
 
     bool useFloat16;
@@ -42,43 +42,43 @@ struct TestFlatOptions {
 
 void testFlat(const TestFlatOptions& opt) {
     int numVecs = opt.numVecsOverride > 0 ? opt.numVecsOverride
-                                          : faiss::gpu::randVal(1000, 5000);
+                                          : knowherefaiss::gpu::randVal(1000, 5000);
     int dim = opt.dimOverride > 0 ? opt.dimOverride
-                                  : faiss::gpu::randVal(50, 800);
+                                  : knowherefaiss::gpu::randVal(50, 800);
     int numQuery = opt.numQueriesOverride > 0 ? opt.numQueriesOverride
-                                              : faiss::gpu::randVal(1, 512);
+                                              : knowherefaiss::gpu::randVal(1, 512);
 
     // Due to loss of precision in a float16 accumulator, for large k,
     // the number of differences is pretty huge. Restrict ourselves to a
     // fairly small `k` for float16
     int k = opt.useFloat16
-            ? std::min(faiss::gpu::randVal(1, 50), numVecs)
+            ? std::min(knowherefaiss::gpu::randVal(1, 50), numVecs)
             : std::min(
-                      faiss::gpu::randVal(1, faiss::gpu::getMaxKSelection()),
+                      knowherefaiss::gpu::randVal(1, knowherefaiss::gpu::getMaxKSelection()),
                       numVecs);
     if (opt.kOverride > 0) {
         k = opt.kOverride;
     }
 
-    faiss::IndexFlat cpuIndex(dim, opt.metric);
+    knowherefaiss::IndexFlat cpuIndex(dim, opt.metric);
     cpuIndex.metric_arg = opt.metricArg;
 
     // Construct on a random device to test multi-device, if we have
     // multiple devices
-    int device = faiss::gpu::randVal(0, faiss::gpu::getNumDevices() - 1);
+    int device = knowherefaiss::gpu::randVal(0, knowherefaiss::gpu::getNumDevices() - 1);
 
-    faiss::gpu::StandardGpuResources res;
+    knowherefaiss::gpu::StandardGpuResources res;
     res.noTempMemory();
 
-    faiss::gpu::GpuIndexFlatConfig config;
+    knowherefaiss::gpu::GpuIndexFlatConfig config;
     config.device = device;
     config.useFloat16 = opt.useFloat16;
     config.storeTransposed = opt.useTransposed;
 
-    faiss::gpu::GpuIndexFlat gpuIndex(&res, dim, opt.metric, config);
+    knowherefaiss::gpu::GpuIndexFlat gpuIndex(&res, dim, opt.metric, config);
     gpuIndex.metric_arg = opt.metricArg;
 
-    std::vector<float> vecs = faiss::gpu::randVecs(numVecs, dim);
+    std::vector<float> vecs = knowherefaiss::gpu::randVecs(numVecs, dim);
     cpuIndex.add(numVecs, vecs.data());
     gpuIndex.add(numVecs, vecs.data());
 
@@ -90,7 +90,7 @@ void testFlat(const TestFlatOptions& opt) {
 
     // To some extent, we depend upon the relative error for the test
     // for float16
-    faiss::gpu::compareIndices(
+    knowherefaiss::gpu::compareIndices(
             cpuIndex,
             gpuIndex,
             numQuery,
@@ -108,7 +108,7 @@ void testFlat(const TestFlatOptions& opt) {
 TEST(TestGpuIndexFlat, IP_Float32) {
     for (int tries = 0; tries < 3; ++tries) {
         TestFlatOptions opt;
-        opt.metric = faiss::MetricType::METRIC_INNER_PRODUCT;
+        opt.metric = knowherefaiss::MetricType::METRIC_INNER_PRODUCT;
         opt.useFloat16 = false;
         opt.useTransposed = false;
 
@@ -121,7 +121,7 @@ TEST(TestGpuIndexFlat, IP_Float32) {
 
 TEST(TestGpuIndexFlat, L1_Float32) {
     TestFlatOptions opt;
-    opt.metric = faiss::MetricType::METRIC_L1;
+    opt.metric = knowherefaiss::MetricType::METRIC_L1;
     opt.useFloat16 = false;
     opt.useTransposed = false;
 
@@ -133,7 +133,7 @@ TEST(TestGpuIndexFlat, L1_Float32) {
 
 TEST(TestGpuIndexFlat, Lp_Float32) {
     TestFlatOptions opt;
-    opt.metric = faiss::MetricType::METRIC_Lp;
+    opt.metric = knowherefaiss::MetricType::METRIC_Lp;
     opt.metricArg = 5;
     opt.useFloat16 = false;
     opt.useTransposed = false;
@@ -147,7 +147,7 @@ TEST(TestGpuIndexFlat, Lp_Float32) {
 TEST(TestGpuIndexFlat, L2_Float32) {
     for (int tries = 0; tries < 3; ++tries) {
         TestFlatOptions opt;
-        opt.metric = faiss::MetricType::METRIC_L2;
+        opt.metric = knowherefaiss::MetricType::METRIC_L2;
 
         opt.useFloat16 = false;
         opt.useTransposed = false;
@@ -163,7 +163,7 @@ TEST(TestGpuIndexFlat, L2_Float32) {
 TEST(TestGpuIndexFlat, L2_Float32_K1) {
     for (int tries = 0; tries < 3; ++tries) {
         TestFlatOptions opt;
-        opt.metric = faiss::MetricType::METRIC_L2;
+        opt.metric = knowherefaiss::MetricType::METRIC_L2;
         opt.useFloat16 = false;
         opt.useTransposed = false;
         opt.kOverride = 1;
@@ -175,7 +175,7 @@ TEST(TestGpuIndexFlat, L2_Float32_K1) {
 TEST(TestGpuIndexFlat, IP_Float16) {
     for (int tries = 0; tries < 3; ++tries) {
         TestFlatOptions opt;
-        opt.metric = faiss::MetricType::METRIC_INNER_PRODUCT;
+        opt.metric = knowherefaiss::MetricType::METRIC_INNER_PRODUCT;
         opt.useFloat16 = true;
         opt.useTransposed = false;
 
@@ -189,7 +189,7 @@ TEST(TestGpuIndexFlat, IP_Float16) {
 TEST(TestGpuIndexFlat, L2_Float16) {
     for (int tries = 0; tries < 3; ++tries) {
         TestFlatOptions opt;
-        opt.metric = faiss::MetricType::METRIC_L2;
+        opt.metric = knowherefaiss::MetricType::METRIC_L2;
         opt.useFloat16 = true;
         opt.useTransposed = false;
 
@@ -204,7 +204,7 @@ TEST(TestGpuIndexFlat, L2_Float16) {
 TEST(TestGpuIndexFlat, L2_Float16_K1) {
     for (int tries = 0; tries < 3; ++tries) {
         TestFlatOptions opt;
-        opt.metric = faiss::MetricType::METRIC_L2;
+        opt.metric = knowherefaiss::MetricType::METRIC_L2;
         opt.useFloat16 = true;
         opt.useTransposed = false;
         opt.kOverride = 1;
@@ -217,7 +217,7 @@ TEST(TestGpuIndexFlat, L2_Float16_K1) {
 TEST(TestGpuIndexFlat, L2_Tiling) {
     for (int tries = 0; tries < 2; ++tries) {
         TestFlatOptions opt;
-        opt.metric = faiss::MetricType::METRIC_L2;
+        opt.metric = knowherefaiss::MetricType::METRIC_L2;
         opt.useFloat16 = false;
         opt.useTransposed = false;
         opt.numVecsOverride = 1000000;
@@ -232,16 +232,16 @@ TEST(TestGpuIndexFlat, L2_Tiling) {
 }
 
 TEST(TestGpuIndexFlat, QueryEmpty) {
-    faiss::gpu::StandardGpuResources res;
+    knowherefaiss::gpu::StandardGpuResources res;
     res.noTempMemory();
 
-    faiss::gpu::GpuIndexFlatConfig config;
+    knowherefaiss::gpu::GpuIndexFlatConfig config;
     config.device = 0;
     config.useFloat16 = false;
     config.storeTransposed = false;
 
     int dim = 128;
-    faiss::gpu::GpuIndexFlatL2 gpuIndex(&res, dim, config);
+    knowherefaiss::gpu::GpuIndexFlatL2 gpuIndex(&res, dim, config);
 
     // Querying an empty index should not blow up, and just return
     // (FLT_MAX, -1)
@@ -250,7 +250,7 @@ TEST(TestGpuIndexFlat, QueryEmpty) {
     std::vector<float> queries(numQuery * dim, 1.0f);
 
     std::vector<float> dist(numQuery * k, 0);
-    std::vector<faiss::Index::idx_t> ind(numQuery * k);
+    std::vector<knowherefaiss::Index::idx_t> ind(numQuery * k);
 
     gpuIndex.search(numQuery, queries.data(), k, dist.data(), ind.data());
 
@@ -264,26 +264,26 @@ TEST(TestGpuIndexFlat, QueryEmpty) {
 }
 
 TEST(TestGpuIndexFlat, CopyFrom) {
-    int numVecs = faiss::gpu::randVal(100, 200);
-    int dim = faiss::gpu::randVal(1, 1000);
+    int numVecs = knowherefaiss::gpu::randVal(100, 200);
+    int dim = knowherefaiss::gpu::randVal(1, 1000);
 
-    faiss::IndexFlatL2 cpuIndex(dim);
+    knowherefaiss::IndexFlatL2 cpuIndex(dim);
 
-    std::vector<float> vecs = faiss::gpu::randVecs(numVecs, dim);
+    std::vector<float> vecs = knowherefaiss::gpu::randVecs(numVecs, dim);
     cpuIndex.add(numVecs, vecs.data());
 
-    faiss::gpu::StandardGpuResources res;
+    knowherefaiss::gpu::StandardGpuResources res;
     res.noTempMemory();
 
     // Fill with garbage values
-    int device = faiss::gpu::randVal(0, faiss::gpu::getNumDevices() - 1);
+    int device = knowherefaiss::gpu::randVal(0, knowherefaiss::gpu::getNumDevices() - 1);
 
-    faiss::gpu::GpuIndexFlatConfig config;
+    knowherefaiss::gpu::GpuIndexFlatConfig config;
     config.device = device;
     config.useFloat16 = false;
     config.storeTransposed = false;
 
-    faiss::gpu::GpuIndexFlatL2 gpuIndex(&res, 2000, config);
+    knowherefaiss::gpu::GpuIndexFlatL2 gpuIndex(&res, 2000, config);
     gpuIndex.copyFrom(&cpuIndex);
 
     EXPECT_EQ(cpuIndex.ntotal, gpuIndex.ntotal);
@@ -292,7 +292,7 @@ TEST(TestGpuIndexFlat, CopyFrom) {
     EXPECT_EQ(cpuIndex.d, gpuIndex.d);
     EXPECT_EQ(cpuIndex.d, dim);
 
-    int idx = faiss::gpu::randVal(0, numVecs - 1);
+    int idx = knowherefaiss::gpu::randVal(0, numVecs - 1);
 
     std::vector<float> gpuVals(dim);
     gpuIndex.reconstruct(idx, gpuVals.data());
@@ -304,26 +304,26 @@ TEST(TestGpuIndexFlat, CopyFrom) {
 }
 
 TEST(TestGpuIndexFlat, CopyTo) {
-    faiss::gpu::StandardGpuResources res;
+    knowherefaiss::gpu::StandardGpuResources res;
     res.noTempMemory();
 
-    int numVecs = faiss::gpu::randVal(100, 200);
-    int dim = faiss::gpu::randVal(1, 1000);
+    int numVecs = knowherefaiss::gpu::randVal(100, 200);
+    int dim = knowherefaiss::gpu::randVal(1, 1000);
 
-    int device = faiss::gpu::randVal(0, faiss::gpu::getNumDevices() - 1);
+    int device = knowherefaiss::gpu::randVal(0, knowherefaiss::gpu::getNumDevices() - 1);
 
-    faiss::gpu::GpuIndexFlatConfig config;
+    knowherefaiss::gpu::GpuIndexFlatConfig config;
     config.device = device;
     config.useFloat16 = false;
     config.storeTransposed = false;
 
-    faiss::gpu::GpuIndexFlatL2 gpuIndex(&res, dim, config);
+    knowherefaiss::gpu::GpuIndexFlatL2 gpuIndex(&res, dim, config);
 
-    std::vector<float> vecs = faiss::gpu::randVecs(numVecs, dim);
+    std::vector<float> vecs = knowherefaiss::gpu::randVecs(numVecs, dim);
     gpuIndex.add(numVecs, vecs.data());
 
     // Fill with garbage values
-    faiss::IndexFlatL2 cpuIndex(2000);
+    knowherefaiss::IndexFlatL2 cpuIndex(2000);
     gpuIndex.copyTo(&cpuIndex);
 
     EXPECT_EQ(cpuIndex.ntotal, gpuIndex.ntotal);
@@ -332,7 +332,7 @@ TEST(TestGpuIndexFlat, CopyTo) {
     EXPECT_EQ(cpuIndex.d, gpuIndex.d);
     EXPECT_EQ(cpuIndex.d, dim);
 
-    int idx = faiss::gpu::randVal(0, numVecs - 1);
+    int idx = knowherefaiss::gpu::randVal(0, numVecs - 1);
 
     std::vector<float> gpuVals(dim);
     gpuIndex.reconstruct(idx, gpuVals.data());
@@ -346,9 +346,9 @@ TEST(TestGpuIndexFlat, CopyTo) {
 TEST(TestGpuIndexFlat, UnifiedMemory) {
     // Construct on a random device to test multi-device, if we have
     // multiple devices
-    int device = faiss::gpu::randVal(0, faiss::gpu::getNumDevices() - 1);
+    int device = knowherefaiss::gpu::randVal(0, knowherefaiss::gpu::getNumDevices() - 1);
 
-    if (!faiss::gpu::getFullUnifiedMemSupport(device)) {
+    if (!knowherefaiss::gpu::getFullUnifiedMemSupport(device)) {
         return;
     }
 
@@ -361,24 +361,24 @@ TEST(TestGpuIndexFlat, UnifiedMemory) {
     int numQuery = 10;
     int k = 10;
 
-    faiss::IndexFlatL2 cpuIndexL2(dim);
+    knowherefaiss::IndexFlatL2 cpuIndexL2(dim);
 
-    faiss::gpu::StandardGpuResources res;
+    knowherefaiss::gpu::StandardGpuResources res;
     res.noTempMemory();
 
-    faiss::gpu::GpuIndexFlatConfig config;
+    knowherefaiss::gpu::GpuIndexFlatConfig config;
     config.device = device;
-    config.memorySpace = faiss::gpu::MemorySpace::Unified;
+    config.memorySpace = knowherefaiss::gpu::MemorySpace::Unified;
 
-    faiss::gpu::GpuIndexFlatL2 gpuIndexL2(&res, dim, config);
+    knowherefaiss::gpu::GpuIndexFlatL2 gpuIndexL2(&res, dim, config);
 
-    std::vector<float> vecs = faiss::gpu::randVecs(numVecs, dim);
+    std::vector<float> vecs = knowherefaiss::gpu::randVecs(numVecs, dim);
     cpuIndexL2.add(numVecs, vecs.data());
     gpuIndexL2.add(numVecs, vecs.data());
 
     // To some extent, we depend upon the relative error for the test
     // for float16
-    faiss::gpu::compareIndices(
+    knowherefaiss::gpu::compareIndices(
             cpuIndexL2,
             gpuIndexL2,
             numQuery,
@@ -394,7 +394,7 @@ int main(int argc, char** argv) {
     testing::InitGoogleTest(&argc, argv);
 
     // just run with a fixed test seed
-    faiss::gpu::setTestSeed(100);
+    knowherefaiss::gpu::setTestSeed(100);
 
     return RUN_ALL_TESTS();
 }
diff --git a/thirdparty/faiss/faiss/gpu/test/TestGpuIndexIVFFlat.cpp b/thirdparty/faiss/knowherefaiss/gpu/test/TestGpuIndexIVFFlat.cpp
similarity index 61%
rename from thirdparty/faiss/faiss/gpu/test/TestGpuIndexIVFFlat.cpp
rename to thirdparty/faiss/knowherefaiss/gpu/test/TestGpuIndexIVFFlat.cpp
index f67f0370..f966b6a5 100644
--- a/thirdparty/faiss/faiss/gpu/test/TestGpuIndexIVFFlat.cpp
+++ b/thirdparty/faiss/knowherefaiss/gpu/test/TestGpuIndexIVFFlat.cpp
@@ -5,12 +5,12 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/IndexFlat.h>
-#include <faiss/IndexIVFFlat.h>
-#include <faiss/gpu/GpuIndexIVFFlat.h>
-#include <faiss/gpu/StandardGpuResources.h>
-#include <faiss/gpu/test/TestUtils.h>
-#include <faiss/gpu/utils/DeviceUtils.h>
+#include <knowherefaiss/IndexFlat.h>
+#include <knowherefaiss/IndexIVFFlat.h>
+#include <knowherefaiss/gpu/GpuIndexIVFFlat.h>
+#include <knowherefaiss/gpu/StandardGpuResources.h>
+#include <knowherefaiss/gpu/test/TestUtils.h>
+#include <knowherefaiss/gpu/utils/DeviceUtils.h>
 #include <gtest/gtest.h>
 #include <cmath>
 #include <sstream>
@@ -22,24 +22,24 @@ constexpr float kF32MaxRelErr = 0.03f;
 
 struct Options {
     Options() {
-        numAdd = 2 * faiss::gpu::randVal(2000, 5000);
-        dim = faiss::gpu::randVal(64, 200);
+        numAdd = 2 * knowherefaiss::gpu::randVal(2000, 5000);
+        dim = knowherefaiss::gpu::randVal(64, 200);
 
         numCentroids = std::sqrt((float)numAdd / 2);
         numTrain = numCentroids * 40;
-        nprobe = faiss::gpu::randVal(std::min(10, numCentroids), numCentroids);
-        numQuery = faiss::gpu::randVal(32, 100);
+        nprobe = knowherefaiss::gpu::randVal(std::min(10, numCentroids), numCentroids);
+        numQuery = knowherefaiss::gpu::randVal(32, 100);
 
         // Due to the approximate nature of the query and of floating point
         // differences between GPU and CPU, to stay within our error bounds,
         // only use a small k
-        k = std::min(faiss::gpu::randVal(10, 30), numAdd / 40);
-        indicesOpt = faiss::gpu::randSelect(
-                {faiss::gpu::INDICES_CPU,
-                 faiss::gpu::INDICES_32_BIT,
-                 faiss::gpu::INDICES_64_BIT});
+        k = std::min(knowherefaiss::gpu::randVal(10, 30), numAdd / 40);
+        indicesOpt = knowherefaiss::gpu::randSelect(
+                {knowherefaiss::gpu::INDICES_CPU,
+                 knowherefaiss::gpu::INDICES_32_BIT,
+                 knowherefaiss::gpu::INDICES_64_BIT});
 
-        device = faiss::gpu::randVal(0, faiss::gpu::getNumDevices() - 1);
+        device = knowherefaiss::gpu::randVal(0, knowherefaiss::gpu::getNumDevices() - 1);
     }
 
     std::string toString() const {
@@ -60,11 +60,11 @@ struct Options {
     int numQuery;
     int k;
     int device;
-    faiss::gpu::IndicesOptions indicesOpt;
+    knowherefaiss::gpu::IndicesOptions indicesOpt;
 };
 
 void queryTest(
-        faiss::MetricType metricType,
+        knowherefaiss::MetricType metricType,
         bool useFloat16CoarseQuantizer,
         int dimOverride = -1) {
     for (int tries = 0; tries < 2; ++tries) {
@@ -72,36 +72,36 @@ void queryTest(
         opt.dim = dimOverride != -1 ? dimOverride : opt.dim;
 
         std::vector<float> trainVecs =
-                faiss::gpu::randVecs(opt.numTrain, opt.dim);
-        std::vector<float> addVecs = faiss::gpu::randVecs(opt.numAdd, opt.dim);
+                knowherefaiss::gpu::randVecs(opt.numTrain, opt.dim);
+        std::vector<float> addVecs = knowherefaiss::gpu::randVecs(opt.numAdd, opt.dim);
 
-        faiss::IndexFlatL2 quantizerL2(opt.dim);
-        faiss::IndexFlatIP quantizerIP(opt.dim);
-        faiss::Index* quantizer = metricType == faiss::METRIC_L2
-                ? (faiss::Index*)&quantizerL2
-                : (faiss::Index*)&quantizerIP;
+        knowherefaiss::IndexFlatL2 quantizerL2(opt.dim);
+        knowherefaiss::IndexFlatIP quantizerIP(opt.dim);
+        knowherefaiss::Index* quantizer = metricType == knowherefaiss::METRIC_L2
+                ? (knowherefaiss::Index*)&quantizerL2
+                : (knowherefaiss::Index*)&quantizerIP;
 
-        faiss::IndexIVFFlat cpuIndex(
+        knowherefaiss::IndexIVFFlat cpuIndex(
                 quantizer, opt.dim, opt.numCentroids, metricType);
         cpuIndex.train(opt.numTrain, trainVecs.data());
         cpuIndex.add(opt.numAdd, addVecs.data());
         cpuIndex.nprobe = opt.nprobe;
 
-        faiss::gpu::StandardGpuResources res;
+        knowherefaiss::gpu::StandardGpuResources res;
         res.noTempMemory();
 
-        faiss::gpu::GpuIndexIVFFlatConfig config;
+        knowherefaiss::gpu::GpuIndexIVFFlatConfig config;
         config.device = opt.device;
         config.indicesOptions = opt.indicesOpt;
         config.flatConfig.useFloat16 = useFloat16CoarseQuantizer;
 
-        faiss::gpu::GpuIndexIVFFlat gpuIndex(
+        knowherefaiss::gpu::GpuIndexIVFFlat gpuIndex(
                 &res, cpuIndex.d, cpuIndex.nlist, cpuIndex.metric_type, config);
         gpuIndex.copyFrom(&cpuIndex);
         gpuIndex.setNumProbes(opt.nprobe);
 
         bool compFloat16 = useFloat16CoarseQuantizer;
-        faiss::gpu::compareIndices(
+        knowherefaiss::gpu::compareIndices(
                 cpuIndex,
                 gpuIndex,
                 opt.numQuery,
@@ -117,34 +117,34 @@ void queryTest(
     }
 }
 
-void addTest(faiss::MetricType metricType, bool useFloat16CoarseQuantizer) {
+void addTest(knowherefaiss::MetricType metricType, bool useFloat16CoarseQuantizer) {
     for (int tries = 0; tries < 2; ++tries) {
         Options opt;
 
         std::vector<float> trainVecs =
-                faiss::gpu::randVecs(opt.numTrain, opt.dim);
-        std::vector<float> addVecs = faiss::gpu::randVecs(opt.numAdd, opt.dim);
+                knowherefaiss::gpu::randVecs(opt.numTrain, opt.dim);
+        std::vector<float> addVecs = knowherefaiss::gpu::randVecs(opt.numAdd, opt.dim);
 
-        faiss::IndexFlatL2 quantizerL2(opt.dim);
-        faiss::IndexFlatIP quantizerIP(opt.dim);
-        faiss::Index* quantizer = metricType == faiss::METRIC_L2
-                ? (faiss::Index*)&quantizerL2
-                : (faiss::Index*)&quantizerIP;
+        knowherefaiss::IndexFlatL2 quantizerL2(opt.dim);
+        knowherefaiss::IndexFlatIP quantizerIP(opt.dim);
+        knowherefaiss::Index* quantizer = metricType == knowherefaiss::METRIC_L2
+                ? (knowherefaiss::Index*)&quantizerL2
+                : (knowherefaiss::Index*)&quantizerIP;
 
-        faiss::IndexIVFFlat cpuIndex(
+        knowherefaiss::IndexIVFFlat cpuIndex(
                 quantizer, opt.dim, opt.numCentroids, metricType);
         cpuIndex.train(opt.numTrain, trainVecs.data());
         cpuIndex.nprobe = opt.nprobe;
 
-        faiss::gpu::StandardGpuResources res;
+        knowherefaiss::gpu::StandardGpuResources res;
         res.noTempMemory();
 
-        faiss::gpu::GpuIndexIVFFlatConfig config;
+        knowherefaiss::gpu::GpuIndexIVFFlatConfig config;
         config.device = opt.device;
         config.indicesOptions = opt.indicesOpt;
         config.flatConfig.useFloat16 = useFloat16CoarseQuantizer;
 
-        faiss::gpu::GpuIndexIVFFlat gpuIndex(
+        knowherefaiss::gpu::GpuIndexIVFFlat gpuIndex(
                 &res, cpuIndex.d, cpuIndex.nlist, cpuIndex.metric_type, config);
         gpuIndex.copyFrom(&cpuIndex);
         gpuIndex.setNumProbes(opt.nprobe);
@@ -153,7 +153,7 @@ void addTest(faiss::MetricType metricType, bool useFloat16CoarseQuantizer) {
         gpuIndex.add(opt.numAdd, addVecs.data());
 
         bool compFloat16 = useFloat16CoarseQuantizer;
-        faiss::gpu::compareIndices(
+        knowherefaiss::gpu::compareIndices(
                 cpuIndex,
                 gpuIndex,
                 opt.numQuery,
@@ -168,26 +168,26 @@ void addTest(faiss::MetricType metricType, bool useFloat16CoarseQuantizer) {
 
 void copyToTest(bool useFloat16CoarseQuantizer) {
     Options opt;
-    std::vector<float> trainVecs = faiss::gpu::randVecs(opt.numTrain, opt.dim);
-    std::vector<float> addVecs = faiss::gpu::randVecs(opt.numAdd, opt.dim);
+    std::vector<float> trainVecs = knowherefaiss::gpu::randVecs(opt.numTrain, opt.dim);
+    std::vector<float> addVecs = knowherefaiss::gpu::randVecs(opt.numAdd, opt.dim);
 
-    faiss::gpu::StandardGpuResources res;
+    knowherefaiss::gpu::StandardGpuResources res;
     res.noTempMemory();
 
-    faiss::gpu::GpuIndexIVFFlatConfig config;
+    knowherefaiss::gpu::GpuIndexIVFFlatConfig config;
     config.device = opt.device;
     config.indicesOptions = opt.indicesOpt;
     config.flatConfig.useFloat16 = useFloat16CoarseQuantizer;
 
-    faiss::gpu::GpuIndexIVFFlat gpuIndex(
-            &res, opt.dim, opt.numCentroids, faiss::METRIC_L2, config);
+    knowherefaiss::gpu::GpuIndexIVFFlat gpuIndex(
+            &res, opt.dim, opt.numCentroids, knowherefaiss::METRIC_L2, config);
     gpuIndex.train(opt.numTrain, trainVecs.data());
     gpuIndex.add(opt.numAdd, addVecs.data());
     gpuIndex.setNumProbes(opt.nprobe);
 
     // use garbage values to see if we overwrite then
-    faiss::IndexFlatL2 cpuQuantizer(1);
-    faiss::IndexIVFFlat cpuIndex(&cpuQuantizer, 1, 1, faiss::METRIC_L2);
+    knowherefaiss::IndexFlatL2 cpuQuantizer(1);
+    knowherefaiss::IndexIVFFlat cpuIndex(&cpuQuantizer, 1, 1, knowherefaiss::METRIC_L2);
     cpuIndex.nprobe = 1;
 
     gpuIndex.copyTo(&cpuIndex);
@@ -205,7 +205,7 @@ void copyToTest(bool useFloat16CoarseQuantizer) {
 
     // Query both objects; results should be equivalent
     bool compFloat16 = useFloat16CoarseQuantizer;
-    faiss::gpu::compareIndices(
+    knowherefaiss::gpu::compareIndices(
             cpuIndex,
             gpuIndex,
             opt.numQuery,
@@ -219,26 +219,26 @@ void copyToTest(bool useFloat16CoarseQuantizer) {
 
 void copyFromTest(bool useFloat16CoarseQuantizer) {
     Options opt;
-    std::vector<float> trainVecs = faiss::gpu::randVecs(opt.numTrain, opt.dim);
-    std::vector<float> addVecs = faiss::gpu::randVecs(opt.numAdd, opt.dim);
+    std::vector<float> trainVecs = knowherefaiss::gpu::randVecs(opt.numTrain, opt.dim);
+    std::vector<float> addVecs = knowherefaiss::gpu::randVecs(opt.numAdd, opt.dim);
 
-    faiss::IndexFlatL2 cpuQuantizer(opt.dim);
-    faiss::IndexIVFFlat cpuIndex(
-            &cpuQuantizer, opt.dim, opt.numCentroids, faiss::METRIC_L2);
+    knowherefaiss::IndexFlatL2 cpuQuantizer(opt.dim);
+    knowherefaiss::IndexIVFFlat cpuIndex(
+            &cpuQuantizer, opt.dim, opt.numCentroids, knowherefaiss::METRIC_L2);
     cpuIndex.nprobe = opt.nprobe;
     cpuIndex.train(opt.numTrain, trainVecs.data());
     cpuIndex.add(opt.numAdd, addVecs.data());
 
     // use garbage values to see if we overwrite then
-    faiss::gpu::StandardGpuResources res;
+    knowherefaiss::gpu::StandardGpuResources res;
     res.noTempMemory();
 
-    faiss::gpu::GpuIndexIVFFlatConfig config;
+    knowherefaiss::gpu::GpuIndexIVFFlatConfig config;
     config.device = opt.device;
     config.indicesOptions = opt.indicesOpt;
     config.flatConfig.useFloat16 = useFloat16CoarseQuantizer;
 
-    faiss::gpu::GpuIndexIVFFlat gpuIndex(&res, 1, 1, faiss::METRIC_L2, config);
+    knowherefaiss::gpu::GpuIndexIVFFlat gpuIndex(&res, 1, 1, knowherefaiss::METRIC_L2, config);
     gpuIndex.setNumProbes(1);
 
     gpuIndex.copyFrom(&cpuIndex);
@@ -255,7 +255,7 @@ void copyFromTest(bool useFloat16CoarseQuantizer) {
 
     // Query both objects; results should be equivalent
     bool compFloat16 = useFloat16CoarseQuantizer;
-    faiss::gpu::compareIndices(
+    knowherefaiss::gpu::compareIndices(
             cpuIndex,
             gpuIndex,
             opt.numQuery,
@@ -268,19 +268,19 @@ void copyFromTest(bool useFloat16CoarseQuantizer) {
 }
 
 TEST(TestGpuIndexIVFFlat, Float32_32_Add_L2) {
-    addTest(faiss::METRIC_L2, false);
+    addTest(knowherefaiss::METRIC_L2, false);
 }
 
 TEST(TestGpuIndexIVFFlat, Float32_32_Add_IP) {
-    addTest(faiss::METRIC_INNER_PRODUCT, false);
+    addTest(knowherefaiss::METRIC_INNER_PRODUCT, false);
 }
 
 TEST(TestGpuIndexIVFFlat, Float16_32_Add_L2) {
-    addTest(faiss::METRIC_L2, true);
+    addTest(knowherefaiss::METRIC_L2, true);
 }
 
 TEST(TestGpuIndexIVFFlat, Float16_32_Add_IP) {
-    addTest(faiss::METRIC_INNER_PRODUCT, true);
+    addTest(knowherefaiss::METRIC_INNER_PRODUCT, true);
 }
 
 //
@@ -288,21 +288,21 @@ TEST(TestGpuIndexIVFFlat, Float16_32_Add_IP) {
 //
 
 TEST(TestGpuIndexIVFFlat, Float32_Query_L2) {
-    queryTest(faiss::METRIC_L2, false);
+    queryTest(knowherefaiss::METRIC_L2, false);
 }
 
 TEST(TestGpuIndexIVFFlat, Float32_Query_IP) {
-    queryTest(faiss::METRIC_INNER_PRODUCT, false);
+    queryTest(knowherefaiss::METRIC_INNER_PRODUCT, false);
 }
 
 // float16 coarse quantizer
 
 TEST(TestGpuIndexIVFFlat, Float16_32_Query_L2) {
-    queryTest(faiss::METRIC_L2, true);
+    queryTest(knowherefaiss::METRIC_L2, true);
 }
 
 TEST(TestGpuIndexIVFFlat, Float16_32_Query_IP) {
-    queryTest(faiss::METRIC_INNER_PRODUCT, true);
+    queryTest(knowherefaiss::METRIC_INNER_PRODUCT, true);
 }
 
 //
@@ -311,19 +311,19 @@ TEST(TestGpuIndexIVFFlat, Float16_32_Query_IP) {
 //
 
 TEST(TestGpuIndexIVFFlat, Float32_Query_L2_64) {
-    queryTest(faiss::METRIC_L2, false, 64);
+    queryTest(knowherefaiss::METRIC_L2, false, 64);
 }
 
 TEST(TestGpuIndexIVFFlat, Float32_Query_IP_64) {
-    queryTest(faiss::METRIC_INNER_PRODUCT, false, 64);
+    queryTest(knowherefaiss::METRIC_INNER_PRODUCT, false, 64);
 }
 
 TEST(TestGpuIndexIVFFlat, Float32_Query_L2_128) {
-    queryTest(faiss::METRIC_L2, false, 128);
+    queryTest(knowherefaiss::METRIC_L2, false, 128);
 }
 
 TEST(TestGpuIndexIVFFlat, Float32_Query_IP_128) {
-    queryTest(faiss::METRIC_INNER_PRODUCT, false, 128);
+    queryTest(knowherefaiss::METRIC_INNER_PRODUCT, false, 128);
 }
 
 //
@@ -341,8 +341,8 @@ TEST(TestGpuIndexIVFFlat, Float32_32_CopyFrom) {
 TEST(TestGpuIndexIVFFlat, Float32_negative) {
     Options opt;
 
-    auto trainVecs = faiss::gpu::randVecs(opt.numTrain, opt.dim);
-    auto addVecs = faiss::gpu::randVecs(opt.numAdd, opt.dim);
+    auto trainVecs = knowherefaiss::gpu::randVecs(opt.numTrain, opt.dim);
+    auto addVecs = knowherefaiss::gpu::randVecs(opt.numAdd, opt.dim);
 
     // Put all vecs on negative side
     for (auto& f : trainVecs) {
@@ -353,29 +353,29 @@ TEST(TestGpuIndexIVFFlat, Float32_negative) {
         f *= std::abs(f) * -1.0f;
     }
 
-    faiss::IndexFlatIP quantizerIP(opt.dim);
-    faiss::Index* quantizer = (faiss::Index*)&quantizerIP;
+    knowherefaiss::IndexFlatIP quantizerIP(opt.dim);
+    knowherefaiss::Index* quantizer = (knowherefaiss::Index*)&quantizerIP;
 
-    faiss::IndexIVFFlat cpuIndex(
-            quantizer, opt.dim, opt.numCentroids, faiss::METRIC_INNER_PRODUCT);
+    knowherefaiss::IndexIVFFlat cpuIndex(
+            quantizer, opt.dim, opt.numCentroids, knowherefaiss::METRIC_INNER_PRODUCT);
     cpuIndex.train(opt.numTrain, trainVecs.data());
     cpuIndex.add(opt.numAdd, addVecs.data());
     cpuIndex.nprobe = opt.nprobe;
 
-    faiss::gpu::StandardGpuResources res;
+    knowherefaiss::gpu::StandardGpuResources res;
     res.noTempMemory();
 
-    faiss::gpu::GpuIndexIVFFlatConfig config;
+    knowherefaiss::gpu::GpuIndexIVFFlatConfig config;
     config.device = opt.device;
     config.indicesOptions = opt.indicesOpt;
 
-    faiss::gpu::GpuIndexIVFFlat gpuIndex(
+    knowherefaiss::gpu::GpuIndexIVFFlat gpuIndex(
             &res, cpuIndex.d, cpuIndex.nlist, cpuIndex.metric_type, config);
     gpuIndex.copyFrom(&cpuIndex);
     gpuIndex.setNumProbes(opt.nprobe);
 
     // Construct a positive test set
-    auto queryVecs = faiss::gpu::randVecs(opt.numQuery, opt.dim);
+    auto queryVecs = knowherefaiss::gpu::randVecs(opt.numQuery, opt.dim);
 
     // Put all vecs on positive size
     for (auto& f : queryVecs) {
@@ -383,7 +383,7 @@ TEST(TestGpuIndexIVFFlat, Float32_negative) {
     }
 
     bool compFloat16 = false;
-    faiss::gpu::compareIndices(
+    knowherefaiss::gpu::compareIndices(
             queryVecs,
             cpuIndex,
             gpuIndex,
@@ -406,19 +406,19 @@ TEST(TestGpuIndexIVFFlat, Float32_negative) {
 TEST(TestGpuIndexIVFFlat, QueryNaN) {
     Options opt;
 
-    std::vector<float> trainVecs = faiss::gpu::randVecs(opt.numTrain, opt.dim);
-    std::vector<float> addVecs = faiss::gpu::randVecs(opt.numAdd, opt.dim);
+    std::vector<float> trainVecs = knowherefaiss::gpu::randVecs(opt.numTrain, opt.dim);
+    std::vector<float> addVecs = knowherefaiss::gpu::randVecs(opt.numAdd, opt.dim);
 
-    faiss::gpu::StandardGpuResources res;
+    knowherefaiss::gpu::StandardGpuResources res;
     res.noTempMemory();
 
-    faiss::gpu::GpuIndexIVFFlatConfig config;
+    knowherefaiss::gpu::GpuIndexIVFFlatConfig config;
     config.device = opt.device;
     config.indicesOptions = opt.indicesOpt;
-    config.flatConfig.useFloat16 = faiss::gpu::randBool();
+    config.flatConfig.useFloat16 = knowherefaiss::gpu::randBool();
 
-    faiss::gpu::GpuIndexIVFFlat gpuIndex(
-            &res, opt.dim, opt.numCentroids, faiss::METRIC_L2, config);
+    knowherefaiss::gpu::GpuIndexIVFFlat gpuIndex(
+            &res, opt.dim, opt.numCentroids, knowherefaiss::METRIC_L2, config);
     gpuIndex.setNumProbes(opt.nprobe);
 
     gpuIndex.train(opt.numTrain, trainVecs.data());
@@ -429,7 +429,7 @@ TEST(TestGpuIndexIVFFlat, QueryNaN) {
             numQuery * opt.dim, std::numeric_limits<float>::quiet_NaN());
 
     std::vector<float> distances(numQuery * opt.k, 0);
-    std::vector<faiss::Index::idx_t> indices(numQuery * opt.k, 0);
+    std::vector<knowherefaiss::Index::idx_t> indices(numQuery * opt.k, 0);
 
     gpuIndex.search(
             numQuery, nans.data(), opt.k, distances.data(), indices.data());
@@ -447,16 +447,16 @@ TEST(TestGpuIndexIVFFlat, QueryNaN) {
 TEST(TestGpuIndexIVFFlat, AddNaN) {
     Options opt;
 
-    faiss::gpu::StandardGpuResources res;
+    knowherefaiss::gpu::StandardGpuResources res;
     res.noTempMemory();
 
-    faiss::gpu::GpuIndexIVFFlatConfig config;
+    knowherefaiss::gpu::GpuIndexIVFFlatConfig config;
     config.device = opt.device;
     config.indicesOptions = opt.indicesOpt;
-    config.flatConfig.useFloat16 = faiss::gpu::randBool();
+    config.flatConfig.useFloat16 = knowherefaiss::gpu::randBool();
 
-    faiss::gpu::GpuIndexIVFFlat gpuIndex(
-            &res, opt.dim, opt.numCentroids, faiss::METRIC_L2, config);
+    knowherefaiss::gpu::GpuIndexIVFFlat gpuIndex(
+            &res, opt.dim, opt.numCentroids, knowherefaiss::METRIC_L2, config);
     gpuIndex.setNumProbes(opt.nprobe);
 
     int numNans = 10;
@@ -469,16 +469,16 @@ TEST(TestGpuIndexIVFFlat, AddNaN) {
         nans[opt.dim + i] = i;
     }
 
-    std::vector<float> trainVecs = faiss::gpu::randVecs(opt.numTrain, opt.dim);
+    std::vector<float> trainVecs = knowherefaiss::gpu::randVecs(opt.numTrain, opt.dim);
     gpuIndex.train(opt.numTrain, trainVecs.data());
 
     // should not crash
     EXPECT_EQ(gpuIndex.ntotal, 0);
     gpuIndex.add(numNans, nans.data());
 
-    std::vector<float> queryVecs = faiss::gpu::randVecs(opt.numQuery, opt.dim);
+    std::vector<float> queryVecs = knowherefaiss::gpu::randVecs(opt.numQuery, opt.dim);
     std::vector<float> distance(opt.numQuery * opt.k, 0);
-    std::vector<faiss::Index::idx_t> indices(opt.numQuery * opt.k, 0);
+    std::vector<knowherefaiss::Index::idx_t> indices(opt.numQuery * opt.k, 0);
 
     // should not crash
     gpuIndex.search(
@@ -492,9 +492,9 @@ TEST(TestGpuIndexIVFFlat, AddNaN) {
 TEST(TestGpuIndexIVFFlat, UnifiedMemory) {
     // Construct on a random device to test multi-device, if we have
     // multiple devices
-    int device = faiss::gpu::randVal(0, faiss::gpu::getNumDevices() - 1);
+    int device = knowherefaiss::gpu::randVal(0, knowherefaiss::gpu::getNumDevices() - 1);
 
-    if (!faiss::gpu::getFullUnifiedMemSupport(device)) {
+    if (!knowherefaiss::gpu::getFullUnifiedMemSupport(device)) {
         return;
     }
 
@@ -510,30 +510,30 @@ TEST(TestGpuIndexIVFFlat, UnifiedMemory) {
     int k = 10;
     int nprobe = 8;
 
-    std::vector<float> trainVecs = faiss::gpu::randVecs(numTrain, dim);
-    std::vector<float> addVecs = faiss::gpu::randVecs(numAdd, dim);
+    std::vector<float> trainVecs = knowherefaiss::gpu::randVecs(numTrain, dim);
+    std::vector<float> addVecs = knowherefaiss::gpu::randVecs(numAdd, dim);
 
-    faiss::IndexFlatL2 quantizer(dim);
-    faiss::IndexIVFFlat cpuIndex(
-            &quantizer, dim, numCentroids, faiss::METRIC_L2);
+    knowherefaiss::IndexFlatL2 quantizer(dim);
+    knowherefaiss::IndexIVFFlat cpuIndex(
+            &quantizer, dim, numCentroids, knowherefaiss::METRIC_L2);
 
     cpuIndex.train(numTrain, trainVecs.data());
     cpuIndex.add(numAdd, addVecs.data());
     cpuIndex.nprobe = nprobe;
 
-    faiss::gpu::StandardGpuResources res;
+    knowherefaiss::gpu::StandardGpuResources res;
     res.noTempMemory();
 
-    faiss::gpu::GpuIndexIVFFlatConfig config;
+    knowherefaiss::gpu::GpuIndexIVFFlatConfig config;
     config.device = device;
-    config.memorySpace = faiss::gpu::MemorySpace::Unified;
+    config.memorySpace = knowherefaiss::gpu::MemorySpace::Unified;
 
-    faiss::gpu::GpuIndexIVFFlat gpuIndex(
-            &res, dim, numCentroids, faiss::METRIC_L2, config);
+    knowherefaiss::gpu::GpuIndexIVFFlat gpuIndex(
+            &res, dim, numCentroids, knowherefaiss::METRIC_L2, config);
     gpuIndex.copyFrom(&cpuIndex);
     gpuIndex.setNumProbes(nprobe);
 
-    faiss::gpu::compareIndices(
+    knowherefaiss::gpu::compareIndices(
             cpuIndex,
             gpuIndex,
             numQuery,
@@ -549,7 +549,7 @@ int main(int argc, char** argv) {
     testing::InitGoogleTest(&argc, argv);
 
     // just run with a fixed test seed
-    faiss::gpu::setTestSeed(100);
+    knowherefaiss::gpu::setTestSeed(100);
 
     return RUN_ALL_TESTS();
 }
diff --git a/thirdparty/faiss/faiss/gpu/test/TestGpuIndexIVFPQ.cpp b/thirdparty/faiss/knowherefaiss/gpu/test/TestGpuIndexIVFPQ.cpp
similarity index 69%
rename from thirdparty/faiss/faiss/gpu/test/TestGpuIndexIVFPQ.cpp
rename to thirdparty/faiss/knowherefaiss/gpu/test/TestGpuIndexIVFPQ.cpp
index 15282c5e..44d66bba 100644
--- a/thirdparty/faiss/faiss/gpu/test/TestGpuIndexIVFPQ.cpp
+++ b/thirdparty/faiss/knowherefaiss/gpu/test/TestGpuIndexIVFPQ.cpp
@@ -5,12 +5,12 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/IndexFlat.h>
-#include <faiss/IndexIVFPQ.h>
-#include <faiss/gpu/GpuIndexIVFPQ.h>
-#include <faiss/gpu/StandardGpuResources.h>
-#include <faiss/gpu/test/TestUtils.h>
-#include <faiss/gpu/utils/DeviceUtils.h>
+#include <knowherefaiss/IndexFlat.h>
+#include <knowherefaiss/IndexIVFPQ.h>
+#include <knowherefaiss/gpu/GpuIndexIVFPQ.h>
+#include <knowherefaiss/gpu/StandardGpuResources.h>
+#include <knowherefaiss/gpu/test/TestUtils.h>
+#include <knowherefaiss/gpu/utils/DeviceUtils.h>
 #include <gtest/gtest.h>
 #include <cmath>
 #include <sstream>
@@ -24,8 +24,8 @@ void pickEncoding(int& codes, int& dim) {
     std::vector<int> dimSizes{4, 8, 10, 12, 16, 20, 24, 28, 32};
 
     while (true) {
-        codes = codeSizes[faiss::gpu::randVal(0, codeSizes.size() - 1)];
-        dim = codes * dimSizes[faiss::gpu::randVal(0, dimSizes.size() - 1)];
+        codes = codeSizes[knowherefaiss::gpu::randVal(0, codeSizes.size() - 1)];
+        dim = codes * dimSizes[knowherefaiss::gpu::randVal(0, dimSizes.size() - 1)];
 
         // for such a small test, super-low or high dim is more likely to
         // generate comparison errors
@@ -37,35 +37,35 @@ void pickEncoding(int& codes, int& dim) {
 
 struct Options {
     Options() {
-        numAdd = faiss::gpu::randVal(2000, 5000);
+        numAdd = knowherefaiss::gpu::randVal(2000, 5000);
         numCentroids = std::sqrt((float)numAdd);
         numTrain = numCentroids * 40;
 
         pickEncoding(codes, dim);
 
-        // TODO: Change back to `faiss::gpu::randVal(3, 7)` when we officially
+        // TODO: Change back to `knowherefaiss::gpu::randVal(3, 7)` when we officially
         //   support non-multiple of 8 subcodes for IVFPQ.
         bitsPerCode = 8;
-        nprobe = std::min(faiss::gpu::randVal(40, 1000), numCentroids);
-        numQuery = faiss::gpu::randVal(4, 8);
+        nprobe = std::min(knowherefaiss::gpu::randVal(40, 1000), numCentroids);
+        numQuery = knowherefaiss::gpu::randVal(4, 8);
 
         // Due to the approximate nature of the query and of floating point
         // differences between GPU and CPU, to stay within our error bounds,
         // only use a small k
-        k = std::min(faiss::gpu::randVal(5, 20), numAdd / 40);
-        usePrecomputed = faiss::gpu::randBool();
-        indicesOpt = faiss::gpu::randSelect(
-                {faiss::gpu::INDICES_CPU,
-                 faiss::gpu::INDICES_32_BIT,
-                 faiss::gpu::INDICES_64_BIT});
+        k = std::min(knowherefaiss::gpu::randVal(5, 20), numAdd / 40);
+        usePrecomputed = knowherefaiss::gpu::randBool();
+        indicesOpt = knowherefaiss::gpu::randSelect(
+                {knowherefaiss::gpu::INDICES_CPU,
+                 knowherefaiss::gpu::INDICES_32_BIT,
+                 knowherefaiss::gpu::INDICES_64_BIT});
         if (codes > 48) {
             // large codes can only fit using float16
             useFloat16 = true;
         } else {
-            useFloat16 = faiss::gpu::randBool();
+            useFloat16 = knowherefaiss::gpu::randBool();
         }
 
-        device = faiss::gpu::randVal(0, faiss::gpu::getNumDevices() - 1);
+        device = knowherefaiss::gpu::randVal(0, knowherefaiss::gpu::getNumDevices() - 1);
     }
 
     std::string toString() const {
@@ -102,7 +102,7 @@ struct Options {
     int numQuery;
     int k;
     bool usePrecomputed;
-    faiss::gpu::IndicesOptions indicesOpt;
+    knowherefaiss::gpu::IndicesOptions indicesOpt;
     bool useFloat16;
     int device;
 };
@@ -112,11 +112,11 @@ TEST(TestGpuIndexIVFPQ, Query_L2) {
         Options opt;
 
         std::vector<float> trainVecs =
-                faiss::gpu::randVecs(opt.numTrain, opt.dim);
-        std::vector<float> addVecs = faiss::gpu::randVecs(opt.numAdd, opt.dim);
+                knowherefaiss::gpu::randVecs(opt.numTrain, opt.dim);
+        std::vector<float> addVecs = knowherefaiss::gpu::randVecs(opt.numAdd, opt.dim);
 
-        faiss::IndexFlatL2 coarseQuantizer(opt.dim);
-        faiss::IndexIVFPQ cpuIndex(
+        knowherefaiss::IndexFlatL2 coarseQuantizer(opt.dim);
+        knowherefaiss::IndexIVFPQ cpuIndex(
                 &coarseQuantizer,
                 opt.dim,
                 opt.numCentroids,
@@ -128,18 +128,18 @@ TEST(TestGpuIndexIVFPQ, Query_L2) {
 
         // Use the default temporary memory management to test the memory
         // manager
-        faiss::gpu::StandardGpuResources res;
+        knowherefaiss::gpu::StandardGpuResources res;
 
-        faiss::gpu::GpuIndexIVFPQConfig config;
+        knowherefaiss::gpu::GpuIndexIVFPQConfig config;
         config.device = opt.device;
         config.usePrecomputedTables = (tries % 2 == 0);
         config.indicesOptions = opt.indicesOpt;
         config.useFloat16LookupTables = opt.useFloat16;
 
-        faiss::gpu::GpuIndexIVFPQ gpuIndex(&res, &cpuIndex, config);
+        knowherefaiss::gpu::GpuIndexIVFPQ gpuIndex(&res, &cpuIndex, config);
         gpuIndex.setNumProbes(opt.nprobe);
 
-        faiss::gpu::compareIndices(
+        knowherefaiss::gpu::compareIndices(
                 cpuIndex,
                 gpuIndex,
                 opt.numQuery,
@@ -152,7 +152,7 @@ TEST(TestGpuIndexIVFPQ, Query_L2) {
     }
 }
 
-void testMMCodeDistance(faiss::MetricType mt) {
+void testMMCodeDistance(knowherefaiss::MetricType mt) {
     // Explicitly test the code distance via batch matrix multiplication route
     // (even for dimension sizes that would otherwise be handled by the
     // specialized route (via enabling `useMMCodeDistance`)
@@ -160,11 +160,11 @@ void testMMCodeDistance(faiss::MetricType mt) {
         Options opt;
 
         std::vector<float> trainVecs =
-                faiss::gpu::randVecs(opt.numTrain, opt.dim);
-        std::vector<float> addVecs = faiss::gpu::randVecs(opt.numAdd, opt.dim);
+                knowherefaiss::gpu::randVecs(opt.numTrain, opt.dim);
+        std::vector<float> addVecs = knowherefaiss::gpu::randVecs(opt.numAdd, opt.dim);
 
-        faiss::IndexFlat coarseQuantizer(opt.dim, mt);
-        faiss::IndexIVFPQ cpuIndex(
+        knowherefaiss::IndexFlat coarseQuantizer(opt.dim, mt);
+        knowherefaiss::IndexIVFPQ cpuIndex(
                 &coarseQuantizer,
                 opt.dim,
                 opt.numCentroids,
@@ -176,9 +176,9 @@ void testMMCodeDistance(faiss::MetricType mt) {
 
         // Use the default temporary memory management to test the memory
         // manager
-        faiss::gpu::StandardGpuResources res;
+        knowherefaiss::gpu::StandardGpuResources res;
 
-        faiss::gpu::GpuIndexIVFPQConfig config;
+        knowherefaiss::gpu::GpuIndexIVFPQConfig config;
         config.device = opt.device;
         config.usePrecomputedTables = false;
         config.useMMCodeDistance = true;
@@ -188,10 +188,10 @@ void testMMCodeDistance(faiss::MetricType mt) {
         config.useFloat16LookupTables = (tries % 2 == 0);
         config.flatConfig.useFloat16 = (tries % 2 == 1);
 
-        faiss::gpu::GpuIndexIVFPQ gpuIndex(&res, &cpuIndex, config);
+        knowherefaiss::gpu::GpuIndexIVFPQ gpuIndex(&res, &cpuIndex, config);
         gpuIndex.setNumProbes(opt.nprobe);
 
-        faiss::gpu::compareIndices(
+        knowherefaiss::gpu::compareIndices(
                 cpuIndex,
                 gpuIndex,
                 opt.numQuery,
@@ -211,11 +211,11 @@ void testMMCodeDistance(faiss::MetricType mt) {
         opt.dim = dimPerSubQ * opt.codes;
 
         std::vector<float> trainVecs =
-                faiss::gpu::randVecs(opt.numTrain, opt.dim);
-        std::vector<float> addVecs = faiss::gpu::randVecs(opt.numAdd, opt.dim);
+                knowherefaiss::gpu::randVecs(opt.numTrain, opt.dim);
+        std::vector<float> addVecs = knowherefaiss::gpu::randVecs(opt.numAdd, opt.dim);
 
-        faiss::IndexFlat coarseQuantizer(opt.dim, mt);
-        faiss::IndexIVFPQ cpuIndex(
+        knowherefaiss::IndexFlat coarseQuantizer(opt.dim, mt);
+        knowherefaiss::IndexIVFPQ cpuIndex(
                 &coarseQuantizer,
                 opt.dim,
                 opt.numCentroids,
@@ -227,9 +227,9 @@ void testMMCodeDistance(faiss::MetricType mt) {
 
         // Use the default temporary memory management to test the memory
         // manager
-        faiss::gpu::StandardGpuResources res;
+        knowherefaiss::gpu::StandardGpuResources res;
 
-        faiss::gpu::GpuIndexIVFPQConfig config;
+        knowherefaiss::gpu::GpuIndexIVFPQConfig config;
         config.device = opt.device;
         config.usePrecomputedTables = false;
         config.indicesOptions = opt.indicesOpt;
@@ -237,10 +237,10 @@ void testMMCodeDistance(faiss::MetricType mt) {
         // Make sure that the float16 version works as well
         config.useFloat16LookupTables = (dimPerSubQ == 7);
 
-        faiss::gpu::GpuIndexIVFPQ gpuIndex(&res, &cpuIndex, config);
+        knowherefaiss::gpu::GpuIndexIVFPQ gpuIndex(&res, &cpuIndex, config);
         gpuIndex.setNumProbes(opt.nprobe);
 
-        faiss::gpu::compareIndices(
+        knowherefaiss::gpu::compareIndices(
                 cpuIndex,
                 gpuIndex,
                 opt.numQuery,
@@ -254,11 +254,11 @@ void testMMCodeDistance(faiss::MetricType mt) {
 }
 
 TEST(TestGpuIndexIVFPQ, Query_L2_MMCodeDistance) {
-    testMMCodeDistance(faiss::MetricType::METRIC_L2);
+    testMMCodeDistance(knowherefaiss::MetricType::METRIC_L2);
 }
 
 TEST(TestGpuIndexIVFPQ, Query_IP_MMCodeDistance) {
-    testMMCodeDistance(faiss::MetricType::METRIC_INNER_PRODUCT);
+    testMMCodeDistance(knowherefaiss::MetricType::METRIC_INNER_PRODUCT);
 }
 
 TEST(TestGpuIndexIVFPQ, Query_IP) {
@@ -266,17 +266,17 @@ TEST(TestGpuIndexIVFPQ, Query_IP) {
         Options opt;
 
         std::vector<float> trainVecs =
-                faiss::gpu::randVecs(opt.numTrain, opt.dim);
-        std::vector<float> addVecs = faiss::gpu::randVecs(opt.numAdd, opt.dim);
+                knowherefaiss::gpu::randVecs(opt.numTrain, opt.dim);
+        std::vector<float> addVecs = knowherefaiss::gpu::randVecs(opt.numAdd, opt.dim);
 
-        faiss::IndexFlatIP coarseQuantizer(opt.dim);
-        faiss::IndexIVFPQ cpuIndex(
+        knowherefaiss::IndexFlatIP coarseQuantizer(opt.dim);
+        knowherefaiss::IndexIVFPQ cpuIndex(
                 &coarseQuantizer,
                 opt.dim,
                 opt.numCentroids,
                 opt.codes,
                 opt.bitsPerCode);
-        cpuIndex.metric_type = faiss::MetricType::METRIC_INNER_PRODUCT;
+        cpuIndex.metric_type = knowherefaiss::MetricType::METRIC_INNER_PRODUCT;
 
         cpuIndex.nprobe = opt.nprobe;
         cpuIndex.train(opt.numTrain, trainVecs.data());
@@ -284,18 +284,18 @@ TEST(TestGpuIndexIVFPQ, Query_IP) {
 
         // Use the default temporary memory management to test the memory
         // manager
-        faiss::gpu::StandardGpuResources res;
+        knowherefaiss::gpu::StandardGpuResources res;
 
-        faiss::gpu::GpuIndexIVFPQConfig config;
+        knowherefaiss::gpu::GpuIndexIVFPQConfig config;
         config.device = opt.device;
         config.usePrecomputedTables = false; // not supported/required for IP
         config.indicesOptions = opt.indicesOpt;
         config.useFloat16LookupTables = opt.useFloat16;
 
-        faiss::gpu::GpuIndexIVFPQ gpuIndex(&res, &cpuIndex, config);
+        knowherefaiss::gpu::GpuIndexIVFPQ gpuIndex(&res, &cpuIndex, config);
         gpuIndex.setNumProbes(opt.nprobe);
 
-        faiss::gpu::compareIndices(
+        knowherefaiss::gpu::compareIndices(
                 cpuIndex,
                 gpuIndex,
                 opt.numQuery,
@@ -311,11 +311,11 @@ TEST(TestGpuIndexIVFPQ, Query_IP) {
 TEST(TestGpuIndexIVFPQ, Float16Coarse) {
     Options opt;
 
-    std::vector<float> trainVecs = faiss::gpu::randVecs(opt.numTrain, opt.dim);
-    std::vector<float> addVecs = faiss::gpu::randVecs(opt.numAdd, opt.dim);
+    std::vector<float> trainVecs = knowherefaiss::gpu::randVecs(opt.numTrain, opt.dim);
+    std::vector<float> addVecs = knowherefaiss::gpu::randVecs(opt.numAdd, opt.dim);
 
-    faiss::IndexFlatL2 coarseQuantizer(opt.dim);
-    faiss::IndexIVFPQ cpuIndex(
+    knowherefaiss::IndexFlatL2 coarseQuantizer(opt.dim);
+    knowherefaiss::IndexIVFPQ cpuIndex(
             &coarseQuantizer,
             opt.dim,
             opt.numCentroids,
@@ -325,22 +325,22 @@ TEST(TestGpuIndexIVFPQ, Float16Coarse) {
     cpuIndex.train(opt.numTrain, trainVecs.data());
 
     // Use the default temporary memory management to test the memory manager
-    faiss::gpu::StandardGpuResources res;
+    knowherefaiss::gpu::StandardGpuResources res;
 
-    faiss::gpu::GpuIndexIVFPQConfig config;
+    knowherefaiss::gpu::GpuIndexIVFPQConfig config;
     config.device = opt.device;
     config.flatConfig.useFloat16 = true;
     config.usePrecomputedTables = opt.usePrecomputed;
     config.indicesOptions = opt.indicesOpt;
     config.useFloat16LookupTables = opt.useFloat16;
 
-    faiss::gpu::GpuIndexIVFPQ gpuIndex(&res, &cpuIndex, config);
+    knowherefaiss::gpu::GpuIndexIVFPQ gpuIndex(&res, &cpuIndex, config);
     gpuIndex.setNumProbes(opt.nprobe);
 
     gpuIndex.add(opt.numAdd, addVecs.data());
     cpuIndex.add(opt.numAdd, addVecs.data());
 
-    faiss::gpu::compareIndices(
+    knowherefaiss::gpu::compareIndices(
             cpuIndex,
             gpuIndex,
             opt.numQuery,
@@ -357,11 +357,11 @@ TEST(TestGpuIndexIVFPQ, Add_L2) {
         Options opt;
 
         std::vector<float> trainVecs =
-                faiss::gpu::randVecs(opt.numTrain, opt.dim);
-        std::vector<float> addVecs = faiss::gpu::randVecs(opt.numAdd, opt.dim);
+                knowherefaiss::gpu::randVecs(opt.numTrain, opt.dim);
+        std::vector<float> addVecs = knowherefaiss::gpu::randVecs(opt.numAdd, opt.dim);
 
-        faiss::IndexFlatL2 coarseQuantizer(opt.dim);
-        faiss::IndexIVFPQ cpuIndex(
+        knowherefaiss::IndexFlatL2 coarseQuantizer(opt.dim);
+        knowherefaiss::IndexIVFPQ cpuIndex(
                 &coarseQuantizer,
                 opt.dim,
                 opt.numCentroids,
@@ -372,21 +372,21 @@ TEST(TestGpuIndexIVFPQ, Add_L2) {
 
         // Use the default temporary memory management to test the memory
         // manager
-        faiss::gpu::StandardGpuResources res;
+        knowherefaiss::gpu::StandardGpuResources res;
 
-        faiss::gpu::GpuIndexIVFPQConfig config;
+        knowherefaiss::gpu::GpuIndexIVFPQConfig config;
         config.device = opt.device;
         config.usePrecomputedTables = opt.usePrecomputed;
         config.indicesOptions = opt.indicesOpt;
         config.useFloat16LookupTables = opt.useFloat16;
 
-        faiss::gpu::GpuIndexIVFPQ gpuIndex(&res, &cpuIndex, config);
+        knowherefaiss::gpu::GpuIndexIVFPQ gpuIndex(&res, &cpuIndex, config);
         gpuIndex.setNumProbes(opt.nprobe);
 
         gpuIndex.add(opt.numAdd, addVecs.data());
         cpuIndex.add(opt.numAdd, addVecs.data());
 
-        faiss::gpu::compareIndices(
+        knowherefaiss::gpu::compareIndices(
                 cpuIndex,
                 gpuIndex,
                 opt.numQuery,
@@ -404,37 +404,37 @@ TEST(TestGpuIndexIVFPQ, Add_IP) {
         Options opt;
 
         std::vector<float> trainVecs =
-                faiss::gpu::randVecs(opt.numTrain, opt.dim);
-        std::vector<float> addVecs = faiss::gpu::randVecs(opt.numAdd, opt.dim);
+                knowherefaiss::gpu::randVecs(opt.numTrain, opt.dim);
+        std::vector<float> addVecs = knowherefaiss::gpu::randVecs(opt.numAdd, opt.dim);
 
-        faiss::IndexFlatIP coarseQuantizer(opt.dim);
-        faiss::IndexIVFPQ cpuIndex(
+        knowherefaiss::IndexFlatIP coarseQuantizer(opt.dim);
+        knowherefaiss::IndexIVFPQ cpuIndex(
                 &coarseQuantizer,
                 opt.dim,
                 opt.numCentroids,
                 opt.codes,
                 opt.bitsPerCode);
-        cpuIndex.metric_type = faiss::MetricType::METRIC_INNER_PRODUCT;
+        cpuIndex.metric_type = knowherefaiss::MetricType::METRIC_INNER_PRODUCT;
         cpuIndex.nprobe = opt.nprobe;
         cpuIndex.train(opt.numTrain, trainVecs.data());
 
         // Use the default temporary memory management to test the memory
         // manager
-        faiss::gpu::StandardGpuResources res;
+        knowherefaiss::gpu::StandardGpuResources res;
 
-        faiss::gpu::GpuIndexIVFPQConfig config;
+        knowherefaiss::gpu::GpuIndexIVFPQConfig config;
         config.device = opt.device;
         config.usePrecomputedTables = opt.usePrecomputed;
         config.indicesOptions = opt.indicesOpt;
         config.useFloat16LookupTables = opt.useFloat16;
 
-        faiss::gpu::GpuIndexIVFPQ gpuIndex(&res, &cpuIndex, config);
+        knowherefaiss::gpu::GpuIndexIVFPQ gpuIndex(&res, &cpuIndex, config);
         gpuIndex.setNumProbes(opt.nprobe);
 
         gpuIndex.add(opt.numAdd, addVecs.data());
         cpuIndex.add(opt.numAdd, addVecs.data());
 
-        faiss::gpu::compareIndices(
+        knowherefaiss::gpu::compareIndices(
                 cpuIndex,
                 gpuIndex,
                 opt.numQuery,
@@ -451,34 +451,34 @@ TEST(TestGpuIndexIVFPQ, CopyTo) {
     for (int tries = 0; tries < 2; ++tries) {
         Options opt;
         std::vector<float> trainVecs =
-                faiss::gpu::randVecs(opt.numTrain, opt.dim);
-        std::vector<float> addVecs = faiss::gpu::randVecs(opt.numAdd, opt.dim);
+                knowherefaiss::gpu::randVecs(opt.numTrain, opt.dim);
+        std::vector<float> addVecs = knowherefaiss::gpu::randVecs(opt.numAdd, opt.dim);
 
         // Use the default temporary memory management to test the memory
         // manager
-        faiss::gpu::StandardGpuResources res;
+        knowherefaiss::gpu::StandardGpuResources res;
 
-        faiss::gpu::GpuIndexIVFPQConfig config;
+        knowherefaiss::gpu::GpuIndexIVFPQConfig config;
         config.device = opt.device;
         config.usePrecomputedTables = (tries % 2 == 0);
         config.indicesOptions = opt.indicesOpt;
         config.useFloat16LookupTables = opt.useFloat16;
 
-        faiss::gpu::GpuIndexIVFPQ gpuIndex(
+        knowherefaiss::gpu::GpuIndexIVFPQ gpuIndex(
                 &res,
                 opt.dim,
                 opt.numCentroids,
                 opt.codes,
                 opt.bitsPerCode,
-                faiss::METRIC_L2,
+                knowherefaiss::METRIC_L2,
                 config);
         gpuIndex.setNumProbes(opt.nprobe);
         gpuIndex.train(opt.numTrain, trainVecs.data());
         gpuIndex.add(opt.numAdd, addVecs.data());
 
         // Use garbage values to see if we overwrite them
-        faiss::IndexFlatL2 cpuQuantizer(1);
-        faiss::IndexIVFPQ cpuIndex(&cpuQuantizer, 1, 1, 1, 1);
+        knowherefaiss::IndexFlatL2 cpuQuantizer(1);
+        knowherefaiss::IndexIVFPQ cpuIndex(&cpuQuantizer, 1, 1, 1, 1);
 
         gpuIndex.copyTo(&cpuIndex);
 
@@ -497,7 +497,7 @@ TEST(TestGpuIndexIVFPQ, CopyTo) {
         testIVFEquality(cpuIndex, gpuIndex);
 
         // Query both objects; results should be equivalent
-        faiss::gpu::compareIndices(
+        knowherefaiss::gpu::compareIndices(
                 cpuIndex,
                 gpuIndex,
                 opt.numQuery,
@@ -512,11 +512,11 @@ TEST(TestGpuIndexIVFPQ, CopyTo) {
 
 TEST(TestGpuIndexIVFPQ, CopyFrom) {
     Options opt;
-    std::vector<float> trainVecs = faiss::gpu::randVecs(opt.numTrain, opt.dim);
-    std::vector<float> addVecs = faiss::gpu::randVecs(opt.numAdd, opt.dim);
+    std::vector<float> trainVecs = knowherefaiss::gpu::randVecs(opt.numTrain, opt.dim);
+    std::vector<float> addVecs = knowherefaiss::gpu::randVecs(opt.numAdd, opt.dim);
 
-    faiss::IndexFlatL2 coarseQuantizer(opt.dim);
-    faiss::IndexIVFPQ cpuIndex(
+    knowherefaiss::IndexFlatL2 coarseQuantizer(opt.dim);
+    knowherefaiss::IndexIVFPQ cpuIndex(
             &coarseQuantizer,
             opt.dim,
             opt.numCentroids,
@@ -527,17 +527,17 @@ TEST(TestGpuIndexIVFPQ, CopyFrom) {
     cpuIndex.add(opt.numAdd, addVecs.data());
 
     // Use the default temporary memory management to test the memory manager
-    faiss::gpu::StandardGpuResources res;
+    knowherefaiss::gpu::StandardGpuResources res;
 
-    faiss::gpu::GpuIndexIVFPQConfig config;
+    knowherefaiss::gpu::GpuIndexIVFPQConfig config;
     config.device = opt.device;
     config.usePrecomputedTables = opt.usePrecomputed;
     config.indicesOptions = opt.indicesOpt;
     config.useFloat16LookupTables = opt.useFloat16;
 
     // Use garbage values to see if we overwrite them
-    faiss::gpu::GpuIndexIVFPQ gpuIndex(
-            &res, 1, 1, 1, 8, faiss::METRIC_L2, config);
+    knowherefaiss::gpu::GpuIndexIVFPQ gpuIndex(
+            &res, 1, 1, 1, 8, knowherefaiss::METRIC_L2, config);
     gpuIndex.setNumProbes(1);
 
     gpuIndex.copyFrom(&cpuIndex);
@@ -558,7 +558,7 @@ TEST(TestGpuIndexIVFPQ, CopyFrom) {
     testIVFEquality(cpuIndex, gpuIndex);
 
     // Query both objects; results should be equivalent
-    faiss::gpu::compareIndices(
+    knowherefaiss::gpu::compareIndices(
             cpuIndex,
             gpuIndex,
             opt.numQuery,
@@ -573,25 +573,25 @@ TEST(TestGpuIndexIVFPQ, CopyFrom) {
 TEST(TestGpuIndexIVFPQ, QueryNaN) {
     Options opt;
 
-    std::vector<float> trainVecs = faiss::gpu::randVecs(opt.numTrain, opt.dim);
-    std::vector<float> addVecs = faiss::gpu::randVecs(opt.numAdd, opt.dim);
+    std::vector<float> trainVecs = knowherefaiss::gpu::randVecs(opt.numTrain, opt.dim);
+    std::vector<float> addVecs = knowherefaiss::gpu::randVecs(opt.numAdd, opt.dim);
 
     // Use the default temporary memory management to test the memory manager
-    faiss::gpu::StandardGpuResources res;
+    knowherefaiss::gpu::StandardGpuResources res;
 
-    faiss::gpu::GpuIndexIVFPQConfig config;
+    knowherefaiss::gpu::GpuIndexIVFPQConfig config;
     config.device = opt.device;
     config.usePrecomputedTables = opt.usePrecomputed;
     config.indicesOptions = opt.indicesOpt;
     config.useFloat16LookupTables = opt.useFloat16;
 
-    faiss::gpu::GpuIndexIVFPQ gpuIndex(
+    knowherefaiss::gpu::GpuIndexIVFPQ gpuIndex(
             &res,
             opt.dim,
             opt.numCentroids,
             opt.codes,
             opt.bitsPerCode,
-            faiss::METRIC_L2,
+            knowherefaiss::METRIC_L2,
             config);
 
     gpuIndex.setNumProbes(opt.nprobe);
@@ -604,7 +604,7 @@ TEST(TestGpuIndexIVFPQ, QueryNaN) {
             numQuery * opt.dim, std::numeric_limits<float>::quiet_NaN());
 
     std::vector<float> distances(numQuery * opt.k, 0);
-    std::vector<faiss::Index::idx_t> indices(numQuery * opt.k, 0);
+    std::vector<knowherefaiss::Index::idx_t> indices(numQuery * opt.k, 0);
 
     gpuIndex.search(
             numQuery, nans.data(), opt.k, distances.data(), indices.data());
@@ -623,21 +623,21 @@ TEST(TestGpuIndexIVFPQ, AddNaN) {
     Options opt;
 
     // Use the default temporary memory management to test the memory manager
-    faiss::gpu::StandardGpuResources res;
+    knowherefaiss::gpu::StandardGpuResources res;
 
-    faiss::gpu::GpuIndexIVFPQConfig config;
+    knowherefaiss::gpu::GpuIndexIVFPQConfig config;
     config.device = opt.device;
     config.usePrecomputedTables = opt.usePrecomputed;
     config.indicesOptions = opt.indicesOpt;
     config.useFloat16LookupTables = opt.useFloat16;
 
-    faiss::gpu::GpuIndexIVFPQ gpuIndex(
+    knowherefaiss::gpu::GpuIndexIVFPQ gpuIndex(
             &res,
             opt.dim,
             opt.numCentroids,
             opt.codes,
             opt.bitsPerCode,
-            faiss::METRIC_L2,
+            knowherefaiss::METRIC_L2,
             config);
 
     gpuIndex.setNumProbes(opt.nprobe);
@@ -651,16 +651,16 @@ TEST(TestGpuIndexIVFPQ, AddNaN) {
         nans[i] = 0.0f;
     }
 
-    std::vector<float> trainVecs = faiss::gpu::randVecs(opt.numTrain, opt.dim);
+    std::vector<float> trainVecs = knowherefaiss::gpu::randVecs(opt.numTrain, opt.dim);
     gpuIndex.train(opt.numTrain, trainVecs.data());
 
     // should not crash
     EXPECT_EQ(gpuIndex.ntotal, 0);
     gpuIndex.add(numNans, nans.data());
 
-    std::vector<float> queryVecs = faiss::gpu::randVecs(opt.numQuery, opt.dim);
+    std::vector<float> queryVecs = knowherefaiss::gpu::randVecs(opt.numQuery, opt.dim);
     std::vector<float> distance(opt.numQuery * opt.k, 0);
-    std::vector<faiss::Index::idx_t> indices(opt.numQuery * opt.k, 0);
+    std::vector<knowherefaiss::Index::idx_t> indices(opt.numQuery * opt.k, 0);
 
     // should not crash
     gpuIndex.search(
@@ -674,9 +674,9 @@ TEST(TestGpuIndexIVFPQ, AddNaN) {
 TEST(TestGpuIndexIVFPQ, UnifiedMemory) {
     // Construct on a random device to test multi-device, if we have
     // multiple devices
-    int device = faiss::gpu::randVal(0, faiss::gpu::getNumDevices() - 1);
+    int device = knowherefaiss::gpu::randVal(0, knowherefaiss::gpu::getNumDevices() - 1);
 
-    if (!faiss::gpu::getFullUnifiedMemSupport(device)) {
+    if (!knowherefaiss::gpu::getFullUnifiedMemSupport(device)) {
         return;
     }
 
@@ -694,36 +694,36 @@ TEST(TestGpuIndexIVFPQ, UnifiedMemory) {
     int codes = 8;
     int bitsPerCode = 8;
 
-    std::vector<float> trainVecs = faiss::gpu::randVecs(numTrain, dim);
-    std::vector<float> addVecs = faiss::gpu::randVecs(numAdd, dim);
+    std::vector<float> trainVecs = knowherefaiss::gpu::randVecs(numTrain, dim);
+    std::vector<float> addVecs = knowherefaiss::gpu::randVecs(numAdd, dim);
 
-    faiss::IndexFlatL2 quantizer(dim);
-    faiss::IndexIVFPQ cpuIndex(
+    knowherefaiss::IndexFlatL2 quantizer(dim);
+    knowherefaiss::IndexIVFPQ cpuIndex(
             &quantizer, dim, numCentroids, codes, bitsPerCode);
 
     cpuIndex.train(numTrain, trainVecs.data());
     cpuIndex.add(numAdd, addVecs.data());
     cpuIndex.nprobe = nprobe;
 
-    faiss::gpu::StandardGpuResources res;
+    knowherefaiss::gpu::StandardGpuResources res;
     res.noTempMemory();
 
-    faiss::gpu::GpuIndexIVFPQConfig config;
+    knowherefaiss::gpu::GpuIndexIVFPQConfig config;
     config.device = device;
-    config.memorySpace = faiss::gpu::MemorySpace::Unified;
+    config.memorySpace = knowherefaiss::gpu::MemorySpace::Unified;
 
-    faiss::gpu::GpuIndexIVFPQ gpuIndex(
+    knowherefaiss::gpu::GpuIndexIVFPQ gpuIndex(
             &res,
             dim,
             numCentroids,
             codes,
             bitsPerCode,
-            faiss::METRIC_L2,
+            knowherefaiss::METRIC_L2,
             config);
     gpuIndex.copyFrom(&cpuIndex);
     gpuIndex.setNumProbes(nprobe);
 
-    faiss::gpu::compareIndices(
+    knowherefaiss::gpu::compareIndices(
             cpuIndex,
             gpuIndex,
             numQuery,
@@ -739,7 +739,7 @@ int main(int argc, char** argv) {
     testing::InitGoogleTest(&argc, argv);
 
     // just run with a fixed test seed
-    faiss::gpu::setTestSeed(100);
+    knowherefaiss::gpu::setTestSeed(100);
 
     return RUN_ALL_TESTS();
 }
diff --git a/thirdparty/faiss/faiss/gpu/test/TestGpuIndexIVFScalarQuantizer.cpp b/thirdparty/faiss/knowherefaiss/gpu/test/TestGpuIndexIVFScalarQuantizer.cpp
similarity index 71%
rename from thirdparty/faiss/faiss/gpu/test/TestGpuIndexIVFScalarQuantizer.cpp
rename to thirdparty/faiss/knowherefaiss/gpu/test/TestGpuIndexIVFScalarQuantizer.cpp
index 89a1f7f0..4e7466cd 100644
--- a/thirdparty/faiss/faiss/gpu/test/TestGpuIndexIVFScalarQuantizer.cpp
+++ b/thirdparty/faiss/knowherefaiss/gpu/test/TestGpuIndexIVFScalarQuantizer.cpp
@@ -5,12 +5,12 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/IndexFlat.h>
-#include <faiss/IndexScalarQuantizer.h>
-#include <faiss/gpu/GpuIndexIVFScalarQuantizer.h>
-#include <faiss/gpu/StandardGpuResources.h>
-#include <faiss/gpu/test/TestUtils.h>
-#include <faiss/gpu/utils/DeviceUtils.h>
+#include <knowherefaiss/IndexFlat.h>
+#include <knowherefaiss/IndexScalarQuantizer.h>
+#include <knowherefaiss/gpu/GpuIndexIVFScalarQuantizer.h>
+#include <knowherefaiss/gpu/StandardGpuResources.h>
+#include <knowherefaiss/gpu/test/TestUtils.h>
+#include <knowherefaiss/gpu/utils/DeviceUtils.h>
 #include <gtest/gtest.h>
 #include <cmath>
 #include <sstream>
@@ -20,24 +20,24 @@ constexpr float kF32MaxRelErr = 0.03f;
 
 struct Options {
     Options() {
-        numAdd = 2 * faiss::gpu::randVal(2000, 5000);
-        dim = faiss::gpu::randVal(64, 200);
+        numAdd = 2 * knowherefaiss::gpu::randVal(2000, 5000);
+        dim = knowherefaiss::gpu::randVal(64, 200);
 
         numCentroids = std::sqrt((float)numAdd / 2);
         numTrain = numCentroids * 40;
-        nprobe = faiss::gpu::randVal(std::min(10, numCentroids), numCentroids);
-        numQuery = faiss::gpu::randVal(32, 100);
+        nprobe = knowherefaiss::gpu::randVal(std::min(10, numCentroids), numCentroids);
+        numQuery = knowherefaiss::gpu::randVal(32, 100);
 
         // Due to the approximate nature of the query and of floating point
         // differences between GPU and CPU, to stay within our error bounds,
         // only use a small k
-        k = std::min(faiss::gpu::randVal(10, 30), numAdd / 40);
-        indicesOpt = faiss::gpu::randSelect(
-                {faiss::gpu::INDICES_CPU,
-                 faiss::gpu::INDICES_32_BIT,
-                 faiss::gpu::INDICES_64_BIT});
+        k = std::min(knowherefaiss::gpu::randVal(10, 30), numAdd / 40);
+        indicesOpt = knowherefaiss::gpu::randSelect(
+                {knowherefaiss::gpu::INDICES_CPU,
+                 knowherefaiss::gpu::INDICES_32_BIT,
+                 knowherefaiss::gpu::INDICES_64_BIT});
 
-        device = faiss::gpu::randVal(0, faiss::gpu::getNumDevices() - 1);
+        device = knowherefaiss::gpu::randVal(0, knowherefaiss::gpu::getNumDevices() - 1);
     }
 
     std::string toString() const {
@@ -58,12 +58,12 @@ struct Options {
     int numQuery;
     int k;
     int device;
-    faiss::gpu::IndicesOptions indicesOpt;
+    knowherefaiss::gpu::IndicesOptions indicesOpt;
 };
 
-void runCopyToTest(faiss::QuantizerType qtype) {
-    using namespace faiss;
-    using namespace faiss::gpu;
+void runCopyToTest(knowherefaiss::QuantizerType qtype) {
+    using namespace knowherefaiss;
+    using namespace knowherefaiss::gpu;
 
     Options opt;
     std::vector<float> trainVecs = randVecs(opt.numTrain, opt.dim);
@@ -118,32 +118,32 @@ void runCopyToTest(faiss::QuantizerType qtype) {
 }
 
 TEST(TestGpuIndexIVFScalarQuantizer, CopyTo_fp16) {
-    runCopyToTest(faiss::QuantizerType::QT_fp16);
+    runCopyToTest(knowherefaiss::QuantizerType::QT_fp16);
 }
 
 TEST(TestGpuIndexIVFScalarQuantizer, CopyTo_8bit) {
-    runCopyToTest(faiss::QuantizerType::QT_8bit);
+    runCopyToTest(knowherefaiss::QuantizerType::QT_8bit);
 }
 
 TEST(TestGpuIndexIVFScalarQuantizer, CopyTo_8bit_uniform) {
-    runCopyToTest(faiss::QuantizerType::QT_8bit_uniform);
+    runCopyToTest(knowherefaiss::QuantizerType::QT_8bit_uniform);
 }
 
 TEST(TestGpuIndexIVFScalarQuantizer, CopyTo_6bit) {
-    runCopyToTest(faiss::QuantizerType::QT_6bit);
+    runCopyToTest(knowherefaiss::QuantizerType::QT_6bit);
 }
 
 TEST(TestGpuIndexIVFScalarQuantizer, CopyTo_4bit) {
-    runCopyToTest(faiss::QuantizerType::QT_4bit);
+    runCopyToTest(knowherefaiss::QuantizerType::QT_4bit);
 }
 
 TEST(TestGpuIndexIVFScalarQuantizer, CopyTo_4bit_uniform) {
-    runCopyToTest(faiss::QuantizerType::QT_4bit_uniform);
+    runCopyToTest(knowherefaiss::QuantizerType::QT_4bit_uniform);
 }
 
-void runCopyFromTest(faiss::QuantizerType qtype) {
-    using namespace faiss;
-    using namespace faiss::gpu;
+void runCopyFromTest(knowherefaiss::QuantizerType qtype) {
+    using namespace knowherefaiss;
+    using namespace knowherefaiss::gpu;
 
     Options opt;
     std::vector<float> trainVecs = randVecs(opt.numTrain, opt.dim);
@@ -200,34 +200,34 @@ void runCopyFromTest(faiss::QuantizerType qtype) {
 }
 
 TEST(TestGpuIndexIVFScalarQuantizer, CopyFrom_fp16) {
-    runCopyFromTest(faiss::QuantizerType::QT_fp16);
+    runCopyFromTest(knowherefaiss::QuantizerType::QT_fp16);
 }
 
 TEST(TestGpuIndexIVFScalarQuantizer, CopyFrom_8bit) {
-    runCopyFromTest(faiss::QuantizerType::QT_8bit);
+    runCopyFromTest(knowherefaiss::QuantizerType::QT_8bit);
 }
 
 TEST(TestGpuIndexIVFScalarQuantizer, CopyFrom_8bit_uniform) {
-    runCopyFromTest(faiss::QuantizerType::QT_8bit_uniform);
+    runCopyFromTest(knowherefaiss::QuantizerType::QT_8bit_uniform);
 }
 
 TEST(TestGpuIndexIVFScalarQuantizer, CopyFrom_6bit) {
-    runCopyFromTest(faiss::QuantizerType::QT_6bit);
+    runCopyFromTest(knowherefaiss::QuantizerType::QT_6bit);
 }
 
 TEST(TestGpuIndexIVFScalarQuantizer, CopyFrom_4bit) {
-    runCopyFromTest(faiss::QuantizerType::QT_4bit);
+    runCopyFromTest(knowherefaiss::QuantizerType::QT_4bit);
 }
 
 TEST(TestGpuIndexIVFScalarQuantizer, CopyFrom_4bit_uniform) {
-    runCopyFromTest(faiss::QuantizerType::QT_4bit_uniform);
+    runCopyFromTest(knowherefaiss::QuantizerType::QT_4bit_uniform);
 }
 
 int main(int argc, char** argv) {
     testing::InitGoogleTest(&argc, argv);
 
     // just run with a fixed test seed
-    faiss::gpu::setTestSeed(100);
+    knowherefaiss::gpu::setTestSeed(100);
 
     return RUN_ALL_TESTS();
 }
diff --git a/thirdparty/faiss/faiss/gpu/test/TestGpuMemoryException.cpp b/thirdparty/faiss/knowherefaiss/gpu/test/TestGpuMemoryException.cpp
similarity index 70%
rename from thirdparty/faiss/faiss/gpu/test/TestGpuMemoryException.cpp
rename to thirdparty/faiss/knowherefaiss/gpu/test/TestGpuMemoryException.cpp
index c6f6e9bd..4686fcf8 100644
--- a/thirdparty/faiss/faiss/gpu/test/TestGpuMemoryException.cpp
+++ b/thirdparty/faiss/knowherefaiss/gpu/test/TestGpuMemoryException.cpp
@@ -5,11 +5,11 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/IndexFlat.h>
-#include <faiss/gpu/GpuIndexFlat.h>
-#include <faiss/gpu/StandardGpuResources.h>
-#include <faiss/gpu/test/TestUtils.h>
-#include <faiss/gpu/utils/DeviceUtils.h>
+#include <knowherefaiss/IndexFlat.h>
+#include <knowherefaiss/gpu/GpuIndexFlat.h>
+#include <knowherefaiss/gpu/StandardGpuResources.h>
+#include <knowherefaiss/gpu/test/TestUtils.h>
+#include <knowherefaiss/gpu/utils/DeviceUtils.h>
 #include <gtest/gtest.h>
 
 // Test to see if we can recover after attempting to allocate too much GPU
@@ -27,15 +27,15 @@ TEST(TestGpuMemoryException, AddException) {
     size_t brokenAddDims = ((devTotal / sizeof(float)) / numBrokenAdd) + 1;
     size_t realAddDims = 128;
 
-    faiss::gpu::StandardGpuResources res;
+    knowherefaiss::gpu::StandardGpuResources res;
 
-    faiss::gpu::GpuIndexFlatConfig config;
-    config.device = faiss::gpu::randVal(0, faiss::gpu::getNumDevices() - 1);
+    knowherefaiss::gpu::GpuIndexFlatConfig config;
+    config.device = knowherefaiss::gpu::randVal(0, knowherefaiss::gpu::getNumDevices() - 1);
 
-    faiss::gpu::GpuIndexFlatL2 gpuIndexL2Broken(
+    knowherefaiss::gpu::GpuIndexFlatL2 gpuIndexL2Broken(
             &res, (int)brokenAddDims, config);
-    faiss::gpu::GpuIndexFlatL2 gpuIndexL2(&res, (int)realAddDims, config);
-    faiss::IndexFlatL2 cpuIndex((int)realAddDims);
+    knowherefaiss::gpu::GpuIndexFlatL2 gpuIndexL2(&res, (int)realAddDims, config);
+    knowherefaiss::IndexFlatL2 cpuIndex((int)realAddDims);
 
     // Should throw on attempting to allocate too much data
     {
@@ -44,12 +44,12 @@ TEST(TestGpuMemoryException, AddException) {
                 new float[numBrokenAdd * brokenAddDims]);
         EXPECT_THROW(
                 gpuIndexL2Broken.add(numBrokenAdd, vecs.get()),
-                faiss::FaissException);
+                knowherefaiss::FaissException);
     }
 
     // Should be able to add a smaller set of data now
     {
-        auto vecs = faiss::gpu::randVecs(numRealAdd, realAddDims);
+        auto vecs = knowherefaiss::gpu::randVecs(numRealAdd, realAddDims);
         EXPECT_NO_THROW(gpuIndexL2.add(numRealAdd, vecs.data()));
         cpuIndex.add(numRealAdd, vecs.data());
     }
@@ -61,13 +61,13 @@ TEST(TestGpuMemoryException, AddException) {
                 new float[numBrokenAdd * brokenAddDims]);
         EXPECT_THROW(
                 gpuIndexL2Broken.add(numBrokenAdd, vecs.get()),
-                faiss::FaissException);
+                knowherefaiss::FaissException);
     }
 
     // Should be able to query results from what we had before
     {
         size_t numQuery = 10;
-        auto vecs = faiss::gpu::randVecs(numQuery, realAddDims);
+        auto vecs = knowherefaiss::gpu::randVecs(numQuery, realAddDims);
         EXPECT_NO_THROW(compareIndices(
                 vecs,
                 cpuIndex,
@@ -86,7 +86,7 @@ int main(int argc, char** argv) {
     testing::InitGoogleTest(&argc, argv);
 
     // just run with a fixed test seed
-    faiss::gpu::setTestSeed(100);
+    knowherefaiss::gpu::setTestSeed(100);
 
     return RUN_ALL_TESTS();
 }
diff --git a/thirdparty/faiss/faiss/gpu/test/TestGpuSelect.cu b/thirdparty/faiss/knowherefaiss/gpu/test/TestGpuSelect.cu
similarity index 74%
rename from thirdparty/faiss/faiss/gpu/test/TestGpuSelect.cu
rename to thirdparty/faiss/knowherefaiss/gpu/test/TestGpuSelect.cu
index c47ac451..367bae39 100644
--- a/thirdparty/faiss/faiss/gpu/test/TestGpuSelect.cu
+++ b/thirdparty/faiss/knowherefaiss/gpu/test/TestGpuSelect.cu
@@ -5,22 +5,22 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/gpu/StandardGpuResources.h>
-#include <faiss/gpu/test/TestUtils.h>
-#include <faiss/gpu/utils/DeviceUtils.h>
+#include <knowherefaiss/gpu/StandardGpuResources.h>
+#include <knowherefaiss/gpu/test/TestUtils.h>
+#include <knowherefaiss/gpu/utils/DeviceUtils.h>
 #include <gtest/gtest.h>
 #include <algorithm>
-#include <faiss/gpu/utils/BlockSelectKernel.cuh>
-#include <faiss/gpu/utils/DeviceDefs.cuh>
-#include <faiss/gpu/utils/DeviceTensor.cuh>
-#include <faiss/gpu/utils/HostTensor.cuh>
-#include <faiss/gpu/utils/WarpSelectKernel.cuh>
+#include <knowherefaiss/gpu/utils/BlockSelectKernel.cuh>
+#include <knowherefaiss/gpu/utils/DeviceDefs.cuh>
+#include <knowherefaiss/gpu/utils/DeviceTensor.cuh>
+#include <knowherefaiss/gpu/utils/HostTensor.cuh>
+#include <knowherefaiss/gpu/utils/WarpSelectKernel.cuh>
 #include <sstream>
 #include <unordered_map>
 #include <vector>
 
 void testForSize(int rows, int cols, int k, bool dir, bool warp) {
-    using namespace faiss::gpu;
+    using namespace knowherefaiss::gpu;
 
     StandardGpuResources res;
 
@@ -33,7 +33,7 @@ void testForSize(int rows, int cols, int k, bool dir, bool warp) {
         }
     }
 
-    faiss::gpu::DeviceTensor<uint8_t, 1, true> bitset(nullptr, {0});
+    knowherefaiss::gpu::DeviceTensor<uint8_t, 1, true> bitset(nullptr, {0});
     // row -> (val -> idx)
     std::unordered_map<int, std::vector<std::pair<int, float>>>
             hostOutValAndInd;
@@ -129,10 +129,10 @@ void testForSize(int rows, int cols, int k, bool dir, bool warp) {
 // General test
 TEST(TestGpuSelect, test) {
     for (int i = 0; i < 10; ++i) {
-        int rows = faiss::gpu::randVal(10, 100);
-        int cols = faiss::gpu::randVal(1, 30000);
-        int k = std::min(cols, faiss::gpu::randVal(1, GPU_MAX_SELECTION_K));
-        bool dir = faiss::gpu::randBool();
+        int rows = knowherefaiss::gpu::randVal(10, 100);
+        int cols = knowherefaiss::gpu::randVal(1, 30000);
+        int k = std::min(cols, knowherefaiss::gpu::randVal(1, GPU_MAX_SELECTION_K));
+        bool dir = knowherefaiss::gpu::randBool();
 
         testForSize(rows, cols, k, dir, false);
     }
@@ -141,9 +141,9 @@ TEST(TestGpuSelect, test) {
 // Test for k = 1
 TEST(TestGpuSelect, test1) {
     for (int i = 0; i < 5; ++i) {
-        int rows = faiss::gpu::randVal(10, 100);
-        int cols = faiss::gpu::randVal(1, 30000);
-        bool dir = faiss::gpu::randBool();
+        int rows = knowherefaiss::gpu::randVal(10, 100);
+        int cols = knowherefaiss::gpu::randVal(1, 30000);
+        bool dir = knowherefaiss::gpu::randBool();
 
         testForSize(rows, cols, 1, dir, false);
     }
@@ -153,9 +153,9 @@ TEST(TestGpuSelect, test1) {
 // just sorted)
 TEST(TestGpuSelect, testExact) {
     for (int i = 0; i < 5; ++i) {
-        int rows = faiss::gpu::randVal(10, 100);
-        int cols = faiss::gpu::randVal(1, GPU_MAX_SELECTION_K);
-        bool dir = faiss::gpu::randBool();
+        int rows = knowherefaiss::gpu::randVal(10, 100);
+        int cols = knowherefaiss::gpu::randVal(1, GPU_MAX_SELECTION_K);
+        bool dir = knowherefaiss::gpu::randBool();
 
         testForSize(rows, cols, cols, dir, false);
     }
@@ -164,10 +164,10 @@ TEST(TestGpuSelect, testExact) {
 // General test
 TEST(TestGpuSelect, testWarp) {
     for (int i = 0; i < 10; ++i) {
-        int rows = faiss::gpu::randVal(10, 100);
-        int cols = faiss::gpu::randVal(1, 30000);
-        int k = std::min(cols, faiss::gpu::randVal(1, GPU_MAX_SELECTION_K));
-        bool dir = faiss::gpu::randBool();
+        int rows = knowherefaiss::gpu::randVal(10, 100);
+        int cols = knowherefaiss::gpu::randVal(1, 30000);
+        int k = std::min(cols, knowherefaiss::gpu::randVal(1, GPU_MAX_SELECTION_K));
+        bool dir = knowherefaiss::gpu::randBool();
 
         testForSize(rows, cols, k, dir, true);
     }
@@ -176,9 +176,9 @@ TEST(TestGpuSelect, testWarp) {
 // Test for k = 1
 TEST(TestGpuSelect, test1Warp) {
     for (int i = 0; i < 5; ++i) {
-        int rows = faiss::gpu::randVal(10, 100);
-        int cols = faiss::gpu::randVal(1, 30000);
-        bool dir = faiss::gpu::randBool();
+        int rows = knowherefaiss::gpu::randVal(10, 100);
+        int cols = knowherefaiss::gpu::randVal(1, 30000);
+        bool dir = knowherefaiss::gpu::randBool();
 
         testForSize(rows, cols, 1, dir, true);
     }
@@ -188,9 +188,9 @@ TEST(TestGpuSelect, test1Warp) {
 // just sorted)
 TEST(TestGpuSelect, testExactWarp) {
     for (int i = 0; i < 5; ++i) {
-        int rows = faiss::gpu::randVal(10, 100);
-        int cols = faiss::gpu::randVal(1, GPU_MAX_SELECTION_K);
-        bool dir = faiss::gpu::randBool();
+        int rows = knowherefaiss::gpu::randVal(10, 100);
+        int cols = knowherefaiss::gpu::randVal(1, GPU_MAX_SELECTION_K);
+        bool dir = knowherefaiss::gpu::randBool();
 
         testForSize(rows, cols, cols, dir, true);
     }
@@ -200,7 +200,7 @@ int main(int argc, char** argv) {
     testing::InitGoogleTest(&argc, argv);
 
     // just run with a fixed test seed
-    faiss::gpu::setTestSeed(100);
+    knowherefaiss::gpu::setTestSeed(100);
 
     return RUN_ALL_TESTS();
 }
diff --git a/thirdparty/faiss/faiss/gpu/test/TestUtils.cpp b/thirdparty/faiss/knowherefaiss/gpu/test/TestUtils.cpp
similarity index 90%
rename from thirdparty/faiss/faiss/gpu/test/TestUtils.cpp
rename to thirdparty/faiss/knowherefaiss/gpu/test/TestUtils.cpp
index 29fbef03..c03ae565 100644
--- a/thirdparty/faiss/faiss/gpu/test/TestUtils.cpp
+++ b/thirdparty/faiss/knowherefaiss/gpu/test/TestUtils.cpp
@@ -5,8 +5,8 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/gpu/test/TestUtils.h>
-#include <faiss/utils/random.h>
+#include <knowherefaiss/gpu/test/TestUtils.h>
+#include <knowherefaiss/utils/random.h>
 #include <gtest/gtest.h>
 #include <time.h>
 #include <cmath>
@@ -14,7 +14,7 @@
 #include <sstream>
 #include <unordered_map>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 inline float relativeError(float a, float b) {
@@ -55,7 +55,7 @@ bool randBool() {
 std::vector<float> randVecs(size_t num, size_t dim) {
     std::vector<float> v(num * dim);
 
-    faiss::float_rand(v.data(), v.size(), s_seed);
+    knowherefaiss::float_rand(v.data(), v.size(), s_seed);
     // unfortunately we generate separate sets of vectors, and don't
     // want the same values
     ++s_seed;
@@ -66,7 +66,7 @@ std::vector<float> randVecs(size_t num, size_t dim) {
 std::vector<unsigned char> randBinaryVecs(size_t num, size_t dim) {
     std::vector<unsigned char> v(num * (dim / 8));
 
-    faiss::byte_rand(v.data(), v.size(), s_seed);
+    knowherefaiss::byte_rand(v.data(), v.size(), s_seed);
     // unfortunately we generate separate sets of vectors, and don't
     // want the same values
     ++s_seed;
@@ -76,8 +76,8 @@ std::vector<unsigned char> randBinaryVecs(size_t num, size_t dim) {
 
 void compareIndices(
         const std::vector<float>& queryVecs,
-        faiss::Index& refIndex,
-        faiss::Index& testIndex,
+        knowherefaiss::Index& refIndex,
+        knowherefaiss::Index& testIndex,
         int numQuery,
         int /*dim*/,
         int k,
@@ -87,7 +87,7 @@ void compareIndices(
         float pctMaxDiffN) {
     // Compare
     std::vector<float> refDistance(numQuery * k, 0);
-    std::vector<faiss::Index::idx_t> refIndices(numQuery * k, -1);
+    std::vector<knowherefaiss::Index::idx_t> refIndices(numQuery * k, -1);
     refIndex.search(
             numQuery,
             queryVecs.data(),
@@ -96,7 +96,7 @@ void compareIndices(
             refIndices.data());
 
     std::vector<float> testDistance(numQuery * k, 0);
-    std::vector<faiss::Index::idx_t> testIndices(numQuery * k, -1);
+    std::vector<knowherefaiss::Index::idx_t> testIndices(numQuery * k, -1);
     testIndex.search(
             numQuery,
             queryVecs.data(),
@@ -104,7 +104,7 @@ void compareIndices(
             testDistance.data(),
             testIndices.data());
 
-    faiss::gpu::compareLists(
+    knowherefaiss::gpu::compareLists(
             refDistance.data(),
             refIndices.data(),
             testDistance.data(),
@@ -121,8 +121,8 @@ void compareIndices(
 }
 
 void compareIndices(
-        faiss::Index& refIndex,
-        faiss::Index& testIndex,
+        knowherefaiss::Index& refIndex,
+        knowherefaiss::Index& testIndex,
         int numQuery,
         int dim,
         int k,
@@ -130,7 +130,7 @@ void compareIndices(
         float maxRelativeError,
         float pctMaxDiff1,
         float pctMaxDiffN) {
-    auto queryVecs = faiss::gpu::randVecs(numQuery, dim);
+    auto queryVecs = knowherefaiss::gpu::randVecs(numQuery, dim);
 
     compareIndices(
             queryVecs,
@@ -152,9 +152,9 @@ inline T lookup(const T* p, int i, int j, int /*dim1*/, int dim2) {
 
 void compareLists(
         const float* refDist,
-        const faiss::Index::idx_t* refInd,
+        const knowherefaiss::Index::idx_t* refInd,
         const float* testDist,
-        const faiss::Index::idx_t* testInd,
+        const knowherefaiss::Index::idx_t* testInd,
         int dim1,
         int dim2,
         const std::string& configMsg,
@@ -171,10 +171,10 @@ void compareLists(
     int numResults = dim1 * dim2;
 
     // query -> {index -> result position}
-    std::vector<std::unordered_map<faiss::Index::idx_t, int>> refIndexMap;
+    std::vector<std::unordered_map<knowherefaiss::Index::idx_t, int>> refIndexMap;
 
     for (int query = 0; query < dim1; ++query) {
-        std::unordered_map<faiss::Index::idx_t, int> indices;
+        std::unordered_map<knowherefaiss::Index::idx_t, int> indices;
 
         for (int result = 0; result < dim2; ++result) {
             indices[lookup(refInd, query, result, dim1, dim2)] = result;
@@ -198,7 +198,7 @@ void compareLists(
 
     for (int query = 0; query < dim1; ++query) {
         std::vector<int> diffs;
-        std::set<faiss::Index::idx_t> uniqueIndices;
+        std::set<knowherefaiss::Index::idx_t> uniqueIndices;
 
         auto& indices = refIndexMap[query];
 
@@ -350,4 +350,4 @@ void compareLists(
 }
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/test/TestUtils.h b/thirdparty/faiss/knowherefaiss/gpu/test/TestUtils.h
similarity index 83%
rename from thirdparty/faiss/faiss/gpu/test/TestUtils.h
rename to thirdparty/faiss/knowherefaiss/gpu/test/TestUtils.h
index 29574c38..223ec4a1 100644
--- a/thirdparty/faiss/faiss/gpu/test/TestUtils.h
+++ b/thirdparty/faiss/knowherefaiss/gpu/test/TestUtils.h
@@ -7,9 +7,9 @@
 
 #pragma once
 
-#include <faiss/Index.h>
-#include <faiss/impl/FaissAssert.h>
-#include <faiss/invlists/InvertedLists.h>
+#include <knowherefaiss/Index.h>
+#include <knowherefaiss/impl/FaissAssert.h>
+#include <knowherefaiss/invlists/InvertedLists.h>
 #include <gtest/gtest.h>
 #include <cstring>
 #include <initializer_list>
@@ -17,7 +17,7 @@
 #include <string>
 #include <vector>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 /// Generates and displays a new seed for the test
@@ -64,8 +64,8 @@ std::vector<unsigned char> randBinaryVecs(size_t num, size_t dim);
 /// query vectors
 void compareIndices(
         const std::vector<float>& queryVecs,
-        faiss::Index& refIndex,
-        faiss::Index& testIndex,
+        knowherefaiss::Index& refIndex,
+        knowherefaiss::Index& testIndex,
         int numQuery,
         int dim,
         int k,
@@ -77,8 +77,8 @@ void compareIndices(
 /// Compare two indices via query for similarity, generating random query
 /// vectors
 void compareIndices(
-        faiss::Index& refIndex,
-        faiss::Index& testIndex,
+        knowherefaiss::Index& refIndex,
+        knowherefaiss::Index& testIndex,
         int numQuery,
         int dim,
         int k,
@@ -90,9 +90,9 @@ void compareIndices(
 /// Display specific differences in the two (distance, index) lists
 void compareLists(
         const float* refDist,
-        const faiss::Index::idx_t* refInd,
+        const knowherefaiss::Index::idx_t* refInd,
         const float* testDist,
-        const faiss::Index::idx_t* testInd,
+        const knowherefaiss::Index::idx_t* testInd,
         int dim1,
         int dim2,
         const std::string& configMsg,
@@ -117,7 +117,7 @@ void testIVFEquality(A& cpuIndex, B& gpuIndex) {
         std::vector<uint8_t> cpuCodes(
                 cpuLists->list_size(i) * cpuLists->code_size);
 
-        auto sc = faiss::InvertedLists::ScopedCodes(cpuLists, i);
+        auto sc = knowherefaiss::InvertedLists::ScopedCodes(cpuLists, i);
         std::memcpy(
                 cpuCodes.data(),
                 sc.get(),
@@ -129,14 +129,14 @@ void testIVFEquality(A& cpuIndex, B& gpuIndex) {
         // Index equality
         std::vector<Index::idx_t> cpuIndices(cpuLists->list_size(i));
 
-        auto si = faiss::InvertedLists::ScopedIds(cpuLists, i);
+        auto si = knowherefaiss::InvertedLists::ScopedIds(cpuLists, i);
         std::memcpy(
                 cpuIndices.data(),
                 si.get(),
-                cpuLists->list_size(i) * sizeof(faiss::Index::idx_t));
+                cpuLists->list_size(i) * sizeof(knowherefaiss::Index::idx_t));
         EXPECT_EQ(cpuIndices, gpuIndex.getListIndices(i));
     }
 }
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/test/demo_ivfpq_indexing_gpu.cpp b/thirdparty/faiss/knowherefaiss/gpu/test/demo_ivfpq_indexing_gpu.cpp
similarity index 87%
rename from thirdparty/faiss/faiss/gpu/test/demo_ivfpq_indexing_gpu.cpp
rename to thirdparty/faiss/knowherefaiss/gpu/test/demo_ivfpq_indexing_gpu.cpp
index b32c3a40..d7c43a07 100644
--- a/thirdparty/faiss/faiss/gpu/test/demo_ivfpq_indexing_gpu.cpp
+++ b/thirdparty/faiss/knowherefaiss/gpu/test/demo_ivfpq_indexing_gpu.cpp
@@ -12,11 +12,11 @@
 
 #include <sys/time.h>
 
-#include <faiss/gpu/GpuIndexIVFPQ.h>
-#include <faiss/gpu/StandardGpuResources.h>
+#include <knowherefaiss/gpu/GpuIndexIVFPQ.h>
+#include <knowherefaiss/gpu/StandardGpuResources.h>
 
-#include <faiss/gpu/GpuAutoTune.h>
-#include <faiss/index_io.h>
+#include <knowherefaiss/gpu/GpuAutoTune.h>
+#include <knowherefaiss/index_io.h>
 
 double elapsed() {
     struct timeval tv;
@@ -45,16 +45,16 @@ int main() {
     // a reasonable number of centroids to index nb vectors
     int ncentroids = int(4 * sqrt(nb));
 
-    faiss::gpu::StandardGpuResources resources;
+    knowherefaiss::gpu::StandardGpuResources resources;
 
     // the coarse quantizer should not be dealloced before the index
     // 4 = nb of bytes per code (d must be a multiple of this)
     // 8 = nb of bits per sub-code (almost always 8)
-    faiss::gpu::GpuIndexIVFPQConfig config;
+    knowherefaiss::gpu::GpuIndexIVFPQConfig config;
     config.device = dev_no;
 
-    faiss::gpu::GpuIndexIVFPQ index(
-            &resources, d, ncentroids, 4, 8, faiss::METRIC_L2, config);
+    knowherefaiss::gpu::GpuIndexIVFPQ index(
+            &resources, d, ncentroids, 4, 8, knowherefaiss::METRIC_L2, config);
 
     std::mt19937 rng;
 
@@ -82,7 +82,7 @@ int main() {
                elapsed() - t0,
                outfilename);
 
-        faiss::Index* cpu_index = faiss::gpu::index_gpu_to_cpu(&index);
+        knowherefaiss::Index* cpu_index = knowherefaiss::gpu::index_gpu_to_cpu(&index);
 
         write_index(cpu_index, outfilename);
 
@@ -130,7 +130,7 @@ int main() {
                k,
                nq);
 
-        std::vector<faiss::Index::idx_t> nns(k * nq);
+        std::vector<knowherefaiss::Index::idx_t> nns(k * nq);
         std::vector<float> dis(k * nq);
 
         index.search(nq, queries.data(), k, dis.data(), nns.data());
diff --git a/thirdparty/faiss/faiss/gpu/test/test_contrib.py b/thirdparty/faiss/knowherefaiss/gpu/test/test_contrib.py
similarity index 100%
rename from thirdparty/faiss/faiss/gpu/test/test_contrib.py
rename to thirdparty/faiss/knowherefaiss/gpu/test/test_contrib.py
diff --git a/thirdparty/faiss/faiss/gpu/test/test_gpu_basics.py b/thirdparty/faiss/knowherefaiss/gpu/test/test_gpu_basics.py
old mode 100755
new mode 100644
similarity index 100%
rename from thirdparty/faiss/faiss/gpu/test/test_gpu_basics.py
rename to thirdparty/faiss/knowherefaiss/gpu/test/test_gpu_basics.py
diff --git a/thirdparty/faiss/faiss/gpu/test/test_gpu_index.py b/thirdparty/faiss/knowherefaiss/gpu/test/test_gpu_index.py
old mode 100755
new mode 100644
similarity index 100%
rename from thirdparty/faiss/faiss/gpu/test/test_gpu_index.py
rename to thirdparty/faiss/knowherefaiss/gpu/test/test_gpu_index.py
diff --git a/thirdparty/faiss/faiss/gpu/test/test_gpu_index_ivfsq.py b/thirdparty/faiss/knowherefaiss/gpu/test/test_gpu_index_ivfsq.py
old mode 100755
new mode 100644
similarity index 100%
rename from thirdparty/faiss/faiss/gpu/test/test_gpu_index_ivfsq.py
rename to thirdparty/faiss/knowherefaiss/gpu/test/test_gpu_index_ivfsq.py
diff --git a/thirdparty/faiss/faiss/gpu/test/torch_test_contrib_gpu.py b/thirdparty/faiss/knowherefaiss/gpu/test/torch_test_contrib_gpu.py
similarity index 100%
rename from thirdparty/faiss/faiss/gpu/test/torch_test_contrib_gpu.py
rename to thirdparty/faiss/knowherefaiss/gpu/test/torch_test_contrib_gpu.py
diff --git a/thirdparty/faiss/faiss/gpu/utils/BlockSelectFloat.cu b/thirdparty/faiss/knowherefaiss/gpu/utils/BlockSelectFloat.cu
similarity index 96%
rename from thirdparty/faiss/faiss/gpu/utils/BlockSelectFloat.cu
rename to thirdparty/faiss/knowherefaiss/gpu/utils/BlockSelectFloat.cu
index 6d821723..70118fcb 100644
--- a/thirdparty/faiss/faiss/gpu/utils/BlockSelectFloat.cu
+++ b/thirdparty/faiss/knowherefaiss/gpu/utils/BlockSelectFloat.cu
@@ -5,10 +5,10 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/gpu/utils/DeviceDefs.cuh>
-#include <faiss/gpu/utils/blockselect/BlockSelectImpl.cuh>
+#include <knowherefaiss/gpu/utils/DeviceDefs.cuh>
+#include <knowherefaiss/gpu/utils/blockselect/BlockSelectImpl.cuh>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 // warp Q to thread Q:
@@ -151,4 +151,4 @@ void runBlockSelectPair(
 }
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/utils/BlockSelectImpl.cuh b/thirdparty/faiss/knowherefaiss/gpu/utils/BlockSelectImpl.cuh
similarity index 98%
rename from thirdparty/faiss/faiss/gpu/utils/BlockSelectImpl.cuh
rename to thirdparty/faiss/knowherefaiss/gpu/utils/BlockSelectImpl.cuh
index 10001059..4018cc31 100644
--- a/thirdparty/faiss/faiss/gpu/utils/BlockSelectImpl.cuh
+++ b/thirdparty/faiss/knowherefaiss/gpu/utils/BlockSelectImpl.cuh
@@ -7,8 +7,8 @@
 
 #pragma once
 
-#include <faiss/gpu/utils/BlockSelectKernel.cuh>
-#include <faiss/gpu/utils/Limits.cuh>
+#include <knowherefaiss/gpu/utils/BlockSelectKernel.cuh>
+#include <knowherefaiss/gpu/utils/Limits.cuh>
 
 #define BLOCK_SELECT_DECL(TYPE, DIR, WARP_Q)                                \
     extern void runBlockSelect_##TYPE##_##DIR##_##WARP_Q##_(                \
diff --git a/thirdparty/faiss/faiss/gpu/utils/BlockSelectKernel.cuh b/thirdparty/faiss/knowherefaiss/gpu/utils/BlockSelectKernel.cuh
similarity index 98%
rename from thirdparty/faiss/faiss/gpu/utils/BlockSelectKernel.cuh
rename to thirdparty/faiss/knowherefaiss/gpu/utils/BlockSelectKernel.cuh
index d0e84f24..44b1a6f9 100644
--- a/thirdparty/faiss/faiss/gpu/utils/BlockSelectKernel.cuh
+++ b/thirdparty/faiss/knowherefaiss/gpu/utils/BlockSelectKernel.cuh
@@ -7,9 +7,9 @@
 
 #pragma once
 
-#include <faiss/gpu/utils/Select.cuh>
+#include <knowherefaiss/gpu/utils/Select.cuh>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 template <
@@ -300,4 +300,4 @@ void runBlockSelectPair(
         cudaStream_t stream);
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/utils/Comparators.cuh b/thirdparty/faiss/knowherefaiss/gpu/utils/Comparators.cuh
similarity index 89%
rename from thirdparty/faiss/faiss/gpu/utils/Comparators.cuh
rename to thirdparty/faiss/knowherefaiss/gpu/utils/Comparators.cuh
index cbbda0ce..4d576cb6 100644
--- a/thirdparty/faiss/faiss/gpu/utils/Comparators.cuh
+++ b/thirdparty/faiss/knowherefaiss/gpu/utils/Comparators.cuh
@@ -8,9 +8,9 @@
 #pragma once
 
 #include <cuda.h>
-#include <faiss/gpu/utils/Float16.cuh>
+#include <knowherefaiss/gpu/utils/Float16.cuh>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 template <typename T>
@@ -44,4 +44,4 @@ struct Comparator<half> {
 };
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/utils/ConversionOperators.cuh b/thirdparty/faiss/knowherefaiss/gpu/utils/ConversionOperators.cuh
similarity index 94%
rename from thirdparty/faiss/faiss/gpu/utils/ConversionOperators.cuh
rename to thirdparty/faiss/knowherefaiss/gpu/utils/ConversionOperators.cuh
index e843c023..815c1b93 100644
--- a/thirdparty/faiss/faiss/gpu/utils/ConversionOperators.cuh
+++ b/thirdparty/faiss/knowherefaiss/gpu/utils/ConversionOperators.cuh
@@ -7,15 +7,15 @@
 
 #pragma once
 
-#include <faiss/MetricType.h>
-#include <faiss/gpu/utils/DeviceTensor.cuh>
-#include <faiss/gpu/utils/Float16.cuh>
+#include <knowherefaiss/MetricType.h>
+#include <knowherefaiss/gpu/utils/DeviceTensor.cuh>
+#include <knowherefaiss/gpu/utils/Float16.cuh>
 
 #include <cuda.h>
 #include <thrust/execution_policy.h>
 #include <thrust/transform.h>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 //
@@ -154,4 +154,4 @@ DeviceTensor<To, Dim, true> convertTensorNonTemporary(
 }
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/utils/CopyUtils.cuh b/thirdparty/faiss/knowherefaiss/gpu/utils/CopyUtils.cuh
similarity index 95%
rename from thirdparty/faiss/faiss/gpu/utils/CopyUtils.cuh
rename to thirdparty/faiss/knowherefaiss/gpu/utils/CopyUtils.cuh
index a99e87ab..84702c52 100644
--- a/thirdparty/faiss/faiss/gpu/utils/CopyUtils.cuh
+++ b/thirdparty/faiss/knowherefaiss/gpu/utils/CopyUtils.cuh
@@ -7,10 +7,10 @@
 
 #pragma once
 
-#include <faiss/gpu/utils/DeviceTensor.cuh>
-#include <faiss/gpu/utils/HostTensor.cuh>
+#include <knowherefaiss/gpu/utils/DeviceTensor.cuh>
+#include <knowherefaiss/gpu/utils/HostTensor.cuh>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 /// Ensure the memory at `p` is either on the given device, or copy it
@@ -135,4 +135,4 @@ void fromDevice(Tensor<T, Dim, true>& src, T* dst, cudaStream_t stream) {
 }
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/utils/DeviceDefs.cuh b/thirdparty/faiss/knowherefaiss/gpu/utils/DeviceDefs.cuh
similarity index 95%
rename from thirdparty/faiss/faiss/gpu/utils/DeviceDefs.cuh
rename to thirdparty/faiss/knowherefaiss/gpu/utils/DeviceDefs.cuh
index bdba8d72..3d036793 100644
--- a/thirdparty/faiss/faiss/gpu/utils/DeviceDefs.cuh
+++ b/thirdparty/faiss/knowherefaiss/gpu/utils/DeviceDefs.cuh
@@ -9,7 +9,7 @@
 
 #include <cuda.h>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 // We require at least CUDA 8.0 for compilation
@@ -40,4 +40,4 @@ __forceinline__ __device__ void warpFence() {
 #endif
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/utils/DeviceTensor-inl.cuh b/thirdparty/faiss/knowherefaiss/gpu/utils/DeviceTensor-inl.cuh
similarity index 99%
rename from thirdparty/faiss/faiss/gpu/utils/DeviceTensor-inl.cuh
rename to thirdparty/faiss/knowherefaiss/gpu/utils/DeviceTensor-inl.cuh
index b218e10b..b567c51d 100644
--- a/thirdparty/faiss/faiss/gpu/utils/DeviceTensor-inl.cuh
+++ b/thirdparty/faiss/knowherefaiss/gpu/utils/DeviceTensor-inl.cuh
@@ -7,7 +7,7 @@
 
 #include <utility> // std::move
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 template <
@@ -189,4 +189,4 @@ __host__ DeviceTensor<T, Dim, InnerContig, IndexT, PtrTraits>& DeviceTensor<
 }
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/utils/DeviceTensor.cuh b/thirdparty/faiss/knowherefaiss/gpu/utils/DeviceTensor.cuh
similarity index 93%
rename from thirdparty/faiss/faiss/gpu/utils/DeviceTensor.cuh
rename to thirdparty/faiss/knowherefaiss/gpu/utils/DeviceTensor.cuh
index eadb61e5..c3f7b02b 100644
--- a/thirdparty/faiss/faiss/gpu/utils/DeviceTensor.cuh
+++ b/thirdparty/faiss/knowherefaiss/gpu/utils/DeviceTensor.cuh
@@ -7,10 +7,10 @@
 
 #pragma once
 
-#include <faiss/gpu/GpuResources.h>
-#include <faiss/gpu/utils/Tensor.cuh>
+#include <knowherefaiss/gpu/GpuResources.h>
+#include <knowherefaiss/gpu/utils/Tensor.cuh>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 template <
@@ -90,6 +90,6 @@ class DeviceTensor : public Tensor<T, Dim, InnerContig, IndexT, PtrTraits> {
 };
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
 
-#include <faiss/gpu/utils/DeviceTensor-inl.cuh>
+#include <knowherefaiss/gpu/utils/DeviceTensor-inl.cuh>
diff --git a/thirdparty/faiss/faiss/gpu/utils/DeviceUtils.cu b/thirdparty/faiss/knowherefaiss/gpu/utils/DeviceUtils.cu
similarity index 96%
rename from thirdparty/faiss/faiss/gpu/utils/DeviceUtils.cu
rename to thirdparty/faiss/knowherefaiss/gpu/utils/DeviceUtils.cu
index 90b1c891..5b33ce70 100644
--- a/thirdparty/faiss/faiss/gpu/utils/DeviceUtils.cu
+++ b/thirdparty/faiss/knowherefaiss/gpu/utils/DeviceUtils.cu
@@ -6,13 +6,13 @@
  */
 
 #include <cuda_profiler_api.h>
-#include <faiss/gpu/utils/DeviceUtils.h>
-#include <faiss/impl/FaissAssert.h>
-#include <faiss/gpu/utils/DeviceDefs.cuh>
+#include <knowherefaiss/gpu/utils/DeviceUtils.h>
+#include <knowherefaiss/impl/FaissAssert.h>
+#include <knowherefaiss/gpu/utils/DeviceDefs.cuh>
 #include <mutex>
 #include <unordered_map>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 int getCurrentDevice() {
@@ -219,4 +219,4 @@ void CudaEvent::cpuWaitOnEvent() {
 }
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/utils/DeviceUtils.h b/thirdparty/faiss/knowherefaiss/gpu/utils/DeviceUtils.h
similarity index 98%
rename from thirdparty/faiss/faiss/gpu/utils/DeviceUtils.h
rename to thirdparty/faiss/knowherefaiss/gpu/utils/DeviceUtils.h
index 3b1326d1..7d2c454a 100644
--- a/thirdparty/faiss/faiss/gpu/utils/DeviceUtils.h
+++ b/thirdparty/faiss/knowherefaiss/gpu/utils/DeviceUtils.h
@@ -9,10 +9,10 @@
 
 #include <cublas_v2.h>
 #include <cuda_runtime.h>
-#include <faiss/impl/FaissAssert.h>
+#include <knowherefaiss/impl/FaissAssert.h>
 #include <vector>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 /// Returns the current thread-local GPU device
@@ -195,4 +195,4 @@ inline void streamWait(
 }
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/utils/DeviceVector.cuh b/thirdparty/faiss/knowherefaiss/gpu/utils/DeviceVector.cuh
similarity index 96%
rename from thirdparty/faiss/faiss/gpu/utils/DeviceVector.cuh
rename to thirdparty/faiss/knowherefaiss/gpu/utils/DeviceVector.cuh
index 75e7478e..c2bee748 100644
--- a/thirdparty/faiss/faiss/gpu/utils/DeviceVector.cuh
+++ b/thirdparty/faiss/knowherefaiss/gpu/utils/DeviceVector.cuh
@@ -8,14 +8,14 @@
 #pragma once
 
 #include <cuda.h>
-#include <faiss/gpu/GpuResources.h>
-#include <faiss/gpu/utils/DeviceUtils.h>
-#include <faiss/gpu/utils/StaticUtils.h>
-#include <faiss/impl/FaissAssert.h>
+#include <knowherefaiss/gpu/GpuResources.h>
+#include <knowherefaiss/gpu/utils/DeviceUtils.h>
+#include <knowherefaiss/gpu/utils/StaticUtils.h>
+#include <knowherefaiss/impl/FaissAssert.h>
 #include <algorithm>
 #include <vector>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 /// A simple version of thrust::device_vector<T>, but has more control
@@ -250,4 +250,4 @@ class DeviceVector {
 };
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/utils/Float16.cuh b/thirdparty/faiss/knowherefaiss/gpu/utils/Float16.cuh
similarity index 89%
rename from thirdparty/faiss/faiss/gpu/utils/Float16.cuh
rename to thirdparty/faiss/knowherefaiss/gpu/utils/Float16.cuh
index 42fb9878..506804b6 100644
--- a/thirdparty/faiss/faiss/gpu/utils/Float16.cuh
+++ b/thirdparty/faiss/knowherefaiss/gpu/utils/Float16.cuh
@@ -8,8 +8,8 @@
 #pragma once
 
 #include <cuda.h>
-#include <faiss/gpu/GpuResources.h>
-#include <faiss/gpu/utils/DeviceUtils.h>
+#include <knowherefaiss/gpu/GpuResources.h>
+#include <knowherefaiss/gpu/utils/DeviceUtils.h>
 
 // Some compute capabilities have full float16 ALUs.
 #if __CUDA_ARCH__ >= 530
@@ -18,7 +18,7 @@
 
 #include <cuda_fp16.h>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 // 64 bytes containing 4 half (float16) values
@@ -70,4 +70,4 @@ inline bool getDeviceSupportsFloat16Math(int device) {
 }
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/utils/HostTensor-inl.cuh b/thirdparty/faiss/knowherefaiss/gpu/utils/HostTensor-inl.cuh
similarity index 99%
rename from thirdparty/faiss/faiss/gpu/utils/HostTensor-inl.cuh
rename to thirdparty/faiss/knowherefaiss/gpu/utils/HostTensor-inl.cuh
index 5b093fb1..eb160b4b 100644
--- a/thirdparty/faiss/faiss/gpu/utils/HostTensor-inl.cuh
+++ b/thirdparty/faiss/knowherefaiss/gpu/utils/HostTensor-inl.cuh
@@ -5,7 +5,7 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 template <
@@ -234,4 +234,4 @@ __host__ T HostTensor<T, Dim, InnerContig, IndexT, PtrTraits>::maxDiff(
 }
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/utils/HostTensor.cuh b/thirdparty/faiss/knowherefaiss/gpu/utils/HostTensor.cuh
similarity index 94%
rename from thirdparty/faiss/faiss/gpu/utils/HostTensor.cuh
rename to thirdparty/faiss/knowherefaiss/gpu/utils/HostTensor.cuh
index e83e8857..f9d46f99 100644
--- a/thirdparty/faiss/faiss/gpu/utils/HostTensor.cuh
+++ b/thirdparty/faiss/knowherefaiss/gpu/utils/HostTensor.cuh
@@ -7,9 +7,9 @@
 
 #pragma once
 
-#include <faiss/gpu/utils/Tensor.cuh>
+#include <knowherefaiss/gpu/utils/Tensor.cuh>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 template <
@@ -88,6 +88,6 @@ class HostTensor : public Tensor<T, Dim, InnerContig, IndexT, PtrTraits> {
 };
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
 
-#include <faiss/gpu/utils/HostTensor-inl.cuh>
+#include <knowherefaiss/gpu/utils/HostTensor-inl.cuh>
diff --git a/thirdparty/faiss/faiss/gpu/utils/Limits.cuh b/thirdparty/faiss/knowherefaiss/gpu/utils/Limits.cuh
similarity index 94%
rename from thirdparty/faiss/faiss/gpu/utils/Limits.cuh
rename to thirdparty/faiss/knowherefaiss/gpu/utils/Limits.cuh
index 9ab3b712..4bef8892 100644
--- a/thirdparty/faiss/faiss/gpu/utils/Limits.cuh
+++ b/thirdparty/faiss/knowherefaiss/gpu/utils/Limits.cuh
@@ -7,10 +7,10 @@
 
 #pragma once
 
-#include <faiss/gpu/utils/Pair.cuh>
+#include <knowherefaiss/gpu/utils/Pair.cuh>
 #include <limits>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 template <typename T>
@@ -79,4 +79,4 @@ struct Limits<Pair<K, V>> {
 };
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/utils/LoadStoreOperators.cuh b/thirdparty/faiss/knowherefaiss/gpu/utils/LoadStoreOperators.cuh
similarity index 96%
rename from thirdparty/faiss/faiss/gpu/utils/LoadStoreOperators.cuh
rename to thirdparty/faiss/knowherefaiss/gpu/utils/LoadStoreOperators.cuh
index a342c400..2a6b2498 100644
--- a/thirdparty/faiss/faiss/gpu/utils/LoadStoreOperators.cuh
+++ b/thirdparty/faiss/knowherefaiss/gpu/utils/LoadStoreOperators.cuh
@@ -7,7 +7,7 @@
 
 #pragma once
 
-#include <faiss/gpu/utils/Float16.cuh>
+#include <knowherefaiss/gpu/utils/Float16.cuh>
 
 #ifndef __HALF2_TO_UI
 // cuda_fp16.hpp doesn't export this
@@ -20,7 +20,7 @@
 // over half and float, and on vector types transparently
 //
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 template <typename T>
@@ -98,4 +98,4 @@ struct LoadStore<Half8> {
 };
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/utils/MathOperators.cuh b/thirdparty/faiss/knowherefaiss/gpu/utils/MathOperators.cuh
similarity index 98%
rename from thirdparty/faiss/faiss/gpu/utils/MathOperators.cuh
rename to thirdparty/faiss/knowherefaiss/gpu/utils/MathOperators.cuh
index 2b2bf7d6..80a9320d 100644
--- a/thirdparty/faiss/faiss/gpu/utils/MathOperators.cuh
+++ b/thirdparty/faiss/knowherefaiss/gpu/utils/MathOperators.cuh
@@ -7,8 +7,8 @@
 
 #pragma once
 
-#include <faiss/gpu/utils/ConversionOperators.cuh>
-#include <faiss/gpu/utils/Float16.cuh>
+#include <knowherefaiss/gpu/utils/ConversionOperators.cuh>
+#include <knowherefaiss/gpu/utils/Float16.cuh>
 
 //
 // Templated wrappers to express math for different scalar and vector
@@ -16,7 +16,7 @@
 // over half and float, and on vector types transparently
 //
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 template <typename T>
@@ -557,4 +557,4 @@ struct Math<Half8> {
 };
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/utils/MatrixMult-inl.cuh b/thirdparty/faiss/knowherefaiss/gpu/utils/MatrixMult-inl.cuh
similarity index 97%
rename from thirdparty/faiss/faiss/gpu/utils/MatrixMult-inl.cuh
rename to thirdparty/faiss/knowherefaiss/gpu/utils/MatrixMult-inl.cuh
index 03a96b67..bfa8cafa 100644
--- a/thirdparty/faiss/faiss/gpu/utils/MatrixMult-inl.cuh
+++ b/thirdparty/faiss/knowherefaiss/gpu/utils/MatrixMult-inl.cuh
@@ -8,12 +8,12 @@
 #pragma once
 
 #include <cublas_v2.h>
-#include <faiss/gpu/utils/DeviceTensor.cuh>
-#include <faiss/gpu/utils/Float16.cuh>
-#include <faiss/gpu/utils/HostTensor.cuh>
-#include <faiss/gpu/utils/Tensor.cuh>
+#include <knowherefaiss/gpu/utils/DeviceTensor.cuh>
+#include <knowherefaiss/gpu/utils/Float16.cuh>
+#include <knowherefaiss/gpu/utils/HostTensor.cuh>
+#include <knowherefaiss/gpu/utils/Tensor.cuh>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 template <typename T>
@@ -357,4 +357,4 @@ void runBatchMatrixMult(
 }
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/utils/MatrixMult.cuh b/thirdparty/faiss/knowherefaiss/gpu/utils/MatrixMult.cuh
similarity index 79%
rename from thirdparty/faiss/faiss/gpu/utils/MatrixMult.cuh
rename to thirdparty/faiss/knowherefaiss/gpu/utils/MatrixMult.cuh
index b15a49f5..13e14888 100644
--- a/thirdparty/faiss/faiss/gpu/utils/MatrixMult.cuh
+++ b/thirdparty/faiss/knowherefaiss/gpu/utils/MatrixMult.cuh
@@ -8,12 +8,12 @@
 #pragma once
 
 #include <cublas_v2.h>
-#include <faiss/gpu/utils/DeviceTensor.cuh>
-#include <faiss/gpu/utils/Float16.cuh>
-#include <faiss/gpu/utils/HostTensor.cuh>
-#include <faiss/gpu/utils/Tensor.cuh>
+#include <knowherefaiss/gpu/utils/DeviceTensor.cuh>
+#include <knowherefaiss/gpu/utils/Float16.cuh>
+#include <knowherefaiss/gpu/utils/HostTensor.cuh>
+#include <knowherefaiss/gpu/utils/Tensor.cuh>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 class GpuResources;
@@ -50,6 +50,6 @@ void runIteratedMatrixMult(
         cudaStream_t stream);
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
 
-#include <faiss/gpu/utils/MatrixMult-inl.cuh>
+#include <knowherefaiss/gpu/utils/MatrixMult-inl.cuh>
diff --git a/thirdparty/faiss/faiss/gpu/utils/MergeNetworkBlock.cuh b/thirdparty/faiss/knowherefaiss/gpu/utils/MergeNetworkBlock.cuh
similarity index 96%
rename from thirdparty/faiss/faiss/gpu/utils/MergeNetworkBlock.cuh
rename to thirdparty/faiss/knowherefaiss/gpu/utils/MergeNetworkBlock.cuh
index 50c9fb9f..d6b7b56e 100644
--- a/thirdparty/faiss/faiss/gpu/utils/MergeNetworkBlock.cuh
+++ b/thirdparty/faiss/knowherefaiss/gpu/utils/MergeNetworkBlock.cuh
@@ -8,14 +8,14 @@
 #pragma once
 
 #include <cuda.h>
-#include <faiss/gpu/utils/StaticUtils.h>
-#include <faiss/impl/FaissAssert.h>
-#include <faiss/gpu/utils/DeviceDefs.cuh>
-#include <faiss/gpu/utils/MergeNetworkUtils.cuh>
-#include <faiss/gpu/utils/PtxUtils.cuh>
-#include <faiss/gpu/utils/WarpShuffles.cuh>
-
-namespace faiss {
+#include <knowherefaiss/gpu/utils/StaticUtils.h>
+#include <knowherefaiss/impl/FaissAssert.h>
+#include <knowherefaiss/gpu/utils/DeviceDefs.cuh>
+#include <knowherefaiss/gpu/utils/MergeNetworkUtils.cuh>
+#include <knowherefaiss/gpu/utils/PtxUtils.cuh>
+#include <knowherefaiss/gpu/utils/WarpShuffles.cuh>
+
+namespace knowherefaiss {
 namespace gpu {
 
 // Merge pairs of lists smaller than blockDim.x (NumThreads)
@@ -318,4 +318,4 @@ inline __device__ void blockMerge(K* listK, V* listV) {
 }
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/utils/MergeNetworkUtils.cuh b/thirdparty/faiss/knowherefaiss/gpu/utils/MergeNetworkUtils.cuh
similarity index 89%
rename from thirdparty/faiss/faiss/gpu/utils/MergeNetworkUtils.cuh
rename to thirdparty/faiss/knowherefaiss/gpu/utils/MergeNetworkUtils.cuh
index 56ebfbb6..47154da3 100644
--- a/thirdparty/faiss/faiss/gpu/utils/MergeNetworkUtils.cuh
+++ b/thirdparty/faiss/knowherefaiss/gpu/utils/MergeNetworkUtils.cuh
@@ -7,7 +7,7 @@
 
 #pragma once
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 template <typename T>
@@ -23,4 +23,4 @@ inline __device__ void assign(bool assign, T& x, T y) {
 }
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/utils/MergeNetworkWarp.cuh b/thirdparty/faiss/knowherefaiss/gpu/utils/MergeNetworkWarp.cuh
similarity index 98%
rename from thirdparty/faiss/faiss/gpu/utils/MergeNetworkWarp.cuh
rename to thirdparty/faiss/knowherefaiss/gpu/utils/MergeNetworkWarp.cuh
index fcd1f648..d465b977 100644
--- a/thirdparty/faiss/faiss/gpu/utils/MergeNetworkWarp.cuh
+++ b/thirdparty/faiss/knowherefaiss/gpu/utils/MergeNetworkWarp.cuh
@@ -7,13 +7,13 @@
 
 #pragma once
 
-#include <faiss/gpu/utils/StaticUtils.h>
-#include <faiss/gpu/utils/DeviceDefs.cuh>
-#include <faiss/gpu/utils/MergeNetworkUtils.cuh>
-#include <faiss/gpu/utils/PtxUtils.cuh>
-#include <faiss/gpu/utils/WarpShuffles.cuh>
+#include <knowherefaiss/gpu/utils/StaticUtils.h>
+#include <knowherefaiss/gpu/utils/DeviceDefs.cuh>
+#include <knowherefaiss/gpu/utils/MergeNetworkUtils.cuh>
+#include <knowherefaiss/gpu/utils/PtxUtils.cuh>
+#include <knowherefaiss/gpu/utils/WarpShuffles.cuh>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 //
@@ -547,4 +547,4 @@ inline __device__ void warpSortAnyRegisters(K k[N], V v[N]) {
 }
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/utils/NoTypeTensor.cuh b/thirdparty/faiss/knowherefaiss/gpu/utils/NoTypeTensor.cuh
similarity index 95%
rename from thirdparty/faiss/faiss/gpu/utils/NoTypeTensor.cuh
rename to thirdparty/faiss/knowherefaiss/gpu/utils/NoTypeTensor.cuh
index c48845b7..e02a577a 100644
--- a/thirdparty/faiss/faiss/gpu/utils/NoTypeTensor.cuh
+++ b/thirdparty/faiss/knowherefaiss/gpu/utils/NoTypeTensor.cuh
@@ -7,11 +7,11 @@
 
 #pragma once
 
-#include <faiss/impl/FaissAssert.h>
-#include <faiss/gpu/utils/Tensor.cuh>
+#include <knowherefaiss/impl/FaissAssert.h>
+#include <knowherefaiss/gpu/utils/Tensor.cuh>
 #include <initializer_list>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 template <int Dim, bool InnerContig = false, typename IndexT = int>
@@ -117,4 +117,4 @@ class NoTypeTensor {
 };
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/utils/Pair.cuh b/thirdparty/faiss/knowherefaiss/gpu/utils/Pair.cuh
similarity index 91%
rename from thirdparty/faiss/faiss/gpu/utils/Pair.cuh
rename to thirdparty/faiss/knowherefaiss/gpu/utils/Pair.cuh
index d7c377c2..c8c22f07 100644
--- a/thirdparty/faiss/faiss/gpu/utils/Pair.cuh
+++ b/thirdparty/faiss/knowherefaiss/gpu/utils/Pair.cuh
@@ -8,10 +8,10 @@
 #pragma once
 
 #include <cuda.h>
-#include <faiss/gpu/utils/MathOperators.cuh>
-#include <faiss/gpu/utils/WarpShuffles.cuh>
+#include <knowherefaiss/gpu/utils/MathOperators.cuh>
+#include <knowherefaiss/gpu/utils/WarpShuffles.cuh>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 /// A simple pair type for CUDA device usage
@@ -63,4 +63,4 @@ inline __device__ Pair<T, U> shfl_xor(
 }
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/utils/PtxUtils.cuh b/thirdparty/faiss/knowherefaiss/gpu/utils/PtxUtils.cuh
similarity index 97%
rename from thirdparty/faiss/faiss/gpu/utils/PtxUtils.cuh
rename to thirdparty/faiss/knowherefaiss/gpu/utils/PtxUtils.cuh
index 35e23dd6..acef196e 100644
--- a/thirdparty/faiss/faiss/gpu/utils/PtxUtils.cuh
+++ b/thirdparty/faiss/knowherefaiss/gpu/utils/PtxUtils.cuh
@@ -9,7 +9,7 @@
 
 #include <cuda.h>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 // defines to simplify the SASS assembly structure file/line in the profiler
@@ -89,4 +89,4 @@ __device__ __forceinline__ void namedBarrierArrived(int name, int numThreads) {
 }
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/utils/ReductionOperators.cuh b/thirdparty/faiss/knowherefaiss/gpu/utils/ReductionOperators.cuh
similarity index 88%
rename from thirdparty/faiss/faiss/gpu/utils/ReductionOperators.cuh
rename to thirdparty/faiss/knowherefaiss/gpu/utils/ReductionOperators.cuh
index ed87ac3a..71f758f4 100644
--- a/thirdparty/faiss/faiss/gpu/utils/ReductionOperators.cuh
+++ b/thirdparty/faiss/knowherefaiss/gpu/utils/ReductionOperators.cuh
@@ -8,11 +8,11 @@
 #pragma once
 
 #include <cuda.h>
-#include <faiss/gpu/utils/Limits.cuh>
-#include <faiss/gpu/utils/MathOperators.cuh>
-#include <faiss/gpu/utils/Pair.cuh>
+#include <knowherefaiss/gpu/utils/Limits.cuh>
+#include <knowherefaiss/gpu/utils/MathOperators.cuh>
+#include <knowherefaiss/gpu/utils/Pair.cuh>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 template <typename T>
@@ -68,4 +68,4 @@ struct SegmentedReduce {
 };
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/utils/Reductions.cuh b/thirdparty/faiss/knowherefaiss/gpu/utils/Reductions.cuh
similarity index 91%
rename from thirdparty/faiss/faiss/gpu/utils/Reductions.cuh
rename to thirdparty/faiss/knowherefaiss/gpu/utils/Reductions.cuh
index 5dcda8f0..b76e1d35 100644
--- a/thirdparty/faiss/faiss/gpu/utils/Reductions.cuh
+++ b/thirdparty/faiss/knowherefaiss/gpu/utils/Reductions.cuh
@@ -8,13 +8,13 @@
 #pragma once
 
 #include <cuda.h>
-#include <faiss/gpu/utils/StaticUtils.h>
-#include <faiss/gpu/utils/DeviceDefs.cuh>
-#include <faiss/gpu/utils/PtxUtils.cuh>
-#include <faiss/gpu/utils/ReductionOperators.cuh>
-#include <faiss/gpu/utils/WarpShuffles.cuh>
+#include <knowherefaiss/gpu/utils/StaticUtils.h>
+#include <knowherefaiss/gpu/utils/DeviceDefs.cuh>
+#include <knowherefaiss/gpu/utils/PtxUtils.cuh>
+#include <knowherefaiss/gpu/utils/ReductionOperators.cuh>
+#include <knowherefaiss/gpu/utils/WarpShuffles.cuh>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 template <typename T, typename Op, int ReduceWidth = kWarpSize>
@@ -144,4 +144,4 @@ __device__ inline void blockReduceAllSum(T vals[Num], T* smem) {
 }
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/utils/Select.cuh b/thirdparty/faiss/knowherefaiss/gpu/utils/Select.cuh
similarity index 97%
rename from thirdparty/faiss/faiss/gpu/utils/Select.cuh
rename to thirdparty/faiss/knowherefaiss/gpu/utils/Select.cuh
index 4ad89239..f4a3cb2c 100644
--- a/thirdparty/faiss/faiss/gpu/utils/Select.cuh
+++ b/thirdparty/faiss/knowherefaiss/gpu/utils/Select.cuh
@@ -7,16 +7,16 @@
 
 #pragma once
 
-#include <faiss/gpu/utils/Comparators.cuh>
-#include <faiss/gpu/utils/DeviceDefs.cuh>
-#include <faiss/gpu/utils/MergeNetworkBlock.cuh>
-#include <faiss/gpu/utils/MergeNetworkWarp.cuh>
-#include <faiss/gpu/utils/PtxUtils.cuh>
-#include <faiss/gpu/utils/ReductionOperators.cuh>
-#include <faiss/gpu/utils/Reductions.cuh>
-#include <faiss/gpu/utils/Tensor.cuh>
-
-namespace faiss {
+#include <knowherefaiss/gpu/utils/Comparators.cuh>
+#include <knowherefaiss/gpu/utils/DeviceDefs.cuh>
+#include <knowherefaiss/gpu/utils/MergeNetworkBlock.cuh>
+#include <knowherefaiss/gpu/utils/MergeNetworkWarp.cuh>
+#include <knowherefaiss/gpu/utils/PtxUtils.cuh>
+#include <knowherefaiss/gpu/utils/ReductionOperators.cuh>
+#include <knowherefaiss/gpu/utils/Reductions.cuh>
+#include <knowherefaiss/gpu/utils/Tensor.cuh>
+
+namespace knowherefaiss {
 namespace gpu {
 
 // Specialization for block-wide monotonic merges producing a merge sort
@@ -644,4 +644,4 @@ struct WarpSelect<K, V, Dir, Comp, 1, NumThreadQ, ThreadsPerBlock> {
 };
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/utils/StackDeviceMemory.cpp b/thirdparty/faiss/knowherefaiss/gpu/utils/StackDeviceMemory.cpp
similarity index 95%
rename from thirdparty/faiss/faiss/gpu/utils/StackDeviceMemory.cpp
rename to thirdparty/faiss/knowherefaiss/gpu/utils/StackDeviceMemory.cpp
index 73d586e5..33ca9db4 100644
--- a/thirdparty/faiss/faiss/gpu/utils/StackDeviceMemory.cpp
+++ b/thirdparty/faiss/knowherefaiss/gpu/utils/StackDeviceMemory.cpp
@@ -5,14 +5,14 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/gpu/utils/DeviceUtils.h>
-#include <faiss/gpu/utils/StackDeviceMemory.h>
-#include <faiss/gpu/utils/StaticUtils.h>
-#include <faiss/impl/FaissAssert.h>
+#include <knowherefaiss/gpu/utils/DeviceUtils.h>
+#include <knowherefaiss/gpu/utils/StackDeviceMemory.h>
+#include <knowherefaiss/gpu/utils/StaticUtils.h>
+#include <knowherefaiss/impl/FaissAssert.h>
 #include <algorithm>
 #include <sstream>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 namespace {
@@ -213,4 +213,4 @@ void StackDeviceMemory::deallocMemory(
 }
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/utils/StackDeviceMemory.h b/thirdparty/faiss/knowherefaiss/gpu/utils/StackDeviceMemory.h
similarity index 96%
rename from thirdparty/faiss/faiss/gpu/utils/StackDeviceMemory.h
rename to thirdparty/faiss/knowherefaiss/gpu/utils/StackDeviceMemory.h
index 26a7987a..d8036964 100644
--- a/thirdparty/faiss/faiss/gpu/utils/StackDeviceMemory.h
+++ b/thirdparty/faiss/knowherefaiss/gpu/utils/StackDeviceMemory.h
@@ -8,13 +8,13 @@
 #pragma once
 
 #include <cuda_runtime.h>
-#include <faiss/gpu/GpuResources.h>
+#include <knowherefaiss/gpu/GpuResources.h>
 #include <list>
 #include <memory>
 #include <tuple>
 #include <unordered_map>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 /// Device memory manager that provides temporary memory allocations
@@ -109,4 +109,4 @@ class StackDeviceMemory {
 };
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/utils/StaticUtils.h b/thirdparty/faiss/knowherefaiss/gpu/utils/StaticUtils.h
similarity index 97%
rename from thirdparty/faiss/faiss/gpu/utils/StaticUtils.h
rename to thirdparty/faiss/knowherefaiss/gpu/utils/StaticUtils.h
index cc18e147..c70df6c2 100644
--- a/thirdparty/faiss/faiss/gpu/utils/StaticUtils.h
+++ b/thirdparty/faiss/knowherefaiss/gpu/utils/StaticUtils.h
@@ -15,7 +15,7 @@
 #define __device__
 #endif
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 namespace utils {
 
@@ -91,4 +91,4 @@ static_assert(
 
 } // namespace utils
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/utils/Tensor-inl.cuh b/thirdparty/faiss/knowherefaiss/gpu/utils/Tensor-inl.cuh
similarity index 99%
rename from thirdparty/faiss/faiss/gpu/utils/Tensor-inl.cuh
rename to thirdparty/faiss/knowherefaiss/gpu/utils/Tensor-inl.cuh
index aa2d03e5..7c5d9fc6 100644
--- a/thirdparty/faiss/faiss/gpu/utils/Tensor-inl.cuh
+++ b/thirdparty/faiss/knowherefaiss/gpu/utils/Tensor-inl.cuh
@@ -5,12 +5,12 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/gpu/GpuFaissAssert.h>
-#include <faiss/gpu/utils/DeviceUtils.h>
+#include <knowherefaiss/gpu/GpuFaissAssert.h>
+#include <knowherefaiss/gpu/utils/DeviceUtils.h>
 #include <cstring>
 #include <limits>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 template <
@@ -1049,4 +1049,4 @@ __host__ __device__ Tensor<T, NewDim, InnerContig, IndexT, PtrTraits> Tensor<
 }
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/utils/Tensor.cuh b/thirdparty/faiss/knowherefaiss/gpu/utils/Tensor.cuh
similarity index 99%
rename from thirdparty/faiss/faiss/gpu/utils/Tensor.cuh
rename to thirdparty/faiss/knowherefaiss/gpu/utils/Tensor.cuh
index 2892e75c..2a5cc283 100644
--- a/thirdparty/faiss/faiss/gpu/utils/Tensor.cuh
+++ b/thirdparty/faiss/knowherefaiss/gpu/utils/Tensor.cuh
@@ -17,7 +17,7 @@
 /// Originally from Facebook's fbcunn, since added to the Torch GPU
 /// library cutorch as well.
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 /// Our tensor type
@@ -692,6 +692,6 @@ Tensor<T, Dim, InnerContig, IndexT, PtrTraits>::operator[](IndexT index) const {
 }
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
 
-#include <faiss/gpu/utils/Tensor-inl.cuh>
+#include <knowherefaiss/gpu/utils/Tensor-inl.cuh>
diff --git a/thirdparty/faiss/faiss/gpu/utils/ThrustAllocator.cuh b/thirdparty/faiss/knowherefaiss/gpu/utils/ThrustAllocator.cuh
similarity index 95%
rename from thirdparty/faiss/faiss/gpu/utils/ThrustAllocator.cuh
rename to thirdparty/faiss/knowherefaiss/gpu/utils/ThrustAllocator.cuh
index 1951e541..75483e7c 100644
--- a/thirdparty/faiss/faiss/gpu/utils/ThrustAllocator.cuh
+++ b/thirdparty/faiss/knowherefaiss/gpu/utils/ThrustAllocator.cuh
@@ -8,10 +8,10 @@
 #pragma once
 
 #include <cuda.h>
-#include <faiss/gpu/GpuResources.h>
+#include <knowherefaiss/gpu/GpuResources.h>
 #include <unordered_set>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 /// Allocator for Thrust that comes out of a specified memory space
@@ -78,4 +78,4 @@ class GpuResourcesThrustAllocator {
 };
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/utils/Timer.cpp b/thirdparty/faiss/knowherefaiss/gpu/utils/Timer.cpp
similarity index 86%
rename from thirdparty/faiss/faiss/gpu/utils/Timer.cpp
rename to thirdparty/faiss/knowherefaiss/gpu/utils/Timer.cpp
index 0d75b64f..b51badfb 100644
--- a/thirdparty/faiss/faiss/gpu/utils/Timer.cpp
+++ b/thirdparty/faiss/knowherefaiss/gpu/utils/Timer.cpp
@@ -5,12 +5,12 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/gpu/utils/DeviceUtils.h>
-#include <faiss/gpu/utils/Timer.h>
-#include <faiss/impl/FaissAssert.h>
+#include <knowherefaiss/gpu/utils/DeviceUtils.h>
+#include <knowherefaiss/gpu/utils/Timer.h>
+#include <knowherefaiss/impl/FaissAssert.h>
 #include <chrono>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 KernelTimer::KernelTimer(cudaStream_t stream)
@@ -52,4 +52,4 @@ float CpuTimer::elapsedMilliseconds() {
 }
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/utils/Timer.h b/thirdparty/faiss/knowherefaiss/gpu/utils/Timer.h
similarity index 95%
rename from thirdparty/faiss/faiss/gpu/utils/Timer.h
rename to thirdparty/faiss/knowherefaiss/gpu/utils/Timer.h
index 7abfa4c9..cf0971ed 100644
--- a/thirdparty/faiss/faiss/gpu/utils/Timer.h
+++ b/thirdparty/faiss/knowherefaiss/gpu/utils/Timer.h
@@ -10,7 +10,7 @@
 #include <cuda_runtime.h>
 #include <chrono>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 /// Utility class for timing execution of a kernel
@@ -50,4 +50,4 @@ class CpuTimer {
 };
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/utils/Transpose.cuh b/thirdparty/faiss/knowherefaiss/gpu/utils/Transpose.cuh
similarity index 96%
rename from thirdparty/faiss/faiss/gpu/utils/Transpose.cuh
rename to thirdparty/faiss/knowherefaiss/gpu/utils/Transpose.cuh
index 2454ef10..8d8daa99 100644
--- a/thirdparty/faiss/faiss/gpu/utils/Transpose.cuh
+++ b/thirdparty/faiss/knowherefaiss/gpu/utils/Transpose.cuh
@@ -8,13 +8,13 @@
 #pragma once
 
 #include <cuda.h>
-#include <faiss/gpu/utils/DeviceUtils.h>
-#include <faiss/gpu/utils/StaticUtils.h>
-#include <faiss/impl/FaissAssert.h>
+#include <knowherefaiss/gpu/utils/DeviceUtils.h>
+#include <knowherefaiss/gpu/utils/StaticUtils.h>
+#include <knowherefaiss/impl/FaissAssert.h>
 #include <stdint.h>
-#include <faiss/gpu/utils/Tensor.cuh>
+#include <knowherefaiss/gpu/utils/Tensor.cuh>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 template <typename T, typename IndexT>
@@ -222,4 +222,4 @@ void runTransposeAny(
 }
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/utils/WarpPackedBits.cuh b/thirdparty/faiss/knowherefaiss/gpu/utils/WarpPackedBits.cuh
similarity index 98%
rename from thirdparty/faiss/faiss/gpu/utils/WarpPackedBits.cuh
rename to thirdparty/faiss/knowherefaiss/gpu/utils/WarpPackedBits.cuh
index c079874a..15543661 100644
--- a/thirdparty/faiss/faiss/gpu/utils/WarpPackedBits.cuh
+++ b/thirdparty/faiss/knowherefaiss/gpu/utils/WarpPackedBits.cuh
@@ -7,10 +7,10 @@
 
 #pragma once
 
-#include <faiss/gpu/utils/PtxUtils.cuh>
-#include <faiss/gpu/utils/WarpShuffles.cuh>
+#include <knowherefaiss/gpu/utils/PtxUtils.cuh>
+#include <knowherefaiss/gpu/utils/WarpShuffles.cuh>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 //
@@ -278,4 +278,4 @@ struct WarpPackedBits<uint8_t, 4> {
 };
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/utils/WarpSelectFloat.cu b/thirdparty/faiss/knowherefaiss/gpu/utils/WarpSelectFloat.cu
similarity index 93%
rename from thirdparty/faiss/faiss/gpu/utils/WarpSelectFloat.cu
rename to thirdparty/faiss/knowherefaiss/gpu/utils/WarpSelectFloat.cu
index b59e5b0f..6649f542 100644
--- a/thirdparty/faiss/faiss/gpu/utils/WarpSelectFloat.cu
+++ b/thirdparty/faiss/knowherefaiss/gpu/utils/WarpSelectFloat.cu
@@ -5,10 +5,10 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/gpu/utils/DeviceDefs.cuh>
-#include <faiss/gpu/utils/warpselect/WarpSelectImpl.cuh>
+#include <knowherefaiss/gpu/utils/DeviceDefs.cuh>
+#include <knowherefaiss/gpu/utils/warpselect/WarpSelectImpl.cuh>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 // warp Q to thread Q:
@@ -96,4 +96,4 @@ void runWarpSelect(
 }
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/utils/WarpSelectKernel.cuh b/thirdparty/faiss/knowherefaiss/gpu/utils/WarpSelectKernel.cuh
similarity index 94%
rename from thirdparty/faiss/faiss/gpu/utils/WarpSelectKernel.cuh
rename to thirdparty/faiss/knowherefaiss/gpu/utils/WarpSelectKernel.cuh
index 7f7e68b4..05cabf1b 100644
--- a/thirdparty/faiss/faiss/gpu/utils/WarpSelectKernel.cuh
+++ b/thirdparty/faiss/knowherefaiss/gpu/utils/WarpSelectKernel.cuh
@@ -7,9 +7,9 @@
 
 #pragma once
 
-#include <faiss/gpu/utils/Select.cuh>
+#include <knowherefaiss/gpu/utils/Select.cuh>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 template <
@@ -82,4 +82,4 @@ void runWarpSelect(
         cudaStream_t stream);
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/utils/WarpShuffles.cuh b/thirdparty/faiss/knowherefaiss/gpu/utils/WarpShuffles.cuh
similarity index 96%
rename from thirdparty/faiss/faiss/gpu/utils/WarpShuffles.cuh
rename to thirdparty/faiss/knowherefaiss/gpu/utils/WarpShuffles.cuh
index 23dbb437..551acadd 100644
--- a/thirdparty/faiss/faiss/gpu/utils/WarpShuffles.cuh
+++ b/thirdparty/faiss/knowherefaiss/gpu/utils/WarpShuffles.cuh
@@ -8,9 +8,9 @@
 #pragma once
 
 #include <cuda.h>
-#include <faiss/gpu/utils/DeviceDefs.cuh>
+#include <knowherefaiss/gpu/utils/DeviceDefs.cuh>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 // defines to simplify the SASS assembly structure file/line in the profiler
@@ -124,4 +124,4 @@ inline __device__ half shfl_xor(half v, int laneMask, int width = kWarpSize) {
 #endif // CUDA_VERSION
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/utils/blockselect/BlockSelectFloat1.cu b/thirdparty/faiss/knowherefaiss/gpu/utils/blockselect/BlockSelectFloat1.cu
similarity index 71%
rename from thirdparty/faiss/faiss/gpu/utils/blockselect/BlockSelectFloat1.cu
rename to thirdparty/faiss/knowherefaiss/gpu/utils/blockselect/BlockSelectFloat1.cu
index 46202d89..8917adf6 100644
--- a/thirdparty/faiss/faiss/gpu/utils/blockselect/BlockSelectFloat1.cu
+++ b/thirdparty/faiss/knowherefaiss/gpu/utils/blockselect/BlockSelectFloat1.cu
@@ -5,13 +5,13 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/gpu/utils/blockselect/BlockSelectImpl.cuh>
+#include <knowherefaiss/gpu/utils/blockselect/BlockSelectImpl.cuh>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 BLOCK_SELECT_IMPL(float, true, 1, 1);
 BLOCK_SELECT_IMPL(float, false, 1, 1);
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/utils/blockselect/BlockSelectFloat128.cu b/thirdparty/faiss/knowherefaiss/gpu/utils/blockselect/BlockSelectFloat128.cu
similarity index 71%
rename from thirdparty/faiss/faiss/gpu/utils/blockselect/BlockSelectFloat128.cu
rename to thirdparty/faiss/knowherefaiss/gpu/utils/blockselect/BlockSelectFloat128.cu
index 85a400d1..511b96ca 100644
--- a/thirdparty/faiss/faiss/gpu/utils/blockselect/BlockSelectFloat128.cu
+++ b/thirdparty/faiss/knowherefaiss/gpu/utils/blockselect/BlockSelectFloat128.cu
@@ -5,13 +5,13 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/gpu/utils/blockselect/BlockSelectImpl.cuh>
+#include <knowherefaiss/gpu/utils/blockselect/BlockSelectImpl.cuh>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 BLOCK_SELECT_IMPL(float, true, 128, 3);
 BLOCK_SELECT_IMPL(float, false, 128, 3);
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/utils/blockselect/BlockSelectFloat256.cu b/thirdparty/faiss/knowherefaiss/gpu/utils/blockselect/BlockSelectFloat256.cu
similarity index 71%
rename from thirdparty/faiss/faiss/gpu/utils/blockselect/BlockSelectFloat256.cu
rename to thirdparty/faiss/knowherefaiss/gpu/utils/blockselect/BlockSelectFloat256.cu
index 7fe2a9dd..f2f88ad8 100644
--- a/thirdparty/faiss/faiss/gpu/utils/blockselect/BlockSelectFloat256.cu
+++ b/thirdparty/faiss/knowherefaiss/gpu/utils/blockselect/BlockSelectFloat256.cu
@@ -5,13 +5,13 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/gpu/utils/blockselect/BlockSelectImpl.cuh>
+#include <knowherefaiss/gpu/utils/blockselect/BlockSelectImpl.cuh>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 BLOCK_SELECT_IMPL(float, true, 256, 4);
 BLOCK_SELECT_IMPL(float, false, 256, 4);
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/utils/blockselect/BlockSelectFloat32.cu b/thirdparty/faiss/knowherefaiss/gpu/utils/blockselect/BlockSelectFloat32.cu
similarity index 71%
rename from thirdparty/faiss/faiss/gpu/utils/blockselect/BlockSelectFloat32.cu
rename to thirdparty/faiss/knowherefaiss/gpu/utils/blockselect/BlockSelectFloat32.cu
index 71c0c4e5..5cc6f9c3 100644
--- a/thirdparty/faiss/faiss/gpu/utils/blockselect/BlockSelectFloat32.cu
+++ b/thirdparty/faiss/knowherefaiss/gpu/utils/blockselect/BlockSelectFloat32.cu
@@ -5,13 +5,13 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/gpu/utils/blockselect/BlockSelectImpl.cuh>
+#include <knowherefaiss/gpu/utils/blockselect/BlockSelectImpl.cuh>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 BLOCK_SELECT_IMPL(float, true, 32, 2);
 BLOCK_SELECT_IMPL(float, false, 32, 2);
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/utils/blockselect/BlockSelectFloat64.cu b/thirdparty/faiss/knowherefaiss/gpu/utils/blockselect/BlockSelectFloat64.cu
similarity index 71%
rename from thirdparty/faiss/faiss/gpu/utils/blockselect/BlockSelectFloat64.cu
rename to thirdparty/faiss/knowherefaiss/gpu/utils/blockselect/BlockSelectFloat64.cu
index 8f774ca8..44d4635c 100644
--- a/thirdparty/faiss/faiss/gpu/utils/blockselect/BlockSelectFloat64.cu
+++ b/thirdparty/faiss/knowherefaiss/gpu/utils/blockselect/BlockSelectFloat64.cu
@@ -5,13 +5,13 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/gpu/utils/blockselect/BlockSelectImpl.cuh>
+#include <knowherefaiss/gpu/utils/blockselect/BlockSelectImpl.cuh>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 BLOCK_SELECT_IMPL(float, true, 64, 3);
 BLOCK_SELECT_IMPL(float, false, 64, 3);
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/utils/blockselect/BlockSelectFloatF1024.cu b/thirdparty/faiss/knowherefaiss/gpu/utils/blockselect/BlockSelectFloatF1024.cu
similarity index 67%
rename from thirdparty/faiss/faiss/gpu/utils/blockselect/BlockSelectFloatF1024.cu
rename to thirdparty/faiss/knowherefaiss/gpu/utils/blockselect/BlockSelectFloatF1024.cu
index 1a4eed22..7d43863d 100644
--- a/thirdparty/faiss/faiss/gpu/utils/blockselect/BlockSelectFloatF1024.cu
+++ b/thirdparty/faiss/knowherefaiss/gpu/utils/blockselect/BlockSelectFloatF1024.cu
@@ -5,12 +5,12 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/gpu/utils/blockselect/BlockSelectImpl.cuh>
+#include <knowherefaiss/gpu/utils/blockselect/BlockSelectImpl.cuh>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 BLOCK_SELECT_IMPL(float, false, 1024, 8);
 
 }
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/utils/blockselect/BlockSelectFloatF2048.cu b/thirdparty/faiss/knowherefaiss/gpu/utils/blockselect/BlockSelectFloatF2048.cu
similarity index 64%
rename from thirdparty/faiss/faiss/gpu/utils/blockselect/BlockSelectFloatF2048.cu
rename to thirdparty/faiss/knowherefaiss/gpu/utils/blockselect/BlockSelectFloatF2048.cu
index 510adcef..0160e32a 100644
--- a/thirdparty/faiss/faiss/gpu/utils/blockselect/BlockSelectFloatF2048.cu
+++ b/thirdparty/faiss/knowherefaiss/gpu/utils/blockselect/BlockSelectFloatF2048.cu
@@ -5,10 +5,10 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/gpu/utils/DeviceDefs.cuh>
-#include <faiss/gpu/utils/blockselect/BlockSelectImpl.cuh>
+#include <knowherefaiss/gpu/utils/DeviceDefs.cuh>
+#include <knowherefaiss/gpu/utils/blockselect/BlockSelectImpl.cuh>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 #if GPU_MAX_SELECTION_K >= 2048
@@ -16,4 +16,4 @@ BLOCK_SELECT_IMPL(float, false, 2048, 8);
 #endif
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/utils/blockselect/BlockSelectFloatF512.cu b/thirdparty/faiss/knowherefaiss/gpu/utils/blockselect/BlockSelectFloatF512.cu
similarity index 67%
rename from thirdparty/faiss/faiss/gpu/utils/blockselect/BlockSelectFloatF512.cu
rename to thirdparty/faiss/knowherefaiss/gpu/utils/blockselect/BlockSelectFloatF512.cu
index f52dffd0..96c208bf 100644
--- a/thirdparty/faiss/faiss/gpu/utils/blockselect/BlockSelectFloatF512.cu
+++ b/thirdparty/faiss/knowherefaiss/gpu/utils/blockselect/BlockSelectFloatF512.cu
@@ -5,12 +5,12 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/gpu/utils/blockselect/BlockSelectImpl.cuh>
+#include <knowherefaiss/gpu/utils/blockselect/BlockSelectImpl.cuh>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 BLOCK_SELECT_IMPL(float, false, 512, 8);
 
 }
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/utils/blockselect/BlockSelectFloatT1024.cu b/thirdparty/faiss/knowherefaiss/gpu/utils/blockselect/BlockSelectFloatT1024.cu
similarity index 67%
rename from thirdparty/faiss/faiss/gpu/utils/blockselect/BlockSelectFloatT1024.cu
rename to thirdparty/faiss/knowherefaiss/gpu/utils/blockselect/BlockSelectFloatT1024.cu
index da22fcf6..eb22d537 100644
--- a/thirdparty/faiss/faiss/gpu/utils/blockselect/BlockSelectFloatT1024.cu
+++ b/thirdparty/faiss/knowherefaiss/gpu/utils/blockselect/BlockSelectFloatT1024.cu
@@ -5,12 +5,12 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/gpu/utils/blockselect/BlockSelectImpl.cuh>
+#include <knowherefaiss/gpu/utils/blockselect/BlockSelectImpl.cuh>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 BLOCK_SELECT_IMPL(float, true, 1024, 8);
 
 }
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/utils/blockselect/BlockSelectFloatT2048.cu b/thirdparty/faiss/knowherefaiss/gpu/utils/blockselect/BlockSelectFloatT2048.cu
similarity index 64%
rename from thirdparty/faiss/faiss/gpu/utils/blockselect/BlockSelectFloatT2048.cu
rename to thirdparty/faiss/knowherefaiss/gpu/utils/blockselect/BlockSelectFloatT2048.cu
index 09d6a049..cd0d8f05 100644
--- a/thirdparty/faiss/faiss/gpu/utils/blockselect/BlockSelectFloatT2048.cu
+++ b/thirdparty/faiss/knowherefaiss/gpu/utils/blockselect/BlockSelectFloatT2048.cu
@@ -5,10 +5,10 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/gpu/utils/DeviceDefs.cuh>
-#include <faiss/gpu/utils/blockselect/BlockSelectImpl.cuh>
+#include <knowherefaiss/gpu/utils/DeviceDefs.cuh>
+#include <knowherefaiss/gpu/utils/blockselect/BlockSelectImpl.cuh>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 #if GPU_MAX_SELECTION_K >= 2048
@@ -16,4 +16,4 @@ BLOCK_SELECT_IMPL(float, true, 2048, 8);
 #endif
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/utils/blockselect/BlockSelectFloatT512.cu b/thirdparty/faiss/knowherefaiss/gpu/utils/blockselect/BlockSelectFloatT512.cu
similarity index 67%
rename from thirdparty/faiss/faiss/gpu/utils/blockselect/BlockSelectFloatT512.cu
rename to thirdparty/faiss/knowherefaiss/gpu/utils/blockselect/BlockSelectFloatT512.cu
index 2f080191..a25771a1 100644
--- a/thirdparty/faiss/faiss/gpu/utils/blockselect/BlockSelectFloatT512.cu
+++ b/thirdparty/faiss/knowherefaiss/gpu/utils/blockselect/BlockSelectFloatT512.cu
@@ -5,12 +5,12 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/gpu/utils/blockselect/BlockSelectImpl.cuh>
+#include <knowherefaiss/gpu/utils/blockselect/BlockSelectImpl.cuh>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 BLOCK_SELECT_IMPL(float, true, 512, 8);
 
 }
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/utils/blockselect/BlockSelectImpl.cuh b/thirdparty/faiss/knowherefaiss/gpu/utils/blockselect/BlockSelectImpl.cuh
similarity index 98%
rename from thirdparty/faiss/faiss/gpu/utils/blockselect/BlockSelectImpl.cuh
rename to thirdparty/faiss/knowherefaiss/gpu/utils/blockselect/BlockSelectImpl.cuh
index 6c4379a3..ce5b1c94 100644
--- a/thirdparty/faiss/faiss/gpu/utils/blockselect/BlockSelectImpl.cuh
+++ b/thirdparty/faiss/knowherefaiss/gpu/utils/blockselect/BlockSelectImpl.cuh
@@ -7,8 +7,8 @@
 
 #pragma once
 
-#include <faiss/gpu/utils/BlockSelectKernel.cuh>
-#include <faiss/gpu/utils/Limits.cuh>
+#include <knowherefaiss/gpu/utils/BlockSelectKernel.cuh>
+#include <knowherefaiss/gpu/utils/Limits.cuh>
 
 #define BLOCK_SELECT_DECL(TYPE, DIR, WARP_Q)                     \
     extern void runBlockSelect_##TYPE##_##DIR##_##WARP_Q##_(     \
diff --git a/thirdparty/faiss/faiss/gpu/utils/warpselect/WarpSelectFloat1.cu b/thirdparty/faiss/knowherefaiss/gpu/utils/warpselect/WarpSelectFloat1.cu
similarity index 71%
rename from thirdparty/faiss/faiss/gpu/utils/warpselect/WarpSelectFloat1.cu
rename to thirdparty/faiss/knowherefaiss/gpu/utils/warpselect/WarpSelectFloat1.cu
index 08f597e7..93ef7604 100644
--- a/thirdparty/faiss/faiss/gpu/utils/warpselect/WarpSelectFloat1.cu
+++ b/thirdparty/faiss/knowherefaiss/gpu/utils/warpselect/WarpSelectFloat1.cu
@@ -5,13 +5,13 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/gpu/utils/warpselect/WarpSelectImpl.cuh>
+#include <knowherefaiss/gpu/utils/warpselect/WarpSelectImpl.cuh>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 WARP_SELECT_IMPL(float, true, 1, 1);
 WARP_SELECT_IMPL(float, false, 1, 1);
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/utils/warpselect/WarpSelectFloat128.cu b/thirdparty/faiss/knowherefaiss/gpu/utils/warpselect/WarpSelectFloat128.cu
similarity index 71%
rename from thirdparty/faiss/faiss/gpu/utils/warpselect/WarpSelectFloat128.cu
rename to thirdparty/faiss/knowherefaiss/gpu/utils/warpselect/WarpSelectFloat128.cu
index ef43dc21..7cab98e9 100644
--- a/thirdparty/faiss/faiss/gpu/utils/warpselect/WarpSelectFloat128.cu
+++ b/thirdparty/faiss/knowherefaiss/gpu/utils/warpselect/WarpSelectFloat128.cu
@@ -5,13 +5,13 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/gpu/utils/warpselect/WarpSelectImpl.cuh>
+#include <knowherefaiss/gpu/utils/warpselect/WarpSelectImpl.cuh>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 WARP_SELECT_IMPL(float, true, 128, 3);
 WARP_SELECT_IMPL(float, false, 128, 3);
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/utils/warpselect/WarpSelectFloat256.cu b/thirdparty/faiss/knowherefaiss/gpu/utils/warpselect/WarpSelectFloat256.cu
similarity index 71%
rename from thirdparty/faiss/faiss/gpu/utils/warpselect/WarpSelectFloat256.cu
rename to thirdparty/faiss/knowherefaiss/gpu/utils/warpselect/WarpSelectFloat256.cu
index c7456351..c02e1ec0 100644
--- a/thirdparty/faiss/faiss/gpu/utils/warpselect/WarpSelectFloat256.cu
+++ b/thirdparty/faiss/knowherefaiss/gpu/utils/warpselect/WarpSelectFloat256.cu
@@ -5,13 +5,13 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/gpu/utils/warpselect/WarpSelectImpl.cuh>
+#include <knowherefaiss/gpu/utils/warpselect/WarpSelectImpl.cuh>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 WARP_SELECT_IMPL(float, true, 256, 4);
 WARP_SELECT_IMPL(float, false, 256, 4);
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/utils/warpselect/WarpSelectFloat32.cu b/thirdparty/faiss/knowherefaiss/gpu/utils/warpselect/WarpSelectFloat32.cu
similarity index 71%
rename from thirdparty/faiss/faiss/gpu/utils/warpselect/WarpSelectFloat32.cu
rename to thirdparty/faiss/knowherefaiss/gpu/utils/warpselect/WarpSelectFloat32.cu
index 183ae49c..6215e074 100644
--- a/thirdparty/faiss/faiss/gpu/utils/warpselect/WarpSelectFloat32.cu
+++ b/thirdparty/faiss/knowherefaiss/gpu/utils/warpselect/WarpSelectFloat32.cu
@@ -5,13 +5,13 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/gpu/utils/warpselect/WarpSelectImpl.cuh>
+#include <knowherefaiss/gpu/utils/warpselect/WarpSelectImpl.cuh>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 WARP_SELECT_IMPL(float, true, 32, 2);
 WARP_SELECT_IMPL(float, false, 32, 2);
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/utils/warpselect/WarpSelectFloat64.cu b/thirdparty/faiss/knowherefaiss/gpu/utils/warpselect/WarpSelectFloat64.cu
similarity index 71%
rename from thirdparty/faiss/faiss/gpu/utils/warpselect/WarpSelectFloat64.cu
rename to thirdparty/faiss/knowherefaiss/gpu/utils/warpselect/WarpSelectFloat64.cu
index 30099344..91eb6d94 100644
--- a/thirdparty/faiss/faiss/gpu/utils/warpselect/WarpSelectFloat64.cu
+++ b/thirdparty/faiss/knowherefaiss/gpu/utils/warpselect/WarpSelectFloat64.cu
@@ -5,13 +5,13 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/gpu/utils/warpselect/WarpSelectImpl.cuh>
+#include <knowherefaiss/gpu/utils/warpselect/WarpSelectImpl.cuh>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 WARP_SELECT_IMPL(float, true, 64, 3);
 WARP_SELECT_IMPL(float, false, 64, 3);
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/utils/warpselect/WarpSelectFloatF1024.cu b/thirdparty/faiss/knowherefaiss/gpu/utils/warpselect/WarpSelectFloatF1024.cu
similarity index 67%
rename from thirdparty/faiss/faiss/gpu/utils/warpselect/WarpSelectFloatF1024.cu
rename to thirdparty/faiss/knowherefaiss/gpu/utils/warpselect/WarpSelectFloatF1024.cu
index 2a671af4..29642d0a 100644
--- a/thirdparty/faiss/faiss/gpu/utils/warpselect/WarpSelectFloatF1024.cu
+++ b/thirdparty/faiss/knowherefaiss/gpu/utils/warpselect/WarpSelectFloatF1024.cu
@@ -5,12 +5,12 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/gpu/utils/warpselect/WarpSelectImpl.cuh>
+#include <knowherefaiss/gpu/utils/warpselect/WarpSelectImpl.cuh>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 WARP_SELECT_IMPL(float, false, 1024, 8);
 
 }
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/utils/warpselect/WarpSelectFloatF2048.cu b/thirdparty/faiss/knowherefaiss/gpu/utils/warpselect/WarpSelectFloatF2048.cu
similarity index 64%
rename from thirdparty/faiss/faiss/gpu/utils/warpselect/WarpSelectFloatF2048.cu
rename to thirdparty/faiss/knowherefaiss/gpu/utils/warpselect/WarpSelectFloatF2048.cu
index 0bef8b21..b7b1ced7 100644
--- a/thirdparty/faiss/faiss/gpu/utils/warpselect/WarpSelectFloatF2048.cu
+++ b/thirdparty/faiss/knowherefaiss/gpu/utils/warpselect/WarpSelectFloatF2048.cu
@@ -5,10 +5,10 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/gpu/utils/DeviceDefs.cuh>
-#include <faiss/gpu/utils/warpselect/WarpSelectImpl.cuh>
+#include <knowherefaiss/gpu/utils/DeviceDefs.cuh>
+#include <knowherefaiss/gpu/utils/warpselect/WarpSelectImpl.cuh>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 #if GPU_MAX_SELECTION_K >= 2048
@@ -16,4 +16,4 @@ WARP_SELECT_IMPL(float, false, 2048, 8);
 #endif
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/utils/warpselect/WarpSelectFloatF512.cu b/thirdparty/faiss/knowherefaiss/gpu/utils/warpselect/WarpSelectFloatF512.cu
similarity index 67%
rename from thirdparty/faiss/faiss/gpu/utils/warpselect/WarpSelectFloatF512.cu
rename to thirdparty/faiss/knowherefaiss/gpu/utils/warpselect/WarpSelectFloatF512.cu
index b8f2f1b7..619ca3e4 100644
--- a/thirdparty/faiss/faiss/gpu/utils/warpselect/WarpSelectFloatF512.cu
+++ b/thirdparty/faiss/knowherefaiss/gpu/utils/warpselect/WarpSelectFloatF512.cu
@@ -5,12 +5,12 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/gpu/utils/warpselect/WarpSelectImpl.cuh>
+#include <knowherefaiss/gpu/utils/warpselect/WarpSelectImpl.cuh>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 WARP_SELECT_IMPL(float, false, 512, 8);
 
 }
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/utils/warpselect/WarpSelectFloatT1024.cu b/thirdparty/faiss/knowherefaiss/gpu/utils/warpselect/WarpSelectFloatT1024.cu
similarity index 67%
rename from thirdparty/faiss/faiss/gpu/utils/warpselect/WarpSelectFloatT1024.cu
rename to thirdparty/faiss/knowherefaiss/gpu/utils/warpselect/WarpSelectFloatT1024.cu
index a9d5b345..e7ba0879 100644
--- a/thirdparty/faiss/faiss/gpu/utils/warpselect/WarpSelectFloatT1024.cu
+++ b/thirdparty/faiss/knowherefaiss/gpu/utils/warpselect/WarpSelectFloatT1024.cu
@@ -5,12 +5,12 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/gpu/utils/warpselect/WarpSelectImpl.cuh>
+#include <knowherefaiss/gpu/utils/warpselect/WarpSelectImpl.cuh>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 WARP_SELECT_IMPL(float, true, 1024, 8);
 
 }
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/utils/warpselect/WarpSelectFloatT2048.cu b/thirdparty/faiss/knowherefaiss/gpu/utils/warpselect/WarpSelectFloatT2048.cu
similarity index 64%
rename from thirdparty/faiss/faiss/gpu/utils/warpselect/WarpSelectFloatT2048.cu
rename to thirdparty/faiss/knowherefaiss/gpu/utils/warpselect/WarpSelectFloatT2048.cu
index 13621aad..62ec7974 100644
--- a/thirdparty/faiss/faiss/gpu/utils/warpselect/WarpSelectFloatT2048.cu
+++ b/thirdparty/faiss/knowherefaiss/gpu/utils/warpselect/WarpSelectFloatT2048.cu
@@ -5,10 +5,10 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/gpu/utils/DeviceDefs.cuh>
-#include <faiss/gpu/utils/warpselect/WarpSelectImpl.cuh>
+#include <knowherefaiss/gpu/utils/DeviceDefs.cuh>
+#include <knowherefaiss/gpu/utils/warpselect/WarpSelectImpl.cuh>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 #if GPU_MAX_SELECTION_K >= 2048
@@ -16,4 +16,4 @@ WARP_SELECT_IMPL(float, true, 2048, 8);
 #endif
 
 } // namespace gpu
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/utils/warpselect/WarpSelectFloatT512.cu b/thirdparty/faiss/knowherefaiss/gpu/utils/warpselect/WarpSelectFloatT512.cu
similarity index 67%
rename from thirdparty/faiss/faiss/gpu/utils/warpselect/WarpSelectFloatT512.cu
rename to thirdparty/faiss/knowherefaiss/gpu/utils/warpselect/WarpSelectFloatT512.cu
index 00c98789..45023e52 100644
--- a/thirdparty/faiss/faiss/gpu/utils/warpselect/WarpSelectFloatT512.cu
+++ b/thirdparty/faiss/knowherefaiss/gpu/utils/warpselect/WarpSelectFloatT512.cu
@@ -5,12 +5,12 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/gpu/utils/warpselect/WarpSelectImpl.cuh>
+#include <knowherefaiss/gpu/utils/warpselect/WarpSelectImpl.cuh>
 
-namespace faiss {
+namespace knowherefaiss {
 namespace gpu {
 
 WARP_SELECT_IMPL(float, true, 512, 8);
 
 }
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/gpu/utils/warpselect/WarpSelectImpl.cuh b/thirdparty/faiss/knowherefaiss/gpu/utils/warpselect/WarpSelectImpl.cuh
similarity index 96%
rename from thirdparty/faiss/faiss/gpu/utils/warpselect/WarpSelectImpl.cuh
rename to thirdparty/faiss/knowherefaiss/gpu/utils/warpselect/WarpSelectImpl.cuh
index e705a52b..4fd37f88 100644
--- a/thirdparty/faiss/faiss/gpu/utils/warpselect/WarpSelectImpl.cuh
+++ b/thirdparty/faiss/knowherefaiss/gpu/utils/warpselect/WarpSelectImpl.cuh
@@ -5,8 +5,8 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/gpu/utils/Limits.cuh>
-#include <faiss/gpu/utils/WarpSelectKernel.cuh>
+#include <knowherefaiss/gpu/utils/Limits.cuh>
+#include <knowherefaiss/gpu/utils/WarpSelectKernel.cuh>
 
 #define WARP_SELECT_DECL(TYPE, DIR, WARP_Q)                 \
     extern void runWarpSelect_##TYPE##_##DIR##_##WARP_Q##_( \
diff --git a/thirdparty/faiss/faiss/impl/AdditiveQuantizer.cpp b/thirdparty/faiss/knowherefaiss/impl/AdditiveQuantizer.cpp
similarity index 97%
rename from thirdparty/faiss/faiss/impl/AdditiveQuantizer.cpp
rename to thirdparty/faiss/knowherefaiss/impl/AdditiveQuantizer.cpp
index eea6be77..c0c65c92 100644
--- a/thirdparty/faiss/faiss/impl/AdditiveQuantizer.cpp
+++ b/thirdparty/faiss/knowherefaiss/impl/AdditiveQuantizer.cpp
@@ -7,7 +7,7 @@
 
 // -*- c++ -*-
 
-#include <faiss/impl/AdditiveQuantizer.h>
+#include <knowherefaiss/impl/AdditiveQuantizer.h>
 
 #include <cstddef>
 #include <cstdio>
@@ -17,15 +17,15 @@
 
 #include <algorithm>
 
-#include <faiss/Clustering.h>
-#include <faiss/FaissHook.h>
-#include <faiss/impl/FaissAssert.h>
-#include <faiss/impl/LocalSearchQuantizer.h>
-#include <faiss/impl/ResidualQuantizer.h>
-#include <faiss/utils/Heap.h>
-#include <faiss/utils/distances.h>
-#include <faiss/utils/hamming.h>
-#include <faiss/utils/utils.h>
+#include <knowherefaiss/Clustering.h>
+#include <knowherefaiss/FaissHook.h>
+#include <knowherefaiss/impl/FaissAssert.h>
+#include <knowherefaiss/impl/LocalSearchQuantizer.h>
+#include <knowherefaiss/impl/ResidualQuantizer.h>
+#include <knowherefaiss/utils/Heap.h>
+#include <knowherefaiss/utils/distances.h>
+#include <knowherefaiss/utils/hamming.h>
+#include <knowherefaiss/utils/utils.h>
 
 extern "C" {
 
@@ -46,7 +46,7 @@ int sgemm_(
         FINTEGER* ldc);
 }
 
-namespace faiss {
+namespace knowherefaiss {
 
 AdditiveQuantizer::AdditiveQuantizer(
         size_t d,
@@ -565,4 +565,4 @@ float AdditiveQuantizer::
     return norm2 - 2 * accu;
 }
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/impl/AdditiveQuantizer.h b/thirdparty/faiss/knowherefaiss/impl/AdditiveQuantizer.h
similarity index 97%
rename from thirdparty/faiss/faiss/impl/AdditiveQuantizer.h
rename to thirdparty/faiss/knowherefaiss/impl/AdditiveQuantizer.h
index 8eceabe5..c4a89a30 100644
--- a/thirdparty/faiss/faiss/impl/AdditiveQuantizer.h
+++ b/thirdparty/faiss/knowherefaiss/impl/AdditiveQuantizer.h
@@ -11,11 +11,11 @@
 #include <cstdint>
 #include <vector>
 
-#include <faiss/Index.h>
-#include <faiss/IndexFlat.h>
-#include <faiss/impl/Quantizer.h>
+#include <knowherefaiss/Index.h>
+#include <knowherefaiss/IndexFlat.h>
+#include <knowherefaiss/impl/Quantizer.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 /** Abstract structure for additive quantizers
  *
@@ -203,4 +203,4 @@ struct AdditiveQuantizer : Quantizer {
     virtual ~AdditiveQuantizer();
 };
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/impl/AuxIndexStructures.cpp b/thirdparty/faiss/knowherefaiss/impl/AuxIndexStructures.cpp
similarity index 96%
rename from thirdparty/faiss/faiss/impl/AuxIndexStructures.cpp
rename to thirdparty/faiss/knowherefaiss/impl/AuxIndexStructures.cpp
index e2b2791e..62e18b98 100644
--- a/thirdparty/faiss/faiss/impl/AuxIndexStructures.cpp
+++ b/thirdparty/faiss/knowherefaiss/impl/AuxIndexStructures.cpp
@@ -10,11 +10,11 @@
 #include <algorithm>
 #include <cstring>
 
-#include <faiss/impl/AuxIndexStructures.h>
+#include <knowherefaiss/impl/AuxIndexStructures.h>
 
-#include <faiss/impl/FaissAssert.h>
+#include <knowherefaiss/impl/FaissAssert.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 /***********************************************************************
  * RangeSearchResult
@@ -256,9 +256,9 @@ bool TimeoutCallback::want_interrupt() {
 }
 
 void TimeoutCallback::reset(double timeout_in_seconds) {
-    auto tc(new faiss::TimeoutCallback());
-    faiss::InterruptCallback::instance.reset(tc);
+    auto tc(new knowherefaiss::TimeoutCallback());
+    knowherefaiss::InterruptCallback::instance.reset(tc);
     tc->set_timeout(timeout_in_seconds);
 }
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/impl/AuxIndexStructures.h b/thirdparty/faiss/knowherefaiss/impl/AuxIndexStructures.h
similarity index 97%
rename from thirdparty/faiss/faiss/impl/AuxIndexStructures.h
rename to thirdparty/faiss/knowherefaiss/impl/AuxIndexStructures.h
index 7e12a1a3..175bc56e 100644
--- a/thirdparty/faiss/faiss/impl/AuxIndexStructures.h
+++ b/thirdparty/faiss/knowherefaiss/impl/AuxIndexStructures.h
@@ -18,10 +18,10 @@
 #include <mutex>
 #include <vector>
 
-#include <faiss/MetricType.h>
-#include <faiss/impl/platform_macros.h>
+#include <knowherefaiss/MetricType.h>
+#include <knowherefaiss/impl/platform_macros.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 /** The objective is to have a simple result structure while
  *  minimizing the number of mem copies in the result. The method
@@ -197,6 +197,6 @@ struct VisitedTable {
     }
 };
 
-} // namespace faiss
+} // namespace knowherefaiss
 
 #endif
diff --git a/thirdparty/faiss/faiss/impl/CodePacker.cpp b/thirdparty/faiss/knowherefaiss/impl/CodePacker.cpp
similarity index 94%
rename from thirdparty/faiss/faiss/impl/CodePacker.cpp
rename to thirdparty/faiss/knowherefaiss/impl/CodePacker.cpp
index 36dbf526..57473217 100644
--- a/thirdparty/faiss/faiss/impl/CodePacker.cpp
+++ b/thirdparty/faiss/knowherefaiss/impl/CodePacker.cpp
@@ -5,12 +5,12 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/impl/CodePacker.h>
+#include <knowherefaiss/impl/CodePacker.h>
 
 #include <cassert>
 #include <cstring>
 
-namespace faiss {
+namespace knowherefaiss {
 
 /*********************************************
  * CodePacker
@@ -64,4 +64,4 @@ void CodePackerFlat::unpack_1(
     unpack_all(block, flat_code);
 }
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/impl/CodePacker.h b/thirdparty/faiss/knowherefaiss/impl/CodePacker.h
similarity index 96%
rename from thirdparty/faiss/faiss/impl/CodePacker.h
rename to thirdparty/faiss/knowherefaiss/impl/CodePacker.h
index 84c323ed..6948c44b 100644
--- a/thirdparty/faiss/faiss/impl/CodePacker.h
+++ b/thirdparty/faiss/knowherefaiss/impl/CodePacker.h
@@ -7,9 +7,9 @@
 
 #pragma once
 
-#include <faiss/MetricType.h>
+#include <knowherefaiss/MetricType.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 /**
  * Packing consists in combining a fixed number of codes of constant size
@@ -68,4 +68,4 @@ struct CodePackerFlat : CodePacker {
     void unpack_all(const uint8_t* block, uint8_t* flat_codes) const final;
 };
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/impl/DistanceComputer.h b/thirdparty/faiss/knowherefaiss/impl/DistanceComputer.h
similarity index 97%
rename from thirdparty/faiss/faiss/impl/DistanceComputer.h
rename to thirdparty/faiss/knowherefaiss/impl/DistanceComputer.h
index 5ac3a702..85b8c577 100644
--- a/thirdparty/faiss/faiss/impl/DistanceComputer.h
+++ b/thirdparty/faiss/knowherefaiss/impl/DistanceComputer.h
@@ -7,9 +7,9 @@
 
 #pragma once
 
-#include <faiss/Index.h>
+#include <knowherefaiss/Index.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 /***********************************************************
  * The distance computer maintains a current query and computes
@@ -128,4 +128,4 @@ struct FlatCodesDistanceComputer : DistanceComputer {
     virtual ~FlatCodesDistanceComputer() {}
 };
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/impl/FaissAssert.h b/thirdparty/faiss/knowherefaiss/impl/FaissAssert.h
similarity index 94%
rename from thirdparty/faiss/faiss/impl/FaissAssert.h
rename to thirdparty/faiss/knowherefaiss/impl/FaissAssert.h
index 9d357823..59a575fc 100644
--- a/thirdparty/faiss/faiss/impl/FaissAssert.h
+++ b/thirdparty/faiss/knowherefaiss/impl/FaissAssert.h
@@ -10,8 +10,8 @@
 #ifndef FAISS_ASSERT_INCLUDED
 #define FAISS_ASSERT_INCLUDED
 
-#include <faiss/impl/FaissException.h>
-#include <faiss/impl/platform_macros.h>
+#include <knowherefaiss/impl/FaissException.h>
+#include <knowherefaiss/impl/platform_macros.h>
 #include <cstdio>
 #include <cstdlib>
 #include <string>
@@ -69,7 +69,7 @@
 
 #define FAISS_THROW_MSG(MSG)                                   \
     do {                                                       \
-        throw faiss::FaissException(                           \
+        throw knowherefaiss::FaissException(                           \
                 MSG, __PRETTY_FUNCTION__, __FILE__, __LINE__); \
     } while (false)
 
@@ -79,7 +79,7 @@
         int __size = snprintf(nullptr, 0, FMT, __VA_ARGS__);   \
         __s.resize(__size + 1);                                \
         snprintf(&__s[0], __s.size(), FMT, __VA_ARGS__);       \
-        throw faiss::FaissException(                           \
+        throw knowherefaiss::FaissException(                           \
                 __s, __PRETTY_FUNCTION__, __FILE__, __LINE__); \
     } while (false)
 
diff --git a/thirdparty/faiss/faiss/impl/FaissException.cpp b/thirdparty/faiss/knowherefaiss/impl/FaissException.cpp
similarity index 96%
rename from thirdparty/faiss/faiss/impl/FaissException.cpp
rename to thirdparty/faiss/knowherefaiss/impl/FaissException.cpp
index 3dcf47a5..753bfcee 100644
--- a/thirdparty/faiss/faiss/impl/FaissException.cpp
+++ b/thirdparty/faiss/knowherefaiss/impl/FaissException.cpp
@@ -7,14 +7,14 @@
 
 // -*- c++ -*-
 
-#include <faiss/impl/FaissException.h>
+#include <knowherefaiss/impl/FaissException.h>
 #include <sstream>
 
 #ifdef __GNUG__
 #include <cxxabi.h>
 #endif
 
-namespace faiss {
+namespace knowherefaiss {
 
 FaissException::FaissException(const std::string& m) : msg(m) {}
 
@@ -97,4 +97,4 @@ std::string demangle_cpp_symbol(const char* name) {
 #endif
 }
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/impl/FaissException.h b/thirdparty/faiss/knowherefaiss/impl/FaissException.h
similarity index 96%
rename from thirdparty/faiss/faiss/impl/FaissException.h
rename to thirdparty/faiss/knowherefaiss/impl/FaissException.h
index b2774e85..16b690fe 100644
--- a/thirdparty/faiss/faiss/impl/FaissException.h
+++ b/thirdparty/faiss/knowherefaiss/impl/FaissException.h
@@ -16,7 +16,7 @@
 #include <utility>
 #include <vector>
 
-namespace faiss {
+namespace knowherefaiss {
 
 /// Base class for Faiss exceptions
 class FaissException : public std::exception {
@@ -61,6 +61,6 @@ struct TransformedVectors {
 /// make typeids more readable
 std::string demangle_cpp_symbol(const char* name);
 
-} // namespace faiss
+} // namespace knowherefaiss
 
 #endif
diff --git a/thirdparty/faiss/faiss/impl/HNSW.cpp b/thirdparty/faiss/knowherefaiss/impl/HNSW.cpp
similarity index 97%
rename from thirdparty/faiss/faiss/impl/HNSW.cpp
rename to thirdparty/faiss/knowherefaiss/impl/HNSW.cpp
index 463f26a8..80473739 100644
--- a/thirdparty/faiss/faiss/impl/HNSW.cpp
+++ b/thirdparty/faiss/knowherefaiss/impl/HNSW.cpp
@@ -5,18 +5,18 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/impl/HNSW.h>
+#include <knowherefaiss/impl/HNSW.h>
 
 #include <cstddef>
 #include <string>
 
-#include <faiss/impl/AuxIndexStructures.h>
-#include <faiss/impl/DistanceComputer.h>
-#include <faiss/impl/IDSelector.h>
-#include <faiss/impl/ResultHandler.h>
-#include <faiss/utils/prefetch.h>
+#include <knowherefaiss/impl/AuxIndexStructures.h>
+#include <knowherefaiss/impl/DistanceComputer.h>
+#include <knowherefaiss/impl/IDSelector.h>
+#include <knowherefaiss/impl/ResultHandler.h>
+#include <knowherefaiss/utils/prefetch.h>
 
-#include <faiss/impl/platform_macros.h>
+#include <knowherefaiss/impl/platform_macros.h>
 
 #ifdef __AVX2__
 #include <immintrin.h>
@@ -25,7 +25,7 @@
 #include <type_traits>
 #endif
 
-namespace faiss {
+namespace knowherefaiss {
 
 /**************************************************************
  * HNSW structure implementation
@@ -235,7 +235,7 @@ void HNSW::shrink_neighbor_list(
     // This prevents number of neighbors at
     // level 0 from being shrunk to less than 2 * M.
     // This is essential in making sure
-    // `faiss::gpu::GpuIndexCagra::copyFrom(IndexHNSWCagra*)` is functional
+    // `knowherefaiss::gpu::GpuIndexCagra::copyFrom(IndexHNSWCagra*)` is functional
     std::vector<NodeDistFarther> outsiders;
 
     while (input.size() > 0) {
@@ -571,7 +571,7 @@ void HNSW::add_links_starting_from(
     // but we can afford only this many neighbors
     int M = nb_neighbors(level);
 
-    ::faiss::shrink_neighbor_list(ptdis, link_targets, M, keep_max_size_level0);
+    ::knowherefaiss::shrink_neighbor_list(ptdis, link_targets, M, keep_max_size_level0);
 
     std::vector<storage_idx_t> neighbors;
     neighbors.reserve(link_targets.size());
@@ -725,9 +725,9 @@ int search_from_candidates(
         //     float d = qdis(v1);
         //     if (!sel || sel->is_member(v1)) {
         //         if (nres < k) {
-        //             faiss::maxheap_push(++nres, D, I, d, v1);
+        //             knowherefaiss::maxheap_push(++nres, D, I, d, v1);
         //         } else if (d < D[0]) {
-        //             faiss::maxheap_replace_top(nres, D, I, d, v1);
+        //             knowherefaiss::maxheap_replace_top(nres, D, I, d, v1);
         //         }
         //     }
         //     candidates.push(v1, d);
@@ -1170,9 +1170,9 @@ void HNSW::MinimaxHeap::push(storage_idx_t i, float v) {
         if (ids[0] != -1) {
             --nvalid;
         }
-        faiss::heap_pop<HC>(k--, dis.data(), ids.data());
+        knowherefaiss::heap_pop<HC>(k--, dis.data(), ids.data());
     }
-    faiss::heap_push<HC>(++k, dis.data(), ids.data(), v, i);
+    knowherefaiss::heap_push<HC>(++k, dis.data(), ids.data(), v, i);
     ++nvalid;
 }
 
@@ -1411,4 +1411,4 @@ int HNSW::MinimaxHeap::count_below(float thresh) {
     return n_below;
 }
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/impl/HNSW.h b/thirdparty/faiss/knowherefaiss/impl/HNSW.h
similarity index 94%
rename from thirdparty/faiss/faiss/impl/HNSW.h
rename to thirdparty/faiss/knowherefaiss/impl/HNSW.h
index 9076f885..bed8a0ce 100644
--- a/thirdparty/faiss/faiss/impl/HNSW.h
+++ b/thirdparty/faiss/knowherefaiss/impl/HNSW.h
@@ -13,14 +13,14 @@
 
 #include <omp.h>
 
-#include <faiss/Index.h>
-#include <faiss/impl/FaissAssert.h>
-#include <faiss/impl/maybe_owned_vector.h>
-#include <faiss/impl/platform_macros.h>
-#include <faiss/utils/Heap.h>
-#include <faiss/utils/random.h>
+#include <knowherefaiss/Index.h>
+#include <knowherefaiss/impl/FaissAssert.h>
+#include <knowherefaiss/impl/maybe_owned_vector.h>
+#include <knowherefaiss/impl/platform_macros.h>
+#include <knowherefaiss/utils/Heap.h>
+#include <knowherefaiss/utils/random.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 /** Implementation of the Hierarchical Navigable Small World
  * datastructure.
@@ -69,7 +69,7 @@ struct HNSW {
 
         std::vector<storage_idx_t> ids;
         std::vector<float> dis;
-        typedef faiss::CMax<float, storage_idx_t> HC;
+        typedef knowherefaiss::CMax<float, storage_idx_t> HC;
 
         explicit MinimaxHeap(int n) : n(n), k(0), nvalid(0), ids(n), dis(n) {}
 
@@ -127,7 +127,7 @@ struct HNSW {
     /// level
     storage_idx_t entry_point = -1;
 
-    faiss::RandomGenerator rng;
+    knowherefaiss::RandomGenerator rng;
 
     /// maximum level
     int max_level = -1;
@@ -258,4 +258,4 @@ struct HNSWStats {
 // global var that collects them all
 FAISS_API extern HNSWStats hnsw_stats;
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/impl/IDSelector.cpp b/thirdparty/faiss/knowherefaiss/impl/IDSelector.cpp
similarity index 95%
rename from thirdparty/faiss/faiss/impl/IDSelector.cpp
rename to thirdparty/faiss/knowherefaiss/impl/IDSelector.cpp
index e4a4bba9..84abd2b3 100644
--- a/thirdparty/faiss/faiss/impl/IDSelector.cpp
+++ b/thirdparty/faiss/knowherefaiss/impl/IDSelector.cpp
@@ -5,10 +5,10 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/impl/FaissAssert.h>
-#include <faiss/impl/IDSelector.h>
+#include <knowherefaiss/impl/FaissAssert.h>
+#include <knowherefaiss/impl/IDSelector.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 /***********************************************************************
  * IDSelectorRange
@@ -122,4 +122,4 @@ bool IDSelectorBitmap::is_member(idx_t ii) const {
     return (bitmap[i >> 3] >> (i & 7)) & 1;
 }
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/impl/IDSelector.h b/thirdparty/faiss/knowherefaiss/impl/IDSelector.h
similarity index 98%
rename from thirdparty/faiss/faiss/impl/IDSelector.h
rename to thirdparty/faiss/knowherefaiss/impl/IDSelector.h
index 2966881e..92020d35 100644
--- a/thirdparty/faiss/faiss/impl/IDSelector.h
+++ b/thirdparty/faiss/knowherefaiss/impl/IDSelector.h
@@ -10,12 +10,12 @@
 #include <unordered_set>
 #include <vector>
 
-#include <faiss/MetricType.h>
+#include <knowherefaiss/MetricType.h>
 
 /** IDSelector is intended to define a subset of vectors to handle (for removal
  * or as subset to search) */
 
-namespace faiss {
+namespace knowherefaiss {
 
 /** Encapsulates a set of ids to handle. */
 struct IDSelector {
@@ -170,4 +170,4 @@ struct IDSelectorXOr : IDSelector {
     virtual ~IDSelectorXOr() {}
 };
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/impl/LocalSearchQuantizer.cpp b/thirdparty/faiss/knowherefaiss/impl/LocalSearchQuantizer.cpp
similarity index 97%
rename from thirdparty/faiss/faiss/impl/LocalSearchQuantizer.cpp
rename to thirdparty/faiss/knowherefaiss/impl/LocalSearchQuantizer.cpp
index 639e32bd..b4bcdc1e 100644
--- a/thirdparty/faiss/faiss/impl/LocalSearchQuantizer.cpp
+++ b/thirdparty/faiss/knowherefaiss/impl/LocalSearchQuantizer.cpp
@@ -5,7 +5,7 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/impl/LocalSearchQuantizer.h>
+#include <knowherefaiss/impl/LocalSearchQuantizer.h>
 
 #include <cstddef>
 #include <cstdio>
@@ -15,16 +15,16 @@
 
 #include <algorithm>
 
-#include <faiss/impl/AuxIndexStructures.h>
-#include <faiss/impl/FaissAssert.h>
-#include <faiss/utils/distances.h>
-#include <faiss/utils/hamming.h> // BitstringWriter
-#include <faiss/utils/utils.h>
+#include <knowherefaiss/impl/AuxIndexStructures.h>
+#include <knowherefaiss/impl/FaissAssert.h>
+#include <knowherefaiss/utils/distances.h>
+#include <knowherefaiss/utils/hamming.h> // BitstringWriter
+#include <knowherefaiss/utils/utils.h>
 
-#include <faiss/utils/approx_topk/approx_topk.h>
+#include <knowherefaiss/utils/approx_topk/approx_topk.h>
 
 // this is needed for prefetching
-#include <faiss/impl/platform_macros.h>
+#include <knowherefaiss/impl/platform_macros.h>
 
 // todo aguzhva: is it needed?
 #ifdef __AVX2__
@@ -151,7 +151,7 @@ void random_int32(
 
 } // anonymous namespace
 
-namespace faiss {
+namespace knowherefaiss {
 
 lsq::LSQTimer lsq_timer;
 using lsq::LSQTimerScope;
@@ -774,7 +774,7 @@ float LocalSearchQuantizer::evaluate(
             fvec_add(d, decoded_i, c, decoded_i);
         }
 
-        float err = faiss::fvec_L2sqr(x + i * d, decoded_i, d);
+        float err = knowherefaiss::fvec_L2sqr(x + i * d, decoded_i, d);
         obj += err;
 
         if (objs) {
@@ -846,4 +846,4 @@ LSQTimerScope::~LSQTimerScope() {
 
 } // namespace lsq
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/impl/LocalSearchQuantizer.h b/thirdparty/faiss/knowherefaiss/impl/LocalSearchQuantizer.h
similarity index 97%
rename from thirdparty/faiss/faiss/impl/LocalSearchQuantizer.h
rename to thirdparty/faiss/knowherefaiss/impl/LocalSearchQuantizer.h
index 3904d349..f1b54568 100644
--- a/thirdparty/faiss/faiss/impl/LocalSearchQuantizer.h
+++ b/thirdparty/faiss/knowherefaiss/impl/LocalSearchQuantizer.h
@@ -14,11 +14,11 @@
 #include <unordered_map>
 #include <vector>
 
-#include <faiss/impl/AdditiveQuantizer.h>
-#include <faiss/impl/platform_macros.h>
-#include <faiss/utils/utils.h>
+#include <knowherefaiss/impl/AdditiveQuantizer.h>
+#include <knowherefaiss/impl/platform_macros.h>
+#include <knowherefaiss/utils/utils.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 namespace lsq {
 
@@ -245,4 +245,4 @@ struct LSQTimerScope {
 
 } // namespace lsq
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/impl/LookupTableScaler.h b/thirdparty/faiss/knowherefaiss/impl/LookupTableScaler.h
similarity index 95%
rename from thirdparty/faiss/faiss/impl/LookupTableScaler.h
rename to thirdparty/faiss/knowherefaiss/impl/LookupTableScaler.h
index c553a0f1..7bd84746 100644
--- a/thirdparty/faiss/faiss/impl/LookupTableScaler.h
+++ b/thirdparty/faiss/knowherefaiss/impl/LookupTableScaler.h
@@ -10,14 +10,14 @@
 #include <cstdint>
 #include <cstdlib>
 
-#include <faiss/utils/simdlib.h>
+#include <knowherefaiss/utils/simdlib.h>
 
 /*******************************************
  * The Scaler objects are used to specialize the handling of the
  * norm components in Additive quantizer fast-scan.
  ********************************************/
 
-namespace faiss {
+namespace knowherefaiss {
 
 /// no-op handler
 struct DummyScaler {
@@ -74,4 +74,4 @@ struct NormTableScaler {
     }
 };
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/impl/NNDescent.cpp b/thirdparty/faiss/knowherefaiss/impl/NNDescent.cpp
similarity index 98%
rename from thirdparty/faiss/faiss/impl/NNDescent.cpp
rename to thirdparty/faiss/knowherefaiss/impl/NNDescent.cpp
index 5afcdaf5..9eccde89 100644
--- a/thirdparty/faiss/faiss/impl/NNDescent.cpp
+++ b/thirdparty/faiss/knowherefaiss/impl/NNDescent.cpp
@@ -7,15 +7,15 @@
 
 // -*- c++ -*-
 
-#include <faiss/impl/NNDescent.h>
+#include <knowherefaiss/impl/NNDescent.h>
 
 #include <mutex>
 #include <string>
 
-#include <faiss/impl/AuxIndexStructures.h>
-#include <faiss/impl/DistanceComputer.h>
+#include <knowherefaiss/impl/AuxIndexStructures.h>
+#include <knowherefaiss/impl/DistanceComputer.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 using LockGuard = std::lock_guard<std::mutex>;
 
@@ -494,4 +494,4 @@ void NNDescent::reset() {
     final_graph.resize(0);
 }
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/impl/NNDescent.h b/thirdparty/faiss/knowherefaiss/impl/NNDescent.h
similarity index 93%
rename from thirdparty/faiss/faiss/impl/NNDescent.h
rename to thirdparty/faiss/knowherefaiss/impl/NNDescent.h
index 2426b0d7..218cff1f 100644
--- a/thirdparty/faiss/faiss/impl/NNDescent.h
+++ b/thirdparty/faiss/knowherefaiss/impl/NNDescent.h
@@ -18,13 +18,13 @@
 
 #include <omp.h>
 
-#include <faiss/Index.h>
-#include <faiss/impl/FaissAssert.h>
-#include <faiss/impl/platform_macros.h>
-#include <faiss/utils/Heap.h>
-#include <faiss/utils/random.h>
+#include <knowherefaiss/Index.h>
+#include <knowherefaiss/impl/FaissAssert.h>
+#include <knowherefaiss/impl/platform_macros.h>
+#include <knowherefaiss/utils/Heap.h>
+#include <knowherefaiss/utils/random.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 /** Implementation of NNDescent which is one of the most popular
  *  KNN graph building algorithms
@@ -151,4 +151,4 @@ struct NNDescent {
     std::vector<int> final_graph;
 };
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/impl/NSG.cpp b/thirdparty/faiss/knowherefaiss/impl/NSG.cpp
similarity index 99%
rename from thirdparty/faiss/faiss/impl/NSG.cpp
rename to thirdparty/faiss/knowherefaiss/impl/NSG.cpp
index c9749433..0e7b13bf 100644
--- a/thirdparty/faiss/faiss/impl/NSG.cpp
+++ b/thirdparty/faiss/knowherefaiss/impl/NSG.cpp
@@ -7,16 +7,16 @@
 
 // -*- c++ -*-
 
-#include <faiss/impl/NSG.h>
+#include <knowherefaiss/impl/NSG.h>
 
 #include <algorithm>
 #include <memory>
 #include <mutex>
 #include <stack>
 
-#include <faiss/impl/DistanceComputer.h>
+#include <knowherefaiss/impl/DistanceComputer.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 namespace nsg {
 
@@ -642,4 +642,4 @@ void NSG::check_graph() const {
     }
 }
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/impl/NSG.h b/thirdparty/faiss/knowherefaiss/impl/NSG.h
similarity index 95%
rename from thirdparty/faiss/faiss/impl/NSG.h
rename to thirdparty/faiss/knowherefaiss/impl/NSG.h
index 641a42f8..99aa94ea 100644
--- a/thirdparty/faiss/faiss/impl/NSG.h
+++ b/thirdparty/faiss/knowherefaiss/impl/NSG.h
@@ -15,13 +15,13 @@
 
 #include <omp.h>
 
-#include <faiss/Index.h>
-#include <faiss/impl/AuxIndexStructures.h>
-#include <faiss/impl/FaissAssert.h>
-#include <faiss/utils/Heap.h>
-#include <faiss/utils/random.h>
+#include <knowherefaiss/Index.h>
+#include <knowherefaiss/impl/AuxIndexStructures.h>
+#include <knowherefaiss/impl/FaissAssert.h>
+#include <knowherefaiss/utils/Heap.h>
+#include <knowherefaiss/utils/random.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 /** Implementation of the Navigating Spreading-out Graph (NSG)
  * datastructure.
@@ -193,4 +193,4 @@ struct NSG {
     void check_graph() const;
 };
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/impl/PolysemousTraining.cpp b/thirdparty/faiss/knowherefaiss/impl/PolysemousTraining.cpp
similarity index 98%
rename from thirdparty/faiss/faiss/impl/PolysemousTraining.cpp
rename to thirdparty/faiss/knowherefaiss/impl/PolysemousTraining.cpp
index 399c6bb6..74cf6b3e 100644
--- a/thirdparty/faiss/faiss/impl/PolysemousTraining.cpp
+++ b/thirdparty/faiss/knowherefaiss/impl/PolysemousTraining.cpp
@@ -7,7 +7,7 @@
 
 // -*- c++ -*-
 
-#include <faiss/impl/PolysemousTraining.h>
+#include <knowherefaiss/impl/PolysemousTraining.h>
 
 #include <omp.h>
 #include <stdint.h>
@@ -18,12 +18,12 @@
 #include <cstring>
 #include <memory>
 
-#include <faiss/utils/distances.h>
-#include <faiss/utils/hamming.h>
-#include <faiss/utils/random.h>
-#include <faiss/utils/utils.h>
+#include <knowherefaiss/utils/distances.h>
+#include <knowherefaiss/utils/hamming.h>
+#include <knowherefaiss/utils/random.h>
+#include <knowherefaiss/utils/utils.h>
 
-#include <faiss/impl/FaissAssert.h>
+#include <knowherefaiss/impl/FaissAssert.h>
 
 #include "simd/hook.h"
 
@@ -31,7 +31,7 @@
  * Mixed PQ / Hamming
  ******************************************/
 
-namespace faiss {
+namespace knowherefaiss {
 
 /****************************************************
  * Optimization code
@@ -970,4 +970,4 @@ size_t PolysemousTraining::memory_usage_per_thread(
     return 0;
 }
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/impl/PolysemousTraining.h b/thirdparty/faiss/knowherefaiss/impl/PolysemousTraining.h
similarity index 97%
rename from thirdparty/faiss/faiss/impl/PolysemousTraining.h
rename to thirdparty/faiss/knowherefaiss/impl/PolysemousTraining.h
index d8b5efac..101f0e1a 100644
--- a/thirdparty/faiss/faiss/impl/PolysemousTraining.h
+++ b/thirdparty/faiss/knowherefaiss/impl/PolysemousTraining.h
@@ -10,9 +10,9 @@
 #ifndef FAISS_POLYSEMOUS_TRAINING_INCLUDED
 #define FAISS_POLYSEMOUS_TRAINING_INCLUDED
 
-#include <faiss/impl/ProductQuantizer.h>
+#include <knowherefaiss/impl/ProductQuantizer.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 /// parameters used for the simulated annealing method
 struct SimulatedAnnealingParameters {
@@ -151,6 +151,6 @@ struct PolysemousTraining : SimulatedAnnealingParameters {
     size_t memory_usage_per_thread(const ProductQuantizer& pq) const;
 };
 
-} // namespace faiss
+} // namespace knowherefaiss
 
 #endif
diff --git a/thirdparty/faiss/faiss/impl/ProductAdditiveQuantizer.cpp b/thirdparty/faiss/knowherefaiss/impl/ProductAdditiveQuantizer.cpp
similarity index 96%
rename from thirdparty/faiss/faiss/impl/ProductAdditiveQuantizer.cpp
rename to thirdparty/faiss/knowherefaiss/impl/ProductAdditiveQuantizer.cpp
index 1104b778..ce6f1f34 100644
--- a/thirdparty/faiss/faiss/impl/ProductAdditiveQuantizer.cpp
+++ b/thirdparty/faiss/knowherefaiss/impl/ProductAdditiveQuantizer.cpp
@@ -5,7 +5,7 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/impl/ProductAdditiveQuantizer.h>
+#include <knowherefaiss/impl/ProductAdditiveQuantizer.h>
 
 #include <cstddef>
 #include <cstdio>
@@ -15,12 +15,12 @@
 
 #include <algorithm>
 
-#include <faiss/clone_index.h>
-#include <faiss/impl/AuxIndexStructures.h>
-#include <faiss/impl/FaissAssert.h>
-#include <faiss/utils/distances.h>
-#include <faiss/utils/hamming.h>
-#include <faiss/utils/utils.h>
+#include <knowherefaiss/clone_index.h>
+#include <knowherefaiss/impl/AuxIndexStructures.h>
+#include <knowherefaiss/impl/FaissAssert.h>
+#include <knowherefaiss/utils/distances.h>
+#include <knowherefaiss/utils/hamming.h>
+#include <knowherefaiss/utils/utils.h>
 
 extern "C" {
 
@@ -41,7 +41,7 @@ int sgemm_(
         FINTEGER* ldc);
 }
 
-namespace faiss {
+namespace knowherefaiss {
 
 ProductAdditiveQuantizer::ProductAdditiveQuantizer(
         size_t d,
@@ -373,4 +373,4 @@ ProductResidualQuantizer::ProductResidualQuantizer(
 ProductResidualQuantizer::ProductResidualQuantizer()
         : ProductResidualQuantizer(0, 0, 0, 0) {}
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/impl/ProductAdditiveQuantizer.h b/thirdparty/faiss/knowherefaiss/impl/ProductAdditiveQuantizer.h
similarity index 94%
rename from thirdparty/faiss/faiss/impl/ProductAdditiveQuantizer.h
rename to thirdparty/faiss/knowherefaiss/impl/ProductAdditiveQuantizer.h
index 9376ba12..30024c7a 100644
--- a/thirdparty/faiss/faiss/impl/ProductAdditiveQuantizer.h
+++ b/thirdparty/faiss/knowherefaiss/impl/ProductAdditiveQuantizer.h
@@ -10,12 +10,12 @@
 #include <cstdint>
 #include <vector>
 
-#include <faiss/Index.h>
-#include <faiss/impl/AdditiveQuantizer.h>
-#include <faiss/impl/LocalSearchQuantizer.h>
-#include <faiss/impl/ResidualQuantizer.h>
+#include <knowherefaiss/Index.h>
+#include <knowherefaiss/impl/AdditiveQuantizer.h>
+#include <knowherefaiss/impl/LocalSearchQuantizer.h>
+#include <knowherefaiss/impl/ResidualQuantizer.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 /** Product Additive Quantizers
  *
@@ -151,4 +151,4 @@ struct ProductResidualQuantizer : ProductAdditiveQuantizer {
     ProductResidualQuantizer();
 };
 
-} // namespace faiss
\ No newline at end of file
+} // namespace knowherefaiss
\ No newline at end of file
diff --git a/thirdparty/faiss/faiss/impl/ProductQuantizer-inl.h b/thirdparty/faiss/knowherefaiss/impl/ProductQuantizer-inl.h
similarity index 97%
rename from thirdparty/faiss/faiss/impl/ProductQuantizer-inl.h
rename to thirdparty/faiss/knowherefaiss/impl/ProductQuantizer-inl.h
index 68427054..f5421e83 100644
--- a/thirdparty/faiss/faiss/impl/ProductQuantizer-inl.h
+++ b/thirdparty/faiss/knowherefaiss/impl/ProductQuantizer-inl.h
@@ -5,7 +5,7 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-namespace faiss {
+namespace knowherefaiss {
 
 inline PQEncoderGeneric::PQEncoderGeneric(
         uint8_t* code,
@@ -113,4 +113,4 @@ inline uint64_t PQDecoder16::decode() {
     return (uint64_t)(*code++);
 }
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/impl/ProductQuantizer.cpp b/thirdparty/faiss/knowherefaiss/impl/ProductQuantizer.cpp
similarity index 97%
rename from thirdparty/faiss/faiss/impl/ProductQuantizer.cpp
rename to thirdparty/faiss/knowherefaiss/impl/ProductQuantizer.cpp
index 4f966def..9544faf3 100644
--- a/thirdparty/faiss/faiss/impl/ProductQuantizer.cpp
+++ b/thirdparty/faiss/knowherefaiss/impl/ProductQuantizer.cpp
@@ -7,7 +7,7 @@
 
 // -*- c++ -*-
 
-#include <faiss/impl/ProductQuantizer.h>
+#include <knowherefaiss/impl/ProductQuantizer.h>
 
 #include <cstddef>
 #include <cstdio>
@@ -16,11 +16,11 @@
 
 #include <algorithm>
 
-#include <faiss/FaissHook.h>
-#include <faiss/IndexFlat.h>
-#include <faiss/VectorTransform.h>
-#include <faiss/impl/FaissAssert.h>
-#include <faiss/utils/distances.h>
+#include <knowherefaiss/FaissHook.h>
+#include <knowherefaiss/IndexFlat.h>
+#include <knowherefaiss/VectorTransform.h>
+#include <knowherefaiss/impl/FaissAssert.h>
+#include <knowherefaiss/utils/distances.h>
 
 extern "C" {
 
@@ -42,7 +42,7 @@ int sgemm_(
         FINTEGER* ldc);
 }
 
-namespace faiss {
+namespace knowherefaiss {
 
 /*********************************************
  * PQ implementation
@@ -273,15 +273,15 @@ void compute_code(const ProductQuantizer& pq, const float* x, uint8_t* code) {
 void ProductQuantizer::compute_code(const float* x, uint8_t* code) const {
     switch (nbits) {
         case 8:
-            faiss::compute_code<PQEncoder8>(*this, x, code);
+            knowherefaiss::compute_code<PQEncoder8>(*this, x, code);
             break;
 
         case 16:
-            faiss::compute_code<PQEncoder16>(*this, x, code);
+            knowherefaiss::compute_code<PQEncoder16>(*this, x, code);
             break;
 
         default:
-            faiss::compute_code<PQEncoderGeneric>(*this, x, code);
+            knowherefaiss::compute_code<PQEncoderGeneric>(*this, x, code);
             break;
     }
 }
@@ -300,15 +300,15 @@ void decode(const ProductQuantizer& pq, const uint8_t* code, float* x) {
 void ProductQuantizer::decode(const uint8_t* code, float* x) const {
     switch (nbits) {
         case 8:
-            faiss::decode<PQDecoder8>(*this, code, x);
+            knowherefaiss::decode<PQDecoder8>(*this, code, x);
             break;
 
         case 16:
-            faiss::decode<PQDecoder16>(*this, code, x);
+            knowherefaiss::decode<PQDecoder16>(*this, code, x);
             break;
 
         default:
-            faiss::decode<PQDecoderGeneric>(*this, code, x);
+            knowherefaiss::decode<PQDecoderGeneric>(*this, code, x);
             break;
     }
 }
@@ -881,4 +881,4 @@ size_t ProductQuantizer::cal_size() const {
     return sizeof(*this) + centroids.size() * sizeof(float);
 }
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/impl/ProductQuantizer.h b/thirdparty/faiss/knowherefaiss/impl/ProductQuantizer.h
similarity index 96%
rename from thirdparty/faiss/faiss/impl/ProductQuantizer.h
rename to thirdparty/faiss/knowherefaiss/impl/ProductQuantizer.h
index 8f5d9088..ce07d34d 100644
--- a/thirdparty/faiss/faiss/impl/ProductQuantizer.h
+++ b/thirdparty/faiss/knowherefaiss/impl/ProductQuantizer.h
@@ -14,12 +14,12 @@
 
 #include <vector>
 
-#include <faiss/Clustering.h>
-#include <faiss/impl/Quantizer.h>
-#include <faiss/impl/platform_macros.h>
-#include <faiss/utils/Heap.h>
+#include <knowherefaiss/Clustering.h>
+#include <knowherefaiss/impl/Quantizer.h>
+#include <knowherefaiss/impl/platform_macros.h>
+#include <knowherefaiss/utils/Heap.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 /** Product Quantizer. Implemented only for METRIC_L2 */
 struct ProductQuantizer : Quantizer {
@@ -240,8 +240,8 @@ struct PQDecoder16 {
     uint64_t decode();
 };
 
-} // namespace faiss
+} // namespace knowherefaiss
 
-#include <faiss/impl/ProductQuantizer-inl.h>
+#include <knowherefaiss/impl/ProductQuantizer-inl.h>
 
 #endif
diff --git a/thirdparty/faiss/faiss/impl/Quantizer.h b/thirdparty/faiss/knowherefaiss/impl/Quantizer.h
similarity index 95%
rename from thirdparty/faiss/faiss/impl/Quantizer.h
rename to thirdparty/faiss/knowherefaiss/impl/Quantizer.h
index 9171448e..d72ea0d7 100644
--- a/thirdparty/faiss/faiss/impl/Quantizer.h
+++ b/thirdparty/faiss/knowherefaiss/impl/Quantizer.h
@@ -9,7 +9,7 @@
 
 #include <stdint.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 /** General interface for quantizer objects */
 struct Quantizer {
@@ -43,4 +43,4 @@ struct Quantizer {
     virtual ~Quantizer() {}
 };
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/impl/RHNSW.cpp b/thirdparty/faiss/knowherefaiss/impl/RHNSW.cpp
similarity index 98%
rename from thirdparty/faiss/faiss/impl/RHNSW.cpp
rename to thirdparty/faiss/knowherefaiss/impl/RHNSW.cpp
index 8a4a21fc..3c707226 100644
--- a/thirdparty/faiss/faiss/impl/RHNSW.cpp
+++ b/thirdparty/faiss/knowherefaiss/impl/RHNSW.cpp
@@ -7,14 +7,14 @@
 
 // -*- c++ -*-
 
-#include <faiss/impl/RHNSW.h>
+#include <knowherefaiss/impl/RHNSW.h>
 
 #include <string>
 #include <vector>
 
-#include <faiss/impl/AuxIndexStructures.h>
+#include <knowherefaiss/impl/AuxIndexStructures.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 
 /**************************************************************
@@ -121,8 +121,8 @@ int RHNSW::prepare_level_tab(size_t n, bool preset_levels)
  * new implementation of hnsw ispired by hnswlib
  * by cmli@zilliz   July 30, 2020
  **************************************************************/
-using Node = faiss::RHNSW::Node;
-using CompareByFirst = faiss::RHNSW::CompareByFirst;
+using Node = knowherefaiss::RHNSW::Node;
+using CompareByFirst = knowherefaiss::RHNSW::CompareByFirst;
 void RHNSW::addPoint(DistanceComputer& ptdis, int pt_level, int pt_id) {
 
   std::unique_lock<std::mutex> lock_el(link_list_locks[pt_id]);
@@ -438,4 +438,4 @@ size_t RHNSW::cal_size() {
   return ret;
 }
 
-}  // namespace faiss
+}  // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/impl/RHNSW.h b/thirdparty/faiss/knowherefaiss/impl/RHNSW.h
similarity index 95%
rename from thirdparty/faiss/faiss/impl/RHNSW.h
rename to thirdparty/faiss/knowherefaiss/impl/RHNSW.h
index 3276912b..7cb075f1 100644
--- a/thirdparty/faiss/faiss/impl/RHNSW.h
+++ b/thirdparty/faiss/knowherefaiss/impl/RHNSW.h
@@ -18,13 +18,13 @@
 
 #include <omp.h>
 
-#include <faiss/Index.h>
-#include <faiss/impl/FaissAssert.h>
-#include <faiss/utils/random.h>
-#include <faiss/utils/Heap.h>
+#include <knowherefaiss/Index.h>
+#include <knowherefaiss/impl/FaissAssert.h>
+#include <knowherefaiss/utils/random.h>
+#include <knowherefaiss/utils/Heap.h>
 
 
-namespace faiss {
+namespace knowherefaiss {
 
 
 /** Implementation of the Hierarchical Navigable Small World
@@ -67,17 +67,17 @@ struct RHNSW {
 
     std::vector<storage_idx_t> ids;
     std::vector<float> dis;
-    typedef faiss::CMax<float, storage_idx_t> HC;
+    typedef knowherefaiss::CMax<float, storage_idx_t> HC;
 
     explicit MinimaxHeap(int n): n(n), k(0), nvalid(0), ids(n), dis(n) {}
 
     void push(storage_idx_t i, float v) {
         if (k == n) {
             if (v >= dis[0]) return;
-            faiss::heap_pop<HC> (k--, dis.data(), ids.data());
+            knowherefaiss::heap_pop<HC> (k--, dis.data(), ids.data());
             --nvalid;
         }
-        faiss::heap_push<HC> (++k, dis.data(), ids.data(), v, i);
+        knowherefaiss::heap_push<HC> (++k, dis.data(), ids.data(), v, i);
         ++nvalid;
     }
 
@@ -166,7 +166,7 @@ struct RHNSW {
   /// entry point in the search structure (one of the points with maximum level
   storage_idx_t entry_point;
 
-  faiss::RandomGenerator rng;
+  knowherefaiss::RandomGenerator rng;
   std::default_random_engine level_generator;
 
   /// maximum level
@@ -398,4 +398,4 @@ struct RHNSWStatInfo {
 extern RHNSWStats rhnsw_stats;
 
 
-}  // namespace faiss
+}  // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/impl/RaBitQuantizer.cpp b/thirdparty/faiss/knowherefaiss/impl/RaBitQuantizer.cpp
similarity index 98%
rename from thirdparty/faiss/faiss/impl/RaBitQuantizer.cpp
rename to thirdparty/faiss/knowherefaiss/impl/RaBitQuantizer.cpp
index 937f86e2..5fdec38f 100644
--- a/thirdparty/faiss/faiss/impl/RaBitQuantizer.cpp
+++ b/thirdparty/faiss/knowherefaiss/impl/RaBitQuantizer.cpp
@@ -1,4 +1,4 @@
-#include <faiss/impl/RaBitQuantizer.h>
+#include <knowherefaiss/impl/RaBitQuantizer.h>
 
 #include <algorithm>
 #include <cmath>
@@ -7,12 +7,12 @@
 #include <memory>
 #include <vector>
 
-#include <faiss/FaissHook.h>
-#include <faiss/impl/FaissAssert.h>
-#include <faiss/impl/platform_macros.h>
-#include <faiss/utils/distances.h>
+#include <knowherefaiss/FaissHook.h>
+#include <knowherefaiss/impl/FaissAssert.h>
+#include <knowherefaiss/impl/platform_macros.h>
+#include <knowherefaiss/utils/distances.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 struct FactorsData {
     // ||or - c||^2 - ((metric==IP) ? ||or||^2 : 0)
@@ -496,4 +496,4 @@ FlatCodesDistanceComputer* RaBitQuantizer::get_distance_computer(
     }
 }
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/impl/RaBitQuantizer.h b/thirdparty/faiss/knowherefaiss/impl/RaBitQuantizer.h
similarity index 93%
rename from thirdparty/faiss/faiss/impl/RaBitQuantizer.h
rename to thirdparty/faiss/knowherefaiss/impl/RaBitQuantizer.h
index 8173e13c..0eee2b1e 100644
--- a/thirdparty/faiss/faiss/impl/RaBitQuantizer.h
+++ b/thirdparty/faiss/knowherefaiss/impl/RaBitQuantizer.h
@@ -4,11 +4,11 @@
 #include <cstdint>
 #include <vector>
 
-#include <faiss/MetricType.h>
-#include <faiss/impl/DistanceComputer.h>
-#include <faiss/impl/Quantizer.h>
+#include <knowherefaiss/MetricType.h>
+#include <knowherefaiss/impl/DistanceComputer.h>
+#include <knowherefaiss/impl/Quantizer.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 // the reference implementation of the https://arxiv.org/pdf/2405.12497
 //   Jianyang Gao, Cheng Long, "RaBitQ: Quantizing High-Dimensional Vectors
@@ -69,4 +69,4 @@ struct RaBitQuantizer : Quantizer {
             const float* centroid_in = nullptr) const;
 };
 
-} // namespace faiss
\ No newline at end of file
+} // namespace knowherefaiss
\ No newline at end of file
diff --git a/thirdparty/faiss/faiss/impl/ResidualQuantizer.cpp b/thirdparty/faiss/knowherefaiss/impl/ResidualQuantizer.cpp
similarity index 97%
rename from thirdparty/faiss/faiss/impl/ResidualQuantizer.cpp
rename to thirdparty/faiss/knowherefaiss/impl/ResidualQuantizer.cpp
index 21ab7810..4a697ec9 100644
--- a/thirdparty/faiss/faiss/impl/ResidualQuantizer.cpp
+++ b/thirdparty/faiss/knowherefaiss/impl/ResidualQuantizer.cpp
@@ -5,7 +5,7 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/impl/ResidualQuantizer.h>
+#include <knowherefaiss/impl/ResidualQuantizer.h>
 
 #include <algorithm>
 #include <cmath>
@@ -14,13 +14,13 @@
 #include <cstring>
 #include <memory>
 
-#include <faiss/IndexFlat.h>
-#include <faiss/VectorTransform.h>
-#include <faiss/impl/FaissAssert.h>
-#include <faiss/impl/residual_quantizer_encode_steps.h>
-#include <faiss/utils/distances.h>
-#include <faiss/utils/hamming.h>
-#include <faiss/utils/utils.h>
+#include <knowherefaiss/IndexFlat.h>
+#include <knowherefaiss/VectorTransform.h>
+#include <knowherefaiss/impl/FaissAssert.h>
+#include <knowherefaiss/impl/residual_quantizer_encode_steps.h>
+#include <knowherefaiss/utils/distances.h>
+#include <knowherefaiss/utils/hamming.h>
+#include <knowherefaiss/utils/utils.h>
 
 #include "simd/hook.h"
 
@@ -62,7 +62,7 @@ int sgelsd_(
         FINTEGER* info);
 }
 
-namespace faiss {
+namespace knowherefaiss {
 
 ResidualQuantizer::ResidualQuantizer() {
     d = 0;
@@ -547,4 +547,4 @@ void ResidualQuantizer::refine_beam_LUT(
             pool);
 }
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/impl/ResidualQuantizer.h b/thirdparty/faiss/knowherefaiss/impl/ResidualQuantizer.h
similarity index 96%
rename from thirdparty/faiss/faiss/impl/ResidualQuantizer.h
rename to thirdparty/faiss/knowherefaiss/impl/ResidualQuantizer.h
index 004f7cab..1049a908 100644
--- a/thirdparty/faiss/faiss/impl/ResidualQuantizer.h
+++ b/thirdparty/faiss/knowherefaiss/impl/ResidualQuantizer.h
@@ -10,12 +10,12 @@
 #include <cstdint>
 #include <vector>
 
-#include <faiss/Clustering.h>
-#include <faiss/impl/AdditiveQuantizer.h>
+#include <knowherefaiss/Clustering.h>
+#include <knowherefaiss/impl/AdditiveQuantizer.h>
 
-#include <faiss/utils/approx_topk/mode.h>
+#include <knowherefaiss/utils/approx_topk/mode.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 /** Residual quantizer with variable number of bits per sub-quantizer
  *
@@ -155,4 +155,4 @@ struct ResidualQuantizer : AdditiveQuantizer {
     std::vector<float> cent_norms;
 };
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/impl/ResultHandler.h b/thirdparty/faiss/knowherefaiss/impl/ResultHandler.h
similarity index 98%
rename from thirdparty/faiss/faiss/impl/ResultHandler.h
rename to thirdparty/faiss/knowherefaiss/impl/ResultHandler.h
index 8d4b8473..426785ec 100644
--- a/thirdparty/faiss/faiss/impl/ResultHandler.h
+++ b/thirdparty/faiss/knowherefaiss/impl/ResultHandler.h
@@ -11,16 +11,16 @@
 
 #pragma once
 
-#include <faiss/impl/AuxIndexStructures.h>
-#include <faiss/impl/FaissException.h>
-#include <faiss/impl/IDSelector.h>
-#include <faiss/utils/Heap.h>
-#include <faiss/utils/partitioning.h>
+#include <knowherefaiss/impl/AuxIndexStructures.h>
+#include <knowherefaiss/impl/FaissException.h>
+#include <knowherefaiss/impl/IDSelector.h>
+#include <knowherefaiss/utils/Heap.h>
+#include <knowherefaiss/utils/partitioning.h>
 #include <iostream>
 
 #include "knowhere/object.h"
 
-namespace faiss {
+namespace knowherefaiss {
 
 /*****************************************************************
  * The classes below are intended to be used as template arguments
@@ -538,7 +538,7 @@ struct RangeSearchBlockResultHandler : BlockResultHandler<C, use_sel> {
             try {
                 // finalize the partial result
                 pres.finalize();
-            } catch (const faiss::FaissException& e) {
+            } catch (const knowherefaiss::FaissException& e) {
                 // Do nothing if allocation fails in finalizing partial results.
 #ifndef NDEBUG
                 std::cerr << e.what() << std::endl;
@@ -605,7 +605,7 @@ struct RangeSearchBlockResultHandler : BlockResultHandler<C, use_sel> {
             if (partial_results.size() > 0) {
                 RangeSearchPartialResult::merge(partial_results);
             }
-        } catch (const faiss::FaissException& e) {
+        } catch (const knowherefaiss::FaissException& e) {
             // Do nothing if allocation fails in merge.
 #ifndef NDEBUG
             std::cerr << e.what() << std::endl;
@@ -756,4 +756,4 @@ typename Consumer::T dispatch_range_ResultHandler(
 #undef DISPATCH_C_SEL
 }
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/impl/ScalarQuantizer.cpp b/thirdparty/faiss/knowherefaiss/impl/ScalarQuantizer.cpp
similarity index 91%
rename from thirdparty/faiss/faiss/impl/ScalarQuantizer.cpp
rename to thirdparty/faiss/knowherefaiss/impl/ScalarQuantizer.cpp
index 449cded8..173a7437 100644
--- a/thirdparty/faiss/faiss/impl/ScalarQuantizer.cpp
+++ b/thirdparty/faiss/knowherefaiss/impl/ScalarQuantizer.cpp
@@ -7,29 +7,29 @@
 
 // -*- c++ -*-
 
-#include <faiss/impl/ScalarQuantizer.h>
+#include <knowherefaiss/impl/ScalarQuantizer.h>
 
 #include <algorithm>
 #include <cstdio>
 
-#include <faiss/impl/platform_macros.h>
+#include <knowherefaiss/impl/platform_macros.h>
 #include <omp.h>
 
 #ifdef __SSE__
 #include <immintrin.h>
 #endif
 
-#include <faiss/FaissHook.h>
-#include <faiss/IndexIVF.h>
-#include <faiss/impl/AuxIndexStructures.h>
-#include <faiss/impl/FaissAssert.h>
-#include <faiss/impl/IDSelector.h>
-#include <faiss/utils/fp16.h>
-#include <faiss/utils/utils.h>
+#include <knowherefaiss/FaissHook.h>
+#include <knowherefaiss/IndexIVF.h>
+#include <knowherefaiss/impl/AuxIndexStructures.h>
+#include <knowherefaiss/impl/FaissAssert.h>
+#include <knowherefaiss/impl/IDSelector.h>
+#include <knowherefaiss/utils/fp16.h>
+#include <knowherefaiss/utils/utils.h>
 
-#include <faiss/impl/ScalarQuantizerOp.h>
+#include <knowherefaiss/impl/ScalarQuantizerOp.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 using QuantizerType = ScalarQuantizer::QuantizerType;
 using RangeStat = ScalarQuantizer::RangeStat;
@@ -191,4 +191,4 @@ InvertedListScanner* ScalarQuantizer::select_InvertedListScanner(
                                    sel, by_residual);
 }
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/impl/ScalarQuantizer.h b/thirdparty/faiss/knowherefaiss/impl/ScalarQuantizer.h
similarity index 95%
rename from thirdparty/faiss/faiss/impl/ScalarQuantizer.h
rename to thirdparty/faiss/knowherefaiss/impl/ScalarQuantizer.h
index 2b4b856a..cdd86154 100644
--- a/thirdparty/faiss/faiss/impl/ScalarQuantizer.h
+++ b/thirdparty/faiss/knowherefaiss/impl/ScalarQuantizer.h
@@ -9,11 +9,11 @@
 
 #pragma once
 
-#include <faiss/impl/AuxIndexStructures.h>
-#include <faiss/impl/DistanceComputer.h>
-#include <faiss/impl/Quantizer.h>
+#include <knowherefaiss/impl/AuxIndexStructures.h>
+#include <knowherefaiss/impl/DistanceComputer.h>
+#include <knowherefaiss/impl/Quantizer.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 struct InvertedListScanner;
 
@@ -138,4 +138,4 @@ struct ScalarQuantizer : Quantizer {
     size_t cal_size() const;
 };
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/impl/ScalarQuantizerCodec.h b/thirdparty/faiss/knowherefaiss/impl/ScalarQuantizerCodec.h
similarity index 98%
rename from thirdparty/faiss/faiss/impl/ScalarQuantizerCodec.h
rename to thirdparty/faiss/knowherefaiss/impl/ScalarQuantizerCodec.h
index 48eea0c4..debc4a26 100644
--- a/thirdparty/faiss/faiss/impl/ScalarQuantizerCodec.h
+++ b/thirdparty/faiss/knowherefaiss/impl/ScalarQuantizerCodec.h
@@ -11,16 +11,16 @@
 #include <algorithm>
 #include <cstdio>
 
-#include <faiss/impl/FaissAssert.h>
-#include <faiss/impl/ScalarQuantizer.h>
-#include <faiss/impl/ScalarQuantizerOp.h>
-#include <faiss/utils/bf16.h>
-#include <faiss/utils/fp16.h>
-#include <faiss/utils/utils.h>
+#include <knowherefaiss/impl/FaissAssert.h>
+#include <knowherefaiss/impl/ScalarQuantizer.h>
+#include <knowherefaiss/impl/ScalarQuantizerOp.h>
+#include <knowherefaiss/utils/bf16.h>
+#include <knowherefaiss/utils/fp16.h>
+#include <knowherefaiss/utils/utils.h>
 
-#include <faiss/impl/ScalarQuantizerScanner.h>
+#include <knowherefaiss/impl/ScalarQuantizerScanner.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 using QuantizerType = ScalarQuantizer::QuantizerType;
 using RangeStat = ScalarQuantizer::RangeStat;
@@ -742,4 +742,4 @@ InvertedListScanner* sel0_InvertedListScanner(
     }
 }
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/impl/ScalarQuantizerCodec_avx.h b/thirdparty/faiss/knowherefaiss/impl/ScalarQuantizerCodec_avx.h
similarity index 99%
rename from thirdparty/faiss/faiss/impl/ScalarQuantizerCodec_avx.h
rename to thirdparty/faiss/knowherefaiss/impl/ScalarQuantizerCodec_avx.h
index c56f379a..68dd04b4 100644
--- a/thirdparty/faiss/faiss/impl/ScalarQuantizerCodec_avx.h
+++ b/thirdparty/faiss/knowherefaiss/impl/ScalarQuantizerCodec_avx.h
@@ -12,11 +12,11 @@
 #include <algorithm>
 #include <cstdio>
 
-#include <faiss/impl/FaissAssert.h>
-#include <faiss/impl/ScalarQuantizerCodec.h>
-#include <faiss/utils/utils.h>
+#include <knowherefaiss/impl/FaissAssert.h>
+#include <knowherefaiss/impl/ScalarQuantizerCodec.h>
+#include <knowherefaiss/utils/utils.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 using QuantizerType = ScalarQuantizer::QuantizerType;
 using RangeStat = ScalarQuantizer::RangeStat;
@@ -776,4 +776,4 @@ InvertedListScanner* sel0_InvertedListScanner_avx(
     }
 }
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/impl/ScalarQuantizerCodec_avx512.h b/thirdparty/faiss/knowherefaiss/impl/ScalarQuantizerCodec_avx512.h
similarity index 99%
rename from thirdparty/faiss/faiss/impl/ScalarQuantizerCodec_avx512.h
rename to thirdparty/faiss/knowherefaiss/impl/ScalarQuantizerCodec_avx512.h
index b90e5f31..df437f82 100644
--- a/thirdparty/faiss/faiss/impl/ScalarQuantizerCodec_avx512.h
+++ b/thirdparty/faiss/knowherefaiss/impl/ScalarQuantizerCodec_avx512.h
@@ -12,11 +12,11 @@
 #include <algorithm>
 #include <cstdio>
 
-#include <faiss/impl/FaissAssert.h>
-#include <faiss/impl/ScalarQuantizerCodec_avx.h>
-#include <faiss/utils/utils.h>
+#include <knowherefaiss/impl/FaissAssert.h>
+#include <knowherefaiss/impl/ScalarQuantizerCodec_avx.h>
+#include <knowherefaiss/utils/utils.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 using QuantizerType = ScalarQuantizer::QuantizerType;
 using RangeStat = ScalarQuantizer::RangeStat;
@@ -914,4 +914,4 @@ InvertedListScanner* sel0_InvertedListScanner_avx512(
     }
 }
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/impl/ScalarQuantizerCodec_neon.h b/thirdparty/faiss/knowherefaiss/impl/ScalarQuantizerCodec_neon.h
similarity index 99%
rename from thirdparty/faiss/faiss/impl/ScalarQuantizerCodec_neon.h
rename to thirdparty/faiss/knowherefaiss/impl/ScalarQuantizerCodec_neon.h
index cef65d8b..e6448c7f 100644
--- a/thirdparty/faiss/faiss/impl/ScalarQuantizerCodec_neon.h
+++ b/thirdparty/faiss/knowherefaiss/impl/ScalarQuantizerCodec_neon.h
@@ -13,11 +13,11 @@
 #include <algorithm>
 #include <cstdio>
 
-#include <faiss/impl/FaissAssert.h>
-#include <faiss/impl/ScalarQuantizerCodec.h>
-#include <faiss/utils/utils.h>
+#include <knowherefaiss/impl/FaissAssert.h>
+#include <knowherefaiss/impl/ScalarQuantizerCodec.h>
+#include <knowherefaiss/utils/utils.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 using QuantizerType = ScalarQuantizer::QuantizerType;
 using RangeStat = ScalarQuantizer::RangeStat;
@@ -758,4 +758,4 @@ InvertedListScanner* sel0_InvertedListScanner_neon(
     }
 }
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/impl/ScalarQuantizerDC.cpp b/thirdparty/faiss/knowherefaiss/impl/ScalarQuantizerDC.cpp
similarity index 89%
rename from thirdparty/faiss/faiss/impl/ScalarQuantizerDC.cpp
rename to thirdparty/faiss/knowherefaiss/impl/ScalarQuantizerDC.cpp
index f1f71206..13b179c1 100644
--- a/thirdparty/faiss/faiss/impl/ScalarQuantizerDC.cpp
+++ b/thirdparty/faiss/knowherefaiss/impl/ScalarQuantizerDC.cpp
@@ -5,10 +5,10 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/impl/ScalarQuantizerDC.h>
-#include <faiss/impl/ScalarQuantizerCodec.h>
+#include <knowherefaiss/impl/ScalarQuantizerDC.h>
+#include <knowherefaiss/impl/ScalarQuantizerCodec.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 /*******************************************************************
  * ScalarQuantizer Distance Computer
@@ -46,4 +46,4 @@ InvertedListScanner* sq_select_inverted_list_scanner_ref(
             mt, sq, quantizer, store_pairs, sel, by_residual);
 }
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/impl/ScalarQuantizerDC.h b/thirdparty/faiss/knowherefaiss/impl/ScalarQuantizerDC.h
similarity index 85%
rename from thirdparty/faiss/faiss/impl/ScalarQuantizerDC.h
rename to thirdparty/faiss/knowherefaiss/impl/ScalarQuantizerDC.h
index d6bc76c9..b833bcbe 100644
--- a/thirdparty/faiss/faiss/impl/ScalarQuantizerDC.h
+++ b/thirdparty/faiss/knowherefaiss/impl/ScalarQuantizerDC.h
@@ -9,10 +9,10 @@
 
 #include <vector>
 
-#include <faiss/MetricType.h>
-#include <faiss/impl/ScalarQuantizer.h>
+#include <knowherefaiss/MetricType.h>
+#include <knowherefaiss/impl/ScalarQuantizer.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 ScalarQuantizer::SQDistanceComputer* sq_get_distance_computer_ref(
         MetricType metric,
@@ -34,4 +34,4 @@ InvertedListScanner* sq_select_inverted_list_scanner_ref(
         const IDSelector* sel,
         bool by_residual);
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/impl/ScalarQuantizerDC_avx.cpp b/thirdparty/faiss/knowherefaiss/impl/ScalarQuantizerDC_avx.cpp
similarity index 92%
rename from thirdparty/faiss/faiss/impl/ScalarQuantizerDC_avx.cpp
rename to thirdparty/faiss/knowherefaiss/impl/ScalarQuantizerDC_avx.cpp
index 4ed54eef..36f17146 100644
--- a/thirdparty/faiss/faiss/impl/ScalarQuantizerDC_avx.cpp
+++ b/thirdparty/faiss/knowherefaiss/impl/ScalarQuantizerDC_avx.cpp
@@ -5,10 +5,10 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/impl/ScalarQuantizerDC_avx.h>
-#include <faiss/impl/ScalarQuantizerCodec_avx.h>
+#include <knowherefaiss/impl/ScalarQuantizerDC_avx.h>
+#include <knowherefaiss/impl/ScalarQuantizerCodec_avx.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 /*******************************************************************
  * ScalarQuantizer Distance Computer
@@ -66,4 +66,4 @@ InvertedListScanner* sq_select_inverted_list_scanner_avx(
     }
 }
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/impl/ScalarQuantizerDC_avx.h b/thirdparty/faiss/knowherefaiss/impl/ScalarQuantizerDC_avx.h
similarity index 85%
rename from thirdparty/faiss/faiss/impl/ScalarQuantizerDC_avx.h
rename to thirdparty/faiss/knowherefaiss/impl/ScalarQuantizerDC_avx.h
index 7e2359e1..e1c59883 100644
--- a/thirdparty/faiss/faiss/impl/ScalarQuantizerDC_avx.h
+++ b/thirdparty/faiss/knowherefaiss/impl/ScalarQuantizerDC_avx.h
@@ -9,10 +9,10 @@
 
 #include <vector>
 
-#include <faiss/MetricType.h>
-#include <faiss/impl/ScalarQuantizer.h>
+#include <knowherefaiss/MetricType.h>
+#include <knowherefaiss/impl/ScalarQuantizer.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 ScalarQuantizer::SQDistanceComputer* sq_get_distance_computer_avx(
         MetricType metric,
@@ -34,4 +34,4 @@ InvertedListScanner* sq_select_inverted_list_scanner_avx(
         const IDSelector* sel,
         bool by_residual);
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/impl/ScalarQuantizerDC_avx512.cpp b/thirdparty/faiss/knowherefaiss/impl/ScalarQuantizerDC_avx512.cpp
similarity index 93%
rename from thirdparty/faiss/faiss/impl/ScalarQuantizerDC_avx512.cpp
rename to thirdparty/faiss/knowherefaiss/impl/ScalarQuantizerDC_avx512.cpp
index 30d5d565..1c5ce3ab 100644
--- a/thirdparty/faiss/faiss/impl/ScalarQuantizerDC_avx512.cpp
+++ b/thirdparty/faiss/knowherefaiss/impl/ScalarQuantizerDC_avx512.cpp
@@ -5,10 +5,10 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/impl/ScalarQuantizerDC_avx512.h>
-#include <faiss/impl/ScalarQuantizerCodec_avx512.h>
+#include <knowherefaiss/impl/ScalarQuantizerDC_avx512.h>
+#include <knowherefaiss/impl/ScalarQuantizerCodec_avx512.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 /*******************************************************************
  * ScalarQuantizer Distance Computer
@@ -77,4 +77,4 @@ InvertedListScanner* sq_select_inverted_list_scanner_avx512(
     }
 }
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/impl/ScalarQuantizerDC_avx512.h b/thirdparty/faiss/knowherefaiss/impl/ScalarQuantizerDC_avx512.h
similarity index 85%
rename from thirdparty/faiss/faiss/impl/ScalarQuantizerDC_avx512.h
rename to thirdparty/faiss/knowherefaiss/impl/ScalarQuantizerDC_avx512.h
index 95daea16..221179c7 100644
--- a/thirdparty/faiss/faiss/impl/ScalarQuantizerDC_avx512.h
+++ b/thirdparty/faiss/knowherefaiss/impl/ScalarQuantizerDC_avx512.h
@@ -9,10 +9,10 @@
 
 #include <vector>
 
-#include <faiss/MetricType.h>
-#include <faiss/impl/ScalarQuantizer.h>
+#include <knowherefaiss/MetricType.h>
+#include <knowherefaiss/impl/ScalarQuantizer.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 ScalarQuantizer::SQDistanceComputer* sq_get_distance_computer_avx512(
         MetricType metric,
@@ -34,4 +34,4 @@ InvertedListScanner* sq_select_inverted_list_scanner_avx512(
         const IDSelector* sel,
         bool by_residual);
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/impl/ScalarQuantizerDC_neon.cpp b/thirdparty/faiss/knowherefaiss/impl/ScalarQuantizerDC_neon.cpp
similarity index 92%
rename from thirdparty/faiss/faiss/impl/ScalarQuantizerDC_neon.cpp
rename to thirdparty/faiss/knowherefaiss/impl/ScalarQuantizerDC_neon.cpp
index 5398803c..449663c7 100644
--- a/thirdparty/faiss/faiss/impl/ScalarQuantizerDC_neon.cpp
+++ b/thirdparty/faiss/knowherefaiss/impl/ScalarQuantizerDC_neon.cpp
@@ -5,10 +5,10 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/impl/ScalarQuantizerDC_neon.h>
-#include <faiss/impl/ScalarQuantizerCodec_neon.h>
+#include <knowherefaiss/impl/ScalarQuantizerDC_neon.h>
+#include <knowherefaiss/impl/ScalarQuantizerCodec_neon.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 /*******************************************************************
  * ScalarQuantizer Distance Computer
@@ -66,4 +66,4 @@ InvertedListScanner* sq_select_inverted_list_scanner_neon(
     }
 }
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/impl/ScalarQuantizerDC_neon.h b/thirdparty/faiss/knowherefaiss/impl/ScalarQuantizerDC_neon.h
similarity index 85%
rename from thirdparty/faiss/faiss/impl/ScalarQuantizerDC_neon.h
rename to thirdparty/faiss/knowherefaiss/impl/ScalarQuantizerDC_neon.h
index ef77327b..992efa02 100644
--- a/thirdparty/faiss/faiss/impl/ScalarQuantizerDC_neon.h
+++ b/thirdparty/faiss/knowherefaiss/impl/ScalarQuantizerDC_neon.h
@@ -9,10 +9,10 @@
 
 #include <vector>
 
-#include <faiss/MetricType.h>
-#include <faiss/impl/ScalarQuantizer.h>
+#include <knowherefaiss/MetricType.h>
+#include <knowherefaiss/impl/ScalarQuantizer.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 ScalarQuantizer::SQDistanceComputer* sq_get_distance_computer_neon(
         MetricType metric,
@@ -34,4 +34,4 @@ InvertedListScanner* sq_select_inverted_list_scanner_neon(
         const IDSelector* sel,
         bool by_residual);
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/impl/ScalarQuantizerOp.cpp b/thirdparty/faiss/knowherefaiss/impl/ScalarQuantizerOp.cpp
similarity index 96%
rename from thirdparty/faiss/faiss/impl/ScalarQuantizerOp.cpp
rename to thirdparty/faiss/knowherefaiss/impl/ScalarQuantizerOp.cpp
index ccbd2141..ceb14e1d 100644
--- a/thirdparty/faiss/faiss/impl/ScalarQuantizerOp.cpp
+++ b/thirdparty/faiss/knowherefaiss/impl/ScalarQuantizerOp.cpp
@@ -8,11 +8,11 @@
 #include <cstdio>
 #include <algorithm>
 
-#include <faiss/impl/FaissAssert.h>
-#include <faiss/impl/ScalarQuantizerOp.h>
-#include <faiss/utils/utils.h>
+#include <knowherefaiss/impl/FaissAssert.h>
+#include <knowherefaiss/impl/ScalarQuantizerOp.h>
+#include <knowherefaiss/utils/utils.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 using RangeStat = ScalarQuantizer::RangeStat;
 
@@ -186,4 +186,4 @@ void train_NonUniform(
     }
 }
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/impl/ScalarQuantizerOp.h b/thirdparty/faiss/knowherefaiss/impl/ScalarQuantizerOp.h
similarity index 84%
rename from thirdparty/faiss/faiss/impl/ScalarQuantizerOp.h
rename to thirdparty/faiss/knowherefaiss/impl/ScalarQuantizerOp.h
index 057fe337..cf89ba31 100644
--- a/thirdparty/faiss/faiss/impl/ScalarQuantizerOp.h
+++ b/thirdparty/faiss/knowherefaiss/impl/ScalarQuantizerOp.h
@@ -7,9 +7,9 @@
 
 #pragma once
 
-#include <faiss/impl/ScalarQuantizer.h>
+#include <knowherefaiss/impl/ScalarQuantizer.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 void train_Uniform(
         ScalarQuantizer::RangeStat rs,
@@ -28,4 +28,4 @@ void train_NonUniform(
         const float* x,
         std::vector<float>& trained);
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/impl/ScalarQuantizerScanner.h b/thirdparty/faiss/knowherefaiss/impl/ScalarQuantizerScanner.h
similarity index 98%
rename from thirdparty/faiss/faiss/impl/ScalarQuantizerScanner.h
rename to thirdparty/faiss/knowherefaiss/impl/ScalarQuantizerScanner.h
index 7aabfba5..929118e8 100644
--- a/thirdparty/faiss/faiss/impl/ScalarQuantizerScanner.h
+++ b/thirdparty/faiss/knowherefaiss/impl/ScalarQuantizerScanner.h
@@ -1,14 +1,14 @@
 #pragma once
 
-#include <faiss/IndexIVF.h>
-//#include <faiss/impl/IDSelector.h>
+#include <knowherefaiss/IndexIVF.h>
+//#include <knowherefaiss/impl/IDSelector.h>
 
 //struct InvertedListScanner;
 //struct IDSelector;
 
-#include <faiss/utils/distances_if.h>
+#include <knowherefaiss/utils/distances_if.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 /*******************************************************************
  * IndexScalarQuantizer/IndexIVFScalarQuantizer scanner object
diff --git a/thirdparty/faiss/faiss/impl/ThreadedIndex-inl.h b/thirdparty/faiss/knowherefaiss/impl/ThreadedIndex-inl.h
similarity index 98%
rename from thirdparty/faiss/faiss/impl/ThreadedIndex-inl.h
rename to thirdparty/faiss/knowherefaiss/impl/ThreadedIndex-inl.h
index 1dbbb672..05f1e266 100644
--- a/thirdparty/faiss/faiss/impl/ThreadedIndex-inl.h
+++ b/thirdparty/faiss/knowherefaiss/impl/ThreadedIndex-inl.h
@@ -5,11 +5,11 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/impl/FaissAssert.h>
+#include <knowherefaiss/impl/FaissAssert.h>
 #include <exception>
 #include <iostream>
 
-namespace faiss {
+namespace knowherefaiss {
 
 template <typename IndexT>
 ThreadedIndex<IndexT>::ThreadedIndex(bool threaded)
@@ -187,4 +187,4 @@ void ThreadedIndex<IndexT>::waitAndHandleFutures(
     handleExceptions(exceptions);
 }
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/impl/ThreadedIndex.h b/thirdparty/faiss/knowherefaiss/impl/ThreadedIndex.h
similarity index 90%
rename from thirdparty/faiss/faiss/impl/ThreadedIndex.h
rename to thirdparty/faiss/knowherefaiss/impl/ThreadedIndex.h
index eaea6d93..e329d518 100644
--- a/thirdparty/faiss/faiss/impl/ThreadedIndex.h
+++ b/thirdparty/faiss/knowherefaiss/impl/ThreadedIndex.h
@@ -7,13 +7,13 @@
 
 #pragma once
 
-#include <faiss/Index.h>
-#include <faiss/IndexBinary.h>
-#include <faiss/utils/WorkerThread.h>
+#include <knowherefaiss/Index.h>
+#include <knowherefaiss/IndexBinary.h>
+#include <knowherefaiss/utils/WorkerThread.h>
 #include <memory>
 #include <vector>
 
-namespace faiss {
+namespace knowherefaiss {
 
 /// A holder of indices in a collection of threads
 /// The interface to this class itself is not thread safe
@@ -42,7 +42,7 @@ class ThreadedIndex : public IndexT {
     void runOnIndex(std::function<void(int, IndexT*)> f);
     void runOnIndex(std::function<void(int, const IndexT*)> f) const;
 
-    /// faiss::Index API
+    /// knowherefaiss::Index API
     /// All indices receive the same call
     void reset() override;
 
@@ -81,6 +81,6 @@ class ThreadedIndex : public IndexT {
     bool isThreaded_;
 };
 
-} // namespace faiss
+} // namespace knowherefaiss
 
-#include <faiss/impl/ThreadedIndex-inl.h>
+#include <knowherefaiss/impl/ThreadedIndex-inl.h>
diff --git a/thirdparty/faiss/faiss/impl/code_distance/code_distance-avx2.h b/thirdparty/faiss/knowherefaiss/impl/code_distance/code_distance-avx2.h
similarity index 98%
rename from thirdparty/faiss/faiss/impl/code_distance/code_distance-avx2.h
rename to thirdparty/faiss/knowherefaiss/impl/code_distance/code_distance-avx2.h
index d37b0224..16eee8cc 100644
--- a/thirdparty/faiss/faiss/impl/code_distance/code_distance-avx2.h
+++ b/thirdparty/faiss/knowherefaiss/impl/code_distance/code_distance-avx2.h
@@ -13,8 +13,8 @@
 
 #include <type_traits>
 
-#include <faiss/impl/ProductQuantizer.h>
-#include <faiss/impl/code_distance/code_distance-generic.h>
+#include <knowherefaiss/impl/ProductQuantizer.h>
+#include <knowherefaiss/impl/code_distance/code_distance-generic.h>
 
 // https://gcc.gnu.org/bugzilla/show_bug.cgi?id=78782
 #if defined(__GNUC__) && __GNUC__ < 9
@@ -234,7 +234,7 @@ inline void distance_four_codes_avx2_pqdecoder8_m8(
 
 } // namespace
 
-namespace faiss {
+namespace knowherefaiss {
 
 template <typename PQDecoderT>
 typename std::enable_if<!std::is_same<PQDecoderT, PQDecoder8>::value, float>::
@@ -529,6 +529,6 @@ distance_four_codes_avx2(
     }
 }
 
-} // namespace faiss
+} // namespace knowherefaiss
 
 #endif
diff --git a/thirdparty/faiss/faiss/impl/code_distance/code_distance-avx512.h b/thirdparty/faiss/knowherefaiss/impl/code_distance/code_distance-avx512.h
similarity index 97%
rename from thirdparty/faiss/faiss/impl/code_distance/code_distance-avx512.h
rename to thirdparty/faiss/knowherefaiss/impl/code_distance/code_distance-avx512.h
index 6c6afc7e..d38f6422 100644
--- a/thirdparty/faiss/faiss/impl/code_distance/code_distance-avx512.h
+++ b/thirdparty/faiss/knowherefaiss/impl/code_distance/code_distance-avx512.h
@@ -13,10 +13,10 @@
 
 #include <type_traits>
 
-#include <faiss/impl/ProductQuantizer.h>
-#include <faiss/impl/code_distance/code_distance-generic.h>
+#include <knowherefaiss/impl/ProductQuantizer.h>
+#include <knowherefaiss/impl/code_distance/code_distance-generic.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 // According to experiments, the AVX-512 version may be SLOWER than
 //   the AVX2 version, which is somewhat unexpected.
@@ -243,6 +243,6 @@ distance_four_codes_avx512(
     }
 }
 
-} // namespace faiss
+} // namespace knowherefaiss
 
 #endif
diff --git a/thirdparty/faiss/faiss/impl/code_distance/code_distance-generic.h b/thirdparty/faiss/knowherefaiss/impl/code_distance/code_distance-generic.h
similarity index 97%
rename from thirdparty/faiss/faiss/impl/code_distance/code_distance-generic.h
rename to thirdparty/faiss/knowherefaiss/impl/code_distance/code_distance-generic.h
index 31f18d27..e5948be3 100644
--- a/thirdparty/faiss/faiss/impl/code_distance/code_distance-generic.h
+++ b/thirdparty/faiss/knowherefaiss/impl/code_distance/code_distance-generic.h
@@ -10,7 +10,7 @@
 #include <cstddef>
 #include <cstdint>
 
-namespace faiss {
+namespace knowherefaiss {
 
 /// Returns the distance to a single code.
 template <typename PQDecoderT>
@@ -78,4 +78,4 @@ inline void distance_four_codes_generic(
     }
 }
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/impl/code_distance/code_distance.h b/thirdparty/faiss/knowherefaiss/impl/code_distance/code_distance.h
similarity index 92%
rename from thirdparty/faiss/faiss/impl/code_distance/code_distance.h
rename to thirdparty/faiss/knowherefaiss/impl/code_distance/code_distance.h
index 7cdf932f..d7d58d04 100644
--- a/thirdparty/faiss/faiss/impl/code_distance/code_distance.h
+++ b/thirdparty/faiss/knowherefaiss/impl/code_distance/code_distance.h
@@ -7,7 +7,7 @@
 
 #pragma once
 
-#include <faiss/impl/platform_macros.h>
+#include <knowherefaiss/impl/platform_macros.h>
 
 // This directory contains functions to compute a distance
 // from a given PQ code to a query vector, given that the
@@ -26,9 +26,9 @@
 
 #ifdef __AVX2__
 
-#include <faiss/impl/code_distance/code_distance-avx2.h>
+#include <knowherefaiss/impl/code_distance/code_distance-avx2.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 template <typename PQDecoderT>
 inline float distance_single_code(
@@ -75,13 +75,13 @@ inline void distance_four_codes(
             result3);
 }
 
-} // namespace faiss
+} // namespace knowherefaiss
 
 #else
 
-#include <faiss/impl/code_distance/code_distance-generic.h>
+#include <knowherefaiss/impl/code_distance/code_distance-generic.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 template <typename PQDecoderT>
 inline float distance_single_code(
@@ -128,6 +128,6 @@ inline void distance_four_codes(
             result3);
 }
 
-} // namespace faiss
+} // namespace knowherefaiss
 
 #endif
diff --git a/thirdparty/faiss/faiss/impl/index_read.cpp b/thirdparty/faiss/knowherefaiss/impl/index_read.cpp
similarity index 96%
rename from thirdparty/faiss/faiss/impl/index_read.cpp
rename to thirdparty/faiss/knowherefaiss/impl/index_read.cpp
index 87001e16..9802e3b7 100644
--- a/thirdparty/faiss/faiss/impl/index_read.cpp
+++ b/thirdparty/faiss/knowherefaiss/impl/index_read.cpp
@@ -5,9 +5,9 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/index_io.h>
+#include <knowherefaiss/index_io.h>
 
-#include <faiss/impl/io_macros.h>
+#include <knowherefaiss/impl/io_macros.h>
 
 #include <cstdio>
 #include <cstdlib>
@@ -17,58 +17,58 @@
 #include <sys/stat.h>
 #include <sys/types.h>
 
-#include <faiss/impl/FaissAssert.h>
-#include <faiss/impl/io.h>
-#include <faiss/impl/io_macros.h>
-#include <faiss/utils/hamming.h>
-
-#include <faiss/invlists/InvertedListsIOHook.h>
-#include <faiss/invlists/OnDiskInvertedLists.h>
-
-#include <faiss/Index2Layer.h>
-#include <faiss/IndexAdditiveQuantizer.h>
-#include <faiss/IndexAdditiveQuantizerFastScan.h>
-#include <faiss/IndexCosine.h>
-#include <faiss/IndexFlat.h>
-#include <faiss/IndexHNSW.h>
-#include <faiss/IndexIVF.h>
-#include <faiss/IndexIVFAdditiveQuantizer.h>
-#include <faiss/IndexIVFAdditiveQuantizerFastScan.h>
-#include <faiss/IndexIVFFlat.h>
-#include <faiss/IndexIVFIndependentQuantizer.h>
-#include <faiss/IndexIVFPQ.h>
-#include <faiss/IndexIVFPQFastScan.h>
-#include <faiss/IndexIVFPQR.h>
-#include <faiss/IndexIVFRaBitQ.h>
-#include <faiss/IndexIVFSpectralHash.h>
-#include <faiss/IndexLSH.h>
-#include <faiss/IndexLattice.h>
-#include <faiss/IndexNNDescent.h>
-#include <faiss/IndexNSG.h>
-#include <faiss/IndexPQ.h>
-#include <faiss/IndexPQFastScan.h>
-#include <faiss/IndexPreTransform.h>
-#include <faiss/IndexRaBitQ.h>
-#include <faiss/IndexRefine.h>
-#include <faiss/IndexRowwiseMinMax.h>
-#include <faiss/IndexScalarQuantizer.h>
-#include <faiss/IndexScaNN.h>
-#include <faiss/MetaIndexes.h>
-#include <faiss/VectorTransform.h>
-
-#include <faiss/IndexBinaryFlat.h>
-#include <faiss/IndexBinaryFromFloat.h>
-#include <faiss/IndexBinaryHNSW.h>
-#include <faiss/IndexBinaryHash.h>
-#include <faiss/IndexBinaryIVF.h>
+#include <knowherefaiss/impl/FaissAssert.h>
+#include <knowherefaiss/impl/io.h>
+#include <knowherefaiss/impl/io_macros.h>
+#include <knowherefaiss/utils/hamming.h>
+
+#include <knowherefaiss/invlists/InvertedListsIOHook.h>
+#include <knowherefaiss/invlists/OnDiskInvertedLists.h>
+
+#include <knowherefaiss/Index2Layer.h>
+#include <knowherefaiss/IndexAdditiveQuantizer.h>
+#include <knowherefaiss/IndexAdditiveQuantizerFastScan.h>
+#include <knowherefaiss/IndexCosine.h>
+#include <knowherefaiss/IndexFlat.h>
+#include <knowherefaiss/IndexHNSW.h>
+#include <knowherefaiss/IndexIVF.h>
+#include <knowherefaiss/IndexIVFAdditiveQuantizer.h>
+#include <knowherefaiss/IndexIVFAdditiveQuantizerFastScan.h>
+#include <knowherefaiss/IndexIVFFlat.h>
+#include <knowherefaiss/IndexIVFIndependentQuantizer.h>
+#include <knowherefaiss/IndexIVFPQ.h>
+#include <knowherefaiss/IndexIVFPQFastScan.h>
+#include <knowherefaiss/IndexIVFPQR.h>
+#include <knowherefaiss/IndexIVFRaBitQ.h>
+#include <knowherefaiss/IndexIVFSpectralHash.h>
+#include <knowherefaiss/IndexLSH.h>
+#include <knowherefaiss/IndexLattice.h>
+#include <knowherefaiss/IndexNNDescent.h>
+#include <knowherefaiss/IndexNSG.h>
+#include <knowherefaiss/IndexPQ.h>
+#include <knowherefaiss/IndexPQFastScan.h>
+#include <knowherefaiss/IndexPreTransform.h>
+#include <knowherefaiss/IndexRaBitQ.h>
+#include <knowherefaiss/IndexRefine.h>
+#include <knowherefaiss/IndexRowwiseMinMax.h>
+#include <knowherefaiss/IndexScalarQuantizer.h>
+#include <knowherefaiss/IndexScaNN.h>
+#include <knowherefaiss/MetaIndexes.h>
+#include <knowherefaiss/VectorTransform.h>
+
+#include <knowherefaiss/IndexBinaryFlat.h>
+#include <knowherefaiss/IndexBinaryFromFloat.h>
+#include <knowherefaiss/IndexBinaryHNSW.h>
+#include <knowherefaiss/IndexBinaryHash.h>
+#include <knowherefaiss/IndexBinaryIVF.h>
 
 // mmap-ing and viewing facilities
-#include <faiss/impl/maybe_owned_vector.h>
+#include <knowherefaiss/impl/maybe_owned_vector.h>
 
-#include <faiss/impl/mapped_io.h>
-#include <faiss/impl/zerocopy_io.h>
+#include <knowherefaiss/impl/mapped_io.h>
+#include <knowherefaiss/impl/zerocopy_io.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 uint32_t read_value(IOReader* f) {
     uint32_t h;
@@ -1757,4 +1757,4 @@ IndexBinary* read_index_binary(const char* fname, int io_flags) {
     }
 }
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/impl/index_write.cpp b/thirdparty/faiss/knowherefaiss/impl/index_write.cpp
similarity index 95%
rename from thirdparty/faiss/faiss/impl/index_write.cpp
rename to thirdparty/faiss/knowherefaiss/impl/index_write.cpp
index c9bab117..c4167319 100644
--- a/thirdparty/faiss/faiss/impl/index_write.cpp
+++ b/thirdparty/faiss/knowherefaiss/impl/index_write.cpp
@@ -5,10 +5,10 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/index_io.h>
+#include <knowherefaiss/index_io.h>
 
-#include <faiss/impl/io.h>
-#include <faiss/impl/io_macros.h>
+#include <knowherefaiss/impl/io.h>
+#include <knowherefaiss/impl/io_macros.h>
 
 #include <cstdio>
 #include <cstdlib>
@@ -16,50 +16,50 @@
 #include <sys/stat.h>
 #include <sys/types.h>
 
-#include <faiss/invlists/InvertedListsIOHook.h>
-#include <faiss/invlists/OnDiskInvertedLists.h>
-
-#include <faiss/impl/FaissAssert.h>
-#include <faiss/impl/io.h>
-#include <faiss/impl/io_macros.h>
-#include <faiss/utils/hamming.h>
-
-#include <faiss/Index2Layer.h>
-#include <faiss/IndexAdditiveQuantizer.h>
-#include <faiss/IndexAdditiveQuantizerFastScan.h>
-#include <faiss/IndexCosine.h>
-#include <faiss/IndexFlat.h>
-#include <faiss/IndexHNSW.h>
-#include <faiss/IndexIVF.h>
-#include <faiss/IndexIVFAdditiveQuantizer.h>
-#include <faiss/IndexIVFAdditiveQuantizerFastScan.h>
-#include <faiss/IndexIVFFlat.h>
-#include <faiss/IndexIVFIndependentQuantizer.h>
-#include <faiss/IndexIVFPQ.h>
-#include <faiss/IndexIVFPQFastScan.h>
-#include <faiss/IndexIVFPQR.h>
-#include <faiss/IndexIVFRaBitQ.h>
-#include <faiss/IndexIVFSpectralHash.h>
-#include <faiss/IndexLSH.h>
-#include <faiss/IndexLattice.h>
-#include <faiss/IndexNNDescent.h>
-#include <faiss/IndexNSG.h>
-#include <faiss/IndexPQ.h>
-#include <faiss/IndexPQFastScan.h>
-#include <faiss/IndexPreTransform.h>
-#include <faiss/IndexRaBitQ.h>
-#include <faiss/IndexRefine.h>
-#include <faiss/IndexRowwiseMinMax.h>
-#include <faiss/IndexScalarQuantizer.h>
-#include <faiss/IndexScaNN.h>
-#include <faiss/MetaIndexes.h>
-#include <faiss/VectorTransform.h>
-
-#include <faiss/IndexBinaryFlat.h>
-#include <faiss/IndexBinaryFromFloat.h>
-#include <faiss/IndexBinaryHNSW.h>
-#include <faiss/IndexBinaryHash.h>
-#include <faiss/IndexBinaryIVF.h>
+#include <knowherefaiss/invlists/InvertedListsIOHook.h>
+#include <knowherefaiss/invlists/OnDiskInvertedLists.h>
+
+#include <knowherefaiss/impl/FaissAssert.h>
+#include <knowherefaiss/impl/io.h>
+#include <knowherefaiss/impl/io_macros.h>
+#include <knowherefaiss/utils/hamming.h>
+
+#include <knowherefaiss/Index2Layer.h>
+#include <knowherefaiss/IndexAdditiveQuantizer.h>
+#include <knowherefaiss/IndexAdditiveQuantizerFastScan.h>
+#include <knowherefaiss/IndexCosine.h>
+#include <knowherefaiss/IndexFlat.h>
+#include <knowherefaiss/IndexHNSW.h>
+#include <knowherefaiss/IndexIVF.h>
+#include <knowherefaiss/IndexIVFAdditiveQuantizer.h>
+#include <knowherefaiss/IndexIVFAdditiveQuantizerFastScan.h>
+#include <knowherefaiss/IndexIVFFlat.h>
+#include <knowherefaiss/IndexIVFIndependentQuantizer.h>
+#include <knowherefaiss/IndexIVFPQ.h>
+#include <knowherefaiss/IndexIVFPQFastScan.h>
+#include <knowherefaiss/IndexIVFPQR.h>
+#include <knowherefaiss/IndexIVFRaBitQ.h>
+#include <knowherefaiss/IndexIVFSpectralHash.h>
+#include <knowherefaiss/IndexLSH.h>
+#include <knowherefaiss/IndexLattice.h>
+#include <knowherefaiss/IndexNNDescent.h>
+#include <knowherefaiss/IndexNSG.h>
+#include <knowherefaiss/IndexPQ.h>
+#include <knowherefaiss/IndexPQFastScan.h>
+#include <knowherefaiss/IndexPreTransform.h>
+#include <knowherefaiss/IndexRaBitQ.h>
+#include <knowherefaiss/IndexRefine.h>
+#include <knowherefaiss/IndexRowwiseMinMax.h>
+#include <knowherefaiss/IndexScalarQuantizer.h>
+#include <knowherefaiss/IndexScaNN.h>
+#include <knowherefaiss/MetaIndexes.h>
+#include <knowherefaiss/VectorTransform.h>
+
+#include <knowherefaiss/IndexBinaryFlat.h>
+#include <knowherefaiss/IndexBinaryFromFloat.h>
+#include <knowherefaiss/IndexBinaryHNSW.h>
+#include <knowherefaiss/IndexBinaryHash.h>
+#include <knowherefaiss/IndexBinaryIVF.h>
 
 /*************************************************************
  * The I/O format is the content of the class. For objects that are
@@ -80,7 +80,7 @@
  * leak memory.
  **************************************************************/
 
-namespace faiss {
+namespace knowherefaiss {
 
 /*************************************************************
  * Write
@@ -1323,4 +1323,4 @@ void write_index_binary(const IndexBinary* idx, const char* fname) {
     write_index_binary(idx, &writer);
 }
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/impl/io.cpp b/thirdparty/faiss/knowherefaiss/impl/io.cpp
similarity index 98%
rename from thirdparty/faiss/faiss/impl/io.cpp
rename to thirdparty/faiss/knowherefaiss/impl/io.cpp
index e4da00ad..4009e1be 100644
--- a/thirdparty/faiss/faiss/impl/io.cpp
+++ b/thirdparty/faiss/knowherefaiss/impl/io.cpp
@@ -11,12 +11,12 @@
 #include <cassert>
 #include <cstring>
 
-#include <faiss/impl/FaissAssert.h>
-#include <faiss/impl/io.h>
+#include <knowherefaiss/impl/FaissAssert.h>
+#include <knowherefaiss/impl/io.h>
 #include <iostream>
 #include "knowhere/utils.h"
 
-namespace faiss {
+namespace knowherefaiss {
 
 /***********************************************************************
  * IO functions
@@ -359,4 +359,4 @@ std::string fourcc_inv_printable(uint32_t x) {
     return str;
 }
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/impl/io.h b/thirdparty/faiss/knowherefaiss/impl/io.h
similarity index 98%
rename from thirdparty/faiss/faiss/impl/io.h
rename to thirdparty/faiss/knowherefaiss/impl/io.h
index 98b13fdb..fc3e261d 100644
--- a/thirdparty/faiss/faiss/impl/io.h
+++ b/thirdparty/faiss/knowherefaiss/impl/io.h
@@ -23,7 +23,7 @@
 #include <string>
 #include <vector>
 
-namespace faiss {
+namespace knowherefaiss {
 
 struct IOReader {
     // name that can be used in error messages
@@ -181,4 +181,4 @@ void fourcc_inv(uint32_t x, char str[5]);
 std::string fourcc_inv(uint32_t x);
 std::string fourcc_inv_printable(uint32_t x);
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/impl/io_macros.h b/thirdparty/faiss/knowherefaiss/impl/io_macros.h
similarity index 98%
rename from thirdparty/faiss/faiss/impl/io_macros.h
rename to thirdparty/faiss/knowherefaiss/impl/io_macros.h
index 5449ba1c..e4300c1b 100644
--- a/thirdparty/faiss/faiss/impl/io_macros.h
+++ b/thirdparty/faiss/knowherefaiss/impl/io_macros.h
@@ -7,7 +7,7 @@
 
 #pragma once
 
-#include <faiss/impl/maybe_owned_vector.h>
+#include <knowherefaiss/impl/maybe_owned_vector.h>
 
 /*************************************************************
  * I/O macros
diff --git a/thirdparty/faiss/faiss/impl/kmeans1d.cpp b/thirdparty/faiss/knowherefaiss/impl/kmeans1d.cpp
similarity index 97%
rename from thirdparty/faiss/faiss/impl/kmeans1d.cpp
rename to thirdparty/faiss/knowherefaiss/impl/kmeans1d.cpp
index faa4fad8..e60e3f74 100644
--- a/thirdparty/faiss/faiss/impl/kmeans1d.cpp
+++ b/thirdparty/faiss/knowherefaiss/impl/kmeans1d.cpp
@@ -14,11 +14,11 @@
 #include <unordered_map>
 #include <vector>
 
-#include <faiss/Index.h>
-#include <faiss/impl/FaissAssert.h>
-#include <faiss/impl/kmeans1d.h>
+#include <knowherefaiss/Index.h>
+#include <knowherefaiss/impl/FaissAssert.h>
+#include <knowherefaiss/impl/kmeans1d.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 using LookUpFunc = std::function<float(idx_t, idx_t)>;
 
@@ -299,4 +299,4 @@ double kmeans1d(const float* x, size_t n, size_t nclusters, float* centroids) {
     return uf;
 }
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/impl/kmeans1d.h b/thirdparty/faiss/knowherefaiss/impl/kmeans1d.h
similarity index 93%
rename from thirdparty/faiss/faiss/impl/kmeans1d.h
rename to thirdparty/faiss/knowherefaiss/impl/kmeans1d.h
index f9a13266..26b6f1f2 100644
--- a/thirdparty/faiss/faiss/impl/kmeans1d.h
+++ b/thirdparty/faiss/knowherefaiss/impl/kmeans1d.h
@@ -7,10 +7,10 @@
 
 #pragma once
 
-#include <faiss/Index.h>
+#include <knowherefaiss/Index.h>
 #include <functional>
 
-namespace faiss {
+namespace knowherefaiss {
 
 /** SMAWK algorithm. Find the row minima of a monotone matrix.
  *
@@ -45,4 +45,4 @@ void smawk(
  */
 double kmeans1d(const float* x, size_t n, size_t nclusters, float* centroids);
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/impl/lattice_Zn.cpp b/thirdparty/faiss/knowherefaiss/impl/lattice_Zn.cpp
similarity index 98%
rename from thirdparty/faiss/faiss/impl/lattice_Zn.cpp
rename to thirdparty/faiss/knowherefaiss/impl/lattice_Zn.cpp
index 5163b12f..6f786943 100644
--- a/thirdparty/faiss/faiss/impl/lattice_Zn.cpp
+++ b/thirdparty/faiss/knowherefaiss/impl/lattice_Zn.cpp
@@ -7,7 +7,7 @@
 
 // -*- c++ -*-
 
-#include <faiss/impl/lattice_Zn.h>
+#include <knowherefaiss/impl/lattice_Zn.h>
 
 #include <cassert>
 #include <cmath>
@@ -19,12 +19,12 @@
 #include <unordered_map>
 #include <unordered_set>
 
-#include <faiss/impl/platform_macros.h>
-#include <faiss/utils/distances.h>
+#include <knowherefaiss/impl/platform_macros.h>
+#include <knowherefaiss/utils/distances.h>
 
 #include "simd/hook.h"
 
-namespace faiss {
+namespace knowherefaiss {
 
 /********************************************
  * small utility functions
@@ -664,4 +664,4 @@ void ZnSphereCodecAlt::decode(uint64_t code, float* c) const {
     }
 }
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/impl/lattice_Zn.h b/thirdparty/faiss/knowherefaiss/impl/lattice_Zn.h
similarity index 98%
rename from thirdparty/faiss/faiss/impl/lattice_Zn.h
rename to thirdparty/faiss/knowherefaiss/impl/lattice_Zn.h
index 44e02490..0bd985f4 100644
--- a/thirdparty/faiss/faiss/impl/lattice_Zn.h
+++ b/thirdparty/faiss/knowherefaiss/impl/lattice_Zn.h
@@ -13,7 +13,7 @@
 #include <stdint.h>
 #include <vector>
 
-namespace faiss {
+namespace knowherefaiss {
 
 /** returns the nearest vertex in the sphere to a query. Returns only
  * the coordinates, not an id.
@@ -183,6 +183,6 @@ struct ZnSphereCodecAlt : ZnSphereCodec {
     void decode(uint64_t code, float* c) const override;
 };
 
-} // namespace faiss
+} // namespace knowherefaiss
 
 #endif
diff --git a/thirdparty/faiss/faiss/impl/mapped_io.cpp b/thirdparty/faiss/knowherefaiss/impl/mapped_io.cpp
similarity index 98%
rename from thirdparty/faiss/faiss/impl/mapped_io.cpp
rename to thirdparty/faiss/knowherefaiss/impl/mapped_io.cpp
index a158fd8e..5e561ffe 100644
--- a/thirdparty/faiss/faiss/impl/mapped_io.cpp
+++ b/thirdparty/faiss/knowherefaiss/impl/mapped_io.cpp
@@ -25,10 +25,10 @@
 
 #include <cstring>
 
-#include <faiss/impl/FaissAssert.h>
-#include <faiss/impl/mapped_io.h>
+#include <knowherefaiss/impl/FaissAssert.h>
+#include <knowherefaiss/impl/mapped_io.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 #if defined(__linux__) || defined(__APPLE__)
 
@@ -307,4 +307,4 @@ int MappedFileIOReader::filedescriptor() {
     return -1;
 }
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/impl/mapped_io.h b/thirdparty/faiss/knowherefaiss/impl/mapped_io.h
similarity index 90%
rename from thirdparty/faiss/faiss/impl/mapped_io.h
rename to thirdparty/faiss/knowherefaiss/impl/mapped_io.h
index 0e32df23..783056f9 100644
--- a/thirdparty/faiss/faiss/impl/mapped_io.h
+++ b/thirdparty/faiss/knowherefaiss/impl/mapped_io.h
@@ -11,10 +11,10 @@
 #include <cstdint>
 #include <memory>
 
-#include <faiss/impl/io.h>
-#include <faiss/impl/maybe_owned_vector.h>
+#include <knowherefaiss/impl/io.h>
+#include <knowherefaiss/impl/maybe_owned_vector.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 // holds a memory-mapped region over a file
 struct MmappedFileMappingOwner : public MaybeOwnedVectorOwner {
@@ -48,4 +48,4 @@ struct MappedFileIOReader : IOReader {
     int filedescriptor() override;
 };
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/impl/maybe_owned_vector.h b/thirdparty/faiss/knowherefaiss/impl/maybe_owned_vector.h
similarity index 98%
rename from thirdparty/faiss/faiss/impl/maybe_owned_vector.h
rename to thirdparty/faiss/knowherefaiss/impl/maybe_owned_vector.h
index 4b6770da..0e2a7447 100644
--- a/thirdparty/faiss/faiss/impl/maybe_owned_vector.h
+++ b/thirdparty/faiss/knowherefaiss/impl/maybe_owned_vector.h
@@ -12,9 +12,9 @@
 #include <memory>
 #include <vector>
 
-#include <faiss/impl/FaissAssert.h>
+#include <knowherefaiss/impl/FaissAssert.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 // An interface for an owner of a MaybeOwnedVector.
 struct MaybeOwnedVectorOwner {
@@ -60,7 +60,7 @@ struct MaybeOwnedVector {
     }
 
     explicit MaybeOwnedVector(const std::vector<T>& vec)
-            : faiss::MaybeOwnedVector<T>(vec.size()) {
+            : knowherefaiss::MaybeOwnedVector<T>(vec.size()) {
         if (vec.size() > 0) {
             memcpy(owned_data.data(), vec.data(), sizeof(T) * vec.size());
         }
@@ -313,4 +313,4 @@ bool operator!=(
     return !(lhs == rhs);
 }
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/impl/platform_macros.h b/thirdparty/faiss/knowherefaiss/impl/platform_macros.h
similarity index 100%
rename from thirdparty/faiss/faiss/impl/platform_macros.h
rename to thirdparty/faiss/knowherefaiss/impl/platform_macros.h
diff --git a/thirdparty/faiss/faiss/impl/pq4_fast_scan.cpp b/thirdparty/faiss/knowherefaiss/impl/pq4_fast_scan.cpp
similarity index 97%
rename from thirdparty/faiss/faiss/impl/pq4_fast_scan.cpp
rename to thirdparty/faiss/knowherefaiss/impl/pq4_fast_scan.cpp
index 5e7f80ad..6cceb469 100644
--- a/thirdparty/faiss/faiss/impl/pq4_fast_scan.cpp
+++ b/thirdparty/faiss/knowherefaiss/impl/pq4_fast_scan.cpp
@@ -5,14 +5,14 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/impl/FaissAssert.h>
-#include <faiss/impl/platform_macros.h>
-#include <faiss/impl/pq4_fast_scan.h>
+#include <knowherefaiss/impl/FaissAssert.h>
+#include <knowherefaiss/impl/platform_macros.h>
+#include <knowherefaiss/impl/pq4_fast_scan.h>
 #include <cstring>
 
 #include <array>
 
-namespace faiss {
+namespace knowherefaiss {
 
 
 /***************************************************************
@@ -320,4 +320,4 @@ int pq4_pack_LUT_qbs_q_map(
     return i0;
 }
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/impl/pq4_fast_scan.h b/thirdparty/faiss/knowherefaiss/impl/pq4_fast_scan.h
similarity index 98%
rename from thirdparty/faiss/faiss/impl/pq4_fast_scan.h
rename to thirdparty/faiss/knowherefaiss/impl/pq4_fast_scan.h
index 9f95f76c..bf691c6b 100644
--- a/thirdparty/faiss/faiss/impl/pq4_fast_scan.h
+++ b/thirdparty/faiss/knowherefaiss/impl/pq4_fast_scan.h
@@ -10,7 +10,7 @@
 #include <cstdint>
 #include <cstdlib>
 
-#include <faiss/impl/CodePacker.h>
+#include <knowherefaiss/impl/CodePacker.h>
 
 /** PQ4 SIMD packing and accumulation functions
  *
@@ -22,7 +22,7 @@
  * parallel compile times. Templates are instantiated explicitly.
  */
 
-namespace faiss {
+namespace knowherefaiss {
 
 struct NormTableScaler;
 struct SIMDResultHandler;
@@ -189,4 +189,4 @@ void pq4_accumulate_loop_qbs(
         SIMDResultHandler& res,
         const NormTableScaler* scaler = nullptr);
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/impl/pq4_fast_scan_search_1.cpp b/thirdparty/faiss/knowherefaiss/impl/pq4_fast_scan_search_1.cpp
similarity index 96%
rename from thirdparty/faiss/faiss/impl/pq4_fast_scan_search_1.cpp
rename to thirdparty/faiss/knowherefaiss/impl/pq4_fast_scan_search_1.cpp
index 5dcd6140..c4320983 100644
--- a/thirdparty/faiss/faiss/impl/pq4_fast_scan_search_1.cpp
+++ b/thirdparty/faiss/knowherefaiss/impl/pq4_fast_scan_search_1.cpp
@@ -5,13 +5,13 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/impl/pq4_fast_scan.h>
+#include <knowherefaiss/impl/pq4_fast_scan.h>
 
-#include <faiss/impl/FaissAssert.h>
-#include <faiss/impl/LookupTableScaler.h>
-#include <faiss/impl/simd_result_handlers.h>
+#include <knowherefaiss/impl/FaissAssert.h>
+#include <knowherefaiss/impl/LookupTableScaler.h>
+#include <knowherefaiss/impl/simd_result_handlers.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 using namespace simd_result_handlers;
 
@@ -238,4 +238,4 @@ void pq4_accumulate_loop(
             res, consumer, nq, nb, bbs, nsq, codes, LUT, scaler);
 }
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/impl/pq4_fast_scan_search_qbs.cpp b/thirdparty/faiss/knowherefaiss/impl/pq4_fast_scan_search_qbs.cpp
similarity index 97%
rename from thirdparty/faiss/faiss/impl/pq4_fast_scan_search_qbs.cpp
rename to thirdparty/faiss/knowherefaiss/impl/pq4_fast_scan_search_qbs.cpp
index e88e4414..b3b2a05e 100644
--- a/thirdparty/faiss/faiss/impl/pq4_fast_scan_search_qbs.cpp
+++ b/thirdparty/faiss/knowherefaiss/impl/pq4_fast_scan_search_qbs.cpp
@@ -5,16 +5,16 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/impl/pq4_fast_scan.h>
+#include <knowherefaiss/impl/pq4_fast_scan.h>
 
 #include <type_traits>
 
-#include <faiss/impl/FaissAssert.h>
-#include <faiss/impl/LookupTableScaler.h>
-#include <faiss/impl/simd_result_handlers.h>
-#include <faiss/utils/simdlib.h>
+#include <knowherefaiss/impl/FaissAssert.h>
+#include <knowherefaiss/impl/LookupTableScaler.h>
+#include <knowherefaiss/impl/simd_result_handlers.h>
+#include <knowherefaiss/utils/simdlib.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 // declared in simd_result_handlers.h
 bool simd_result_handlers_accept_virtual = true;
@@ -374,4 +374,4 @@ int pq4_preferred_qbs(int n) {
     }
 }
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/impl/residual_quantizer_encode_steps.cpp b/thirdparty/faiss/knowherefaiss/impl/residual_quantizer_encode_steps.cpp
similarity index 98%
rename from thirdparty/faiss/faiss/impl/residual_quantizer_encode_steps.cpp
rename to thirdparty/faiss/knowherefaiss/impl/residual_quantizer_encode_steps.cpp
index ff93219c..59a0a2e1 100644
--- a/thirdparty/faiss/faiss/impl/residual_quantizer_encode_steps.cpp
+++ b/thirdparty/faiss/knowherefaiss/impl/residual_quantizer_encode_steps.cpp
@@ -5,17 +5,17 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/impl/residual_quantizer_encode_steps.h>
+#include <knowherefaiss/impl/residual_quantizer_encode_steps.h>
 
-#include <faiss/impl/AuxIndexStructures.h>
-#include <faiss/impl/FaissAssert.h>
-#include <faiss/impl/ResidualQuantizer.h>
-#include <faiss/utils/Heap.h>
-#include <faiss/utils/distances.h>
-#include <faiss/utils/simdlib.h>
-#include <faiss/utils/utils.h>
+#include <knowherefaiss/impl/AuxIndexStructures.h>
+#include <knowherefaiss/impl/FaissAssert.h>
+#include <knowherefaiss/impl/ResidualQuantizer.h>
+#include <knowherefaiss/utils/Heap.h>
+#include <knowherefaiss/utils/distances.h>
+#include <knowherefaiss/utils/simdlib.h>
+#include <knowherefaiss/utils/utils.h>
 
-#include <faiss/utils/approx_topk/approx_topk.h>
+#include <knowherefaiss/utils/approx_topk/approx_topk.h>
 
 #include "simd/hook.h"
 
@@ -38,7 +38,7 @@ int sgemm_(
         FINTEGER* ldc);
 }
 
-namespace faiss {
+namespace knowherefaiss {
 
 /********************************************************************
  * Basic routines
@@ -959,4 +959,4 @@ void compute_codes_add_centroids_mp_lut1(
 
 } // namespace rq_encode_steps
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/impl/residual_quantizer_encode_steps.h b/thirdparty/faiss/knowherefaiss/impl/residual_quantizer_encode_steps.h
similarity index 97%
rename from thirdparty/faiss/faiss/impl/residual_quantizer_encode_steps.h
rename to thirdparty/faiss/knowherefaiss/impl/residual_quantizer_encode_steps.h
index 70ce4b84..b4e3a03f 100644
--- a/thirdparty/faiss/faiss/impl/residual_quantizer_encode_steps.h
+++ b/thirdparty/faiss/knowherefaiss/impl/residual_quantizer_encode_steps.h
@@ -10,10 +10,10 @@
 #include <cstdint>
 #include <vector>
 
-#include <faiss/Index.h>
-#include <faiss/utils/approx_topk/mode.h>
+#include <knowherefaiss/Index.h>
+#include <knowherefaiss/utils/approx_topk/mode.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 /********************************************************************
  * Single step of encoding
@@ -173,4 +173,4 @@ void compute_codes_add_centroids_mp_lut1(
 
 } // namespace rq_encode_steps
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/impl/simd_result_handlers.h b/thirdparty/faiss/knowherefaiss/impl/simd_result_handlers.h
similarity index 98%
rename from thirdparty/faiss/faiss/impl/simd_result_handlers.h
rename to thirdparty/faiss/knowherefaiss/impl/simd_result_handlers.h
index efc77d62..86b2e4b5 100644
--- a/thirdparty/faiss/faiss/impl/simd_result_handlers.h
+++ b/thirdparty/faiss/knowherefaiss/impl/simd_result_handlers.h
@@ -11,20 +11,20 @@
 #include <type_traits>
 #include <vector>
 
-#include <faiss/utils/Heap.h>
-#include <faiss/utils/simdlib.h>
+#include <knowherefaiss/utils/Heap.h>
+#include <knowherefaiss/utils/simdlib.h>
 
-#include <faiss/impl/FaissAssert.h>
-#include <faiss/impl/IDSelector.h>
-#include <faiss/impl/ResultHandler.h>
-#include <faiss/impl/platform_macros.h>
-#include <faiss/utils/AlignedTable.h>
-#include <faiss/utils/partitioning.h>
+#include <knowherefaiss/impl/FaissAssert.h>
+#include <knowherefaiss/impl/IDSelector.h>
+#include <knowherefaiss/impl/ResultHandler.h>
+#include <knowherefaiss/impl/platform_macros.h>
+#include <knowherefaiss/utils/AlignedTable.h>
+#include <knowherefaiss/utils/partitioning.h>
 
 /** This file contains callbacks for kernels that compute distances.
  */
 
-namespace faiss {
+namespace knowherefaiss {
 
 namespace {
 
@@ -1016,4 +1016,4 @@ void dispatch_SIMDResultHanlder(
 
 } // namespace simd_result_handlers
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/impl/zerocopy_io.cpp b/thirdparty/faiss/knowherefaiss/impl/zerocopy_io.cpp
similarity index 93%
rename from thirdparty/faiss/faiss/impl/zerocopy_io.cpp
rename to thirdparty/faiss/knowherefaiss/impl/zerocopy_io.cpp
index 2d37f6a8..72c57b05 100644
--- a/thirdparty/faiss/faiss/impl/zerocopy_io.cpp
+++ b/thirdparty/faiss/knowherefaiss/impl/zerocopy_io.cpp
@@ -5,10 +5,10 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/impl/zerocopy_io.h>
+#include <knowherefaiss/impl/zerocopy_io.h>
 #include <cstring>
 
-namespace faiss {
+namespace knowherefaiss {
 
 ZeroCopyIOReader::ZeroCopyIOReader(uint8_t* data, size_t size)
         : data_(data), rp_(0), total_(size) {}
@@ -64,4 +64,4 @@ int ZeroCopyIOReader::filedescriptor() {
     return -1; // Indicating no file descriptor available for memory buffer
 }
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/impl/zerocopy_io.h b/thirdparty/faiss/knowherefaiss/impl/zerocopy_io.h
similarity index 80%
rename from thirdparty/faiss/faiss/impl/zerocopy_io.h
rename to thirdparty/faiss/knowherefaiss/impl/zerocopy_io.h
index 488b5d1e..c0aaeea3 100644
--- a/thirdparty/faiss/faiss/impl/zerocopy_io.h
+++ b/thirdparty/faiss/knowherefaiss/impl/zerocopy_io.h
@@ -9,12 +9,12 @@
 
 #include <cstdint>
 
-#include <faiss/impl/io.h>
+#include <knowherefaiss/impl/io.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 // ZeroCopyIOReader just maps the data from a given pointer.
-struct ZeroCopyIOReader : public faiss::IOReader {
+struct ZeroCopyIOReader : public knowherefaiss::IOReader {
     uint8_t* data_;
     size_t rp_ = 0;
     size_t total_ = 0;
@@ -29,4 +29,4 @@ struct ZeroCopyIOReader : public faiss::IOReader {
     int filedescriptor() override;
 };
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/index_factory.cpp b/thirdparty/faiss/knowherefaiss/index_factory.cpp
similarity index 95%
rename from thirdparty/faiss/faiss/index_factory.cpp
rename to thirdparty/faiss/knowherefaiss/index_factory.cpp
index 07b4111d..3ecae2d4 100644
--- a/thirdparty/faiss/faiss/index_factory.cpp
+++ b/thirdparty/faiss/knowherefaiss/index_factory.cpp
@@ -9,9 +9,9 @@
  * implementation of the index_factory function. Lots of regex parsing code.
  */
 
-#include <faiss/index_factory.h>
-#include "faiss/MetricType.h"
-#include "faiss/impl/FaissAssert.h"
+#include <knowherefaiss/index_factory.h>
+#include "knowherefaiss/MetricType.h"
+#include "knowherefaiss/impl/FaissAssert.h"
 
 #include <cinttypes>
 #include <cmath>
@@ -20,44 +20,44 @@
 
 #include <regex>
 
-#include <faiss/impl/FaissAssert.h>
-#include <faiss/utils/random.h>
-#include <faiss/utils/utils.h>
-
-#include <faiss/Index2Layer.h>
-#include <faiss/IndexAdditiveQuantizer.h>
-#include <faiss/IndexAdditiveQuantizerFastScan.h>
-#include <faiss/IndexFlat.h>
-#include <faiss/IndexHNSW.h>
-#include <faiss/IndexIVF.h>
-#include <faiss/IndexIVFAdditiveQuantizer.h>
-#include <faiss/IndexIVFAdditiveQuantizerFastScan.h>
-#include <faiss/IndexIVFFlat.h>
-#include <faiss/IndexIVFPQ.h>
-#include <faiss/IndexIVFPQFastScan.h>
-#include <faiss/IndexIVFPQR.h>
-#include <faiss/IndexIVFRaBitQ.h>
-#include <faiss/IndexIVFSpectralHash.h>
-#include <faiss/IndexLSH.h>
-#include <faiss/IndexLattice.h>
-#include <faiss/IndexNSG.h>
-#include <faiss/IndexPQ.h>
-#include <faiss/IndexPQFastScan.h>
-#include <faiss/IndexPreTransform.h>
-#include <faiss/IndexRaBitQ.h>
-#include <faiss/IndexRefine.h>
-#include <faiss/IndexRowwiseMinMax.h>
-#include <faiss/IndexScalarQuantizer.h>
-#include <faiss/MetaIndexes.h>
-#include <faiss/VectorTransform.h>
-
-#include <faiss/IndexBinaryFlat.h>
-#include <faiss/IndexBinaryHNSW.h>
-#include <faiss/IndexBinaryHash.h>
-#include <faiss/IndexBinaryIVF.h>
+#include <knowherefaiss/impl/FaissAssert.h>
+#include <knowherefaiss/utils/random.h>
+#include <knowherefaiss/utils/utils.h>
+
+#include <knowherefaiss/Index2Layer.h>
+#include <knowherefaiss/IndexAdditiveQuantizer.h>
+#include <knowherefaiss/IndexAdditiveQuantizerFastScan.h>
+#include <knowherefaiss/IndexFlat.h>
+#include <knowherefaiss/IndexHNSW.h>
+#include <knowherefaiss/IndexIVF.h>
+#include <knowherefaiss/IndexIVFAdditiveQuantizer.h>
+#include <knowherefaiss/IndexIVFAdditiveQuantizerFastScan.h>
+#include <knowherefaiss/IndexIVFFlat.h>
+#include <knowherefaiss/IndexIVFPQ.h>
+#include <knowherefaiss/IndexIVFPQFastScan.h>
+#include <knowherefaiss/IndexIVFPQR.h>
+#include <knowherefaiss/IndexIVFRaBitQ.h>
+#include <knowherefaiss/IndexIVFSpectralHash.h>
+#include <knowherefaiss/IndexLSH.h>
+#include <knowherefaiss/IndexLattice.h>
+#include <knowherefaiss/IndexNSG.h>
+#include <knowherefaiss/IndexPQ.h>
+#include <knowherefaiss/IndexPQFastScan.h>
+#include <knowherefaiss/IndexPreTransform.h>
+#include <knowherefaiss/IndexRaBitQ.h>
+#include <knowherefaiss/IndexRefine.h>
+#include <knowherefaiss/IndexRowwiseMinMax.h>
+#include <knowherefaiss/IndexScalarQuantizer.h>
+#include <knowherefaiss/MetaIndexes.h>
+#include <knowherefaiss/VectorTransform.h>
+
+#include <knowherefaiss/IndexBinaryFlat.h>
+#include <knowherefaiss/IndexBinaryHNSW.h>
+#include <knowherefaiss/IndexBinaryHash.h>
+#include <knowherefaiss/IndexBinaryIVF.h>
 #include <string>
 
-namespace faiss {
+namespace knowherefaiss {
 
 /***************************************************************
  * index_factory
@@ -950,4 +950,4 @@ IndexBinary* index_binary_factory(
     return index;
 }
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/index_factory.h b/thirdparty/faiss/knowherefaiss/index_factory.h
similarity index 83%
rename from thirdparty/faiss/faiss/index_factory.h
rename to thirdparty/faiss/knowherefaiss/index_factory.h
index d206f517..fd2b9044 100644
--- a/thirdparty/faiss/faiss/index_factory.h
+++ b/thirdparty/faiss/knowherefaiss/index_factory.h
@@ -7,10 +7,10 @@
 
 #pragma once
 
-#include <faiss/Index.h>
-#include <faiss/IndexBinary.h>
+#include <knowherefaiss/Index.h>
+#include <knowherefaiss/IndexBinary.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 /** Build and index with the sequence of processing steps described in
  *  the string. */
@@ -27,4 +27,4 @@ IndexBinary* index_binary_factory(
         const char* description,
         MetricType metric = METRIC_L2);
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/index_io.h b/thirdparty/faiss/knowherefaiss/index_io.h
similarity index 97%
rename from thirdparty/faiss/faiss/index_io.h
rename to thirdparty/faiss/knowherefaiss/index_io.h
index 2f68a0bb..1ae752fc 100644
--- a/thirdparty/faiss/faiss/index_io.h
+++ b/thirdparty/faiss/knowherefaiss/index_io.h
@@ -15,7 +15,7 @@
 #include <typeinfo>
 #include <vector>
 
-#include <faiss/IndexIVF.h>
+#include <knowherefaiss/IndexIVF.h>
 
 /** I/O functions can read/write to a filename, a file handle or to an
  * object that abstracts the medium.
@@ -25,7 +25,7 @@
  * object.
  */
 
-namespace faiss {
+namespace knowherefaiss {
 
 struct Index;
 struct IndexBinary;
@@ -106,6 +106,6 @@ void read_vector(std::vector<uint32_t>& v, IOReader* f);
 uint32_t read_value(IOReader *f);
 void write_value(uint32_t v, IOWriter* writer);
 void write_mv(IOWriter* writer);
-} // namespace faiss
+} // namespace knowherefaiss
 
 #endif
diff --git a/thirdparty/faiss/faiss/invlists/BlockInvertedLists.cpp b/thirdparty/faiss/knowherefaiss/invlists/BlockInvertedLists.cpp
similarity index 93%
rename from thirdparty/faiss/faiss/invlists/BlockInvertedLists.cpp
rename to thirdparty/faiss/knowherefaiss/invlists/BlockInvertedLists.cpp
index 103d224d..191ca9f8 100644
--- a/thirdparty/faiss/faiss/invlists/BlockInvertedLists.cpp
+++ b/thirdparty/faiss/knowherefaiss/invlists/BlockInvertedLists.cpp
@@ -5,16 +5,16 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/invlists/BlockInvertedLists.h>
+#include <knowherefaiss/invlists/BlockInvertedLists.h>
 
-#include <faiss/impl/CodePacker.h>
-#include <faiss/impl/FaissAssert.h>
-#include <faiss/impl/IDSelector.h>
+#include <knowherefaiss/impl/CodePacker.h>
+#include <knowherefaiss/impl/FaissAssert.h>
+#include <knowherefaiss/impl/IDSelector.h>
 
-#include <faiss/impl/io.h>
-#include <faiss/impl/io_macros.h>
+#include <knowherefaiss/impl/io.h>
+#include <knowherefaiss/impl/io_macros.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 BlockInvertedLists::BlockInvertedLists(
         size_t nlist,
@@ -178,4 +178,4 @@ InvertedLists* BlockInvertedListsIOHook::read(IOReader* f, int /* io_flags */)
     return il;
 }
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/invlists/BlockInvertedLists.h b/thirdparty/faiss/knowherefaiss/invlists/BlockInvertedLists.h
similarity index 91%
rename from thirdparty/faiss/faiss/invlists/BlockInvertedLists.h
rename to thirdparty/faiss/knowherefaiss/invlists/BlockInvertedLists.h
index 528e1e2f..7b57e111 100644
--- a/thirdparty/faiss/faiss/invlists/BlockInvertedLists.h
+++ b/thirdparty/faiss/knowherefaiss/invlists/BlockInvertedLists.h
@@ -7,12 +7,12 @@
 
 #pragma once
 
-#include <faiss/index_io.h>
-#include <faiss/invlists/InvertedLists.h>
-#include <faiss/invlists/InvertedListsIOHook.h>
-#include <faiss/utils/AlignedTable.h>
+#include <knowherefaiss/index_io.h>
+#include <knowherefaiss/invlists/InvertedLists.h>
+#include <knowherefaiss/invlists/InvertedListsIOHook.h>
+#include <knowherefaiss/utils/AlignedTable.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 struct CodePacker;
 struct IDSelector;
@@ -81,4 +81,4 @@ struct BlockInvertedListsIOHook : InvertedListsIOHook {
     InvertedLists* read(IOReader* f, int io_flags) const override;
 };
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/invlists/DirectMap.cpp b/thirdparty/faiss/knowherefaiss/invlists/DirectMap.cpp
similarity index 97%
rename from thirdparty/faiss/faiss/invlists/DirectMap.cpp
rename to thirdparty/faiss/knowherefaiss/invlists/DirectMap.cpp
index 213671ef..41e2e37a 100644
--- a/thirdparty/faiss/faiss/invlists/DirectMap.cpp
+++ b/thirdparty/faiss/knowherefaiss/invlists/DirectMap.cpp
@@ -7,17 +7,17 @@
 
 // -*- c++ -*-
 
-#include <faiss/invlists/DirectMap.h>
+#include <knowherefaiss/invlists/DirectMap.h>
 
 #include <cassert>
 #include <cstdio>
 
-#include <faiss/impl/AuxIndexStructures.h>
-#include <faiss/impl/FaissAssert.h>
-#include <faiss/impl/IDSelector.h>
-#include <faiss/invlists/BlockInvertedLists.h>
+#include <knowherefaiss/impl/AuxIndexStructures.h>
+#include <knowherefaiss/impl/FaissAssert.h>
+#include <knowherefaiss/impl/IDSelector.h>
+#include <knowherefaiss/invlists/BlockInvertedLists.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 DirectMap::DirectMap() : type(NoMap) {}
 
@@ -287,4 +287,4 @@ void DirectMap::update_codes(
     }
 }
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/invlists/DirectMap.h b/thirdparty/faiss/knowherefaiss/invlists/DirectMap.h
similarity index 95%
rename from thirdparty/faiss/faiss/invlists/DirectMap.h
rename to thirdparty/faiss/knowherefaiss/invlists/DirectMap.h
index 2d63d98f..eb0cb7dc 100644
--- a/thirdparty/faiss/faiss/invlists/DirectMap.h
+++ b/thirdparty/faiss/knowherefaiss/invlists/DirectMap.h
@@ -10,12 +10,12 @@
 #ifndef FAISS_DIRECT_MAP_H
 #define FAISS_DIRECT_MAP_H
 
-#include <faiss/impl/IDSelector.h>
-#include <faiss/invlists/InvertedLists.h>
+#include <knowherefaiss/impl/IDSelector.h>
+#include <knowherefaiss/invlists/InvertedLists.h>
 #include <unordered_map>
-#include "faiss/impl/FaissAssert.h"
+#include "knowherefaiss/impl/FaissAssert.h"
 
-namespace faiss {
+namespace knowherefaiss {
 
 // When offsets list id + offset are encoded in an uint64
 // we call this LO = list-offset
@@ -142,6 +142,6 @@ struct DirectMapAdd {
     ~DirectMapAdd();
 };
 
-} // namespace faiss
+} // namespace knowherefaiss
 
 #endif
diff --git a/thirdparty/faiss/faiss/invlists/InvertedLists.cpp b/thirdparty/faiss/knowherefaiss/invlists/InvertedLists.cpp
similarity index 99%
rename from thirdparty/faiss/faiss/invlists/InvertedLists.cpp
rename to thirdparty/faiss/knowherefaiss/invlists/InvertedLists.cpp
index a4574f3d..175ff9bf 100644
--- a/thirdparty/faiss/faiss/invlists/InvertedLists.cpp
+++ b/thirdparty/faiss/knowherefaiss/invlists/InvertedLists.cpp
@@ -5,24 +5,24 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/invlists/InvertedLists.h>
+#include <knowherefaiss/invlists/InvertedLists.h>
 
 #include <algorithm>
 #include <cstdio>
 #include <memory>
 #include <numeric>
 
-#include <faiss/impl/FaissAssert.h>
-#include <faiss/utils/distances.h>
-#include <faiss/utils/utils.h>
+#include <knowherefaiss/impl/FaissAssert.h>
+#include <knowherefaiss/utils/distances.h>
+#include <knowherefaiss/utils/utils.h>
 
 //TODO: refactor to decouple dependency between CPU and Cuda, or upgrade faiss
 #ifdef USE_GPU
-#include "faiss/gpu/utils/DeviceUtils.h"
+#include "knowherefaiss/gpu/utils/DeviceUtils.h"
 #include "cuda.h"
 #include "cuda_runtime.h"
 
-namespace faiss {
+namespace knowherefaiss {
 
 /*
  * Use pin memory to build Readonly Inverted list will accelerate cuda memory copy, but it will downgrade cpu ivf search
@@ -64,7 +64,7 @@ PageLockMemory::PageLockMemory(PageLockMemory &&other) {
 }
 #endif
 
-namespace faiss {
+namespace knowherefaiss {
 
 InvertedListsIterator::~InvertedListsIterator() {}
 
@@ -278,7 +278,7 @@ double InvertedLists::imbalance_factor() const {
         hist[i] = list_size(i);
     }
 
-    return faiss::imbalance_factor(nlist, hist.data());
+    return knowherefaiss::imbalance_factor(nlist, hist.data());
 }
 
 void InvertedLists::print_stats() const {
@@ -1466,4 +1466,4 @@ void StopWordsInvertedLists::prefetch_lists(const idx_t* list_nos, int nlist)
     il0->prefetch_lists(list0.data(), list0.size());
 }
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/invlists/InvertedLists.h b/thirdparty/faiss/knowherefaiss/invlists/InvertedLists.h
similarity index 99%
rename from thirdparty/faiss/faiss/invlists/InvertedLists.h
rename to thirdparty/faiss/knowherefaiss/invlists/InvertedLists.h
index cabf4261..ebdd3682 100644
--- a/thirdparty/faiss/faiss/invlists/InvertedLists.h
+++ b/thirdparty/faiss/knowherefaiss/invlists/InvertedLists.h
@@ -22,10 +22,10 @@
 #include <set>
 #include <vector>
 
-#include <faiss/MetricType.h>
-#include <faiss/impl/maybe_owned_vector.h>
+#include <knowherefaiss/MetricType.h>
+#include <knowherefaiss/impl/maybe_owned_vector.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 struct PageLockMemory {
 public:
@@ -49,7 +49,7 @@ public:
 using PageLockMemoryPtr = std::shared_ptr<PageLockMemory>;
 }
 
-namespace faiss {
+namespace knowherefaiss {
 
 struct InvertedListsIterator {
     virtual ~InvertedListsIterator();
@@ -658,6 +658,6 @@ struct StopWordsInvertedLists : ReadOnlyInvertedLists {
     void prefetch_lists(const idx_t* list_nos, int nlist) const override;
 };
 
-} // namespace faiss
+} // namespace knowherefaiss
 
 #endif
diff --git a/thirdparty/faiss/faiss/invlists/InvertedListsIOHook.cpp b/thirdparty/faiss/knowherefaiss/invlists/InvertedListsIOHook.cpp
similarity index 87%
rename from thirdparty/faiss/faiss/invlists/InvertedListsIOHook.cpp
rename to thirdparty/faiss/knowherefaiss/invlists/InvertedListsIOHook.cpp
index 0081c4f9..4317298a 100644
--- a/thirdparty/faiss/faiss/invlists/InvertedListsIOHook.cpp
+++ b/thirdparty/faiss/knowherefaiss/invlists/InvertedListsIOHook.cpp
@@ -5,19 +5,19 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/invlists/InvertedListsIOHook.h>
+#include <knowherefaiss/invlists/InvertedListsIOHook.h>
 
-#include <faiss/impl/FaissAssert.h>
-#include <faiss/impl/io.h>
-#include <faiss/impl/io_macros.h>
+#include <knowherefaiss/impl/FaissAssert.h>
+#include <knowherefaiss/impl/io.h>
+#include <knowherefaiss/impl/io_macros.h>
 
-#include <faiss/invlists/BlockInvertedLists.h>
+#include <knowherefaiss/invlists/BlockInvertedLists.h>
 
 #ifndef _MSC_VER
-#include <faiss/invlists/OnDiskInvertedLists.h>
+#include <knowherefaiss/invlists/OnDiskInvertedLists.h>
 #endif // !_MSC_VER
 
-namespace faiss {
+namespace knowherefaiss {
 
 /**********************************************************
  * InvertedListIOHook's
@@ -99,4 +99,4 @@ InvertedLists* InvertedListsIOHook::read_ArrayInvertedLists(
     FAISS_THROW_FMT("read to array not implemented for %s", classname.c_str());
 }
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/invlists/InvertedListsIOHook.h b/thirdparty/faiss/knowherefaiss/invlists/InvertedListsIOHook.h
similarity index 93%
rename from thirdparty/faiss/faiss/invlists/InvertedListsIOHook.h
rename to thirdparty/faiss/knowherefaiss/invlists/InvertedListsIOHook.h
index 8100aa29..bb703fff 100644
--- a/thirdparty/faiss/faiss/invlists/InvertedListsIOHook.h
+++ b/thirdparty/faiss/knowherefaiss/invlists/InvertedListsIOHook.h
@@ -7,11 +7,11 @@
 
 #pragma once
 
-#include <faiss/impl/io.h>
-#include <faiss/invlists/InvertedLists.h>
+#include <knowherefaiss/impl/io.h>
+#include <knowherefaiss/invlists/InvertedLists.h>
 #include <string>
 
-namespace faiss {
+namespace knowherefaiss {
 
 /** Callbacks to handle other types of InvertedList objects.
  *
@@ -59,4 +59,4 @@ struct InvertedListsIOHook {
     static InvertedListsIOHook* lookup_classname(const std::string& classname);
 };
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/invlists/OnDiskInvertedLists.cpp b/thirdparty/faiss/knowherefaiss/invlists/OnDiskInvertedLists.cpp
similarity index 98%
rename from thirdparty/faiss/faiss/invlists/OnDiskInvertedLists.cpp
rename to thirdparty/faiss/knowherefaiss/invlists/OnDiskInvertedLists.cpp
index c19daafd..4adf8ed7 100644
--- a/thirdparty/faiss/faiss/invlists/OnDiskInvertedLists.cpp
+++ b/thirdparty/faiss/knowherefaiss/invlists/OnDiskInvertedLists.cpp
@@ -7,7 +7,7 @@
 
 // -*- c++ -*-
 
-#include <faiss/invlists/OnDiskInvertedLists.h>
+#include <knowherefaiss/invlists/OnDiskInvertedLists.h>
 
 #include <pthread.h>
 
@@ -18,13 +18,13 @@
 #include <sys/types.h>
 #include <unistd.h>
 
-#include <faiss/impl/FaissAssert.h>
-#include <faiss/utils/utils.h>
+#include <knowherefaiss/impl/FaissAssert.h>
+#include <knowherefaiss/utils/utils.h>
 
-#include <faiss/impl/io.h>
-#include <faiss/impl/io_macros.h>
+#include <knowherefaiss/impl/io.h>
+#include <knowherefaiss/impl/io_macros.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 /**********************************************
  * LockLevels
@@ -829,4 +829,4 @@ InvertedLists* OnDiskInvertedListsIOHook::read_ArrayInvertedLists(
     return ails;
 }
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/invlists/OnDiskInvertedLists.h b/thirdparty/faiss/knowherefaiss/invlists/OnDiskInvertedLists.h
similarity index 96%
rename from thirdparty/faiss/faiss/invlists/OnDiskInvertedLists.h
rename to thirdparty/faiss/knowherefaiss/invlists/OnDiskInvertedLists.h
index dee70115..5c0e4ca2 100644
--- a/thirdparty/faiss/faiss/invlists/OnDiskInvertedLists.h
+++ b/thirdparty/faiss/knowherefaiss/invlists/OnDiskInvertedLists.h
@@ -14,11 +14,11 @@
 #include <typeinfo>
 #include <vector>
 
-#include <faiss/IndexIVF.h>
-#include <faiss/index_io.h>
-#include <faiss/invlists/InvertedListsIOHook.h>
+#include <knowherefaiss/IndexIVF.h>
+#include <knowherefaiss/index_io.h>
+#include <knowherefaiss/invlists/InvertedListsIOHook.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 struct LockLevels;
 
@@ -155,6 +155,6 @@ struct OnDiskInvertedListsIOHook : InvertedListsIOHook {
             const std::vector<size_t>& sizes) const override;
 };
 
-} // namespace faiss
+} // namespace knowherefaiss
 
 #endif
diff --git a/thirdparty/faiss/faiss/python/CMakeLists.txt b/thirdparty/faiss/knowherefaiss/python/CMakeLists.txt
similarity index 95%
rename from thirdparty/faiss/faiss/python/CMakeLists.txt
rename to thirdparty/faiss/knowherefaiss/python/CMakeLists.txt
index dee8c776..822b309c 100644
--- a/thirdparty/faiss/faiss/python/CMakeLists.txt
+++ b/thirdparty/faiss/knowherefaiss/python/CMakeLists.txt
@@ -54,14 +54,14 @@ if(TARGET faiss)
   # Manually add headers as extra dependencies of swigfaiss.
   set(SWIG_MODULE_swigfaiss_EXTRA_DEPS)
   foreach(h ${FAISS_HEADERS})
-    list(APPEND SWIG_MODULE_swigfaiss_EXTRA_DEPS "${faiss_SOURCE_DIR}/faiss/${h}")
-    list(APPEND SWIG_MODULE_swigfaiss_avx2_EXTRA_DEPS "${faiss_SOURCE_DIR}/faiss/${h}")
-    list(APPEND SWIG_MODULE_swigfaiss_avx512_EXTRA_DEPS "${faiss_SOURCE_DIR}/faiss/${h}")
+    list(APPEND SWIG_MODULE_swigfaiss_EXTRA_DEPS "${faiss_SOURCE_DIR}/knowherefaiss/${h}")
+    list(APPEND SWIG_MODULE_swigfaiss_avx2_EXTRA_DEPS "${faiss_SOURCE_DIR}/knowherefaiss/${h}")
+    list(APPEND SWIG_MODULE_swigfaiss_avx512_EXTRA_DEPS "${faiss_SOURCE_DIR}/knowherefaiss/${h}")
   endforeach()
   foreach(h ${FAISS_GPU_HEADERS})
-    list(APPEND SWIG_MODULE_swigfaiss_EXTRA_DEPS "${faiss_SOURCE_DIR}/faiss/gpu/${h}")
-    list(APPEND SWIG_MODULE_swigfaiss_avx2_EXTRA_DEPS "${faiss_SOURCE_DIR}/faiss/gpu/${h}")
-    list(APPEND SWIG_MODULE_swigfaiss_avx512_EXTRA_DEPS "${faiss_SOURCE_DIR}/faiss/gpu/${h}")
+    list(APPEND SWIG_MODULE_swigfaiss_EXTRA_DEPS "${faiss_SOURCE_DIR}/knowherefaiss/gpu/${h}")
+    list(APPEND SWIG_MODULE_swigfaiss_avx2_EXTRA_DEPS "${faiss_SOURCE_DIR}/knowherefaiss/gpu/${h}")
+    list(APPEND SWIG_MODULE_swigfaiss_avx512_EXTRA_DEPS "${faiss_SOURCE_DIR}/knowherefaiss/gpu/${h}")
   endforeach()
 else()
   find_package(faiss REQUIRED)
@@ -153,7 +153,7 @@ target_link_libraries(swigfaiss_avx512 PRIVATE
 )
 
 # Hack so that python_callbacks.h can be included as
-# `#include <faiss/python/python_callbacks.h>`.
+# `#include <knowherefaiss/python/python_callbacks.h>`.
 target_include_directories(swigfaiss PRIVATE ${PROJECT_SOURCE_DIR}/../..)
 target_include_directories(swigfaiss_avx2 PRIVATE ${PROJECT_SOURCE_DIR}/../..)
 target_include_directories(swigfaiss_avx512 PRIVATE ${PROJECT_SOURCE_DIR}/../..)
@@ -174,7 +174,7 @@ target_link_libraries(faiss_python_callbacks PRIVATE faiss)
 endif()
 
 # Hack so that python_callbacks.h can be included as
-# `#include <faiss/python/python_callbacks.h>`.
+# `#include <knowherefaiss/python/python_callbacks.h>`.
 target_include_directories(faiss_python_callbacks PRIVATE ${PROJECT_SOURCE_DIR}/../..)
 target_include_directories(faiss_python_callbacks PRIVATE ${Python_INCLUDE_DIRS})
 
diff --git a/thirdparty/faiss/faiss/python/__init__.py b/thirdparty/faiss/knowherefaiss/python/__init__.py
similarity index 100%
rename from thirdparty/faiss/faiss/python/__init__.py
rename to thirdparty/faiss/knowherefaiss/python/__init__.py
diff --git a/thirdparty/faiss/faiss/python/loader.py b/thirdparty/faiss/knowherefaiss/python/loader.py
similarity index 100%
rename from thirdparty/faiss/faiss/python/loader.py
rename to thirdparty/faiss/knowherefaiss/python/loader.py
diff --git a/thirdparty/faiss/faiss/python/python_callbacks.cpp b/thirdparty/faiss/knowherefaiss/python/python_callbacks.cpp
similarity index 96%
rename from thirdparty/faiss/faiss/python/python_callbacks.cpp
rename to thirdparty/faiss/knowherefaiss/python/python_callbacks.cpp
index 551a2410..53c221c2 100644
--- a/thirdparty/faiss/faiss/python/python_callbacks.cpp
+++ b/thirdparty/faiss/knowherefaiss/python/python_callbacks.cpp
@@ -5,8 +5,8 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/impl/FaissAssert.h>
-#include <faiss/python/python_callbacks.h>
+#include <knowherefaiss/impl/FaissAssert.h>
+#include <knowherefaiss/python/python_callbacks.h>
 
 namespace {
 
diff --git a/thirdparty/faiss/faiss/python/python_callbacks.h b/thirdparty/faiss/knowherefaiss/python/python_callbacks.h
similarity index 86%
rename from thirdparty/faiss/faiss/python/python_callbacks.h
rename to thirdparty/faiss/knowherefaiss/python/python_callbacks.h
index 4ebd3104..f3fe0f5f 100644
--- a/thirdparty/faiss/faiss/python/python_callbacks.h
+++ b/thirdparty/faiss/knowherefaiss/python/python_callbacks.h
@@ -7,8 +7,8 @@
 
 #pragma once
 
-#include <faiss/impl/io.h>
-#include <faiss/invlists/InvertedLists.h>
+#include <knowherefaiss/impl/io.h>
+#include <knowherefaiss/invlists/InvertedLists.h>
 #include "Python.h"
 
 //  all callbacks have to acquire the GIL on input
@@ -17,7 +17,7 @@
  * Callbacks for IO reader and writer
  ***********************************************************/
 
-struct PyCallbackIOWriter : faiss::IOWriter {
+struct PyCallbackIOWriter : knowherefaiss::IOWriter {
     PyObject* callback;
     size_t bs; // maximum write size
 
@@ -31,7 +31,7 @@ struct PyCallbackIOWriter : faiss::IOWriter {
     ~PyCallbackIOWriter() override;
 };
 
-struct PyCallbackIOReader : faiss::IOReader {
+struct PyCallbackIOReader : knowherefaiss::IOReader {
     PyObject* callback;
     size_t bs; // maximum buffer size
 
diff --git a/thirdparty/faiss/faiss/python/setup.py b/thirdparty/faiss/knowherefaiss/python/setup.py
similarity index 69%
rename from thirdparty/faiss/faiss/python/setup.py
rename to thirdparty/faiss/knowherefaiss/python/setup.py
index 939aeeff..87435e62 100644
--- a/thirdparty/faiss/faiss/python/setup.py
+++ b/thirdparty/faiss/knowherefaiss/python/setup.py
@@ -10,15 +10,15 @@ import shutil
 import platform
 
 # make the faiss python package dir
-shutil.rmtree("faiss", ignore_errors=True)
-os.mkdir("faiss")
-shutil.copytree("contrib", "faiss/contrib")
-shutil.copyfile("__init__.py", "faiss/__init__.py")
-shutil.copyfile("loader.py", "faiss/loader.py")
-shutil.copyfile("class_wrappers.py", "faiss/class_wrappers.py")
-shutil.copyfile("gpu_wrappers.py", "faiss/gpu_wrappers.py")
-shutil.copyfile("extra_wrappers.py", "faiss/extra_wrappers.py")
-shutil.copyfile("array_conversions.py", "faiss/array_conversions.py")
+shutil.rmtree("knowherefaiss", ignore_errors=True)
+os.mkdir("knowherefaiss")
+shutil.copytree("contrib", "knowherefaiss/contrib")
+shutil.copyfile("__init__.py", "knowherefaiss/__init__.py")
+shutil.copyfile("loader.py", "knowherefaiss/loader.py")
+shutil.copyfile("class_wrappers.py", "knowherefaiss/class_wrappers.py")
+shutil.copyfile("gpu_wrappers.py", "knowherefaiss/gpu_wrappers.py")
+shutil.copyfile("extra_wrappers.py", "knowherefaiss/extra_wrappers.py")
+shutil.copyfile("array_conversions.py", "knowherefaiss/array_conversions.py")
 
 ext = ".pyd" if platform.system() == 'Windows' else ".so"
 prefix = "Release/" * (platform.system() == 'Windows')
@@ -37,18 +37,18 @@ assert (found_swigfaiss_generic or found_swigfaiss_avx2 or found_swigfaiss_avx51
 
 if found_swigfaiss_generic:
     print(f"Copying {swigfaiss_generic_lib}")
-    shutil.copyfile("swigfaiss.py", "faiss/swigfaiss.py")
-    shutil.copyfile(swigfaiss_generic_lib, f"faiss/_swigfaiss{ext}")
+    shutil.copyfile("swigfaiss.py", "knowherefaiss/swigfaiss.py")
+    shutil.copyfile(swigfaiss_generic_lib, f"knowherefaiss/_swigfaiss{ext}")
 
 if found_swigfaiss_avx2:
     print(f"Copying {swigfaiss_avx2_lib}")
-    shutil.copyfile("swigfaiss_avx2.py", "faiss/swigfaiss_avx2.py")
-    shutil.copyfile(swigfaiss_avx2_lib, f"faiss/_swigfaiss_avx2{ext}")
+    shutil.copyfile("swigfaiss_avx2.py", "knowherefaiss/swigfaiss_avx2.py")
+    shutil.copyfile(swigfaiss_avx2_lib, f"knowherefaiss/_swigfaiss_avx2{ext}")
 
 if found_swigfaiss_avx512:
     print(f"Copying {swigfaiss_avx512_lib}")
-    shutil.copyfile("swigfaiss_avx512.py", "faiss/swigfaiss_avx512.py")
-    shutil.copyfile(swigfaiss_avx512_lib, f"faiss/_swigfaiss_avx512{ext}")
+    shutil.copyfile("swigfaiss_avx512.py", "knowherefaiss/swigfaiss_avx512.py")
+    shutil.copyfile(swigfaiss_avx512_lib, f"knowherefaiss/_swigfaiss_avx512{ext}")
 
 long_description="""
 Faiss is a library for efficient similarity search and clustering of dense
diff --git a/thirdparty/faiss/faiss/python/swigfaiss.swig b/thirdparty/faiss/knowherefaiss/python/swigfaiss.swig
similarity index 57%
rename from thirdparty/faiss/faiss/python/swigfaiss.swig
rename to thirdparty/faiss/knowherefaiss/python/swigfaiss.swig
index 0ea93609..fbc131f6 100644
--- a/thirdparty/faiss/faiss/python/swigfaiss.swig
+++ b/thirdparty/faiss/knowherefaiss/python/swigfaiss.swig
@@ -65,104 +65,104 @@ typedef uint64_t size_t;
 #endif
 
 
-#include <faiss/IndexFlat.h>
-#include <faiss/VectorTransform.h>
-#include <faiss/IndexPreTransform.h>
-#include <faiss/IndexLSH.h>
-#include <faiss/IndexPQ.h>
-#include <faiss/IndexAdditiveQuantizer.h>
-#include <faiss/IndexIVF.h>
-#include <faiss/IndexIVFPQ.h>
-#include <faiss/Index2Layer.h>
-#include <faiss/IndexIVFPQR.h>
-#include <faiss/IndexIVFFlat.h>
-#include <faiss/IndexIVFIndependentQuantizer.h>
-
-#include <faiss/IndexFastScan.h>
-#include <faiss/IndexAdditiveQuantizerFastScan.h>
-#include <faiss/IndexPQFastScan.h>
-#include <faiss/utils/simdlib.h>
-#include <faiss/impl/simd_result_handlers.h>
-
-#include <faiss/IndexIVFFastScan.h>
-#include <faiss/IndexIVFAdditiveQuantizerFastScan.h>
-#include <faiss/IndexIVFPQFastScan.h>
-#include <faiss/utils/quantize_lut.h>
-
-#include <faiss/IndexScalarQuantizer.h>
-#include <faiss/IndexIVFAdditiveQuantizer.h>
-#include <faiss/IndexIVFSpectralHash.h>
-#include <faiss/impl/ThreadedIndex.h>
-#include <faiss/IndexShards.h>
-#include <faiss/IndexShardsIVF.h>
-#include <faiss/IndexReplicas.h>
-#include <faiss/impl/HNSW.h>
-#include <faiss/IndexHNSW.h>
-
-#include <faiss/impl/kmeans1d.h>
-
-#include <faiss/impl/NNDescent.h>
-#include <faiss/IndexNNDescent.h>
-
-#include <faiss/impl/NSG.h>
-#include <faiss/IndexNSG.h>
-
-#include <faiss/MetaIndexes.h>
-#include <faiss/IndexIDMap.h>
-#include <faiss/IndexRefine.h>
-
-#include <faiss/IndexRowwiseMinMax.h>
-
-#include <faiss/impl/FaissAssert.h>
-
-#include <faiss/IndexBinaryFlat.h>
-#include <faiss/IndexBinaryIVF.h>
-#include <faiss/IndexBinaryFromFloat.h>
-#include <faiss/IndexBinaryHNSW.h>
-#include <faiss/IndexBinaryHash.h>
-
-#include <faiss/impl/io.h>
-#include <faiss/index_io.h>
-#include <faiss/clone_index.h>
-
-#include <faiss/IVFlib.h>
-#include <faiss/utils/utils.h>
-
-#include <faiss/utils/sorting.h>
-#include <faiss/utils/distances.h>
-#include <faiss/utils/extra_distances.h>
-#include <faiss/utils/random.h>
-#include <faiss/utils/Heap.h>
-#include <faiss/utils/AlignedTable.h>
-#include <faiss/utils/partitioning.h>
-#include <faiss/impl/AuxIndexStructures.h>
-#include <faiss/impl/IDSelector.h>
-#include <faiss/impl/DistanceComputer.h>
-#include <faiss/impl/AdditiveQuantizer.h>
-#include <faiss/impl/ResidualQuantizer.h>
-#include <faiss/impl/residual_quantizer_encode_steps.h>
-
-#include <faiss/impl/LocalSearchQuantizer.h>
-#include <faiss/impl/ProductAdditiveQuantizer.h>
-#include <faiss/impl/CodePacker.h>
-
-#include <faiss/invlists/BlockInvertedLists.h>
+#include <knowherefaiss/IndexFlat.h>
+#include <knowherefaiss/VectorTransform.h>
+#include <knowherefaiss/IndexPreTransform.h>
+#include <knowherefaiss/IndexLSH.h>
+#include <knowherefaiss/IndexPQ.h>
+#include <knowherefaiss/IndexAdditiveQuantizer.h>
+#include <knowherefaiss/IndexIVF.h>
+#include <knowherefaiss/IndexIVFPQ.h>
+#include <knowherefaiss/Index2Layer.h>
+#include <knowherefaiss/IndexIVFPQR.h>
+#include <knowherefaiss/IndexIVFFlat.h>
+#include <knowherefaiss/IndexIVFIndependentQuantizer.h>
+
+#include <knowherefaiss/IndexFastScan.h>
+#include <knowherefaiss/IndexAdditiveQuantizerFastScan.h>
+#include <knowherefaiss/IndexPQFastScan.h>
+#include <knowherefaiss/utils/simdlib.h>
+#include <knowherefaiss/impl/simd_result_handlers.h>
+
+#include <knowherefaiss/IndexIVFFastScan.h>
+#include <knowherefaiss/IndexIVFAdditiveQuantizerFastScan.h>
+#include <knowherefaiss/IndexIVFPQFastScan.h>
+#include <knowherefaiss/utils/quantize_lut.h>
+
+#include <knowherefaiss/IndexScalarQuantizer.h>
+#include <knowherefaiss/IndexIVFAdditiveQuantizer.h>
+#include <knowherefaiss/IndexIVFSpectralHash.h>
+#include <knowherefaiss/impl/ThreadedIndex.h>
+#include <knowherefaiss/IndexShards.h>
+#include <knowherefaiss/IndexShardsIVF.h>
+#include <knowherefaiss/IndexReplicas.h>
+#include <knowherefaiss/impl/HNSW.h>
+#include <knowherefaiss/IndexHNSW.h>
+
+#include <knowherefaiss/impl/kmeans1d.h>
+
+#include <knowherefaiss/impl/NNDescent.h>
+#include <knowherefaiss/IndexNNDescent.h>
+
+#include <knowherefaiss/impl/NSG.h>
+#include <knowherefaiss/IndexNSG.h>
+
+#include <knowherefaiss/MetaIndexes.h>
+#include <knowherefaiss/IndexIDMap.h>
+#include <knowherefaiss/IndexRefine.h>
+
+#include <knowherefaiss/IndexRowwiseMinMax.h>
+
+#include <knowherefaiss/impl/FaissAssert.h>
+
+#include <knowherefaiss/IndexBinaryFlat.h>
+#include <knowherefaiss/IndexBinaryIVF.h>
+#include <knowherefaiss/IndexBinaryFromFloat.h>
+#include <knowherefaiss/IndexBinaryHNSW.h>
+#include <knowherefaiss/IndexBinaryHash.h>
+
+#include <knowherefaiss/impl/io.h>
+#include <knowherefaiss/index_io.h>
+#include <knowherefaiss/clone_index.h>
+
+#include <knowherefaiss/IVFlib.h>
+#include <knowherefaiss/utils/utils.h>
+
+#include <knowherefaiss/utils/sorting.h>
+#include <knowherefaiss/utils/distances.h>
+#include <knowherefaiss/utils/extra_distances.h>
+#include <knowherefaiss/utils/random.h>
+#include <knowherefaiss/utils/Heap.h>
+#include <knowherefaiss/utils/AlignedTable.h>
+#include <knowherefaiss/utils/partitioning.h>
+#include <knowherefaiss/impl/AuxIndexStructures.h>
+#include <knowherefaiss/impl/IDSelector.h>
+#include <knowherefaiss/impl/DistanceComputer.h>
+#include <knowherefaiss/impl/AdditiveQuantizer.h>
+#include <knowherefaiss/impl/ResidualQuantizer.h>
+#include <knowherefaiss/impl/residual_quantizer_encode_steps.h>
+
+#include <knowherefaiss/impl/LocalSearchQuantizer.h>
+#include <knowherefaiss/impl/ProductAdditiveQuantizer.h>
+#include <knowherefaiss/impl/CodePacker.h>
+
+#include <knowherefaiss/invlists/BlockInvertedLists.h>
 
 #ifndef _MSC_VER
-#include <faiss/invlists/OnDiskInvertedLists.h>
+#include <knowherefaiss/invlists/OnDiskInvertedLists.h>
 #endif // !_MSC_VER
 
-#include <faiss/Clustering.h>
+#include <knowherefaiss/Clustering.h>
 
-#include <faiss/utils/hamming.h>
-#include <faiss/utils/hamming_distance/common.h>
+#include <knowherefaiss/utils/hamming.h>
+#include <knowherefaiss/utils/hamming_distance/common.h>
 
-#include <faiss/AutoTune.h>
-#include <faiss/MatrixStats.h>
-#include <faiss/index_factory.h>
+#include <knowherefaiss/AutoTune.h>
+#include <knowherefaiss/MatrixStats.h>
+#include <knowherefaiss/index_factory.h>
 
-#include <faiss/impl/lattice_Zn.h>
-#include <faiss/IndexLattice.h>
+#include <knowherefaiss/impl/lattice_Zn.h>
+#include <knowherefaiss/IndexLattice.h>
 
 
 %}
@@ -172,7 +172,7 @@ typedef uint64_t size_t;
  ********************************************************/
 
 #ifdef SWIGPYTHON
-// %catches(faiss::FaissException);
+// %catches(knowherefaiss::FaissException);
 
 
 // Python-specific: release GIL by default for all functions
@@ -180,7 +180,7 @@ typedef uint64_t size_t;
     Py_BEGIN_ALLOW_THREADS
     try {
         $action
-    } catch(faiss::FaissException & e) {
+    } catch(knowherefaiss::FaissException & e) {
         PyEval_RestoreThread(_save);
 
         if (PyErr_Occurred()) {
@@ -250,43 +250,43 @@ namespace std {
 %template(UInt8VectorVector) std::vector<std::vector<uint8_t> >;
 %template(Int32VectorVector) std::vector<std::vector<int32_t> >;
 %template(Int64VectorVector) std::vector<std::vector<int64_t> >;
-%template(VectorTransformVector) std::vector<faiss::VectorTransform*>;
-%template(OperatingPointVector) std::vector<faiss::OperatingPoint>;
-%template(InvertedListsPtrVector) std::vector<faiss::InvertedLists*>;
-%template(RepeatVector) std::vector<faiss::Repeat>;
-%template(ClusteringIterationStatsVector) std::vector<faiss::ClusteringIterationStats>;
-%template(ParameterRangeVector) std::vector<faiss::ParameterRange>;
+%template(VectorTransformVector) std::vector<knowherefaiss::VectorTransform*>;
+%template(OperatingPointVector) std::vector<knowherefaiss::OperatingPoint>;
+%template(InvertedListsPtrVector) std::vector<knowherefaiss::InvertedLists*>;
+%template(RepeatVector) std::vector<knowherefaiss::Repeat>;
+%template(ClusteringIterationStatsVector) std::vector<knowherefaiss::ClusteringIterationStats>;
+%template(ParameterRangeVector) std::vector<knowherefaiss::ParameterRange>;
 
 
 #ifndef SWIGWIN
-%template(OnDiskOneListVector) std::vector<faiss::OnDiskOneList>;
+%template(OnDiskOneListVector) std::vector<knowherefaiss::OnDiskOneList>;
 #endif // !SWIGWIN
 
 #ifdef GPU_WRAPPER
-%template(GpuResourcesVector) std::vector<faiss::gpu::GpuResourcesProvider*>;
+%template(GpuResourcesVector) std::vector<knowherefaiss::gpu::GpuResourcesProvider*>;
 #endif
 
 // produces an error on the Mac
-%ignore faiss::hamming;
+%ignore knowherefaiss::hamming;
 
 /*******************************************************************
  * Parse headers
  *******************************************************************/
 
-%include <faiss/impl/platform_macros.h>
+%include <knowherefaiss/impl/platform_macros.h>
 
 %ignore *::cmp;
 
-%include <faiss/utils/ordered_key_value.h>
-%include <faiss/utils/Heap.h>
+%include <knowherefaiss/utils/ordered_key_value.h>
+%include <knowherefaiss/utils/Heap.h>
 
 // this ignore seems to be ignored, so disable W362 above
-%ignore faiss::AlignedTable::operator=;
+%ignore knowherefaiss::AlignedTable::operator=;
 
-%include <faiss/utils/AlignedTable.h>
-%include <faiss/utils/partitioning.h>
-%include <faiss/utils/hamming.h>
-%include <faiss/utils/hamming_distance/common.h>
+%include <knowherefaiss/utils/AlignedTable.h>
+%include <knowherefaiss/utils/partitioning.h>
+%include <knowherefaiss/utils/hamming.h>
+%include <knowherefaiss/utils/hamming_distance/common.h>
 
 int get_num_gpus();
 void gpu_profiler_start();
@@ -295,44 +295,44 @@ void gpu_sync_all_devices();
 
 #ifdef GPU_WRAPPER
 
-%shared_ptr(faiss::gpu::GpuResources);
-%shared_ptr(faiss::gpu::StandardGpuResourcesImpl);
+%shared_ptr(knowherefaiss::gpu::GpuResources);
+%shared_ptr(knowherefaiss::gpu::StandardGpuResourcesImpl);
 
 %{
 
-#include <faiss/gpu/StandardGpuResources.h>
-#include <faiss/gpu/GpuIndicesOptions.h>
-#include <faiss/gpu/GpuClonerOptions.h>
-#include <faiss/gpu/GpuIndex.h>
-#include <faiss/gpu/GpuIndexFlat.h>
-#include <faiss/gpu/GpuIndexIVF.h>
-#include <faiss/gpu/GpuIndexIVFPQ.h>
-#include <faiss/gpu/GpuIndexIVFFlat.h>
-#include <faiss/gpu/GpuIndexIVFScalarQuantizer.h>
-#include <faiss/gpu/GpuIndexBinaryFlat.h>
-#include <faiss/gpu/GpuAutoTune.h>
-#include <faiss/gpu/GpuCloner.h>
-#include <faiss/gpu/GpuDistance.h>
-#include <faiss/gpu/GpuIcmEncoder.h>
+#include <knowherefaiss/gpu/StandardGpuResources.h>
+#include <knowherefaiss/gpu/GpuIndicesOptions.h>
+#include <knowherefaiss/gpu/GpuClonerOptions.h>
+#include <knowherefaiss/gpu/GpuIndex.h>
+#include <knowherefaiss/gpu/GpuIndexFlat.h>
+#include <knowherefaiss/gpu/GpuIndexIVF.h>
+#include <knowherefaiss/gpu/GpuIndexIVFPQ.h>
+#include <knowherefaiss/gpu/GpuIndexIVFFlat.h>
+#include <knowherefaiss/gpu/GpuIndexIVFScalarQuantizer.h>
+#include <knowherefaiss/gpu/GpuIndexBinaryFlat.h>
+#include <knowherefaiss/gpu/GpuAutoTune.h>
+#include <knowherefaiss/gpu/GpuCloner.h>
+#include <knowherefaiss/gpu/GpuDistance.h>
+#include <knowherefaiss/gpu/GpuIcmEncoder.h>
 
 int get_num_gpus()
 {
-    return faiss::gpu::getNumDevices();
+    return knowherefaiss::gpu::getNumDevices();
 }
 
 void gpu_profiler_start()
 {
-    return faiss::gpu::profilerStart();
+    return knowherefaiss::gpu::profilerStart();
 }
 
 void gpu_profiler_stop()
 {
-    return faiss::gpu::profilerStop();
+    return knowherefaiss::gpu::profilerStop();
 }
 
 void gpu_sync_all_devices()
 {
-    return faiss::gpu::synchronizeAllDevices();
+    return knowherefaiss::gpu::synchronizeAllDevices();
 }
 
 %}
@@ -343,12 +343,12 @@ void gpu_sync_all_devices()
 
 // causes weird wrapper bug
 %ignore *::allocMemoryHandle;
-%ignore faiss::gpu::GpuMemoryReservation;
-%ignore faiss::gpu::GpuMemoryReservation::operator=(GpuMemoryReservation&&);
-%ignore faiss::gpu::AllocType;
+%ignore knowherefaiss::gpu::GpuMemoryReservation;
+%ignore knowherefaiss::gpu::GpuMemoryReservation::operator=(GpuMemoryReservation&&);
+%ignore knowherefaiss::gpu::AllocType;
 
-%include  <faiss/gpu/GpuResources.h>
-%include  <faiss/gpu/StandardGpuResources.h>
+%include  <knowherefaiss/gpu/GpuResources.h>
+%include  <knowherefaiss/gpu/StandardGpuResources.h>
 
 typedef CUstream_st* cudaStream_t;
 
@@ -391,180 +391,180 @@ void gpu_sync_all_devices()
 
 // order matters because includes are not recursive
 
-%include  <faiss/utils/utils.h>
-%template(CombinerRangeKNNfloat) faiss::CombinerRangeKNN<float>;
-%template(CombinerRangeKNNint16) faiss::CombinerRangeKNN<int16_t>;
+%include  <knowherefaiss/utils/utils.h>
+%template(CombinerRangeKNNfloat) knowherefaiss::CombinerRangeKNN<float>;
+%template(CombinerRangeKNNint16) knowherefaiss::CombinerRangeKNN<int16_t>;
 
-%include  <faiss/utils/distances.h>
-%include  <faiss/utils/random.h>
-%include  <faiss/utils/sorting.h>
+%include  <knowherefaiss/utils/distances.h>
+%include  <knowherefaiss/utils/random.h>
+%include  <knowherefaiss/utils/sorting.h>
 
-%include  <faiss/MetricType.h>
+%include  <knowherefaiss/MetricType.h>
 
 %newobject *::get_distance_computer() const;
 %newobject *::get_CodePacker() const;
 
-%include  <faiss/Index.h>
+%include  <knowherefaiss/Index.h>
 
-%include <faiss/impl/DistanceComputer.h>
+%include <knowherefaiss/impl/DistanceComputer.h>
 
 %newobject *::get_FlatCodesDistanceComputer() const;
-%include  <faiss/IndexFlatCodes.h>
-%include  <faiss/IndexFlat.h>
-%include  <faiss/Clustering.h>
-
-%include  <faiss/utils/extra_distances.h>
-
-%ignore faiss::ProductQuantizer::get_centroids(size_t,size_t) const;
-
-%include  <faiss/impl/Quantizer.h>
-%include  <faiss/impl/ProductQuantizer.h>
-%include  <faiss/impl/AdditiveQuantizer.h>
-%include  <faiss/impl/residual_quantizer_encode_steps.h>
-%include  <faiss/impl/ResidualQuantizer.h>
-%include  <faiss/impl/LocalSearchQuantizer.h>
-%include  <faiss/impl/ProductAdditiveQuantizer.h>
-%include  <faiss/impl/CodePacker.h>
-
-%include  <faiss/VectorTransform.h>
-%include  <faiss/IndexPreTransform.h>
-%include  <faiss/IndexRefine.h>
-%include  <faiss/IndexLSH.h>
-%include  <faiss/impl/PolysemousTraining.h>
-%include  <faiss/IndexPQ.h>
-%include  <faiss/IndexAdditiveQuantizer.h>
-%include  <faiss/impl/io.h>
-
-%include  <faiss/invlists/InvertedLists.h>
-%include  <faiss/invlists/InvertedListsIOHook.h>
+%include  <knowherefaiss/IndexFlatCodes.h>
+%include  <knowherefaiss/IndexFlat.h>
+%include  <knowherefaiss/Clustering.h>
+
+%include  <knowherefaiss/utils/extra_distances.h>
+
+%ignore knowherefaiss::ProductQuantizer::get_centroids(size_t,size_t) const;
+
+%include  <knowherefaiss/impl/Quantizer.h>
+%include  <knowherefaiss/impl/ProductQuantizer.h>
+%include  <knowherefaiss/impl/AdditiveQuantizer.h>
+%include  <knowherefaiss/impl/residual_quantizer_encode_steps.h>
+%include  <knowherefaiss/impl/ResidualQuantizer.h>
+%include  <knowherefaiss/impl/LocalSearchQuantizer.h>
+%include  <knowherefaiss/impl/ProductAdditiveQuantizer.h>
+%include  <knowherefaiss/impl/CodePacker.h>
+
+%include  <knowherefaiss/VectorTransform.h>
+%include  <knowherefaiss/IndexPreTransform.h>
+%include  <knowherefaiss/IndexRefine.h>
+%include  <knowherefaiss/IndexLSH.h>
+%include  <knowherefaiss/impl/PolysemousTraining.h>
+%include  <knowherefaiss/IndexPQ.h>
+%include  <knowherefaiss/IndexAdditiveQuantizer.h>
+%include  <knowherefaiss/impl/io.h>
+
+%include  <knowherefaiss/invlists/InvertedLists.h>
+%include  <knowherefaiss/invlists/InvertedListsIOHook.h>
 %ignore BlockInvertedListsIOHook;
-%include  <faiss/invlists/BlockInvertedLists.h>
-%include  <faiss/invlists/DirectMap.h>
-%include  <faiss/IndexIVF.h>
+%include  <knowherefaiss/invlists/BlockInvertedLists.h>
+%include  <knowherefaiss/invlists/DirectMap.h>
+%include  <knowherefaiss/IndexIVF.h>
 // NOTE(hoss): SWIG (wrongly) believes the overloaded const version shadows the
 //   non-const one.
 %warnfilter(509) extract_index_ivf;
 %warnfilter(509) try_extract_index_ivf;
-%include  <faiss/IVFlib.h>
-%include  <faiss/impl/ScalarQuantizer.h>
-%include  <faiss/IndexScalarQuantizer.h>
-%include  <faiss/IndexIVFSpectralHash.h>
-%include  <faiss/IndexIVFAdditiveQuantizer.h>
-%include  <faiss/impl/HNSW.h>
-%include  <faiss/IndexHNSW.h>
+%include  <knowherefaiss/IVFlib.h>
+%include  <knowherefaiss/impl/ScalarQuantizer.h>
+%include  <knowherefaiss/IndexScalarQuantizer.h>
+%include  <knowherefaiss/IndexIVFSpectralHash.h>
+%include  <knowherefaiss/IndexIVFAdditiveQuantizer.h>
+%include  <knowherefaiss/impl/HNSW.h>
+%include  <knowherefaiss/IndexHNSW.h>
 
-%include <faiss/impl/kmeans1d.h>
+%include <knowherefaiss/impl/kmeans1d.h>
 
-%ignore faiss::nndescent::Nhood::lock;
-%include  <faiss/impl/NNDescent.h>
-%include  <faiss/IndexNNDescent.h>
+%ignore knowherefaiss::nndescent::Nhood::lock;
+%include  <knowherefaiss/impl/NNDescent.h>
+%include  <knowherefaiss/IndexNNDescent.h>
 
-%include  <faiss/IndexIVFFlat.h>
+%include  <knowherefaiss/IndexIVFFlat.h>
 
-%warnfilter(509) faiss::nsg::Graph< int >::at(int,int);
+%warnfilter(509) knowherefaiss::nsg::Graph< int >::at(int,int);
 
-%include  <faiss/impl/NSG.h>
+%include  <knowherefaiss/impl/NSG.h>
 
-%template(NSG_Graph_int) faiss::nsg::Graph<int>;
+%template(NSG_Graph_int) knowherefaiss::nsg::Graph<int>;
 
 // not using %shared_ptr to avoid mem leaks
-%extend faiss::NSG {
-    faiss::nsg::Graph<int>* get_final_graph() {
+%extend knowherefaiss::NSG {
+    knowherefaiss::nsg::Graph<int>* get_final_graph() {
         return $self->final_graph.get();
     }
 }
 
-%include  <faiss/IndexNSG.h>
+%include  <knowherefaiss/IndexNSG.h>
 
 #ifndef SWIGWIN
-%warnfilter(401) faiss::OnDiskInvertedListsIOHook;
+%warnfilter(401) knowherefaiss::OnDiskInvertedListsIOHook;
 %ignore OnDiskInvertedListsIOHook;
-%include  <faiss/invlists/OnDiskInvertedLists.h>
+%include  <knowherefaiss/invlists/OnDiskInvertedLists.h>
 #endif // !SWIGWIN
 
-%include  <faiss/impl/lattice_Zn.h>
-%include  <faiss/IndexLattice.h>
+%include  <knowherefaiss/impl/lattice_Zn.h>
+%include  <knowherefaiss/IndexLattice.h>
 
-%ignore faiss::IndexIVFPQ::alloc_type;
-%include  <faiss/IndexIVFPQ.h>
-%include  <faiss/IndexIVFPQR.h>
-%include  <faiss/Index2Layer.h>
+%ignore knowherefaiss::IndexIVFPQ::alloc_type;
+%include  <knowherefaiss/IndexIVFPQ.h>
+%include  <knowherefaiss/IndexIVFPQR.h>
+%include  <knowherefaiss/Index2Layer.h>
 
-%include  <faiss/IndexFastScan.h>
-%include  <faiss/IndexAdditiveQuantizerFastScan.h>
-%include  <faiss/IndexPQFastScan.h>
+%include  <knowherefaiss/IndexFastScan.h>
+%include  <knowherefaiss/IndexAdditiveQuantizerFastScan.h>
+%include  <knowherefaiss/IndexPQFastScan.h>
 
 // NOTE(matthijs) let's not go into wrapping simdlib
-struct faiss::simd16uint16 {};
+struct knowherefaiss::simd16uint16 {};
 
-%include  <faiss/impl/simd_result_handlers.h>
-%include  <faiss/IndexIVFFastScan.h>
-%include  <faiss/IndexIVFAdditiveQuantizerFastScan.h>
-%include  <faiss/IndexIVFIndependentQuantizer.h>
+%include  <knowherefaiss/impl/simd_result_handlers.h>
+%include  <knowherefaiss/IndexIVFFastScan.h>
+%include  <knowherefaiss/IndexIVFAdditiveQuantizerFastScan.h>
+%include  <knowherefaiss/IndexIVFIndependentQuantizer.h>
 
-%include  <faiss/IndexIVFPQFastScan.h>
-%include  <faiss/utils/quantize_lut.h>
+%include  <knowherefaiss/IndexIVFPQFastScan.h>
+%include  <knowherefaiss/utils/quantize_lut.h>
 
-%include  <faiss/IndexBinary.h>
-%include  <faiss/IndexBinaryFlat.h>
-%include  <faiss/IndexBinaryIVF.h>
-%include  <faiss/IndexBinaryFromFloat.h>
-%include  <faiss/IndexBinaryHNSW.h>
-%include  <faiss/IndexBinaryHash.h>
+%include  <knowherefaiss/IndexBinary.h>
+%include  <knowherefaiss/IndexBinaryFlat.h>
+%include  <knowherefaiss/IndexBinaryIVF.h>
+%include  <knowherefaiss/IndexBinaryFromFloat.h>
+%include  <knowherefaiss/IndexBinaryHNSW.h>
+%include  <knowherefaiss/IndexBinaryHash.h>
 
-%include  <faiss/impl/ThreadedIndex.h>
-%template(ThreadedIndexBase) faiss::ThreadedIndex<faiss::Index>;
-%template(ThreadedIndexBaseBinary) faiss::ThreadedIndex<faiss::IndexBinary>;
+%include  <knowherefaiss/impl/ThreadedIndex.h>
+%template(ThreadedIndexBase) knowherefaiss::ThreadedIndex<knowherefaiss::Index>;
+%template(ThreadedIndexBaseBinary) knowherefaiss::ThreadedIndex<knowherefaiss::IndexBinary>;
 
-%include  <faiss/IndexShards.h>
-%template(IndexShards) faiss::IndexShardsTemplate<faiss::Index>;
-%template(IndexBinaryShards) faiss::IndexShardsTemplate<faiss::IndexBinary>;
-%include  <faiss/IndexShardsIVF.h>
+%include  <knowherefaiss/IndexShards.h>
+%template(IndexShards) knowherefaiss::IndexShardsTemplate<knowherefaiss::Index>;
+%template(IndexBinaryShards) knowherefaiss::IndexShardsTemplate<knowherefaiss::IndexBinary>;
+%include  <knowherefaiss/IndexShardsIVF.h>
 
-%include  <faiss/IndexReplicas.h>
-%template(IndexReplicas) faiss::IndexReplicasTemplate<faiss::Index>;
-%template(IndexBinaryReplicas) faiss::IndexReplicasTemplate<faiss::IndexBinary>;
+%include  <knowherefaiss/IndexReplicas.h>
+%template(IndexReplicas) knowherefaiss::IndexReplicasTemplate<knowherefaiss::Index>;
+%template(IndexBinaryReplicas) knowherefaiss::IndexReplicasTemplate<knowherefaiss::IndexBinary>;
 
-%include  <faiss/MetaIndexes.h>
+%include  <knowherefaiss/MetaIndexes.h>
 
-%include  <faiss/IndexRowwiseMinMax.h>
+%include  <knowherefaiss/IndexRowwiseMinMax.h>
 
 
-%ignore faiss::BufferList::Buffer;
-%ignore faiss::RangeSearchPartialResult::QueryResult;
-%ignore faiss::IDSelectorBatch::set;
-%ignore faiss::IDSelectorBatch::bloom;
-%ignore faiss::InterruptCallback::instance;
-%ignore faiss::InterruptCallback::lock;
+%ignore knowherefaiss::BufferList::Buffer;
+%ignore knowherefaiss::RangeSearchPartialResult::QueryResult;
+%ignore knowherefaiss::IDSelectorBatch::set;
+%ignore knowherefaiss::IDSelectorBatch::bloom;
+%ignore knowherefaiss::InterruptCallback::instance;
+%ignore knowherefaiss::InterruptCallback::lock;
 
-%include <faiss/impl/AuxIndexStructures.h>
-%include <faiss/impl/IDSelector.h>
+%include <knowherefaiss/impl/AuxIndexStructures.h>
+%include <knowherefaiss/impl/IDSelector.h>
 
-%include  <faiss/IndexIDMap.h>
-%template(IndexIDMap) faiss::IndexIDMapTemplate<faiss::Index>;
-%template(IndexBinaryIDMap) faiss::IndexIDMapTemplate<faiss::IndexBinary>;
-%template(IndexIDMap2) faiss::IndexIDMap2Template<faiss::Index>;
-%template(IndexBinaryIDMap2) faiss::IndexIDMap2Template<faiss::IndexBinary>;
+%include  <knowherefaiss/IndexIDMap.h>
+%template(IndexIDMap) knowherefaiss::IndexIDMapTemplate<knowherefaiss::Index>;
+%template(IndexBinaryIDMap) knowherefaiss::IndexIDMapTemplate<knowherefaiss::IndexBinary>;
+%template(IndexIDMap2) knowherefaiss::IndexIDMap2Template<knowherefaiss::Index>;
+%template(IndexBinaryIDMap2) knowherefaiss::IndexIDMap2Template<knowherefaiss::IndexBinary>;
 
 
-%include <faiss/utils/approx_topk/mode.h>
+%include <knowherefaiss/utils/approx_topk/mode.h>
 
 #ifdef GPU_WRAPPER
 
 // quiet SWIG warnings
-%ignore faiss::gpu::GpuIndexIVF::GpuIndexIVF;
+%ignore knowherefaiss::gpu::GpuIndexIVF::GpuIndexIVF;
 
-%include  <faiss/gpu/GpuIndicesOptions.h>
-%include  <faiss/gpu/GpuClonerOptions.h>
-%include  <faiss/gpu/GpuIndex.h>
-%include  <faiss/gpu/GpuIndexFlat.h>
-%include  <faiss/gpu/GpuIndexIVF.h>
-%include  <faiss/gpu/GpuIndexIVFPQ.h>
-%include  <faiss/gpu/GpuIndexIVFFlat.h>
-%include  <faiss/gpu/GpuIndexIVFScalarQuantizer.h>
-%include  <faiss/gpu/GpuIndexBinaryFlat.h>
-%include  <faiss/gpu/GpuDistance.h>
-%include  <faiss/gpu/GpuIcmEncoder.h>
+%include  <knowherefaiss/gpu/GpuIndicesOptions.h>
+%include  <knowherefaiss/gpu/GpuClonerOptions.h>
+%include  <knowherefaiss/gpu/GpuIndex.h>
+%include  <knowherefaiss/gpu/GpuIndexFlat.h>
+%include  <knowherefaiss/gpu/GpuIndexIVF.h>
+%include  <knowherefaiss/gpu/GpuIndexIVFPQ.h>
+%include  <knowherefaiss/gpu/GpuIndexIVFFlat.h>
+%include  <knowherefaiss/gpu/GpuIndexIVFScalarQuantizer.h>
+%include  <knowherefaiss/gpu/GpuIndexBinaryFlat.h>
+%include  <knowherefaiss/gpu/GpuDistance.h>
+%include  <knowherefaiss/gpu/GpuIcmEncoder.h>
 
 
 #endif
@@ -585,19 +585,19 @@ struct faiss::simd16uint16 {};
 #ifdef SWIGPYTHON
 
 %define DOWNCAST(subclass)
-    if (dynamic_cast<faiss::subclass *> ($1)) {
+    if (dynamic_cast<knowherefaiss::subclass *> ($1)) {
       $result = SWIG_NewPointerObj($1,SWIGTYPE_p_faiss__ ## subclass,$owner);
     } else
 %enddef
 
 %define DOWNCAST2(subclass, longname)
-    if (dynamic_cast<faiss::subclass *> ($1)) {
+    if (dynamic_cast<knowherefaiss::subclass *> ($1)) {
       $result = SWIG_NewPointerObj($1,SWIGTYPE_p_faiss__ ## longname,$owner);
     } else
 %enddef
 
 %define DOWNCAST_GPU(subclass)
-    if (dynamic_cast<faiss::gpu::subclass *> ($1)) {
+    if (dynamic_cast<knowherefaiss::gpu::subclass *> ($1)) {
       $result = SWIG_NewPointerObj($1,SWIGTYPE_p_faiss__gpu__ ## subclass,$owner);
     } else
 %enddef
@@ -614,7 +614,7 @@ struct faiss::simd16uint16 {};
 %newobject clone_VectorTransform;
 
 // Subclasses should appear before their parent
-%typemap(out) faiss::Index * {
+%typemap(out) knowherefaiss::Index * {
     DOWNCAST2 ( IndexIDMap2, IndexIDMap2TemplateT_faiss__Index_t )
     DOWNCAST2 ( IndexIDMap, IndexIDMapTemplateT_faiss__Index_t )
     DOWNCAST ( IndexShardsIVF )
@@ -691,7 +691,7 @@ struct faiss::simd16uint16 {};
 }
 
 
-%typemap(out) faiss::IndexBinary * {
+%typemap(out) knowherefaiss::IndexBinary * {
     DOWNCAST2 ( IndexBinaryReplicas, IndexReplicasTemplateT_faiss__IndexBinary_t )
     DOWNCAST2 ( IndexBinaryIDMap2, IndexIDMap2TemplateT_faiss__IndexBinary_t )
     DOWNCAST2 ( IndexBinaryIDMap, IndexIDMapTemplateT_faiss__IndexBinary_t )
@@ -716,7 +716,7 @@ struct faiss::simd16uint16 {};
     }
 }
 
-%typemap(out) faiss::VectorTransform * {
+%typemap(out) knowherefaiss::VectorTransform * {
     DOWNCAST (RemapDimensionsTransform)
     DOWNCAST (OPQMatrix)
     DOWNCAST (PCAMatrix)
@@ -732,7 +732,7 @@ struct faiss::simd16uint16 {};
     }
 }
 
-%typemap(out) faiss::InvertedLists * {
+%typemap(out) knowherefaiss::InvertedLists * {
     DOWNCAST (ArrayInvertedLists)
     DOWNCAST (BlockInvertedLists)
 #ifndef SWIGWIN
@@ -747,7 +747,7 @@ struct faiss::simd16uint16 {};
     }
 }
 
-%typemap(out) faiss::Quantizer * {
+%typemap(out) knowherefaiss::Quantizer * {
     DOWNCAST (ScalarQuantizer)
     DOWNCAST (ProductQuantizer)
     DOWNCAST (LocalSearchQuantizer)
@@ -762,52 +762,52 @@ struct faiss::simd16uint16 {};
 // just to downcast pointers that come from elsewhere (eg. direct
 // access to object fields)
 %inline %{
-faiss::Index * downcast_index (faiss::Index *index)
+knowherefaiss::Index * downcast_index (knowherefaiss::Index *index)
 {
     return index;
 }
-faiss::VectorTransform * downcast_VectorTransform (faiss::VectorTransform *vt)
+knowherefaiss::VectorTransform * downcast_VectorTransform (knowherefaiss::VectorTransform *vt)
 {
     return vt;
 }
-faiss::IndexBinary * downcast_IndexBinary (faiss::IndexBinary *index)
+knowherefaiss::IndexBinary * downcast_IndexBinary (knowherefaiss::IndexBinary *index)
 {
     return index;
 }
-faiss::InvertedLists * downcast_InvertedLists (faiss::InvertedLists *il)
+knowherefaiss::InvertedLists * downcast_InvertedLists (knowherefaiss::InvertedLists *il)
 {
     return il;
 }
 // backwards compatibility
-faiss::Quantizer * downcast_AdditiveQuantizer (faiss::AdditiveQuantizer *aq)
+knowherefaiss::Quantizer * downcast_AdditiveQuantizer (knowherefaiss::AdditiveQuantizer *aq)
 {
     return aq;
 }
-faiss::Quantizer * downcast_Quantizer (faiss::Quantizer *aq)
+knowherefaiss::Quantizer * downcast_Quantizer (knowherefaiss::Quantizer *aq)
 {
     return aq;
 }
 %}
 
-%include  <faiss/index_io.h>
-%include  <faiss/clone_index.h>
+%include  <knowherefaiss/index_io.h>
+%include  <knowherefaiss/clone_index.h>
 %newobject index_factory;
 %newobject index_binary_factory;
 
-%include  <faiss/AutoTune.h>
-%include  <faiss/index_factory.h>
-%include  <faiss/MatrixStats.h>
+%include  <knowherefaiss/AutoTune.h>
+%include  <knowherefaiss/index_factory.h>
+%include  <knowherefaiss/MatrixStats.h>
 
 
 #ifdef GPU_WRAPPER
 
-%include  <faiss/gpu/GpuAutoTune.h>
+%include  <knowherefaiss/gpu/GpuAutoTune.h>
 
 %newobject index_gpu_to_cpu;
 %newobject index_cpu_to_gpu;
 %newobject index_cpu_to_gpu_multiple;
 
-%include  <faiss/gpu/GpuCloner.h>
+%include  <knowherefaiss/gpu/GpuCloner.h>
 
 #endif
 
@@ -819,11 +819,11 @@ faiss::Quantizer * downcast_Quantizer (faiss::Quantizer *aq)
 
 
 #ifdef SWIGPYTHON
-%include <faiss/python/python_callbacks.h>
+%include <knowherefaiss/python/python_callbacks.h>
 
 
 %{
-#include <faiss/python/python_callbacks.h>
+#include <knowherefaiss/python/python_callbacks.h>
 %}
 
 #endif
@@ -835,24 +835,24 @@ faiss::Quantizer * downcast_Quantizer (faiss::Quantizer *aq)
 
 // answer: the same as the C++ typedefs, but we still have to redefine them
 
-%template() faiss::CMin<float, int64_t>;
-%template() faiss::CMin<int, int64_t>;
-%template() faiss::CMax<float, int64_t>;
-%template() faiss::CMax<int, int64_t>;
+%template() knowherefaiss::CMin<float, int64_t>;
+%template() knowherefaiss::CMin<int, int64_t>;
+%template() knowherefaiss::CMax<float, int64_t>;
+%template() knowherefaiss::CMax<int, int64_t>;
 
-%template(float_minheap_array_t) faiss::HeapArray<faiss::CMin<float, int64_t> >;
-%template(int_minheap_array_t) faiss::HeapArray<faiss::CMin<int, int64_t> >;
-%template(float_maxheap_array_t) faiss::HeapArray<faiss::CMax<float, int64_t> >;
-%template(int_maxheap_array_t) faiss::HeapArray<faiss::CMax<int, int64_t> >;
+%template(float_minheap_array_t) knowherefaiss::HeapArray<knowherefaiss::CMin<float, int64_t> >;
+%template(int_minheap_array_t) knowherefaiss::HeapArray<knowherefaiss::CMin<int, int64_t> >;
+%template(float_maxheap_array_t) knowherefaiss::HeapArray<knowherefaiss::CMax<float, int64_t> >;
+%template(int_maxheap_array_t) knowherefaiss::HeapArray<knowherefaiss::CMax<int, int64_t> >;
 
 %template(CMin_float_partition_fuzzy)
-    faiss::partition_fuzzy<faiss::CMin<float, int64_t> >;
+    knowherefaiss::partition_fuzzy<knowherefaiss::CMin<float, int64_t> >;
 %template(CMax_float_partition_fuzzy)
-    faiss::partition_fuzzy<faiss::CMax<float, int64_t> >;
+    knowherefaiss::partition_fuzzy<knowherefaiss::CMax<float, int64_t> >;
 
-%template(AlignedTableUint8) faiss::AlignedTable<uint8_t>;
-%template(AlignedTableUint16) faiss::AlignedTable<uint16_t>;
-%template(AlignedTableFloat32) faiss::AlignedTable<float>;
+%template(AlignedTableUint8) knowherefaiss::AlignedTable<uint8_t>;
+%template(AlignedTableUint16) knowherefaiss::AlignedTable<uint16_t>;
+%template(AlignedTableFloat32) knowherefaiss::AlignedTable<float>;
 
 
 // SWIG seems to have some trouble resolving function template types here, so
@@ -866,7 +866,7 @@ uint16_t C ## _uint16_partition_fuzzy(
         uint16_t *vals, id_t *ids, size_t n,
         size_t q_min, size_t q_max, size_t * q_out)
 {
-    return faiss::partition_fuzzy<faiss::C<unsigned short, id_t> >(
+    return knowherefaiss::partition_fuzzy<knowherefaiss::C<unsigned short, id_t> >(
         vals, ids, n, q_min, q_max, q_out);
 }
 
@@ -887,10 +887,10 @@ INSTANTIATE_uint16_partition_fuzzy(CMax, int)
 %inline %{
 void merge_knn_results_ ## C(
     size_t n, size_t k, int nshard,
-    const distance_t *all_distances, const faiss::idx_t *all_labels,
-    distance_t *distances, faiss::idx_t *labels)
+    const distance_t *all_distances, const knowherefaiss::idx_t *all_labels,
+    distance_t *distances, knowherefaiss::idx_t *labels)
 {
-    faiss::merge_knn_results<faiss::idx_t, faiss::C<distance_t, int>>(
+    knowherefaiss::merge_knn_results<knowherefaiss::idx_t, knowherefaiss::C<distance_t, int>>(
         n, k, nshard, all_distances, all_labels, distances, labels);
 }
 %}
@@ -1040,7 +1040,7 @@ PyObject *swig_ptr (PyObject *a)
 }
 
 
-struct PythonInterruptCallback: faiss::InterruptCallback {
+struct PythonInterruptCallback: knowherefaiss::InterruptCallback {
 
     bool want_interrupt () override {
         int err;
@@ -1063,7 +1063,7 @@ struct PythonInterruptCallback: faiss::InterruptCallback {
     /* needed, else crash at runtime */
     import_array();
 
-    faiss::InterruptCallback::instance.reset(new PythonInterruptCallback());
+    knowherefaiss::InterruptCallback::instance.reset(new PythonInterruptCallback());
 
 %}
 
@@ -1110,8 +1110,8 @@ float * cast_integer_to_float_ptr (int64_t x) {
     return (float*)x;
 }
 
-faiss::idx_t* cast_integer_to_idx_t_ptr (int64_t x) {
-    return (faiss::idx_t*)x;
+knowherefaiss::idx_t* cast_integer_to_idx_t_ptr (int64_t x) {
+    return (knowherefaiss::idx_t*)x;
 }
 
 int * cast_integer_to_int_ptr (int64_t x) {
diff --git a/thirdparty/faiss/faiss/utils/AlignedTable.h b/thirdparty/faiss/knowherefaiss/utils/AlignedTable.h
similarity index 97%
rename from thirdparty/faiss/faiss/utils/AlignedTable.h
rename to thirdparty/faiss/knowherefaiss/utils/AlignedTable.h
index 05adb1c0..88794769 100644
--- a/thirdparty/faiss/faiss/utils/AlignedTable.h
+++ b/thirdparty/faiss/knowherefaiss/utils/AlignedTable.h
@@ -14,9 +14,9 @@
 
 #include <algorithm>
 
-#include <faiss/impl/platform_macros.h>
+#include <knowherefaiss/impl/platform_macros.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 template <int A = 32>
 inline bool is_aligned_pointer(const void* x) {
@@ -175,4 +175,4 @@ struct AlignedTable {
     // assign and copy constructor should work as expected
 };
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/utils/Heap.cpp b/thirdparty/faiss/knowherefaiss/utils/Heap.cpp
similarity index 98%
rename from thirdparty/faiss/faiss/utils/Heap.cpp
rename to thirdparty/faiss/knowherefaiss/utils/Heap.cpp
index 3a3e4940..1b111fd4 100644
--- a/thirdparty/faiss/faiss/utils/Heap.cpp
+++ b/thirdparty/faiss/knowherefaiss/utils/Heap.cpp
@@ -9,10 +9,10 @@
 
 /* Function for soft heap */
 
-#include <faiss/impl/FaissAssert.h>
-#include <faiss/utils/Heap.h>
+#include <knowherefaiss/impl/FaissAssert.h>
+#include <knowherefaiss/utils/Heap.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 template <typename C>
 void HeapArray<C>::heapify() {
@@ -293,4 +293,4 @@ template void reorder_2_heaps<CMin<float, int64_t>>(
         size_t k_base,
         const int64_t* __restrict base_labels,
         const float* __restrict base_distances);
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/utils/Heap.h b/thirdparty/faiss/knowherefaiss/utils/Heap.h
similarity index 99%
rename from thirdparty/faiss/faiss/utils/Heap.h
rename to thirdparty/faiss/knowherefaiss/utils/Heap.h
index 41b24f89..07e24eb8 100644
--- a/thirdparty/faiss/faiss/utils/Heap.h
+++ b/thirdparty/faiss/knowherefaiss/utils/Heap.h
@@ -32,9 +32,9 @@
 #include <limits>
 #include <utility>
 
-#include <faiss/utils/ordered_key_value.h>
+#include <knowherefaiss/utils/ordered_key_value.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 /*******************************************************************
  * Basic heap ops: push and pop
@@ -641,6 +641,6 @@ void reorder_2_heaps(
         const typename C::TI* __restrict base_labels,
         const float* __restrict base_distances);
 
-} // namespace faiss
+} // namespace knowherefaiss
 
 #endif /* FAISS_Heap_h */
diff --git a/thirdparty/faiss/faiss/utils/WorkerThread.cpp b/thirdparty/faiss/knowherefaiss/utils/WorkerThread.cpp
similarity index 94%
rename from thirdparty/faiss/faiss/utils/WorkerThread.cpp
rename to thirdparty/faiss/knowherefaiss/utils/WorkerThread.cpp
index afef9c04..691f2638 100644
--- a/thirdparty/faiss/faiss/utils/WorkerThread.cpp
+++ b/thirdparty/faiss/knowherefaiss/utils/WorkerThread.cpp
@@ -5,11 +5,11 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/impl/FaissAssert.h>
-#include <faiss/utils/WorkerThread.h>
+#include <knowherefaiss/impl/FaissAssert.h>
+#include <knowherefaiss/utils/WorkerThread.h>
 #include <exception>
 
-namespace faiss {
+namespace knowherefaiss {
 
 namespace {
 
@@ -114,4 +114,4 @@ void WorkerThread::waitForThreadExit() {
     }
 }
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/utils/WorkerThread.h b/thirdparty/faiss/knowherefaiss/utils/WorkerThread.h
similarity index 96%
rename from thirdparty/faiss/faiss/utils/WorkerThread.h
rename to thirdparty/faiss/knowherefaiss/utils/WorkerThread.h
index 3f2377eb..4c14a3e4 100644
--- a/thirdparty/faiss/faiss/utils/WorkerThread.h
+++ b/thirdparty/faiss/knowherefaiss/utils/WorkerThread.h
@@ -13,7 +13,7 @@
 #include <future>
 #include <thread>
 
-namespace faiss {
+namespace knowherefaiss {
 
 class WorkerThread {
    public:
@@ -58,4 +58,4 @@ class WorkerThread {
     std::deque<std::pair<std::function<void()>, std::promise<bool>>> queue_;
 };
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/utils/approx_topk/approx_topk.h b/thirdparty/faiss/knowherefaiss/utils/approx_topk/approx_topk.h
similarity index 93%
rename from thirdparty/faiss/faiss/utils/approx_topk/approx_topk.h
rename to thirdparty/faiss/knowherefaiss/utils/approx_topk/approx_topk.h
index f5af1ffe..44e98810 100644
--- a/thirdparty/faiss/faiss/utils/approx_topk/approx_topk.h
+++ b/thirdparty/faiss/knowherefaiss/utils/approx_topk/approx_topk.h
@@ -72,13 +72,13 @@
 
 #pragma once
 
-#include <faiss/impl/platform_macros.h>
+#include <knowherefaiss/impl/platform_macros.h>
 
 // the list of available modes is in the following file
-#include <faiss/utils/approx_topk/mode.h>
+#include <knowherefaiss/utils/approx_topk/mode.h>
 
 #ifdef __AVX2__
-#include <faiss/utils/approx_topk/avx2-inl.h>
+#include <knowherefaiss/utils/approx_topk/avx2-inl.h>
 #else
-#include <faiss/utils/approx_topk/generic.h>
+#include <knowherefaiss/utils/approx_topk/generic.h>
 #endif
diff --git a/thirdparty/faiss/faiss/utils/approx_topk/avx2-inl.h b/thirdparty/faiss/knowherefaiss/utils/approx_topk/avx2-inl.h
similarity index 98%
rename from thirdparty/faiss/faiss/utils/approx_topk/avx2-inl.h
rename to thirdparty/faiss/knowherefaiss/utils/approx_topk/avx2-inl.h
index 09bae696..876fb250 100644
--- a/thirdparty/faiss/faiss/utils/approx_topk/avx2-inl.h
+++ b/thirdparty/faiss/knowherefaiss/utils/approx_topk/avx2-inl.h
@@ -11,10 +11,10 @@
 
 #include <limits>
 
-#include <faiss/impl/FaissAssert.h>
-#include <faiss/utils/Heap.h>
+#include <knowherefaiss/impl/FaissAssert.h>
+#include <knowherefaiss/utils/Heap.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 template <typename C, uint32_t NBUCKETS, uint32_t N>
 struct HeapWithBuckets {
@@ -193,4 +193,4 @@ struct HeapWithBuckets<CMax<float, int>, NBUCKETS, N> {
     }
 };
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/utils/approx_topk/generic.h b/thirdparty/faiss/knowherefaiss/utils/approx_topk/generic.h
similarity index 97%
rename from thirdparty/faiss/faiss/utils/approx_topk/generic.h
rename to thirdparty/faiss/knowherefaiss/utils/approx_topk/generic.h
index 59a8dc8d..825c947e 100644
--- a/thirdparty/faiss/faiss/utils/approx_topk/generic.h
+++ b/thirdparty/faiss/knowherefaiss/utils/approx_topk/generic.h
@@ -11,10 +11,10 @@
 #include <limits>
 #include <utility>
 
-#include <faiss/impl/FaissAssert.h>
-#include <faiss/utils/Heap.h>
+#include <knowherefaiss/impl/FaissAssert.h>
+#include <knowherefaiss/utils/Heap.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 // This is the implementation of the idea and it is very slow,
 // because a compiler is unable to vectorize it properly.
@@ -135,4 +135,4 @@ struct HeapWithBuckets<CMax<float, int>, NBUCKETS, N> {
     }
 };
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/utils/approx_topk/mode.h b/thirdparty/faiss/knowherefaiss/utils/approx_topk/mode.h
similarity index 100%
rename from thirdparty/faiss/faiss/utils/approx_topk/mode.h
rename to thirdparty/faiss/knowherefaiss/utils/approx_topk/mode.h
diff --git a/thirdparty/faiss/faiss/utils/approx_topk_hamming/approx_topk_hamming.h b/thirdparty/faiss/knowherefaiss/utils/approx_topk_hamming/approx_topk_hamming.h
similarity index 98%
rename from thirdparty/faiss/faiss/utils/approx_topk_hamming/approx_topk_hamming.h
rename to thirdparty/faiss/knowherefaiss/utils/approx_topk_hamming/approx_topk_hamming.h
index 91c51f2b..24a1afad 100644
--- a/thirdparty/faiss/faiss/utils/approx_topk_hamming/approx_topk_hamming.h
+++ b/thirdparty/faiss/knowherefaiss/utils/approx_topk_hamming/approx_topk_hamming.h
@@ -11,10 +11,10 @@
 #include <limits>
 #include <utility>
 
-#include <faiss/utils/Heap.h>
-#include <faiss/utils/simdlib.h>
+#include <knowherefaiss/utils/Heap.h>
+#include <knowherefaiss/utils/simdlib.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 // HeapWithBucketsForHamming32 uses simd8uint32 under the hood.
 
@@ -113,7 +113,7 @@ struct HeapWithBucketsForHamming32<
                         simd8uint32 max_distances_new;
                         simd8uint32 max_indices_new;
 
-                        faiss::cmplt_min_max_fast(
+                        knowherefaiss::cmplt_min_max_fast(
                                 distance_candidate,
                                 indices_candidate,
                                 min_distances_i[j][p],
@@ -297,7 +297,7 @@ struct HeapWithBucketsForHamming16<
                         simd16uint16 max_distances_new;
                         simd16uint16 max_indices_new;
 
-                        faiss::cmplt_min_max_fast(
+                        knowherefaiss::cmplt_min_max_fast(
                                 distance_candidate,
                                 indices_candidate,
                                 min_distances_i[j][p],
@@ -364,4 +364,4 @@ struct HeapWithBucketsForHamming16<
     }
 };
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/utils/bf16.h b/thirdparty/faiss/knowherefaiss/utils/bf16.h
similarity index 91%
rename from thirdparty/faiss/faiss/utils/bf16.h
rename to thirdparty/faiss/knowherefaiss/utils/bf16.h
index ff0fbe89..dbeb340a 100644
--- a/thirdparty/faiss/faiss/utils/bf16.h
+++ b/thirdparty/faiss/knowherefaiss/utils/bf16.h
@@ -9,7 +9,7 @@
 
 #include <cstdint>
 
-namespace faiss {
+namespace knowherefaiss {
 
 namespace {
 
@@ -33,4 +33,4 @@ inline float decode_bf16(const uint16_t v) {
     return fp.as_f32;
 }
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/utils/binary_distances.cpp b/thirdparty/faiss/knowherefaiss/utils/binary_distances.cpp
similarity index 94%
rename from thirdparty/faiss/faiss/utils/binary_distances.cpp
rename to thirdparty/faiss/knowherefaiss/utils/binary_distances.cpp
index 3fa6d774..dd14697a 100644
--- a/thirdparty/faiss/faiss/utils/binary_distances.cpp
+++ b/thirdparty/faiss/knowherefaiss/utils/binary_distances.cpp
@@ -12,20 +12,20 @@
 // License for the specific language governing permissions and limitations under
 // the License
 
-#include <faiss/utils/binary_distances.h>
+#include <knowherefaiss/utils/binary_distances.h>
 
 #include <omp.h>
 
-#include <faiss/impl/IDSelector.h>
-#include <faiss/utils/hamming.h>
-#include <faiss/utils/jaccard-inl.h>
-#include <faiss/utils/structure-inl.h>
-#include <faiss/utils/utils.h>
+#include <knowherefaiss/impl/IDSelector.h>
+#include <knowherefaiss/utils/hamming.h>
+#include <knowherefaiss/utils/jaccard-inl.h>
+#include <knowherefaiss/utils/structure-inl.h>
+#include <knowherefaiss/utils/utils.h>
 #include <simd/hook.h>
 
 #include <knowhere/bitsetview.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 extern uint8_t lookup8bit[256];
 
@@ -315,7 +315,7 @@ void binary_knn_mc(
             switch (ncodes) {
 #define binary_knn_mc_Substructure(ncodes)                           \
     case ncodes:                                                     \
-        binary_knn_mc<faiss::StructureComputer##ncodes<false>>(      \
+        binary_knn_mc<knowherefaiss::StructureComputer##ncodes<false>>(      \
                 ncodes, a, b, na, nb, k, distances, labels, sel); \
         break;
                 binary_knn_mc_Substructure(8);
@@ -327,7 +327,7 @@ void binary_knn_mc(
                 binary_knn_mc_Substructure(512);
 #undef binary_knn_mc_Substructure
                 default:
-                    binary_knn_mc<faiss::StructureComputerDefault<false>>(
+                    binary_knn_mc<knowherefaiss::StructureComputerDefault<false>>(
                             ncodes, a, b, na, nb, k, distances, labels, sel);
                     break;
             }
@@ -337,7 +337,7 @@ void binary_knn_mc(
             switch (ncodes) {
 #define binary_knn_mc_Superstructure(ncodes)                         \
     case ncodes:                                                     \
-        binary_knn_mc<faiss::StructureComputer##ncodes<true>>(       \
+        binary_knn_mc<knowherefaiss::StructureComputer##ncodes<true>>(       \
                 ncodes, a, b, na, nb, k, distances, labels, sel); \
         break;
                 binary_knn_mc_Superstructure(8);
@@ -349,7 +349,7 @@ void binary_knn_mc(
                 binary_knn_mc_Superstructure(512);
 #undef binary_knn_mc_Superstructure
                 default:
-                    binary_knn_mc<faiss::StructureComputerDefault<true>>(
+                    binary_knn_mc<knowherefaiss::StructureComputerDefault<true>>(
                             ncodes, a, b, na, nb, k, distances, labels, sel);
                     break;
             }
@@ -417,7 +417,7 @@ void binary_knn_hc(
                     int64_t* ids_ =
                             labels + thread_no * thread_heap_size + i * k;
                     if (C::cmp(val_[0], dis)) {
-                        faiss::heap_replace_top<C>(k, val_, ids_, dis, j);
+                        knowherefaiss::heap_replace_top<C>(k, val_, ids_, dis, j);
                     }
                 }
             }
@@ -432,7 +432,7 @@ void binary_knn_hc(
                 int64_t* labels_x_t = labels_x + t * thread_heap_size;
                 for (size_t j = 0; j < k; j++) {
                     if (C::cmp(value_x[0], value_x_t[j])) {
-                        faiss::heap_replace_top<C>(
+                        knowherefaiss::heap_replace_top<C>(
                                 k,
                                 value_x,
                                 labels_x,
@@ -470,7 +470,7 @@ void binary_knn_hc(
                     if (!sel || sel->is_member(j)) {
                         dis = hc.compute(bs2_);
                         if (C::cmp(bh_val_[0], dis)) {
-                            faiss::heap_replace_top<C>(
+                            knowherefaiss::heap_replace_top<C>(
                                     k, bh_val_, bh_ids_, dis, j);
                         }
                     }
@@ -496,7 +496,7 @@ void binary_knn_hc(
                 switch (ncodes) {
 #define binary_knn_hc_jaccard(ncodes)                     \
     case ncodes:                                          \
-        binary_knn_hc<C, faiss::JaccardComputer##ncodes>( \
+        binary_knn_hc<C, knowherefaiss::JaccardComputer##ncodes>( \
                 ncodes, ha, a, b, nb, sel);            \
         break;
                     binary_knn_hc_jaccard(8);
@@ -508,7 +508,7 @@ void binary_knn_hc(
                     binary_knn_hc_jaccard(512);
 #undef binary_knn_hc_jaccard
                     default:
-                        binary_knn_hc<C, faiss::JaccardComputerDefault>(
+                        binary_knn_hc<C, knowherefaiss::JaccardComputerDefault>(
                                 ncodes, ha, a, b, nb, sel);
                         break;
                 }
@@ -521,7 +521,7 @@ void binary_knn_hc(
                 switch (ncodes) {
 #define binary_knn_hc_hamming(ncodes)                     \
     case ncodes:                                          \
-        binary_knn_hc<C, faiss::HammingComputer##ncodes>( \
+        binary_knn_hc<C, knowherefaiss::HammingComputer##ncodes>( \
                 ncodes, ha, a, b, nb, sel);            \
         break;
                     binary_knn_hc_hamming(4);
@@ -532,7 +532,7 @@ void binary_knn_hc(
                     binary_knn_hc_hamming(64);
 #undef binary_knn_hc_hamming
                     default:
-                        binary_knn_hc<C, faiss::HammingComputerDefault>(
+                        binary_knn_hc<C, knowherefaiss::HammingComputerDefault>(
                                 ncodes, ha, a, b, nb, sel);
                         break;
                 }
@@ -610,7 +610,7 @@ void binary_range_search(
                 switch (code_size) {
 #define binary_range_search_jaccard(ncodes)                        \
     case ncodes:                                                   \
-        binary_range_search<C, T, faiss::JaccardComputer##ncodes>( \
+        binary_range_search<C, T, knowherefaiss::JaccardComputer##ncodes>( \
                 a, b, na, nb, radius, code_size, res, sel);     \
         break;
                     binary_range_search_jaccard(8);
@@ -625,7 +625,7 @@ void binary_range_search(
                         binary_range_search<
                                 C,
                                 T,
-                                faiss::JaccardComputerDefault>(
+                                knowherefaiss::JaccardComputerDefault>(
                                 a, b, na, nb, radius, code_size, res, sel);
                         break;
                 }
@@ -638,7 +638,7 @@ void binary_range_search(
                 switch (code_size) {
 #define binary_range_search_hamming(ncodes)                        \
     case ncodes:                                                   \
-        binary_range_search<C, T, faiss::HammingComputer##ncodes>( \
+        binary_range_search<C, T, knowherefaiss::HammingComputer##ncodes>( \
                 a, b, na, nb, radius, code_size, res, sel);     \
         break;
                     binary_range_search_hamming(4);
@@ -652,7 +652,7 @@ void binary_range_search(
                         binary_range_search<
                                 C,
                                 T,
-                                faiss::HammingComputerDefault>(
+                                knowherefaiss::HammingComputerDefault>(
                                 a, b, na, nb, radius, code_size, res, sel);
                         break;
                 }
@@ -688,4 +688,4 @@ template void binary_range_search<CMin<float, int64_t>, float>(
         RangeSearchResult* res,
         const IDSelector* sel);
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/utils/binary_distances.h b/thirdparty/faiss/knowherefaiss/utils/binary_distances.h
similarity index 95%
rename from thirdparty/faiss/faiss/utils/binary_distances.h
rename to thirdparty/faiss/knowherefaiss/utils/binary_distances.h
index acb059a4..7bee19b9 100644
--- a/thirdparty/faiss/faiss/utils/binary_distances.h
+++ b/thirdparty/faiss/knowherefaiss/utils/binary_distances.h
@@ -15,15 +15,15 @@
 #ifndef FAISS_BINARY_DISTANCE_H
 #define FAISS_BINARY_DISTANCE_H
 
-#include <faiss/MetricType.h>
-#include <faiss/impl/AuxIndexStructures.h>
-#include <faiss/utils/Heap.h>
+#include <knowherefaiss/MetricType.h>
+#include <knowherefaiss/impl/AuxIndexStructures.h>
+#include <knowherefaiss/utils/Heap.h>
 #include <stdint.h>
 
 /* The binary distance type */
 typedef float tadis_t;
 
-namespace faiss {
+namespace knowherefaiss {
 
 struct IDSelector;
 
@@ -136,6 +136,6 @@ void binary_range_search(
         RangeSearchResult* res,
         const IDSelector* sel = nullptr);
 
-} // namespace faiss
+} // namespace knowherefaiss
 
 #endif // FAISS_BINARY_DISTANCE_H
diff --git a/thirdparty/faiss/faiss/utils/bit_table.cpp b/thirdparty/faiss/knowherefaiss/utils/bit_table.cpp
similarity index 99%
rename from thirdparty/faiss/faiss/utils/bit_table.cpp
rename to thirdparty/faiss/knowherefaiss/utils/bit_table.cpp
index fb5b4a49..59712b5d 100644
--- a/thirdparty/faiss/faiss/utils/bit_table.cpp
+++ b/thirdparty/faiss/knowherefaiss/utils/bit_table.cpp
@@ -1,5 +1,5 @@
 #include <cstdint>
-namespace faiss {
+namespace knowherefaiss {
 // todo aguzhva: this is duplicated in utils/hamming_distance/common.h
 uint8_t lookup8bit[256] = {
         /*  0 */ 0, /*  1 */ 1, /*  2 */ 1, /*  3 */ 2,
diff --git a/thirdparty/faiss/faiss/utils/data_backup_file.cpp b/thirdparty/faiss/knowherefaiss/utils/data_backup_file.cpp
similarity index 96%
rename from thirdparty/faiss/faiss/utils/data_backup_file.cpp
rename to thirdparty/faiss/knowherefaiss/utils/data_backup_file.cpp
index 95abf801..df52c26a 100644
--- a/thirdparty/faiss/faiss/utils/data_backup_file.cpp
+++ b/thirdparty/faiss/knowherefaiss/utils/data_backup_file.cpp
@@ -1,8 +1,8 @@
-#include <faiss/utils/data_backup_file.h>
+#include <knowherefaiss/utils/data_backup_file.h>
 #include <cstring>
 #include <cmath>
 #include <mutex>
-namespace faiss {
+namespace knowherefaiss {
 
 namespace {
 constexpr const char* kRawDataFileName = "/ivf_sq_cc_raw_data.bin";
@@ -73,4 +73,4 @@ void DataBackFileHandler::AppendDataBlock(
         file_block_num_ += buffer_max_block_num_;
     }
 }
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/utils/data_backup_file.h b/thirdparty/faiss/knowherefaiss/utils/data_backup_file.h
similarity index 90%
rename from thirdparty/faiss/faiss/utils/data_backup_file.h
rename to thirdparty/faiss/knowherefaiss/utils/data_backup_file.h
index a328d4f9..e6fe4017 100644
--- a/thirdparty/faiss/faiss/utils/data_backup_file.h
+++ b/thirdparty/faiss/knowherefaiss/utils/data_backup_file.h
@@ -1,10 +1,10 @@
 #pragma once
 #include <shared_mutex>
 #include <memory>
-#include <faiss/impl/FaissAssert.h>
+#include <knowherefaiss/impl/FaissAssert.h>
 #include <cstdio>
 #include <fstream>
-namespace faiss {
+namespace knowherefaiss {
     /**
      * @brief BackDataFileHandler is a temporary file structure, and the temperary file only exist in the life cycle of the struct. 
      *  It is used to back up the original data of the index for the needs of data reconstruction with no loss.
@@ -28,4 +28,4 @@ namespace faiss {
         size_t buffer_block_num_;
         size_t buffer_max_block_num_;
     };
-} // namespace  faiss
\ No newline at end of file
+} // namespace knowherefaiss
\ No newline at end of file
diff --git a/thirdparty/faiss/faiss/utils/distances.cpp b/thirdparty/faiss/knowherefaiss/utils/distances.cpp
similarity index 99%
rename from thirdparty/faiss/faiss/utils/distances.cpp
rename to thirdparty/faiss/knowherefaiss/utils/distances.cpp
index 7dd46fdd..8f17e1bc 100644
--- a/thirdparty/faiss/faiss/utils/distances.cpp
+++ b/thirdparty/faiss/knowherefaiss/utils/distances.cpp
@@ -5,8 +5,8 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/utils/distances.h>
-#include <faiss/utils/distances_if.h>
+#include <knowherefaiss/utils/distances.h>
+#include <knowherefaiss/utils/distances_if.h>
 
 #include <algorithm>
 #include <cassert>
@@ -20,12 +20,12 @@
 #include "knowhere/bitsetview_idselector.h"
 #include "knowhere/object.h"
 
-#include <faiss/FaissHook.h>
-#include <faiss/impl/AuxIndexStructures.h>
-#include <faiss/impl/FaissAssert.h>
-#include <faiss/impl/IDSelector.h>
-#include <faiss/impl/ResultHandler.h>
-#include <faiss/utils/utils.h>
+#include <knowherefaiss/FaissHook.h>
+#include <knowherefaiss/impl/AuxIndexStructures.h>
+#include <knowherefaiss/impl/FaissAssert.h>
+#include <knowherefaiss/impl/IDSelector.h>
+#include <knowherefaiss/impl/ResultHandler.h>
+#include <knowherefaiss/utils/utils.h>
 
 #ifndef FINTEGER
 #define FINTEGER long
@@ -51,7 +51,7 @@ int sgemm_(
         FINTEGER* ldc);
 }
 
-namespace faiss {
+namespace knowherefaiss {
 
 /***************************************************************************
  * Matrix/vector ops
@@ -1728,4 +1728,4 @@ void elkan_L2_sse(
 
 }
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/utils/distances.h b/thirdparty/faiss/knowherefaiss/utils/distances.h
similarity index 99%
rename from thirdparty/faiss/faiss/utils/distances.h
rename to thirdparty/faiss/knowherefaiss/utils/distances.h
index 12fb6add..5f320e5a 100644
--- a/thirdparty/faiss/faiss/utils/distances.h
+++ b/thirdparty/faiss/knowherefaiss/utils/distances.h
@@ -14,12 +14,12 @@
 #include <stdint.h>
 #include <vector>
 
-#include <faiss/impl/platform_macros.h>
-#include <faiss/utils/Heap.h>
+#include <knowherefaiss/impl/platform_macros.h>
+#include <knowherefaiss/utils/Heap.h>
 
 #include "knowhere/object.h"
 
-namespace faiss {
+namespace knowherefaiss {
 
 struct IDSelector;
 
@@ -491,4 +491,4 @@ void elkan_L2_sse(
  * Templatized versions of distance functions
  ***************************************************************************/
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/utils/distances_fused/avx512.cpp b/thirdparty/faiss/knowherefaiss/utils/distances_fused/avx512.cpp
similarity index 99%
rename from thirdparty/faiss/faiss/utils/distances_fused/avx512.cpp
rename to thirdparty/faiss/knowherefaiss/utils/distances_fused/avx512.cpp
index d4c442c7..dffa6030 100644
--- a/thirdparty/faiss/faiss/utils/distances_fused/avx512.cpp
+++ b/thirdparty/faiss/knowherefaiss/utils/distances_fused/avx512.cpp
@@ -7,13 +7,13 @@
 
 // -*- c++ -*-
 
-#include <faiss/utils/distances_fused/avx512.h>
+#include <knowherefaiss/utils/distances_fused/avx512.h>
 
 #ifdef __AVX512F__
 
 #include <immintrin.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 namespace {
 
@@ -341,6 +341,6 @@ bool exhaustive_L2sqr_fused_cmax_AVX512(
 #undef DISPATCH
 }
 
-} // namespace faiss
+} // namespace knowherefaiss
 
 #endif
diff --git a/thirdparty/faiss/faiss/utils/distances_fused/avx512.h b/thirdparty/faiss/knowherefaiss/utils/distances_fused/avx512.h
similarity index 80%
rename from thirdparty/faiss/faiss/utils/distances_fused/avx512.h
rename to thirdparty/faiss/knowherefaiss/utils/distances_fused/avx512.h
index 4cb62771..fc025f47 100644
--- a/thirdparty/faiss/faiss/utils/distances_fused/avx512.h
+++ b/thirdparty/faiss/knowherefaiss/utils/distances_fused/avx512.h
@@ -11,14 +11,14 @@
 
 #pragma once
 
-#include <faiss/impl/ResultHandler.h>
-#include <faiss/impl/platform_macros.h>
+#include <knowherefaiss/impl/ResultHandler.h>
+#include <knowherefaiss/impl/platform_macros.h>
 
-#include <faiss/utils/Heap.h>
+#include <knowherefaiss/utils/Heap.h>
 
 #ifdef __AVX512F__
 
-namespace faiss {
+namespace knowherefaiss {
 
 // Returns true if the fused kernel is available and the data was processed.
 // Returns false if the fused kernel is not available.
@@ -31,6 +31,6 @@ bool exhaustive_L2sqr_fused_cmax_AVX512(
         Top1BlockResultHandler<CMax<float, int64_t>>& res,
         const float* y_norms);
 
-} // namespace faiss
+} // namespace knowherefaiss
 
 #endif
diff --git a/thirdparty/faiss/faiss/utils/distances_fused/distances_fused.cpp b/thirdparty/faiss/knowherefaiss/utils/distances_fused/distances_fused.cpp
similarity index 75%
rename from thirdparty/faiss/faiss/utils/distances_fused/distances_fused.cpp
rename to thirdparty/faiss/knowherefaiss/utils/distances_fused/distances_fused.cpp
index 2ba7e290..0b64c745 100644
--- a/thirdparty/faiss/faiss/utils/distances_fused/distances_fused.cpp
+++ b/thirdparty/faiss/knowherefaiss/utils/distances_fused/distances_fused.cpp
@@ -5,14 +5,14 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/utils/distances_fused/distances_fused.h>
+#include <knowherefaiss/utils/distances_fused/distances_fused.h>
 
-#include <faiss/impl/platform_macros.h>
+#include <knowherefaiss/impl/platform_macros.h>
 
-#include <faiss/utils/distances_fused/avx512.h>
-#include <faiss/utils/distances_fused/simdlib_based.h>
+#include <knowherefaiss/utils/distances_fused/avx512.h>
+#include <knowherefaiss/utils/distances_fused/simdlib_based.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 bool exhaustive_L2sqr_fused_cmax(
         const float* x,
@@ -39,4 +39,4 @@ bool exhaustive_L2sqr_fused_cmax(
 #endif
 }
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/utils/distances_fused/distances_fused.h b/thirdparty/faiss/knowherefaiss/utils/distances_fused/distances_fused.h
similarity index 89%
rename from thirdparty/faiss/faiss/utils/distances_fused/distances_fused.h
rename to thirdparty/faiss/knowherefaiss/utils/distances_fused/distances_fused.h
index 54b58752..fa62bff0 100644
--- a/thirdparty/faiss/faiss/utils/distances_fused/distances_fused.h
+++ b/thirdparty/faiss/knowherefaiss/utils/distances_fused/distances_fused.h
@@ -20,11 +20,11 @@
 
 #pragma once
 
-#include <faiss/impl/ResultHandler.h>
+#include <knowherefaiss/impl/ResultHandler.h>
 
-#include <faiss/utils/Heap.h>
+#include <knowherefaiss/utils/Heap.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 // Returns true if the fused kernel is available and the data was processed.
 // Returns false if the fused kernel is not available.
@@ -37,4 +37,4 @@ bool exhaustive_L2sqr_fused_cmax(
         Top1BlockResultHandler<CMax<float, int64_t>>& res,
         const float* y_norms);
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/utils/distances_fused/simdlib_based.cpp b/thirdparty/faiss/knowherefaiss/utils/distances_fused/simdlib_based.cpp
similarity index 98%
rename from thirdparty/faiss/faiss/utils/distances_fused/simdlib_based.cpp
rename to thirdparty/faiss/knowherefaiss/utils/distances_fused/simdlib_based.cpp
index 7fea64e0..d8805f1c 100644
--- a/thirdparty/faiss/faiss/utils/distances_fused/simdlib_based.cpp
+++ b/thirdparty/faiss/knowherefaiss/utils/distances_fused/simdlib_based.cpp
@@ -7,17 +7,17 @@
 
 // -*- c++ -*-
 
-#include <faiss/utils/distances_fused/simdlib_based.h>
+#include <knowherefaiss/utils/distances_fused/simdlib_based.h>
 
 #if defined(__AVX2__) || defined(__aarch64__)
 
-#include <faiss/utils/simdlib.h>
+#include <knowherefaiss/utils/simdlib.h>
 
 #if defined(__AVX2__)
 #include <immintrin.h>
 #endif
 
-namespace faiss {
+namespace knowherefaiss {
 
 namespace {
 
@@ -347,6 +347,6 @@ bool exhaustive_L2sqr_fused_cmax_simdlib(
 #undef DISPATCH
 }
 
-} // namespace faiss
+} // namespace knowherefaiss
 
 #endif
diff --git a/thirdparty/faiss/faiss/utils/distances_fused/simdlib_based.h b/thirdparty/faiss/knowherefaiss/utils/distances_fused/simdlib_based.h
similarity index 77%
rename from thirdparty/faiss/faiss/utils/distances_fused/simdlib_based.h
rename to thirdparty/faiss/knowherefaiss/utils/distances_fused/simdlib_based.h
index 6240a8f1..5368a065 100644
--- a/thirdparty/faiss/faiss/utils/distances_fused/simdlib_based.h
+++ b/thirdparty/faiss/knowherefaiss/utils/distances_fused/simdlib_based.h
@@ -7,14 +7,14 @@
 
 #pragma once
 
-#include <faiss/impl/ResultHandler.h>
-#include <faiss/impl/platform_macros.h>
+#include <knowherefaiss/impl/ResultHandler.h>
+#include <knowherefaiss/impl/platform_macros.h>
 
-#include <faiss/utils/Heap.h>
+#include <knowherefaiss/utils/Heap.h>
 
 #if defined(__AVX2__) || defined(__aarch64__)
 
-namespace faiss {
+namespace knowherefaiss {
 
 // Returns true if the fused kernel is available and the data was processed.
 // Returns false if the fused kernel is not available.
@@ -27,6 +27,6 @@ bool exhaustive_L2sqr_fused_cmax_simdlib(
         Top1BlockResultHandler<CMax<float, int64_t>>& res,
         const float* y_norms);
 
-} // namespace faiss
+} // namespace knowherefaiss
 
 #endif
diff --git a/thirdparty/faiss/faiss/utils/distances_if.h b/thirdparty/faiss/knowherefaiss/utils/distances_if.h
similarity index 99%
rename from thirdparty/faiss/faiss/utils/distances_if.h
rename to thirdparty/faiss/knowherefaiss/utils/distances_if.h
index a436b33b..ac03b794 100644
--- a/thirdparty/faiss/faiss/utils/distances_if.h
+++ b/thirdparty/faiss/knowherefaiss/utils/distances_if.h
@@ -10,11 +10,11 @@
 #include <optional>
 #include <tuple>
 
-#include <faiss/impl/DistanceComputer.h>
-#include <faiss/utils/distances.h>
+#include <knowherefaiss/impl/DistanceComputer.h>
+#include <knowherefaiss/utils/distances.h>
 #include "simd/hook.h"
 
-namespace faiss {
+namespace knowherefaiss {
 
 /*********************************************************
  * Facilities that are used for batch distance computation
@@ -1265,5 +1265,5 @@ void int8_vec_L2sqr_ny_by_idx_if(
     internal_int8_vec_L2sqr_ny_if(x, y, d, ny, pred, remapper, apply);
 }
 
-} //namespace faiss
+} //namespace knowherefaiss
 
diff --git a/thirdparty/faiss/faiss/utils/distances_simd.cpp b/thirdparty/faiss/knowherefaiss/utils/distances_simd.cpp
similarity index 95%
rename from thirdparty/faiss/faiss/utils/distances_simd.cpp
rename to thirdparty/faiss/knowherefaiss/utils/distances_simd.cpp
index 749e9c3f..52312d93 100644
--- a/thirdparty/faiss/faiss/utils/distances_simd.cpp
+++ b/thirdparty/faiss/knowherefaiss/utils/distances_simd.cpp
@@ -7,17 +7,17 @@
 
 // -*- c++ -*-
 
-#include <faiss/utils/distances.h>
+#include <knowherefaiss/utils/distances.h>
 
 #include <algorithm>
 #include <cstdio>
 #include <cstring>
 
-#include <faiss/impl/FaissAssert.h>
-#include <faiss/impl/platform_macros.h>
-#include <faiss/utils/simdlib.h>
+#include <knowherefaiss/impl/FaissAssert.h>
+#include <knowherefaiss/impl/platform_macros.h>
+#include <knowherefaiss/utils/simdlib.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 /***************************************************************************
  * PQ tables computations
@@ -186,4 +186,4 @@ void fvec_add(size_t d, const float* a, float b, float* c) {
     }
 }
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/utils/distances_typed.cpp b/thirdparty/faiss/knowherefaiss/utils/distances_typed.cpp
similarity index 89%
rename from thirdparty/faiss/faiss/utils/distances_typed.cpp
rename to thirdparty/faiss/knowherefaiss/utils/distances_typed.cpp
index cf4cac43..d82e41bf 100644
--- a/thirdparty/faiss/faiss/utils/distances_typed.cpp
+++ b/thirdparty/faiss/knowherefaiss/utils/distances_typed.cpp
@@ -14,15 +14,15 @@
 
 #include <algorithm>
 
-#include <faiss/impl/IDSelector.h>
-#include <faiss/impl/ResultHandler.h>
-#include <faiss/utils/distances.h>
-#include <faiss/utils/distances_if.h>
-#include <faiss/utils/distances_typed.h>
+#include <knowherefaiss/impl/IDSelector.h>
+#include <knowherefaiss/impl/ResultHandler.h>
+#include <knowherefaiss/utils/distances.h>
+#include <knowherefaiss/utils/distances_if.h>
+#include <knowherefaiss/utils/distances_typed.h>
 #include "knowhere/bitsetview_idselector.h"
 #include "knowhere/operands.h"
 #include "simd/hook.h"
-namespace faiss {
+namespace knowherefaiss {
 namespace {
 template <typename DataType, class BlockResultHandler, class IDSelector>
 void exhaustive_inner_product_impl_typed(
@@ -504,7 +504,7 @@ void range_search_cosine_typed(
 }
 
 // fp16 knn functions
-template void faiss::knn_inner_product_typed<knowhere::fp16>(
+template void knowherefaiss::knn_inner_product_typed<knowhere::fp16>(
         const knowhere::fp16*,
         const knowhere::fp16*,
         size_t,
@@ -515,7 +515,7 @@ template void faiss::knn_inner_product_typed<knowhere::fp16>(
         int64_t*,
         const IDSelector*);
 
-template void faiss::all_inner_product_typed<knowhere::fp16>(
+template void knowherefaiss::all_inner_product_typed<knowhere::fp16>(
         const knowhere::fp16*,
         const knowhere::fp16*,
         size_t,
@@ -524,7 +524,7 @@ template void faiss::all_inner_product_typed<knowhere::fp16>(
         std::vector<knowhere::DistId>&,
         const IDSelector*);
 
-template void faiss::knn_L2sqr_typed<knowhere::fp16>(
+template void knowherefaiss::knn_L2sqr_typed<knowhere::fp16>(
         const knowhere::fp16*,
         const knowhere::fp16*,
         size_t,
@@ -536,7 +536,7 @@ template void faiss::knn_L2sqr_typed<knowhere::fp16>(
         const float*,
         const IDSelector*);
 
-template void faiss::all_L2sqr_typed<knowhere::fp16>(
+template void knowherefaiss::all_L2sqr_typed<knowhere::fp16>(
         const knowhere::fp16*,
         const knowhere::fp16*,
         size_t,
@@ -546,7 +546,7 @@ template void faiss::all_L2sqr_typed<knowhere::fp16>(
         const float*,
         const IDSelector*);
 
-template void faiss::knn_cosine_typed<knowhere::fp16>(
+template void knowherefaiss::knn_cosine_typed<knowhere::fp16>(
         const knowhere::fp16*,
         const knowhere::fp16*,
         const float*,
@@ -558,7 +558,7 @@ template void faiss::knn_cosine_typed<knowhere::fp16>(
         int64_t*,
         const IDSelector*);
 
-template void faiss::all_cosine_typed<knowhere::fp16>(
+template void knowherefaiss::all_cosine_typed<knowhere::fp16>(
         const knowhere::fp16*,
         const knowhere::fp16*,
         const float*,
@@ -569,7 +569,7 @@ template void faiss::all_cosine_typed<knowhere::fp16>(
         const IDSelector*);
 
 // bf16 knn functions
-template void faiss::knn_inner_product_typed<knowhere::bf16>(
+template void knowherefaiss::knn_inner_product_typed<knowhere::bf16>(
         const knowhere::bf16*,
         const knowhere::bf16*,
         size_t,
@@ -580,7 +580,7 @@ template void faiss::knn_inner_product_typed<knowhere::bf16>(
         int64_t*,
         const IDSelector*);
 
-template void faiss::all_inner_product_typed<knowhere::bf16>(
+template void knowherefaiss::all_inner_product_typed<knowhere::bf16>(
         const knowhere::bf16*,
         const knowhere::bf16*,
         size_t,
@@ -589,7 +589,7 @@ template void faiss::all_inner_product_typed<knowhere::bf16>(
         std::vector<knowhere::DistId>&,
         const IDSelector*);
 
-template void faiss::knn_L2sqr_typed<knowhere::bf16>(
+template void knowherefaiss::knn_L2sqr_typed<knowhere::bf16>(
         const knowhere::bf16*,
         const knowhere::bf16*,
         size_t,
@@ -601,7 +601,7 @@ template void faiss::knn_L2sqr_typed<knowhere::bf16>(
         const float*,
         const IDSelector*);
 
-template void faiss::all_L2sqr_typed<knowhere::bf16>(
+template void knowherefaiss::all_L2sqr_typed<knowhere::bf16>(
         const knowhere::bf16*,
         const knowhere::bf16*,
         size_t,
@@ -611,7 +611,7 @@ template void faiss::all_L2sqr_typed<knowhere::bf16>(
         const float*,
         const IDSelector*);
 
-template void faiss::knn_cosine_typed<knowhere::bf16>(
+template void knowherefaiss::knn_cosine_typed<knowhere::bf16>(
         const knowhere::bf16*,
         const knowhere::bf16*,
         const float*,
@@ -623,7 +623,7 @@ template void faiss::knn_cosine_typed<knowhere::bf16>(
         int64_t*,
         const IDSelector*);
 
-template void faiss::all_cosine_typed<knowhere::bf16>(
+template void knowherefaiss::all_cosine_typed<knowhere::bf16>(
         const knowhere::bf16*,
         const knowhere::bf16*,
         const float*,
@@ -634,7 +634,7 @@ template void faiss::all_cosine_typed<knowhere::bf16>(
         const IDSelector*);
 
 // int8 knn functions
-template void faiss::knn_inner_product_typed<knowhere::int8>(
+template void knowherefaiss::knn_inner_product_typed<knowhere::int8>(
         const knowhere::int8*,
         const knowhere::int8*,
         size_t,
@@ -645,7 +645,7 @@ template void faiss::knn_inner_product_typed<knowhere::int8>(
         int64_t*,
         const IDSelector*);
 
-template void faiss::all_inner_product_typed<knowhere::int8>(
+template void knowherefaiss::all_inner_product_typed<knowhere::int8>(
         const knowhere::int8*,
         const knowhere::int8*,
         size_t,
@@ -654,7 +654,7 @@ template void faiss::all_inner_product_typed<knowhere::int8>(
         std::vector<knowhere::DistId>&,
         const IDSelector*);
 
-template void faiss::knn_L2sqr_typed<knowhere::int8>(
+template void knowherefaiss::knn_L2sqr_typed<knowhere::int8>(
         const knowhere::int8*,
         const knowhere::int8*,
         size_t,
@@ -666,7 +666,7 @@ template void faiss::knn_L2sqr_typed<knowhere::int8>(
         const float*,
         const IDSelector*);
 
-template void faiss::all_L2sqr_typed<knowhere::int8>(
+template void knowherefaiss::all_L2sqr_typed<knowhere::int8>(
         const knowhere::int8*,
         const knowhere::int8*,
         size_t,
@@ -676,7 +676,7 @@ template void faiss::all_L2sqr_typed<knowhere::int8>(
         const float*,
         const IDSelector*);
 
-template void faiss::knn_cosine_typed<knowhere::int8>(
+template void knowherefaiss::knn_cosine_typed<knowhere::int8>(
         const knowhere::int8*,
         const knowhere::int8*,
         const float*,
@@ -688,7 +688,7 @@ template void faiss::knn_cosine_typed<knowhere::int8>(
         int64_t*,
         const IDSelector*);
 
-template void faiss::all_cosine_typed<knowhere::int8>(
+template void knowherefaiss::all_cosine_typed<knowhere::int8>(
         const knowhere::int8*,
         const knowhere::int8*,
         const float*,
@@ -699,27 +699,27 @@ template void faiss::all_cosine_typed<knowhere::int8>(
         const IDSelector*);
 
 // fp16 range search functions
-template void faiss::range_search_L2sqr_typed<knowhere::fp16>(
+template void knowherefaiss::range_search_L2sqr_typed<knowhere::fp16>(
         const knowhere::fp16*,
         const knowhere::fp16*,
         size_t,
         size_t,
         size_t,
         float,
-        faiss::RangeSearchResult*,
-        const faiss::IDSelector*);
+        knowherefaiss::RangeSearchResult*,
+        const knowherefaiss::IDSelector*);
 
-template void faiss::range_search_inner_product_typed<knowhere::fp16>(
+template void knowherefaiss::range_search_inner_product_typed<knowhere::fp16>(
         const knowhere::fp16*,
         const knowhere::fp16*,
         size_t,
         size_t,
         size_t,
         float,
-        faiss::RangeSearchResult*,
-        const faiss::IDSelector*);
+        knowherefaiss::RangeSearchResult*,
+        const knowherefaiss::IDSelector*);
 
-template void faiss::range_search_cosine_typed<knowhere::fp16>(
+template void knowherefaiss::range_search_cosine_typed<knowhere::fp16>(
         const knowhere::fp16*,
         const knowhere::fp16*,
         const float*,
@@ -727,31 +727,31 @@ template void faiss::range_search_cosine_typed<knowhere::fp16>(
         size_t,
         size_t,
         float,
-        faiss::RangeSearchResult*,
-        const faiss::IDSelector*);
+        knowherefaiss::RangeSearchResult*,
+        const knowherefaiss::IDSelector*);
 
 // bf16 range search functions
-template void faiss::range_search_L2sqr_typed<knowhere::bf16>(
+template void knowherefaiss::range_search_L2sqr_typed<knowhere::bf16>(
         const knowhere::bf16*,
         const knowhere::bf16*,
         size_t,
         size_t,
         size_t,
         float,
-        faiss::RangeSearchResult*,
-        const faiss::IDSelector*);
+        knowherefaiss::RangeSearchResult*,
+        const knowherefaiss::IDSelector*);
 
-template void faiss::range_search_inner_product_typed<knowhere::bf16>(
+template void knowherefaiss::range_search_inner_product_typed<knowhere::bf16>(
         const knowhere::bf16*,
         const knowhere::bf16*,
         size_t,
         size_t,
         size_t,
         float,
-        faiss::RangeSearchResult*,
-        const faiss::IDSelector*);
+        knowherefaiss::RangeSearchResult*,
+        const knowherefaiss::IDSelector*);
 
-template void faiss::range_search_cosine_typed<knowhere::bf16>(
+template void knowherefaiss::range_search_cosine_typed<knowhere::bf16>(
         const knowhere::bf16*,
         const knowhere::bf16*,
         const float*,
@@ -759,31 +759,31 @@ template void faiss::range_search_cosine_typed<knowhere::bf16>(
         size_t,
         size_t,
         float,
-        faiss::RangeSearchResult*,
-        const faiss::IDSelector*);
+        knowherefaiss::RangeSearchResult*,
+        const knowherefaiss::IDSelector*);
 
 // int8 range search functions
-template void faiss::range_search_L2sqr_typed<knowhere::int8>(
+template void knowherefaiss::range_search_L2sqr_typed<knowhere::int8>(
         const knowhere::int8*,
         const knowhere::int8*,
         size_t,
         size_t,
         size_t,
         float,
-        faiss::RangeSearchResult*,
-        const faiss::IDSelector*);
+        knowherefaiss::RangeSearchResult*,
+        const knowherefaiss::IDSelector*);
 
-template void faiss::range_search_inner_product_typed<knowhere::int8>(
+template void knowherefaiss::range_search_inner_product_typed<knowhere::int8>(
         const knowhere::int8*,
         const knowhere::int8*,
         size_t,
         size_t,
         size_t,
         float,
-        faiss::RangeSearchResult*,
-        const faiss::IDSelector*);
+        knowherefaiss::RangeSearchResult*,
+        const knowherefaiss::IDSelector*);
 
-template void faiss::range_search_cosine_typed<knowhere::int8>(
+template void knowherefaiss::range_search_cosine_typed<knowhere::int8>(
         const knowhere::int8*,
         const knowhere::int8*,
         const float*,
@@ -791,7 +791,7 @@ template void faiss::range_search_cosine_typed<knowhere::int8>(
         size_t,
         size_t,
         float,
-        faiss::RangeSearchResult*,
-        const faiss::IDSelector*);
+        knowherefaiss::RangeSearchResult*,
+        const knowherefaiss::IDSelector*);
 
-} // namespace faiss
\ No newline at end of file
+} // namespace knowherefaiss
\ No newline at end of file
diff --git a/thirdparty/faiss/faiss/utils/distances_typed.h b/thirdparty/faiss/knowherefaiss/utils/distances_typed.h
similarity index 97%
rename from thirdparty/faiss/faiss/utils/distances_typed.h
rename to thirdparty/faiss/knowherefaiss/utils/distances_typed.h
index 47fdcd45..9566b5e7 100644
--- a/thirdparty/faiss/faiss/utils/distances_typed.h
+++ b/thirdparty/faiss/knowherefaiss/utils/distances_typed.h
@@ -15,11 +15,11 @@
 #ifndef FAISS_HALF_PRECISION_FLOATING_POINT_DISTANCES_H
 #define FAISS_HALF_PRECISION_FLOATING_POINT_DISTANCES_H
 #pragma once
-#include <faiss/utils/Heap.h>
+#include <knowherefaiss/utils/Heap.h>
 #include <stdint.h>
 #include <vector>
 #include "knowhere/object.h"
-namespace faiss {
+namespace knowherefaiss {
 struct IDSelector;
 /***************************************************************************
  * KNN functions
@@ -134,5 +134,5 @@ void range_search_cosine_typed(
         float radius,
         RangeSearchResult* result,
         const IDSelector* sel = nullptr);
-} // namespace faiss
+} // namespace knowherefaiss
 #endif // FAISS_HALF_PRECISION_FLOATING_POINT_DISTANCES_H
\ No newline at end of file
diff --git a/thirdparty/faiss/faiss/utils/extra_distances-inl.h b/thirdparty/faiss/knowherefaiss/utils/extra_distances-inl.h
similarity index 96%
rename from thirdparty/faiss/faiss/utils/extra_distances-inl.h
rename to thirdparty/faiss/knowherefaiss/utils/extra_distances-inl.h
index 25ce3643..1a1cbb06 100644
--- a/thirdparty/faiss/faiss/utils/extra_distances-inl.h
+++ b/thirdparty/faiss/knowherefaiss/utils/extra_distances-inl.h
@@ -11,11 +11,11 @@
 #include <cmath>
 #include <type_traits>
 
-#include <faiss/FaissHook.h>
-#include <faiss/MetricType.h>
-#include <faiss/utils/distances.h>
+#include <knowherefaiss/FaissHook.h>
+#include <knowherefaiss/MetricType.h>
+#include <knowherefaiss/utils/distances.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 template <MetricType mt>
 struct VectorDistance {
@@ -167,4 +167,4 @@ inline float VectorDistance<METRIC_ABS_INNER_PRODUCT>::operator()(
     return accu;
 }
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/utils/extra_distances.cpp b/thirdparty/faiss/knowherefaiss/utils/extra_distances.cpp
similarity index 95%
rename from thirdparty/faiss/faiss/utils/extra_distances.cpp
rename to thirdparty/faiss/knowherefaiss/utils/extra_distances.cpp
index 0403ec82..3ffe09ce 100644
--- a/thirdparty/faiss/faiss/utils/extra_distances.cpp
+++ b/thirdparty/faiss/knowherefaiss/utils/extra_distances.cpp
@@ -7,19 +7,19 @@
 
 // -*- c++ -*-
 
-#include <faiss/utils/extra_distances.h>
+#include <knowherefaiss/utils/extra_distances.h>
 
 #include <omp.h>
 #include <algorithm>
 #include <cmath>
 
-#include <faiss/impl/AuxIndexStructures.h>
-#include <faiss/impl/DistanceComputer.h>
-#include <faiss/impl/FaissAssert.h>
-#include <faiss/impl/IDSelector.h>
-#include <faiss/utils/utils.h>
+#include <knowherefaiss/impl/AuxIndexStructures.h>
+#include <knowherefaiss/impl/DistanceComputer.h>
+#include <knowherefaiss/impl/FaissAssert.h>
+#include <knowherefaiss/impl/IDSelector.h>
+#include <knowherefaiss/utils/utils.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 /***************************************************************************
  * Distance functions (other than L2 and IP)
@@ -239,4 +239,4 @@ FlatCodesDistanceComputer* get_extra_distance_computer(
     }
 }
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/utils/extra_distances.h b/thirdparty/faiss/knowherefaiss/utils/extra_distances.h
similarity index 87%
rename from thirdparty/faiss/faiss/utils/extra_distances.h
rename to thirdparty/faiss/knowherefaiss/utils/extra_distances.h
index d786279a..9a331ad5 100644
--- a/thirdparty/faiss/faiss/utils/extra_distances.h
+++ b/thirdparty/faiss/knowherefaiss/utils/extra_distances.h
@@ -12,11 +12,11 @@
 
 #include <stdint.h>
 
-#include <faiss/Index.h>
+#include <knowherefaiss/Index.h>
 
-#include <faiss/utils/Heap.h>
+#include <knowherefaiss/utils/Heap.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 struct FlatCodesDistanceComputer;
 struct IDSelector;
@@ -56,6 +56,6 @@ FlatCodesDistanceComputer* get_extra_distance_computer(
         size_t nb,
         const float* xb);
 
-} // namespace faiss
+} // namespace knowherefaiss
 
-#include <faiss/utils/extra_distances-inl.h>
+#include <knowherefaiss/utils/extra_distances-inl.h>
diff --git a/thirdparty/faiss/faiss/utils/fp16-arm.h b/thirdparty/faiss/knowherefaiss/utils/fp16-arm.h
similarity index 92%
rename from thirdparty/faiss/faiss/utils/fp16-arm.h
rename to thirdparty/faiss/knowherefaiss/utils/fp16-arm.h
index 79c885b0..27d400da 100644
--- a/thirdparty/faiss/faiss/utils/fp16-arm.h
+++ b/thirdparty/faiss/knowherefaiss/utils/fp16-arm.h
@@ -10,7 +10,7 @@
 #include <arm_neon.h>
 #include <cstdint>
 
-namespace faiss {
+namespace knowherefaiss {
 
 inline uint16_t encode_fp16(float x) {
     float32x4_t fx4 = vdupq_n_f32(x);
@@ -26,4 +26,4 @@ inline float decode_fp16(uint16_t x) {
     return vdups_laneq_f32(fx4, 3);
 }
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/utils/fp16-fp16c.h b/thirdparty/faiss/knowherefaiss/utils/fp16-fp16c.h
similarity index 91%
rename from thirdparty/faiss/faiss/utils/fp16-fp16c.h
rename to thirdparty/faiss/knowherefaiss/utils/fp16-fp16c.h
index 571d5275..0b051e1a 100644
--- a/thirdparty/faiss/faiss/utils/fp16-fp16c.h
+++ b/thirdparty/faiss/knowherefaiss/utils/fp16-fp16c.h
@@ -10,7 +10,7 @@
 #include <immintrin.h>
 #include <cstdint>
 
-namespace faiss {
+namespace knowherefaiss {
 
 inline uint16_t encode_fp16(float x) {
     __m128 xf = _mm_set1_ps(x);
@@ -25,4 +25,4 @@ inline float decode_fp16(uint16_t x) {
     return _mm_cvtss_f32(xf);
 }
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/utils/fp16-inl.h b/thirdparty/faiss/knowherefaiss/utils/fp16-inl.h
similarity index 98%
rename from thirdparty/faiss/faiss/utils/fp16-inl.h
rename to thirdparty/faiss/knowherefaiss/utils/fp16-inl.h
index c07d36f5..2b8c8636 100644
--- a/thirdparty/faiss/faiss/utils/fp16-inl.h
+++ b/thirdparty/faiss/knowherefaiss/utils/fp16-inl.h
@@ -10,7 +10,7 @@
 #include <algorithm>
 #include <cstdint>
 
-namespace faiss {
+namespace knowherefaiss {
 
 // non-intrinsic FP16 <-> FP32 code adapted from
 // https://github.com/ispc/ispc/blob/master/stdlib.ispc
@@ -105,4 +105,4 @@ inline float decode_fp16(uint16_t h) {
     return floatbits(((exp == shifted_exp) ? infnan_val : reg_val) | sign_bit);
 }
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/utils/fp16.h b/thirdparty/faiss/knowherefaiss/utils/fp16.h
similarity index 61%
rename from thirdparty/faiss/faiss/utils/fp16.h
rename to thirdparty/faiss/knowherefaiss/utils/fp16.h
index 43e05dc3..87a7a2bb 100644
--- a/thirdparty/faiss/faiss/utils/fp16.h
+++ b/thirdparty/faiss/knowherefaiss/utils/fp16.h
@@ -9,12 +9,12 @@
 
 #include <cstdint>
 
-#include <faiss/impl/platform_macros.h>
+#include <knowherefaiss/impl/platform_macros.h>
 
 #if defined(__F16C__)
-#include <faiss/utils/fp16-fp16c.h>
+#include <knowherefaiss/utils/fp16-fp16c.h>
 #elif defined(__aarch64__)
-#include <faiss/utils/fp16-arm.h>
+#include <knowherefaiss/utils/fp16-arm.h>
 #else
-#include <faiss/utils/fp16-inl.h>
+#include <knowherefaiss/utils/fp16-inl.h>
 #endif
diff --git a/thirdparty/faiss/faiss/utils/hamming-inl.h b/thirdparty/faiss/knowherefaiss/utils/hamming-inl.h
similarity index 96%
rename from thirdparty/faiss/faiss/utils/hamming-inl.h
rename to thirdparty/faiss/knowherefaiss/utils/hamming-inl.h
index 5bfd3153..ca795ae4 100644
--- a/thirdparty/faiss/faiss/utils/hamming-inl.h
+++ b/thirdparty/faiss/knowherefaiss/utils/hamming-inl.h
@@ -5,9 +5,9 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/utils/binary_distances.h>
+#include <knowherefaiss/utils/binary_distances.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 // BitstringWriter and BitstringReader functions
 inline BitstringWriter::BitstringWriter(uint8_t* code, size_t code_size)
@@ -118,4 +118,4 @@ struct HCounterState {
     }
 };
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/utils/hamming.cpp b/thirdparty/faiss/knowherefaiss/utils/hamming.cpp
similarity index 93%
rename from thirdparty/faiss/faiss/utils/hamming.cpp
rename to thirdparty/faiss/knowherefaiss/utils/hamming.cpp
index e2732d35..5f7a3d8b 100644
--- a/thirdparty/faiss/faiss/utils/hamming.cpp
+++ b/thirdparty/faiss/knowherefaiss/utils/hamming.cpp
@@ -21,7 +21,7 @@
  *
  */
 
-#include <faiss/utils/hamming.h>
+#include <knowherefaiss/utils/hamming.h>
 
 #include <algorithm>
 #include <cmath>
@@ -29,14 +29,14 @@
 #include <memory>
 #include <vector>
 
-#include <faiss/impl/AuxIndexStructures.h>
-#include <faiss/impl/FaissAssert.h>
-#include <faiss/impl/IDSelector.h>
-#include <faiss/utils/Heap.h>
-#include <faiss/utils/approx_topk_hamming/approx_topk_hamming.h>
-#include <faiss/utils/utils.h>
+#include <knowherefaiss/impl/AuxIndexStructures.h>
+#include <knowherefaiss/impl/FaissAssert.h>
+#include <knowherefaiss/impl/IDSelector.h>
+#include <knowherefaiss/utils/Heap.h>
+#include <knowherefaiss/utils/approx_topk_hamming/approx_topk_hamming.h>
+#include <knowherefaiss/utils/utils.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 size_t hamming_batch_size = 65536;
 
@@ -218,7 +218,7 @@ void hammings_knn_hc(
                     for (size_t j = j0; j < j1; j++, bs2_ += bytes_per_code) {
                         dis = hc.compute(bs2_);
                         if (dis < bh_val_[0]) {
-                            faiss::maxheap_replace_top<hamdis_t>(
+                            knowherefaiss::maxheap_replace_top<hamdis_t>(
                                     k, bh_val_, bh_ids_, dis, j);
                         }
                     }
@@ -460,19 +460,19 @@ void hammings(
     FAISS_THROW_IF_NOT(ncodes % 8 == 0);
     switch (ncodes) {
         case 8:
-            faiss::hammings<64>(C64(a), C64(b), na, nb, dis);
+            knowherefaiss::hammings<64>(C64(a), C64(b), na, nb, dis);
             return;
         case 16:
-            faiss::hammings<128>(C64(a), C64(b), na, nb, dis);
+            knowherefaiss::hammings<128>(C64(a), C64(b), na, nb, dis);
             return;
         case 32:
-            faiss::hammings<256>(C64(a), C64(b), na, nb, dis);
+            knowherefaiss::hammings<256>(C64(a), C64(b), na, nb, dis);
             return;
         case 64:
-            faiss::hammings<512>(C64(a), C64(b), na, nb, dis);
+            knowherefaiss::hammings<512>(C64(a), C64(b), na, nb, dis);
             return;
         default:
-            faiss::hammings(C64(a), C64(b), na, nb, ncodes * 8, dis);
+            knowherefaiss::hammings(C64(a), C64(b), na, nb, ncodes * 8, dis);
             return;
     }
 }
@@ -539,19 +539,19 @@ void hamming_count_thres(
         size_t* nptr) {
     switch (ncodes) {
         case 8:
-            faiss::hamming_count_thres<64>(
+            knowherefaiss::hamming_count_thres<64>(
                     C64(bs1), C64(bs2), n1, n2, ht, nptr);
             return;
         case 16:
-            faiss::hamming_count_thres<128>(
+            knowherefaiss::hamming_count_thres<128>(
                     C64(bs1), C64(bs2), n1, n2, ht, nptr);
             return;
         case 32:
-            faiss::hamming_count_thres<256>(
+            knowherefaiss::hamming_count_thres<256>(
                     C64(bs1), C64(bs2), n1, n2, ht, nptr);
             return;
         case 64:
-            faiss::hamming_count_thres<512>(
+            knowherefaiss::hamming_count_thres<512>(
                     C64(bs1), C64(bs2), n1, n2, ht, nptr);
             return;
         default:
@@ -568,16 +568,16 @@ void crosshamming_count_thres(
         size_t* nptr) {
     switch (ncodes) {
         case 8:
-            faiss::crosshamming_count_thres<64>(C64(dbs), n, ht, nptr);
+            knowherefaiss::crosshamming_count_thres<64>(C64(dbs), n, ht, nptr);
             return;
         case 16:
-            faiss::crosshamming_count_thres<128>(C64(dbs), n, ht, nptr);
+            knowherefaiss::crosshamming_count_thres<128>(C64(dbs), n, ht, nptr);
             return;
         case 32:
-            faiss::crosshamming_count_thres<256>(C64(dbs), n, ht, nptr);
+            knowherefaiss::crosshamming_count_thres<256>(C64(dbs), n, ht, nptr);
             return;
         case 64:
-            faiss::crosshamming_count_thres<512>(C64(dbs), n, ht, nptr);
+            knowherefaiss::crosshamming_count_thres<512>(C64(dbs), n, ht, nptr);
             return;
         default:
             FAISS_THROW_FMT("not implemented for %zu bits", ncodes);
@@ -596,16 +596,16 @@ size_t match_hamming_thres(
         hamdis_t* dis) {
     switch (ncodes) {
         case 8:
-            return faiss::match_hamming_thres<64>(
+            return knowherefaiss::match_hamming_thres<64>(
                     C64(bs1), C64(bs2), n1, n2, ht, idx, dis);
         case 16:
-            return faiss::match_hamming_thres<128>(
+            return knowherefaiss::match_hamming_thres<128>(
                     C64(bs1), C64(bs2), n1, n2, ht, idx, dis);
         case 32:
-            return faiss::match_hamming_thres<256>(
+            return knowherefaiss::match_hamming_thres<256>(
                     C64(bs1), C64(bs2), n1, n2, ht, idx, dis);
         case 64:
-            return faiss::match_hamming_thres<512>(
+            return knowherefaiss::match_hamming_thres<512>(
                     C64(bs1), C64(bs2), n1, n2, ht, idx, dis);
         default:
             FAISS_THROW_FMT("not implemented for %zu bits", ncodes);
@@ -768,4 +768,4 @@ void unpack_bitstrings(
     }
 }
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/utils/hamming.h b/thirdparty/faiss/knowherefaiss/utils/hamming.h
similarity index 96%
rename from thirdparty/faiss/faiss/utils/hamming.h
rename to thirdparty/faiss/knowherefaiss/utils/hamming.h
index 89b1dc5d..4db22cee 100644
--- a/thirdparty/faiss/faiss/utils/hamming.h
+++ b/thirdparty/faiss/knowherefaiss/utils/hamming.h
@@ -27,15 +27,15 @@
 
 #include <stdint.h>
 
-#include <faiss/impl/platform_macros.h>
-#include <faiss/utils/Heap.h>
+#include <knowherefaiss/impl/platform_macros.h>
+#include <knowherefaiss/utils/Heap.h>
 
 // Low-level Hamming distance computations and hamdis_t.
-#include <faiss/utils/hamming_distance/hamdis-inl.h>
+#include <knowherefaiss/utils/hamming_distance/hamdis-inl.h>
 
-#include <faiss/utils/approx_topk/mode.h>
+#include <knowherefaiss/utils/approx_topk/mode.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 struct IDSelector;
 
@@ -283,8 +283,8 @@ void unpack_bitstrings(
         size_t code_size,
         int32_t* unpacked);
 
-} // namespace faiss
+} // namespace knowherefaiss
 
-#include <faiss/utils/hamming-inl.h>
+#include <knowherefaiss/utils/hamming-inl.h>
 
 #endif /* FAISS_hamming_h */
diff --git a/thirdparty/faiss/faiss/utils/hamming_distance/avx2-inl.h b/thirdparty/faiss/knowherefaiss/utils/hamming_distance/avx2-inl.h
similarity index 99%
rename from thirdparty/faiss/faiss/utils/hamming_distance/avx2-inl.h
rename to thirdparty/faiss/knowherefaiss/utils/hamming_distance/avx2-inl.h
index 6777d116..b8c889b1 100644
--- a/thirdparty/faiss/faiss/utils/hamming_distance/avx2-inl.h
+++ b/thirdparty/faiss/knowherefaiss/utils/hamming_distance/avx2-inl.h
@@ -14,11 +14,11 @@
 #include <cstddef>
 #include <cstdint>
 
-#include <faiss/impl/platform_macros.h>
+#include <knowherefaiss/impl/platform_macros.h>
 
 #include <immintrin.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 /* Elementary Hamming distance computation: unoptimized  */
 template <size_t nbits, typename T>
@@ -457,6 +457,6 @@ struct GenHammingComputerM8 {
     }
 };
 
-} // namespace faiss
+} // namespace knowherefaiss
 
 #endif
diff --git a/thirdparty/faiss/faiss/utils/hamming_distance/common.h b/thirdparty/faiss/knowherefaiss/utils/hamming_distance/common.h
similarity index 94%
rename from thirdparty/faiss/faiss/utils/hamming_distance/common.h
rename to thirdparty/faiss/knowherefaiss/utils/hamming_distance/common.h
index 0a2de08d..e668735f 100644
--- a/thirdparty/faiss/faiss/utils/hamming_distance/common.h
+++ b/thirdparty/faiss/knowherefaiss/utils/hamming_distance/common.h
@@ -10,12 +10,12 @@
 
 #include <cstdint>
 
-#include <faiss/impl/platform_macros.h>
+#include <knowherefaiss/impl/platform_macros.h>
 
 /* The Hamming distance type */
 using hamdis_t = int32_t;
 
-namespace faiss {
+namespace knowherefaiss {
 
 // trust the compiler to provide efficient popcount implementations
 inline int popcount32(uint32_t x) {
@@ -44,6 +44,6 @@ static constexpr uint8_t hamdis_tab_ham_bytes[256] = {
         4, 5, 5, 6, 5, 6, 6, 7, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
         4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8};
 
-} // namespace faiss
+} // namespace knowherefaiss
 
 #endif
diff --git a/thirdparty/faiss/faiss/utils/hamming_distance/generic-inl.h b/thirdparty/faiss/knowherefaiss/utils/hamming_distance/generic-inl.h
similarity index 99%
rename from thirdparty/faiss/faiss/utils/hamming_distance/generic-inl.h
rename to thirdparty/faiss/knowherefaiss/utils/hamming_distance/generic-inl.h
index 5beb2011..34d60750 100644
--- a/thirdparty/faiss/faiss/utils/hamming_distance/generic-inl.h
+++ b/thirdparty/faiss/knowherefaiss/utils/hamming_distance/generic-inl.h
@@ -14,9 +14,9 @@
 #include <cstddef>
 #include <cstdint>
 
-#include <faiss/impl/platform_macros.h>
+#include <knowherefaiss/impl/platform_macros.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 /* Elementary Hamming distance computation: unoptimized  */
 template <size_t nbits, typename T>
@@ -441,6 +441,6 @@ struct GenHammingComputerM8 {
     }
 };
 
-} // namespace faiss
+} // namespace knowherefaiss
 
 #endif
diff --git a/thirdparty/faiss/faiss/utils/hamming_distance/hamdis-inl.h b/thirdparty/faiss/knowherefaiss/utils/hamming_distance/hamdis-inl.h
similarity index 89%
rename from thirdparty/faiss/faiss/utils/hamming_distance/hamdis-inl.h
rename to thirdparty/faiss/knowherefaiss/utils/hamming_distance/hamdis-inl.h
index b830df38..ec3aef46 100644
--- a/thirdparty/faiss/faiss/utils/hamming_distance/hamdis-inl.h
+++ b/thirdparty/faiss/knowherefaiss/utils/hamming_distance/hamdis-inl.h
@@ -11,19 +11,19 @@
 #ifndef FAISS_hamming_inl_h
 #define FAISS_hamming_inl_h
 
-#include <faiss/utils/hamming_distance/common.h>
+#include <knowherefaiss/utils/hamming_distance/common.h>
 
 #ifdef __aarch64__
 // ARM compilers may produce inoptimal code for Hamming distance somewhy.
-#include <faiss/utils/hamming_distance/neon-inl.h>
+#include <knowherefaiss/utils/hamming_distance/neon-inl.h>
 #elif __AVX2__
 // better versions for GenHammingComputer
-#include <faiss/utils/hamming_distance/avx2-inl.h>
+#include <knowherefaiss/utils/hamming_distance/avx2-inl.h>
 #else
-#include <faiss/utils/hamming_distance/generic-inl.h>
+#include <knowherefaiss/utils/hamming_distance/generic-inl.h>
 #endif
 
-namespace faiss {
+namespace knowherefaiss {
 
 /***************************************************************************
  * Equivalence with a template class when code size is known at compile time
@@ -78,6 +78,6 @@ typename Consumer::T dispatch_HammingComputer(
     }
 }
 
-} // namespace faiss
+} // namespace knowherefaiss
 
 #endif
diff --git a/thirdparty/faiss/faiss/utils/hamming_distance/neon-inl.h b/thirdparty/faiss/knowherefaiss/utils/hamming_distance/neon-inl.h
similarity index 98%
rename from thirdparty/faiss/faiss/utils/hamming_distance/neon-inl.h
rename to thirdparty/faiss/knowherefaiss/utils/hamming_distance/neon-inl.h
index ad6ba117..f40a46dd 100644
--- a/thirdparty/faiss/faiss/utils/hamming_distance/neon-inl.h
+++ b/thirdparty/faiss/knowherefaiss/utils/hamming_distance/neon-inl.h
@@ -19,11 +19,11 @@
 #include <cstddef>
 #include <cstdint>
 
-#include <faiss/impl/platform_macros.h>
+#include <knowherefaiss/impl/platform_macros.h>
 
-#include <faiss/utils/hamming_distance/common.h>
+#include <knowherefaiss/utils/hamming_distance/common.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 /* Elementary Hamming distance computation: unoptimized  */
 template <size_t nbits, typename T>
@@ -327,7 +327,7 @@ struct HammingComputerDefault {
 
         int len256 = (quotient8 / 4) * 4;
         for (; i < len256; i += 4) {
-            accu += ::faiss::hamming<256>(a64 + i, b64 + i);
+            accu += ::knowherefaiss::hamming<256>(a64 + i, b64 + i);
             len -= 4;
         }
 
@@ -517,7 +517,7 @@ struct GenHammingComputerM8 {
     }
 };
 
-} // namespace faiss
+} // namespace knowherefaiss
 
 #endif
 
diff --git a/thirdparty/faiss/faiss/utils/jaccard-inl.h b/thirdparty/faiss/knowherefaiss/utils/jaccard-inl.h
similarity index 99%
rename from thirdparty/faiss/faiss/utils/jaccard-inl.h
rename to thirdparty/faiss/knowherefaiss/utils/jaccard-inl.h
index f1d175d9..9ea7e124 100644
--- a/thirdparty/faiss/faiss/utils/jaccard-inl.h
+++ b/thirdparty/faiss/knowherefaiss/utils/jaccard-inl.h
@@ -15,11 +15,11 @@
 #ifndef FAISS_JACCARD_INL_H
 #define FAISS_JACCARD_INL_H
 
-#include <faiss/utils/binary_distances.h>
+#include <knowherefaiss/utils/binary_distances.h>
 
-#include <faiss/utils/hamming_distance/common.h>
+#include <knowherefaiss/utils/hamming_distance/common.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 // todo aguzhva: upgrade code
 
@@ -483,6 +483,6 @@ SPECIALIZED_HC(512);
 
 #undef SPECIALIZED_HC
 
-} // namespace faiss
+} // namespace knowherefaiss
 
 #endif
diff --git a/thirdparty/faiss/faiss/utils/ordered_key_value.h b/thirdparty/faiss/knowherefaiss/utils/ordered_key_value.h
similarity index 97%
rename from thirdparty/faiss/faiss/utils/ordered_key_value.h
rename to thirdparty/faiss/knowherefaiss/utils/ordered_key_value.h
index 2f19f3a3..0a8e5a99 100644
--- a/thirdparty/faiss/faiss/utils/ordered_key_value.h
+++ b/thirdparty/faiss/knowherefaiss/utils/ordered_key_value.h
@@ -12,7 +12,7 @@
 
 #include <limits>
 
-namespace faiss {
+namespace knowherefaiss {
 
 /*******************************************************************
  * C object: uniform handling of min and max heap
@@ -103,4 +103,4 @@ inline uint16_t cmax_nextafter<uint16_t>(uint16_t x) {
     return x + 1;
 }
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/utils/partitioning.cpp b/thirdparty/faiss/knowherefaiss/utils/partitioning.cpp
similarity index 98%
rename from thirdparty/faiss/faiss/utils/partitioning.cpp
rename to thirdparty/faiss/knowherefaiss/utils/partitioning.cpp
index b55761e7..4fa6d582 100644
--- a/thirdparty/faiss/faiss/utils/partitioning.cpp
+++ b/thirdparty/faiss/knowherefaiss/utils/partitioning.cpp
@@ -5,20 +5,20 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/utils/partitioning.h>
+#include <knowherefaiss/utils/partitioning.h>
 
 #include <cassert>
 #include <cmath>
 
-#include <faiss/impl/FaissAssert.h>
-#include <faiss/utils/AlignedTable.h>
-#include <faiss/utils/ordered_key_value.h>
+#include <knowherefaiss/impl/FaissAssert.h>
+#include <knowherefaiss/utils/AlignedTable.h>
+#include <knowherefaiss/utils/ordered_key_value.h>
 #ifdef __AVX2__
-#include <faiss/utils/simdlib.h>
+#include <knowherefaiss/utils/simdlib.h>
 #endif
-#include <faiss/impl/platform_macros.h>
+#include <knowherefaiss/impl/platform_macros.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 /******************************************************************
  * Internal routines
@@ -1327,4 +1327,4 @@ void PartitionStats::reset() {
 
 PartitionStats partition_stats;
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/utils/partitioning.h b/thirdparty/faiss/knowherefaiss/utils/partitioning.h
similarity index 95%
rename from thirdparty/faiss/faiss/utils/partitioning.h
rename to thirdparty/faiss/knowherefaiss/utils/partitioning.h
index de65669a..79f282ca 100644
--- a/thirdparty/faiss/faiss/utils/partitioning.h
+++ b/thirdparty/faiss/knowherefaiss/utils/partitioning.h
@@ -10,9 +10,9 @@
 #include <stdint.h>
 #include <stdio.h>
 
-#include <faiss/impl/platform_macros.h>
+#include <knowherefaiss/impl/platform_macros.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 /** partitions the table into 0:q and q:n where all elements above q are >= all
  * elements below q (for C = CMax, for CMin comparisons are reversed)
@@ -92,4 +92,4 @@ struct PartitionStats {
 // global var that collects them all
 FAISS_API extern PartitionStats partition_stats;
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/utils/partitioning_avx2.cpp b/thirdparty/faiss/knowherefaiss/utils/partitioning_avx2.cpp
similarity index 96%
rename from thirdparty/faiss/faiss/utils/partitioning_avx2.cpp
rename to thirdparty/faiss/knowherefaiss/utils/partitioning_avx2.cpp
index 893f469d..69d8091e 100644
--- a/thirdparty/faiss/faiss/utils/partitioning_avx2.cpp
+++ b/thirdparty/faiss/knowherefaiss/utils/partitioning_avx2.cpp
@@ -1,16 +1,16 @@
-#include <faiss/utils/partitioning.h>
+#include <knowherefaiss/utils/partitioning.h>
 
 #include <cassert>
 #include <cmath>
 
-#include <faiss/impl/FaissAssert.h>
-#include <faiss/utils/AlignedTable.h>
-#include <faiss/utils/ordered_key_value.h>
-#include <faiss/utils/simdlib.h>
+#include <knowherefaiss/impl/FaissAssert.h>
+#include <knowherefaiss/utils/AlignedTable.h>
+#include <knowherefaiss/utils/ordered_key_value.h>
+#include <knowherefaiss/utils/simdlib.h>
 
-#include <faiss/impl/platform_macros.h>
+#include <knowherefaiss/impl/platform_macros.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 /******************************************************************
  * Internal routines
@@ -426,4 +426,4 @@ template uint16_t partition_fuzzy_avx2<CMax<uint16_t, int>>(
         size_t q_max,
         size_t* q_out);
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/utils/prefetch.h b/thirdparty/faiss/knowherefaiss/utils/prefetch.h
similarity index 100%
rename from thirdparty/faiss/faiss/utils/prefetch.h
rename to thirdparty/faiss/knowherefaiss/utils/prefetch.h
diff --git a/thirdparty/faiss/faiss/utils/quantize_lut.cpp b/thirdparty/faiss/knowherefaiss/utils/quantize_lut.cpp
similarity index 98%
rename from thirdparty/faiss/faiss/utils/quantize_lut.cpp
rename to thirdparty/faiss/knowherefaiss/utils/quantize_lut.cpp
index ca917e58..c40f6156 100644
--- a/thirdparty/faiss/faiss/utils/quantize_lut.cpp
+++ b/thirdparty/faiss/knowherefaiss/utils/quantize_lut.cpp
@@ -5,16 +5,16 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/utils/quantize_lut.h>
+#include <knowherefaiss/utils/quantize_lut.h>
 
 #include <algorithm>
 #include <cmath>
 #include <cstring>
 #include <vector>
 
-#include <faiss/impl/FaissAssert.h>
+#include <knowherefaiss/impl/FaissAssert.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 namespace quantize_lut {
 
@@ -334,4 +334,4 @@ float aq_estimate_norm_scale(
 
 } // namespace quantize_lut
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/utils/quantize_lut.h b/thirdparty/faiss/knowherefaiss/utils/quantize_lut.h
similarity index 97%
rename from thirdparty/faiss/faiss/utils/quantize_lut.h
rename to thirdparty/faiss/knowherefaiss/utils/quantize_lut.h
index b7d4fc42..d2fe2392 100644
--- a/thirdparty/faiss/faiss/utils/quantize_lut.h
+++ b/thirdparty/faiss/knowherefaiss/utils/quantize_lut.h
@@ -10,7 +10,7 @@
 #include <cstdint>
 #include <cstdio>
 
-namespace faiss {
+namespace knowherefaiss {
 
 /** Functions to quantize PQ floating-point Look Up Tables (LUT) to uint8, and
  * biases to uint16. The accumulation is supposed to take place in uint16.
@@ -99,4 +99,4 @@ float aq_estimate_norm_scale(
 
 } // namespace quantize_lut
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/utils/random.cpp b/thirdparty/faiss/knowherefaiss/utils/random.cpp
similarity index 98%
rename from thirdparty/faiss/faiss/utils/random.cpp
rename to thirdparty/faiss/knowherefaiss/utils/random.cpp
index 877a7c25..8a738abb 100644
--- a/thirdparty/faiss/faiss/utils/random.cpp
+++ b/thirdparty/faiss/knowherefaiss/utils/random.cpp
@@ -7,7 +7,7 @@
 
 // -*- c++ -*-
 
-#include <faiss/utils/random.h>
+#include <knowherefaiss/utils/random.h>
 
 extern "C" {
 int sgemm_(
@@ -26,7 +26,7 @@ int sgemm_(
         FINTEGER* ldc);
 }
 
-namespace faiss {
+namespace knowherefaiss {
 
 /**************************************************
  * Random data generation functions
@@ -261,4 +261,4 @@ void rand_smooth_vectors(size_t n, size_t d, float* x, int64_t seed) {
     }
 }
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/utils/random.h b/thirdparty/faiss/knowherefaiss/utils/random.h
similarity index 97%
rename from thirdparty/faiss/faiss/utils/random.h
rename to thirdparty/faiss/knowherefaiss/utils/random.h
index ac985d69..e2326266 100644
--- a/thirdparty/faiss/faiss/utils/random.h
+++ b/thirdparty/faiss/knowherefaiss/utils/random.h
@@ -16,7 +16,7 @@
 #include <stdint.h>
 #include <random>
 
-namespace faiss {
+namespace knowherefaiss {
 
 /**************************************************
  * Random data generation functions
@@ -84,4 +84,4 @@ void rand_perm_splitmix64(int* perm, size_t n, int64_t seed);
  * */
 void rand_smooth_vectors(size_t n, size_t d, float* x, int64_t seed);
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/utils/simdlib.h b/thirdparty/faiss/knowherefaiss/utils/simdlib.h
similarity index 71%
rename from thirdparty/faiss/faiss/utils/simdlib.h
rename to thirdparty/faiss/knowherefaiss/utils/simdlib.h
index ea5020d7..6d210612 100644
--- a/thirdparty/faiss/faiss/utils/simdlib.h
+++ b/thirdparty/faiss/knowherefaiss/utils/simdlib.h
@@ -16,25 +16,25 @@
 
 #if defined(__AVX512F__)
 
-#include <faiss/utils/simdlib_avx2.h>
-#include <faiss/utils/simdlib_avx512.h>
+#include <knowherefaiss/utils/simdlib_avx2.h>
+#include <knowherefaiss/utils/simdlib_avx512.h>
 
 #elif defined(__AVX2__)
 
-#include <faiss/utils/simdlib_avx2.h>
+#include <knowherefaiss/utils/simdlib_avx2.h>
 
 #elif defined(__aarch64__)
 
-#include <faiss/utils/simdlib_neon.h>
+#include <knowherefaiss/utils/simdlib_neon.h>
 
 #elif defined(__PPC64__)
 
-#include <faiss/utils/simdlib_ppc64.h>
+#include <knowherefaiss/utils/simdlib_ppc64.h>
 
 #else
 
 // emulated = all operations are implemented as scalars
-#include <faiss/utils/simdlib_emulated.h>
+#include <knowherefaiss/utils/simdlib_emulated.h>
 
 // FIXME: make a SSE version
 // is this ever going to happen? We will probably rather implement AVX512
diff --git a/thirdparty/faiss/faiss/utils/simdlib_avx2.h b/thirdparty/faiss/knowherefaiss/utils/simdlib_avx2.h
similarity index 99%
rename from thirdparty/faiss/faiss/utils/simdlib_avx2.h
rename to thirdparty/faiss/knowherefaiss/utils/simdlib_avx2.h
index fc51e3ed..27ae6bb6 100644
--- a/thirdparty/faiss/faiss/utils/simdlib_avx2.h
+++ b/thirdparty/faiss/knowherefaiss/utils/simdlib_avx2.h
@@ -12,9 +12,9 @@
 
 #include <immintrin.h>
 
-#include <faiss/impl/platform_macros.h>
+#include <knowherefaiss/impl/platform_macros.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 /** Simple wrapper around the AVX 256-bit registers
  *
@@ -800,4 +800,4 @@ inline simd8float32 gethigh128(simd8float32 a, simd8float32 b) {
 
 } // namespace
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/utils/simdlib_avx512.h b/thirdparty/faiss/knowherefaiss/utils/simdlib_avx512.h
similarity index 98%
rename from thirdparty/faiss/faiss/utils/simdlib_avx512.h
rename to thirdparty/faiss/knowherefaiss/utils/simdlib_avx512.h
index 9ce09658..5f669cf8 100644
--- a/thirdparty/faiss/faiss/utils/simdlib_avx512.h
+++ b/thirdparty/faiss/knowherefaiss/utils/simdlib_avx512.h
@@ -12,11 +12,11 @@
 
 #include <immintrin.h>
 
-#include <faiss/impl/platform_macros.h>
+#include <knowherefaiss/impl/platform_macros.h>
 
-#include <faiss/utils/simdlib_avx2.h>
+#include <knowherefaiss/utils/simdlib_avx2.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 /** Simple wrapper around the AVX 512-bit registers
  *
@@ -293,4 +293,4 @@ struct simd64uint8 : simd512bit {
     }
 };
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/utils/simdlib_emulated.h b/thirdparty/faiss/knowherefaiss/utils/simdlib_emulated.h
similarity index 99%
rename from thirdparty/faiss/faiss/utils/simdlib_emulated.h
rename to thirdparty/faiss/knowherefaiss/utils/simdlib_emulated.h
index f9cfb3b3..51f2d34f 100644
--- a/thirdparty/faiss/faiss/utils/simdlib_emulated.h
+++ b/thirdparty/faiss/knowherefaiss/utils/simdlib_emulated.h
@@ -12,7 +12,7 @@
 #include <cstring>
 #include <string>
 
-namespace faiss {
+namespace knowherefaiss {
 
 struct simd256bit {
     union {
@@ -1042,4 +1042,4 @@ inline void cmplt_min_max_fast(
 
 } // namespace
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/utils/simdlib_neon.h b/thirdparty/faiss/knowherefaiss/utils/simdlib_neon.h
similarity index 99%
rename from thirdparty/faiss/faiss/utils/simdlib_neon.h
rename to thirdparty/faiss/knowherefaiss/utils/simdlib_neon.h
index 1bdf0ed0..a1334446 100644
--- a/thirdparty/faiss/faiss/utils/simdlib_neon.h
+++ b/thirdparty/faiss/knowherefaiss/utils/simdlib_neon.h
@@ -18,9 +18,9 @@
 
 #include <arm_neon.h>
 
-#include <faiss/impl/FaissAssert.h>
+#include <knowherefaiss/impl/FaissAssert.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 namespace detail {
 
@@ -1357,4 +1357,4 @@ simd8float32 gethigh128(const simd8float32& a, const simd8float32& b) {
 
 } // namespace
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/utils/simdlib_ppc64.h b/thirdparty/faiss/knowherefaiss/utils/simdlib_ppc64.h
similarity index 99%
rename from thirdparty/faiss/faiss/utils/simdlib_ppc64.h
rename to thirdparty/faiss/knowherefaiss/utils/simdlib_ppc64.h
index 94b3e42d..8ce79852 100644
--- a/thirdparty/faiss/faiss/utils/simdlib_ppc64.h
+++ b/thirdparty/faiss/knowherefaiss/utils/simdlib_ppc64.h
@@ -12,7 +12,7 @@
 #include <cstring>
 #include <string>
 
-namespace faiss {
+namespace knowherefaiss {
 
 struct simd256bit {
     union {
@@ -1081,4 +1081,4 @@ inline void cmplt_min_max_fast(
 
 } // namespace
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/utils/sorting.cpp b/thirdparty/faiss/knowherefaiss/utils/sorting.cpp
similarity index 99%
rename from thirdparty/faiss/faiss/utils/sorting.cpp
rename to thirdparty/faiss/knowherefaiss/utils/sorting.cpp
index f8ed250d..dba3ab61 100644
--- a/thirdparty/faiss/faiss/utils/sorting.cpp
+++ b/thirdparty/faiss/knowherefaiss/utils/sorting.cpp
@@ -7,15 +7,15 @@
 
 // -*- c++ -*-
 
-#include <faiss/utils/sorting.h>
+#include <knowherefaiss/utils/sorting.h>
 
 #include <omp.h>
 #include <algorithm>
 
-#include <faiss/impl/FaissAssert.h>
-#include <faiss/utils/utils.h>
+#include <knowherefaiss/impl/FaissAssert.h>
+#include <knowherefaiss/utils/utils.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 /*****************************************************************************
  * Argsort
@@ -824,4 +824,4 @@ void hashtable_int64_to_int64_lookup(
     }
 }
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/utils/sorting.h b/thirdparty/faiss/knowherefaiss/utils/sorting.h
similarity index 96%
rename from thirdparty/faiss/faiss/utils/sorting.h
rename to thirdparty/faiss/knowherefaiss/utils/sorting.h
index 50dadad4..d4d1f21d 100644
--- a/thirdparty/faiss/faiss/utils/sorting.h
+++ b/thirdparty/faiss/knowherefaiss/utils/sorting.h
@@ -10,9 +10,9 @@
 #include <cstddef>
 #include <cstdint>
 
-#include <faiss/impl/platform_macros.h>
+#include <knowherefaiss/impl/platform_macros.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 /** Indirect sort of a floating-point array
  *
@@ -98,4 +98,4 @@ void hashtable_int64_to_int64_lookup(
         const int64_t* keys,
         int64_t* vals);
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/utils/structure-inl.h b/thirdparty/faiss/knowherefaiss/utils/structure-inl.h
similarity index 99%
rename from thirdparty/faiss/faiss/utils/structure-inl.h
rename to thirdparty/faiss/knowherefaiss/utils/structure-inl.h
index 88288456..c2d263e0 100644
--- a/thirdparty/faiss/faiss/utils/structure-inl.h
+++ b/thirdparty/faiss/knowherefaiss/utils/structure-inl.h
@@ -12,9 +12,9 @@
 #ifndef FAISS_STRUCTURE_INL_H
 #define FAISS_STRUCTURE_INL_H
 
-#include <faiss/utils/binary_distances.h>
+#include <knowherefaiss/utils/binary_distances.h>
 
-namespace faiss {
+namespace knowherefaiss {
     template<bool is_super>
     struct StructureComputer8 {
         uint64_t a0;
diff --git a/thirdparty/faiss/faiss/utils/transpose/transpose-avx2-inl.h b/thirdparty/faiss/knowherefaiss/utils/transpose/transpose-avx2-inl.h
similarity index 99%
rename from thirdparty/faiss/faiss/utils/transpose/transpose-avx2-inl.h
rename to thirdparty/faiss/knowherefaiss/utils/transpose/transpose-avx2-inl.h
index 4b679842..01854d46 100644
--- a/thirdparty/faiss/faiss/utils/transpose/transpose-avx2-inl.h
+++ b/thirdparty/faiss/knowherefaiss/utils/transpose/transpose-avx2-inl.h
@@ -14,7 +14,7 @@
 
 #include <immintrin.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 // 8x2 -> 2x8
 inline void transpose_8x2(
@@ -160,6 +160,6 @@ inline void transpose_8x8(
     o7 = _mm256_permute2f128_ps(rr3, rr7, 0x31);
 }
 
-} // namespace faiss
+} // namespace knowherefaiss
 
 #endif
diff --git a/thirdparty/faiss/faiss/utils/utils.cpp b/thirdparty/faiss/knowherefaiss/utils/utils.cpp
similarity index 98%
rename from thirdparty/faiss/faiss/utils/utils.cpp
rename to thirdparty/faiss/knowherefaiss/utils/utils.cpp
index 38b959f6..d2990186 100644
--- a/thirdparty/faiss/faiss/utils/utils.cpp
+++ b/thirdparty/faiss/knowherefaiss/utils/utils.cpp
@@ -7,7 +7,7 @@
 
 // -*- c++ -*-
 
-#include <faiss/utils/utils.h>
+#include <knowherefaiss/utils/utils.h>
 
 #include <cassert>
 #include <cmath>
@@ -33,10 +33,10 @@
 #include <type_traits>
 #include <vector>
 
-#include <faiss/impl/AuxIndexStructures.h>
-#include <faiss/impl/FaissAssert.h>
-#include <faiss/impl/platform_macros.h>
-#include <faiss/utils/random.h>
+#include <knowherefaiss/impl/AuxIndexStructures.h>
+#include <knowherefaiss/impl/FaissAssert.h>
+#include <knowherefaiss/impl/platform_macros.h>
+#include <knowherefaiss/utils/random.h>
 
 #ifndef FINTEGER
 #define FINTEGER long
@@ -102,7 +102,7 @@ int sgemv_(
  * Get some stats about the system
  **************************************************/
 
-namespace faiss {
+namespace knowherefaiss {
 
 // this will be set at load time from GPU Faiss
 std::string gpu_compile_options;
@@ -658,4 +658,4 @@ void CodeSet::insert(size_t n, const uint8_t* codes, bool* inserted) {
     }
 }
 
-} // namespace faiss
+} // namespace knowherefaiss
diff --git a/thirdparty/faiss/faiss/utils/utils.h b/thirdparty/faiss/knowherefaiss/utils/utils.h
similarity index 98%
rename from thirdparty/faiss/faiss/utils/utils.h
rename to thirdparty/faiss/knowherefaiss/utils/utils.h
index 4742102f..cde6de02 100644
--- a/thirdparty/faiss/faiss/utils/utils.h
+++ b/thirdparty/faiss/knowherefaiss/utils/utils.h
@@ -21,10 +21,10 @@
 #include <string>
 #include <vector>
 
-#include <faiss/impl/platform_macros.h>
-#include <faiss/utils/Heap.h>
+#include <knowherefaiss/impl/platform_macros.h>
+#include <knowherefaiss/utils/Heap.h>
 
-namespace faiss {
+namespace knowherefaiss {
 
 /****************************************************************************
  * Get compile specific variables
@@ -224,6 +224,6 @@ struct CodeSet {
     void insert(size_t n, const uint8_t* codes, bool* inserted);
 };
 
-} // namespace faiss
+} // namespace knowherefaiss
 
 #endif /* FAISS_utils_h */
diff --git a/thirdparty/faiss/tests/test_RCQ_cropping.cpp b/thirdparty/faiss/tests/test_RCQ_cropping.cpp
index 4dd34708..621f187a 100644
--- a/thirdparty/faiss/tests/test_RCQ_cropping.cpp
+++ b/thirdparty/faiss/tests/test_RCQ_cropping.cpp
@@ -5,9 +5,9 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/IndexAdditiveQuantizer.h>
-#include <faiss/IndexScalarQuantizer.h>
-#include <faiss/utils/random.h>
+#include <knowherefaiss/IndexAdditiveQuantizer.h>
+#include <knowherefaiss/IndexScalarQuantizer.h>
+#include <knowherefaiss/utils/random.h>
 #include <gtest/gtest.h>
 
 /* This test creates a 3-level RCQ and performs a search on it.
@@ -16,16 +16,16 @@
 TEST(RCQCropping, test_cropping) {
     size_t nq = 10, nt = 2000, nb = 1000, d = 32;
 
-    using idx_t = faiss::idx_t;
+    using idx_t = knowherefaiss::idx_t;
 
     std::vector<float> buf((nq + nb + nt) * d);
-    faiss::rand_smooth_vectors(nq + nb + nt, d, buf.data(), 1234);
+    knowherefaiss::rand_smooth_vectors(nq + nb + nt, d, buf.data(), 1234);
     const float* xt = buf.data();
     const float* xb = xt + nt * d;
     const float* xq = xb + nb * d;
 
     std::vector<size_t> nbits = {5, 4, 4};
-    faiss::ResidualCoarseQuantizer rcq(d, nbits);
+    knowherefaiss::ResidualCoarseQuantizer rcq(d, nbits);
 
     rcq.train(nt, xt);
     // fprintf(stderr, "nb centroids: %zd\n", rcq.ntotal);
@@ -35,21 +35,21 @@ TEST(RCQCropping, test_cropping) {
 
     // perform search
     int nprobe = 15;
-    std::vector<faiss::idx_t> Iref(nq * nprobe);
+    std::vector<knowherefaiss::idx_t> Iref(nq * nprobe);
     std::vector<float> Dref(nq * nprobe);
     rcq.search(nq, xq, nprobe, Dref.data(), Iref.data());
 
     // crop to the first 2 quantization levels
     int last_nbits = nbits.back();
     nbits.pop_back();
-    faiss::ResidualCoarseQuantizer rcq_cropped(d, nbits);
+    knowherefaiss::ResidualCoarseQuantizer rcq_cropped(d, nbits);
     rcq_cropped.initialize_from(rcq);
     // fprintf(stderr, "cropped nb centroids: %zd\n", rcq_cropped.ntotal);
 
     EXPECT_EQ(rcq_cropped.ntotal, rcq.ntotal >> last_nbits);
 
     // perform search
-    std::vector<faiss::idx_t> Inew(nq * nprobe);
+    std::vector<knowherefaiss::idx_t> Inew(nq * nprobe);
     std::vector<float> Dnew(nq * nprobe);
     rcq_cropped.search(nq, xq, nprobe, Dnew.data(), Inew.data());
 
@@ -77,19 +77,19 @@ TEST(RCQCropping, test_cropping) {
 TEST(RCQCropping, search_params) {
     size_t nq = 10, nt = 2000, nb = 1000, d = 32;
 
-    using idx_t = faiss::idx_t;
+    using idx_t = knowherefaiss::idx_t;
 
     std::vector<float> buf((nq + nb + nt) * d);
-    faiss::rand_smooth_vectors(nq + nb + nt, d, buf.data(), 1234);
+    knowherefaiss::rand_smooth_vectors(nq + nb + nt, d, buf.data(), 1234);
     const float* xt = buf.data();
     const float* xb = xt + nt * d;
     const float* xq = xb + nb * d;
 
     std::vector<size_t> nbits = {3, 6, 3};
-    faiss::ResidualCoarseQuantizer quantizer(d, nbits);
+    knowherefaiss::ResidualCoarseQuantizer quantizer(d, nbits);
     size_t ntotal = (size_t)1 << quantizer.rq.tot_bits;
-    faiss::IndexIVFScalarQuantizer index(
-            &quantizer, d, ntotal, faiss::ScalarQuantizer::QT_8bit);
+    knowherefaiss::IndexIVFScalarQuantizer index(
+            &quantizer, d, ntotal, knowherefaiss::ScalarQuantizer::QT_8bit);
     index.quantizer_trains_alone = true;
 
     index.train(nt, xt);
@@ -115,9 +115,9 @@ TEST(RCQCropping, search_params) {
     EXPECT_NE(D1, D2);
 
     // override the class level beam factor
-    faiss::SearchParametersResidualCoarseQuantizer params1;
+    knowherefaiss::SearchParametersResidualCoarseQuantizer params1;
     params1.beam_factor = beam_factor_1;
-    faiss::SearchParametersIVF params;
+    knowherefaiss::SearchParametersIVF params;
     params.nprobe = index.nprobe;
     params.quantizer_params = &params1;
 
diff --git a/thirdparty/faiss/tests/test_approx_topk.cpp b/thirdparty/faiss/tests/test_approx_topk.cpp
index 4bdf8f6c..c8c03e9f 100644
--- a/thirdparty/faiss/tests/test_approx_topk.cpp
+++ b/thirdparty/faiss/tests/test_approx_topk.cpp
@@ -15,14 +15,14 @@
 #include <unordered_set>
 #include <vector>
 
-#include <faiss/utils/approx_topk/approx_topk.h>
+#include <knowherefaiss/utils/approx_topk/approx_topk.h>
 
-#include <faiss/impl/FaissAssert.h>
-#include <faiss/impl/FaissException.h>
-#include <faiss/utils/Heap.h>
+#include <knowherefaiss/impl/FaissAssert.h>
+#include <knowherefaiss/impl/FaissException.h>
+#include <knowherefaiss/utils/Heap.h>
 
 //
-using namespace faiss;
+using namespace knowherefaiss;
 
 //
 template <uint32_t NBUCKETS, uint32_t N>
@@ -99,7 +99,7 @@ void test_approx_topk(
                     k,
                     approxDistances.data(),
                     approxIndices.data());
-        } catch (const faiss::FaissException&) {
+        } catch (const knowherefaiss::FaissException&) {
             //
             if (verbose) {
                 printf("Skipping the case.\n");
diff --git a/thirdparty/faiss/tests/test_binary_flat.cpp b/thirdparty/faiss/tests/test_binary_flat.cpp
index ea37d16e..61ab1c11 100644
--- a/thirdparty/faiss/tests/test_binary_flat.cpp
+++ b/thirdparty/faiss/tests/test_binary_flat.cpp
@@ -10,8 +10,8 @@
 
 #include <gtest/gtest.h>
 
-#include <faiss/IndexBinaryFlat.h>
-#include <faiss/utils/hamming.h>
+#include <knowherefaiss/IndexBinaryFlat.h>
+#include <knowherefaiss/utils/hamming.h>
 
 TEST(BinaryFlat, accuracy) {
     // dimension of the vectors to index
@@ -21,7 +21,7 @@ TEST(BinaryFlat, accuracy) {
     size_t nb = 1000;
 
     // make the index object and train it
-    faiss::IndexBinaryFlat index(d);
+    knowherefaiss::IndexBinaryFlat index(d);
 
     std::vector<uint8_t> database(nb * (d / 8));
     for (size_t i = 0; i < nb * (d / 8); i++) {
@@ -42,13 +42,13 @@ TEST(BinaryFlat, accuracy) {
         }
 
         int k = 5;
-        std::vector<faiss::idx_t> nns(k * nq);
+        std::vector<knowherefaiss::idx_t> nns(k * nq);
         std::vector<int> dis(k * nq);
 
         index.search(nq, queries.data(), k, dis.data(), nns.data());
 
         for (size_t i = 0; i < nq; ++i) {
-            faiss::HammingComputer8 hc(queries.data() + i * (d / 8), d / 8);
+            knowherefaiss::HammingComputer8 hc(queries.data() + i * (d / 8), d / 8);
             hamdis_t dist_min = hc.compute(database.data());
             for (size_t j = 1; j < nb; ++j) {
                 hamdis_t dist = hc.compute(database.data() + j * (d / 8));
diff --git a/thirdparty/faiss/tests/test_callback.cpp b/thirdparty/faiss/tests/test_callback.cpp
index cdfadf1d..041148c9 100644
--- a/thirdparty/faiss/tests/test_callback.cpp
+++ b/thirdparty/faiss/tests/test_callback.cpp
@@ -7,11 +7,11 @@
 
 #include <gtest/gtest.h>
 
-#include <faiss/Clustering.h>
-#include <faiss/IndexFlat.h>
-#include <faiss/impl/AuxIndexStructures.h>
-#include <faiss/impl/FaissException.h>
-#include <faiss/utils/random.h>
+#include <knowherefaiss/Clustering.h>
+#include <knowherefaiss/IndexFlat.h>
+#include <knowherefaiss/impl/AuxIndexStructures.h>
+#include <knowherefaiss/impl/FaissException.h>
+#include <knowherefaiss/utils/random.h>
 
 TEST(TestCallback, timeout) {
     int n = 1000;
@@ -21,17 +21,17 @@ TEST(TestCallback, timeout) {
     int seed = 42;
 
     std::vector<float> vecs(n * d);
-    faiss::float_rand(vecs.data(), vecs.size(), seed);
+    knowherefaiss::float_rand(vecs.data(), vecs.size(), seed);
 
-    auto index(new faiss::IndexFlat(d));
+    auto index(new knowherefaiss::IndexFlat(d));
 
-    faiss::ClusteringParameters cp;
+    knowherefaiss::ClusteringParameters cp;
     cp.niter = niter;
     cp.verbose = false;
 
-    faiss::Clustering kmeans(d, k, cp);
+    knowherefaiss::Clustering kmeans(d, k, cp);
 
-    faiss::TimeoutCallback::reset(0.010);
-    EXPECT_THROW(kmeans.train(n, vecs.data(), *index), faiss::FaissException);
+    knowherefaiss::TimeoutCallback::reset(0.010);
+    EXPECT_THROW(kmeans.train(n, vecs.data(), *index), knowherefaiss::FaissException);
     delete index;
 }
diff --git a/thirdparty/faiss/tests/test_code_distance.cpp b/thirdparty/faiss/tests/test_code_distance.cpp
index 4a2021a7..937eb703 100644
--- a/thirdparty/faiss/tests/test_code_distance.cpp
+++ b/thirdparty/faiss/tests/test_code_distance.cpp
@@ -19,9 +19,9 @@
 #include <tuple>
 #include <vector>
 
-#include <faiss/impl/FaissAssert.h>
-#include <faiss/impl/ProductQuantizer.h>
-#include <faiss/impl/code_distance/code_distance.h>
+#include <knowherefaiss/impl/FaissAssert.h>
+#include <knowherefaiss/impl/ProductQuantizer.h>
+#include <knowherefaiss/impl/code_distance/code_distance.h>
 
 size_t nMismatches(
         const std::vector<float>& ref,
@@ -81,7 +81,7 @@ void test(
 #pragma omp parallel for schedule(guided)
         for (size_t i = 0; i < n; i++) {
             resultsRef[i] =
-                    faiss::distance_single_code_generic<faiss::PQDecoder8>(
+                    knowherefaiss::distance_single_code_generic<knowherefaiss::PQDecoder8>(
                             subq, 8, lookup.data(), codes.data() + subq * i);
         }
     }
@@ -95,7 +95,7 @@ void test(
 #pragma omp parallel for schedule(guided)
             for (size_t i = 0; i < n; i++) {
                 resultsNewGeneric1x[i] =
-                        faiss::distance_single_code_generic<faiss::PQDecoder8>(
+                        knowherefaiss::distance_single_code_generic<knowherefaiss::PQDecoder8>(
                                 subq,
                                 8,
                                 lookup.data(),
@@ -117,7 +117,7 @@ void test(
         for (size_t k = 0; k < 1000; k++) {
 #pragma omp parallel for schedule(guided)
             for (size_t i = 0; i < n; i += 4) {
-                faiss::distance_four_codes_generic<faiss::PQDecoder8>(
+                knowherefaiss::distance_four_codes_generic<knowherefaiss::PQDecoder8>(
                         subq,
                         8,
                         lookup.data(),
@@ -148,7 +148,7 @@ void test(
 #pragma omp parallel for schedule(guided)
             for (size_t i = 0; i < n; i++) {
                 resultsNewCustom1x[i] =
-                        faiss::distance_single_code<faiss::PQDecoder8>(
+                        knowherefaiss::distance_single_code<knowherefaiss::PQDecoder8>(
                                 subq,
                                 8,
                                 lookup.data(),
@@ -170,7 +170,7 @@ void test(
         for (size_t k = 0; k < 1000; k++) {
 #pragma omp parallel for schedule(guided)
             for (size_t i = 0; i < n; i += 4) {
-                faiss::distance_four_codes<faiss::PQDecoder8>(
+                knowherefaiss::distance_four_codes<knowherefaiss::PQDecoder8>(
                         subq,
                         8,
                         lookup.data(),
diff --git a/thirdparty/faiss/tests/test_common_ivf_empty_index.cpp b/thirdparty/faiss/tests/test_common_ivf_empty_index.cpp
index a3e33031..eca0bc72 100644
--- a/thirdparty/faiss/tests/test_common_ivf_empty_index.cpp
+++ b/thirdparty/faiss/tests/test_common_ivf_empty_index.cpp
@@ -7,12 +7,12 @@
 #include <memory>
 #include <vector>
 
-#include <faiss/IndexIVF.h>
-#include <faiss/clone_index.h>
-#include <faiss/impl/FaissAssert.h>
-#include <faiss/index_factory.h>
-#include <faiss/invlists/InvertedLists.h>
-#include <faiss/utils/random.h>
+#include <knowherefaiss/IndexIVF.h>
+#include <knowherefaiss/clone_index.h>
+#include <knowherefaiss/impl/FaissAssert.h>
+#include <knowherefaiss/index_factory.h>
+#include <knowherefaiss/invlists/InvertedLists.h>
+#include <knowherefaiss/utils/random.h>
 
 /* This demonstrates how to query several independent IVF indexes with a trained
  *index in common. This avoids to duplicate the coarse quantizer and metadata
@@ -27,7 +27,7 @@ int d = 64;
 
 std::vector<float> get_random_vectors(size_t n, int seed) {
     std::vector<float> x(n * d);
-    faiss::rand_smooth_vectors(n, d, x.data(), seed);
+    knowherefaiss::rand_smooth_vectors(n, d, x.data(), seed);
     seed++;
     return x;
 }
@@ -35,22 +35,22 @@ std::vector<float> get_random_vectors(size_t n, int seed) {
 /** InvetedLists implementation that dispatches the search to an InvertedList
  * object that is passed in at query time */
 
-struct DispatchingInvertedLists : faiss::ReadOnlyInvertedLists {
+struct DispatchingInvertedLists : knowherefaiss::ReadOnlyInvertedLists {
     DispatchingInvertedLists(size_t nlist, size_t code_size)
-            : faiss::ReadOnlyInvertedLists(nlist, code_size) {
+            : knowherefaiss::ReadOnlyInvertedLists(nlist, code_size) {
         use_iterator = true;
     }
 
-    faiss::InvertedListsIterator* get_iterator(
+    knowherefaiss::InvertedListsIterator* get_iterator(
             size_t list_no,
             void* inverted_list_context = nullptr) const override {
         assert(inverted_list_context);
         auto il =
-                static_cast<const faiss::InvertedLists*>(inverted_list_context);
+                static_cast<const knowherefaiss::InvertedLists*>(inverted_list_context);
         return il->get_iterator(list_no);
     }
 
-    using idx_t = faiss::idx_t;
+    using idx_t = knowherefaiss::idx_t;
 
     size_t list_size(size_t list_no) const override {
         FAISS_THROW_MSG("use iterator interface");
@@ -72,38 +72,38 @@ TEST(COMMON, test_common_trained_index) {
 
     // construct and build an "empty index": a trained index that does not
     // itself hold any data
-    std::unique_ptr<faiss::IndexIVF> empty_index(dynamic_cast<faiss::IndexIVF*>(
-            faiss::index_factory(d, "IVF32,PQ8np")));
+    std::unique_ptr<knowherefaiss::IndexIVF> empty_index(dynamic_cast<knowherefaiss::IndexIVF*>(
+            knowherefaiss::index_factory(d, "IVF32,PQ8np")));
     auto xt = get_random_vectors(nt, 123);
     empty_index->train(nt, xt.data());
     empty_index->nprobe = 4;
 
     // reference run: build one index for each set of db / queries and record
     // results
-    std::vector<std::vector<faiss::idx_t>> ref_I(N);
+    std::vector<std::vector<knowherefaiss::idx_t>> ref_I(N);
 
     for (int i = 0; i < N; i++) {
         // clone the empty index
-        std::unique_ptr<faiss::Index> index(
-                faiss::clone_index(empty_index.get()));
+        std::unique_ptr<knowherefaiss::Index> index(
+                knowherefaiss::clone_index(empty_index.get()));
         auto xb = get_random_vectors(nb, 1234 + i);
         auto xq = get_random_vectors(nq, 12345 + i);
         // add vectors and perform a search
         index->add(nb, xb.data());
         std::vector<float> D(k * nq);
-        std::vector<faiss::idx_t> I(k * nq);
+        std::vector<knowherefaiss::idx_t> I(k * nq);
         index->search(nq, xq.data(), k, D.data(), I.data());
         // record result as reference
         ref_I[i] = I;
     }
 
     // build a set of inverted lists for each independent index
-    std::vector<faiss::ArrayInvertedLists> sub_invlists;
+    std::vector<knowherefaiss::ArrayInvertedLists> sub_invlists;
 
     for (int i = 0; i < N; i++) {
         // swap in other inverted lists
         sub_invlists.emplace_back(empty_index->nlist, empty_index->code_size);
-        faiss::InvertedLists* invlists = &sub_invlists.back();
+        knowherefaiss::InvertedLists* invlists = &sub_invlists.back();
 
         // replace_invlists swaps in a new InvertedLists for an existing index
         empty_index->replace_invlists(invlists, false);
@@ -119,17 +119,17 @@ TEST(COMMON, test_common_trained_index) {
     DispatchingInvertedLists di(empty_index->nlist, empty_index->code_size);
     empty_index->replace_invlists(&di, false);
 
-    std::vector<std::vector<faiss::idx_t>> new_I(N);
+    std::vector<std::vector<knowherefaiss::idx_t>> new_I(N);
 
     // run searches in the independent indexes but with a common empty_index
 #pragma omp parallel for
     for (int i = 0; i < N; i++) {
         auto xq = get_random_vectors(nq, 12345 + i);
         std::vector<float> D(k * nq);
-        std::vector<faiss::idx_t> I(k * nq);
+        std::vector<knowherefaiss::idx_t> I(k * nq);
 
         // here we set to what sub-index the queries should be directed
-        faiss::SearchParametersIVF params;
+        knowherefaiss::SearchParametersIVF params;
         params.nprobe = empty_index->nprobe;
         params.inverted_list_context = &sub_invlists[i];
 
diff --git a/thirdparty/faiss/tests/test_cppcontrib_sa_decode.cpp b/thirdparty/faiss/tests/test_cppcontrib_sa_decode.cpp
index cb13e8bf..ee039ccd 100644
--- a/thirdparty/faiss/tests/test_cppcontrib_sa_decode.cpp
+++ b/thirdparty/faiss/tests/test_cppcontrib_sa_decode.cpp
@@ -12,29 +12,29 @@
 #include <tuple>
 #include <vector>
 
-#include <faiss/Index.h>
-#include <faiss/Index2Layer.h>
-#include <faiss/IndexIVFPQ.h>
-#include <faiss/IndexPQ.h>
-#include <faiss/impl/io.h>
-#include <faiss/index_factory.h>
-#include <faiss/index_io.h>
+#include <knowherefaiss/Index.h>
+#include <knowherefaiss/Index2Layer.h>
+#include <knowherefaiss/IndexIVFPQ.h>
+#include <knowherefaiss/IndexPQ.h>
+#include <knowherefaiss/impl/io.h>
+#include <knowherefaiss/index_factory.h>
+#include <knowherefaiss/index_io.h>
 
-#include <faiss/IndexRowwiseMinMax.h>
-#include <faiss/cppcontrib/SaDecodeKernels.h>
+#include <knowherefaiss/IndexRowwiseMinMax.h>
+#include <knowherefaiss/cppcontrib/SaDecodeKernels.h>
 
 using namespace ::testing;
 using ::testing::TestWithParam;
 using ::testing::Values;
 
-std::tuple<std::shared_ptr<faiss::Index>, std::vector<uint8_t>> trainDataset(
+std::tuple<std::shared_ptr<knowherefaiss::Index>, std::vector<uint8_t>> trainDataset(
         const std::vector<float>& input,
         const uint64_t n,
         const uint64_t d,
         const std::string& description) {
     // train an index
-    auto index = std::shared_ptr<faiss::Index>(
-            faiss::index_factory((int)d, description.c_str()));
+    auto index = std::shared_ptr<knowherefaiss::Index>(
+            knowherefaiss::index_factory((int)d, description.c_str()));
     index->train((int)n, input.data());
 
     // encode
@@ -47,21 +47,21 @@ std::tuple<std::shared_ptr<faiss::Index>, std::vector<uint8_t>> trainDataset(
 }
 
 bool testIfIVFPQ(
-        const faiss::Index* const index,
+        const knowherefaiss::Index* const index,
         const float** pqCoarseCentroidsQ,
         const float** pqFineCentroidsQ) {
     if (pqFineCentroidsQ == nullptr || pqCoarseCentroidsQ == nullptr) {
         return false;
     }
 
-    const faiss::IndexIVFPQ* const indexQ =
-            dynamic_cast<const faiss::IndexIVFPQ*>(index);
+    const knowherefaiss::IndexIVFPQ* const indexQ =
+            dynamic_cast<const knowherefaiss::IndexIVFPQ*>(index);
     if (indexQ == nullptr) {
         return false;
     }
 
     const auto coarseIndexQ =
-            dynamic_cast<const faiss::IndexFlatCodes*>(indexQ->quantizer);
+            dynamic_cast<const knowherefaiss::IndexFlatCodes*>(indexQ->quantizer);
     if (coarseIndexQ == nullptr) {
         return false;
     }
@@ -73,20 +73,20 @@ bool testIfIVFPQ(
 }
 
 bool testIfResidualPQ(
-        const faiss::Index* const index,
+        const knowherefaiss::Index* const index,
         const float** pqCoarseCentroidsQ,
         const float** pqFineCentroidsQ) {
     if (pqFineCentroidsQ == nullptr || pqCoarseCentroidsQ == nullptr) {
         return false;
     }
 
-    const faiss::Index2Layer* const indexQ =
-            dynamic_cast<const faiss::Index2Layer*>(index);
+    const knowherefaiss::Index2Layer* const indexQ =
+            dynamic_cast<const knowherefaiss::Index2Layer*>(index);
     if (indexQ == nullptr) {
         return false;
     }
 
-    const auto coarseIndexQ = dynamic_cast<const faiss::MultiIndexQuantizer*>(
+    const auto coarseIndexQ = dynamic_cast<const knowherefaiss::MultiIndexQuantizer*>(
             indexQ->q1.quantizer);
     if (coarseIndexQ == nullptr) {
         return false;
@@ -101,7 +101,7 @@ template <typename T>
 void verifyIndex2LevelDecoder(
         const uint64_t n,
         const uint64_t d,
-        const std::shared_ptr<faiss::Index>& index,
+        const std::shared_ptr<knowherefaiss::Index>& index,
         const std::vector<uint8_t>& encodedData) {
     //
     const float* pqFineCentroidsQ = nullptr;
@@ -123,7 +123,7 @@ void verifyIndex2LevelDecoder(
     std::vector<float> tmpFaiss(d, 0);
     std::vector<float> tmpContrib(d, 0);
     for (size_t i = 0; i < n; i++) {
-        // compute using faiss
+        // compute using knowherefaiss
         index->sa_decode(1, encodedData.data() + i * codeSize, tmpFaiss.data());
 
         // compute using contrib
@@ -300,15 +300,15 @@ template <typename T>
 void verifyMinMaxIndex2LevelDecoder(
         const uint64_t n,
         const uint64_t d,
-        const std::shared_ptr<faiss::Index>& index,
+        const std::shared_ptr<knowherefaiss::Index>& index,
         const std::vector<uint8_t>& encodedData) {
     //
     const float* pqFineCentroidsQ = nullptr;
     const float* pqCoarseCentroidsQ = nullptr;
 
     // extract an index that is wrapped with IndexRowwiseMinMaxBase
-    const std::shared_ptr<faiss::IndexRowwiseMinMaxBase> indexMinMax =
-            std::dynamic_pointer_cast<faiss::IndexRowwiseMinMaxBase>(index);
+    const std::shared_ptr<knowherefaiss::IndexRowwiseMinMaxBase> indexMinMax =
+            std::dynamic_pointer_cast<knowherefaiss::IndexRowwiseMinMaxBase>(index);
     ASSERT_NE(indexMinMax.get(), nullptr);
 
     auto subIndex = indexMinMax->index;
@@ -329,7 +329,7 @@ void verifyMinMaxIndex2LevelDecoder(
     std::vector<float> tmpFaiss(d, 0);
     std::vector<float> tmpContrib(d, 0);
     for (size_t i = 0; i < n; i++) {
-        // compute using faiss
+        // compute using knowherefaiss
         index->sa_decode(1, encodedData.data() + i * codeSize, tmpFaiss.data());
 
         // compute using contrib
@@ -358,7 +358,7 @@ void verifyMinMaxIndex2LevelDecoder(
     std::vector<float> outputContrib1s(d, 0);
     float outputMinv1s = 0;
     for (size_t i = 0; i < n; i++) {
-        // compute using faiss
+        // compute using knowherefaiss
         index->sa_decode(1, encodedData.data() + i * codeSize, tmpFaiss.data());
 
         // populate some initial data
@@ -551,11 +551,11 @@ template <typename T>
 void verifyIndexPQDecoder(
         const uint64_t n,
         const uint64_t d,
-        const std::shared_ptr<faiss::Index>& index,
+        const std::shared_ptr<knowherefaiss::Index>& index,
         const std::vector<uint8_t>& encodedData) {
     //
-    const faiss::IndexPQ* const indexQ =
-            dynamic_cast<const faiss::IndexPQ*>(index.get());
+    const knowherefaiss::IndexPQ* const indexQ =
+            dynamic_cast<const knowherefaiss::IndexPQ*>(index.get());
     const float* const pqFineCentroidsQ = indexQ->pq.centroids.data();
 
     //
@@ -570,7 +570,7 @@ void verifyIndexPQDecoder(
     std::vector<float> tmpFaiss(d, 0);
     std::vector<float> tmpContrib(d, 0);
     for (size_t i = 0; i < n; i++) {
-        // compute using faiss
+        // compute using knowherefaiss
         index->sa_decode(1, encodedData.data() + i * codeSize, tmpFaiss.data());
 
         // compute using contrib
@@ -733,18 +733,18 @@ template <typename T>
 void verifyMinMaxIndexPQDecoder(
         const uint64_t n,
         const uint64_t d,
-        const std::shared_ptr<faiss::Index>& index,
+        const std::shared_ptr<knowherefaiss::Index>& index,
         const std::vector<uint8_t>& encodedData) {
     // extract an index that is wrapped with IndexRowwiseMinMaxBase
-    const std::shared_ptr<faiss::IndexRowwiseMinMaxBase> indexMinMax =
-            std::dynamic_pointer_cast<faiss::IndexRowwiseMinMaxBase>(index);
+    const std::shared_ptr<knowherefaiss::IndexRowwiseMinMaxBase> indexMinMax =
+            std::dynamic_pointer_cast<knowherefaiss::IndexRowwiseMinMaxBase>(index);
     ASSERT_NE(indexMinMax.get(), nullptr);
 
     auto subIndex = indexMinMax->index;
 
     //
-    const faiss::IndexPQ* const indexQ =
-            dynamic_cast<const faiss::IndexPQ*>(subIndex);
+    const knowherefaiss::IndexPQ* const indexQ =
+            dynamic_cast<const knowherefaiss::IndexPQ*>(subIndex);
     const float* const pqFineCentroidsQ = indexQ->pq.centroids.data();
 
     //
@@ -759,7 +759,7 @@ void verifyMinMaxIndexPQDecoder(
     std::vector<float> tmpFaiss(d, 0);
     std::vector<float> tmpContrib(d, 0);
     for (size_t i = 0; i < n; i++) {
-        // compute using faiss
+        // compute using knowherefaiss
         index->sa_decode(1, encodedData.data() + i * codeSize, tmpFaiss.data());
 
         // compute using contrib
@@ -787,7 +787,7 @@ void verifyMinMaxIndexPQDecoder(
     std::vector<float> outputContrib1s(d, 0);
     float outputMinv1s = 0;
     for (size_t i = 0; i < n; i++) {
-        // compute using faiss
+        // compute using knowherefaiss
         index->sa_decode(1, encodedData.data() + i * codeSize, tmpFaiss.data());
 
         // populate some initial data
@@ -985,7 +985,7 @@ void testIndex2LevelDecoder(
         const uint64_t d,
         const std::string& description) {
     auto data = generate(n, d);
-    std::shared_ptr<faiss::Index> index;
+    std::shared_ptr<knowherefaiss::Index> index;
     std::vector<uint8_t> encodedData;
     std::tie(index, encodedData) = trainDataset(data, n, d, description);
 
@@ -998,7 +998,7 @@ void testMinMaxIndex2LevelDecoder(
         const uint64_t d,
         const std::string& description) {
     auto data = generate(n, d);
-    std::shared_ptr<faiss::Index> index;
+    std::shared_ptr<knowherefaiss::Index> index;
     std::vector<uint8_t> encodedData;
     std::tie(index, encodedData) = trainDataset(data, n, d, description);
 
@@ -1011,7 +1011,7 @@ void testIndexPQDecoder(
         const uint64_t d,
         const std::string& description) {
     auto data = generate(n, d);
-    std::shared_ptr<faiss::Index> index;
+    std::shared_ptr<knowherefaiss::Index> index;
     std::vector<uint8_t> encodedData;
     std::tie(index, encodedData) = trainDataset(data, n, d, description);
 
@@ -1024,7 +1024,7 @@ void testMinMaxIndexPQDecoder(
         const uint64_t d,
         const std::string& description) {
     auto data = generate(n, d);
-    std::shared_ptr<faiss::Index> index;
+    std::shared_ptr<knowherefaiss::Index> index;
     std::vector<uint8_t> encodedData;
     std::tie(index, encodedData) = trainDataset(data, n, d, description);
 
@@ -1035,134 +1035,134 @@ constexpr size_t NSAMPLES = 256;
 
 //
 TEST(testCppcontribSaDecode, D256_IVF256_PQ16) {
-    using T = faiss::cppcontrib::Index2LevelDecoder<256, 256, 16>;
+    using T = knowherefaiss::cppcontrib::Index2LevelDecoder<256, 256, 16>;
     testIndex2LevelDecoder<T>(NSAMPLES, 256, "IVF256,PQ16np");
 }
 
 TEST(testCppcontribSaDecode, D256_IVF256_PQ8) {
-    using T = faiss::cppcontrib::Index2LevelDecoder<256, 256, 32>;
+    using T = knowherefaiss::cppcontrib::Index2LevelDecoder<256, 256, 32>;
     testIndex2LevelDecoder<T>(NSAMPLES, 256, "IVF256,PQ8np");
 }
 
 //
 TEST(testCppcontribSaDecode, D192_IVF256_PQ24) {
-    using T = faiss::cppcontrib::Index2LevelDecoder<192, 192, 8>;
+    using T = knowherefaiss::cppcontrib::Index2LevelDecoder<192, 192, 8>;
     testIndex2LevelDecoder<T>(NSAMPLES, 192, "IVF256,PQ24np");
 }
 
 //
 TEST(testCppcontribSaDecode, D192_IVF256_PQ16) {
-    using T = faiss::cppcontrib::Index2LevelDecoder<192, 192, 12>;
+    using T = knowherefaiss::cppcontrib::Index2LevelDecoder<192, 192, 12>;
     testIndex2LevelDecoder<T>(NSAMPLES, 192, "IVF256,PQ16np");
 }
 
 //
 TEST(testCppcontribSaDecode, D192_IVF256_PQ12) {
-    using T = faiss::cppcontrib::Index2LevelDecoder<192, 192, 16>;
+    using T = knowherefaiss::cppcontrib::Index2LevelDecoder<192, 192, 16>;
     testIndex2LevelDecoder<T>(NSAMPLES, 192, "IVF256,PQ12np");
 }
 
 //
 TEST(testCppcontribSaDecode, D160_IVF256_PQ40) {
-    using T = faiss::cppcontrib::Index2LevelDecoder<160, 160, 4>;
+    using T = knowherefaiss::cppcontrib::Index2LevelDecoder<160, 160, 4>;
     testIndex2LevelDecoder<T>(NSAMPLES, 160, "IVF256,PQ40np");
 }
 
 //
 TEST(testCppcontribSaDecode, D160_IVF256_PQ20) {
-    using T = faiss::cppcontrib::Index2LevelDecoder<160, 160, 8>;
+    using T = knowherefaiss::cppcontrib::Index2LevelDecoder<160, 160, 8>;
     testIndex2LevelDecoder<T>(NSAMPLES, 160, "IVF256,PQ20np");
 }
 
 //
 TEST(testCppcontribSaDecode, D160_IVF256_PQ10) {
-    using T = faiss::cppcontrib::Index2LevelDecoder<160, 160, 16>;
+    using T = knowherefaiss::cppcontrib::Index2LevelDecoder<160, 160, 16>;
     testIndex2LevelDecoder<T>(NSAMPLES, 160, "IVF256,PQ10np");
 }
 
 //
 TEST(testCppcontribSaDecode, D160_IVF256_PQ8) {
-    using T = faiss::cppcontrib::Index2LevelDecoder<160, 160, 20>;
+    using T = knowherefaiss::cppcontrib::Index2LevelDecoder<160, 160, 20>;
     testIndex2LevelDecoder<T>(NSAMPLES, 160, "IVF256,PQ8np");
 }
 
 //
 TEST(testCppcontribSaDecode, D128_IVF256_PQ8) {
-    using T = faiss::cppcontrib::Index2LevelDecoder<128, 128, 16>;
+    using T = knowherefaiss::cppcontrib::Index2LevelDecoder<128, 128, 16>;
     testIndex2LevelDecoder<T>(NSAMPLES, 128, "IVF256,PQ8np");
 }
 
 TEST(testCppcontribSaDecode, D128_IVF256_PQ4) {
-    using T = faiss::cppcontrib::Index2LevelDecoder<128, 128, 32>;
+    using T = knowherefaiss::cppcontrib::Index2LevelDecoder<128, 128, 32>;
     testIndex2LevelDecoder<T>(NSAMPLES, 128, "IVF256,PQ4np");
 }
 
 //
 TEST(testCppcontribSaDecode, D64_IVF256_PQ16) {
-    using T = faiss::cppcontrib::Index2LevelDecoder<64, 64, 8>;
+    using T = knowherefaiss::cppcontrib::Index2LevelDecoder<64, 64, 8>;
     testIndex2LevelDecoder<T>(NSAMPLES, 64, "IVF256,PQ8np");
 }
 
 TEST(testCppcontribSaDecode, D64_IVF256_PQ8) {
-    using T = faiss::cppcontrib::Index2LevelDecoder<64, 64, 16>;
+    using T = knowherefaiss::cppcontrib::Index2LevelDecoder<64, 64, 16>;
     testIndex2LevelDecoder<T>(NSAMPLES, 64, "IVF256,PQ4np");
 }
 
 #if defined(__AVX2__)
 TEST(testCppcontribSaDecode, D40_IVF256_PQ20) {
-    using T = faiss::cppcontrib::Index2LevelDecoder<40, 40, 2>;
+    using T = knowherefaiss::cppcontrib::Index2LevelDecoder<40, 40, 2>;
     testIndex2LevelDecoder<T>(NSAMPLES, 40, "IVF256,PQ20np");
 }
 #endif
 
 //
 TEST(testCppcontribSaDecode, D256_Residual4x8_PQ16) {
-    using T = faiss::cppcontrib::Index2LevelDecoder<256, 64, 16>;
+    using T = knowherefaiss::cppcontrib::Index2LevelDecoder<256, 64, 16>;
     testIndex2LevelDecoder<T>(NSAMPLES, 256, "Residual4x8,PQ16");
 }
 
 TEST(testCppcontribSaDecode, D256_Residual4x8_PQ8) {
-    using T = faiss::cppcontrib::Index2LevelDecoder<256, 64, 32>;
+    using T = knowherefaiss::cppcontrib::Index2LevelDecoder<256, 64, 32>;
     testIndex2LevelDecoder<T>(NSAMPLES, 256, "Residual4x8,PQ8");
 }
 
 //
 TEST(testCppcontribSaDecode, D160_Residual4x8_PQ10) {
-    using T = faiss::cppcontrib::Index2LevelDecoder<160, 40, 16>;
+    using T = knowherefaiss::cppcontrib::Index2LevelDecoder<160, 40, 16>;
     testIndex2LevelDecoder<T>(NSAMPLES, 160, "Residual4x8,PQ10");
 }
 
 //
 TEST(testCppcontribSaDecode, D160_Residual2x8_PQ10) {
-    using T = faiss::cppcontrib::Index2LevelDecoder<160, 80, 16>;
+    using T = knowherefaiss::cppcontrib::Index2LevelDecoder<160, 80, 16>;
     testIndex2LevelDecoder<T>(NSAMPLES, 160, "Residual2x8,PQ10");
 }
 
 //
 TEST(testCppcontribSaDecode, D160_Residual1x8_PQ10) {
-    using T = faiss::cppcontrib::Index2LevelDecoder<160, 160, 16>;
+    using T = knowherefaiss::cppcontrib::Index2LevelDecoder<160, 160, 16>;
     testIndex2LevelDecoder<T>(NSAMPLES, 160, "Residual1x8,PQ10");
 }
 
 //
 TEST(testCppcontribSaDecode, D128_Residual4x8_PQ8) {
-    using T = faiss::cppcontrib::Index2LevelDecoder<128, 32, 16>;
+    using T = knowherefaiss::cppcontrib::Index2LevelDecoder<128, 32, 16>;
     testIndex2LevelDecoder<T>(NSAMPLES, 128, "Residual4x8,PQ8");
 }
 
 TEST(testCppcontribSaDecode, D128_Residual4x8_PQ4) {
-    using T = faiss::cppcontrib::Index2LevelDecoder<128, 32, 32>;
+    using T = knowherefaiss::cppcontrib::Index2LevelDecoder<128, 32, 32>;
     testIndex2LevelDecoder<T>(NSAMPLES, 128, "Residual4x8,PQ4");
 }
 
 //
 TEST(testCppcontribSaDecode, D64_Residual4x8_PQ8) {
-    using T = faiss::cppcontrib::Index2LevelDecoder<64, 16, 8>;
+    using T = knowherefaiss::cppcontrib::Index2LevelDecoder<64, 16, 8>;
     testIndex2LevelDecoder<T>(NSAMPLES, 64, "Residual4x8,PQ8");
 }
 
 TEST(testCppcontribSaDecode, D64_Residual4x8_PQ4) {
-    using T = faiss::cppcontrib::Index2LevelDecoder<64, 16, 16>;
+    using T = knowherefaiss::cppcontrib::Index2LevelDecoder<64, 16, 16>;
     testIndex2LevelDecoder<T>(NSAMPLES, 64, "Residual4x8,PQ4");
 }
 
@@ -1170,7 +1170,7 @@ TEST(testCppcontribSaDecode, D64_Residual4x8_PQ4) {
 TEST(testCppcontribSaDecode, D256_IVF1024_PQ16) {
     // It is acceptable to use COARSE_BITS=16 in this case,
     // because there's only one coarse quantizer element.
-    using T = faiss::cppcontrib::Index2LevelDecoder<256, 256, 16, 16>;
+    using T = knowherefaiss::cppcontrib::Index2LevelDecoder<256, 256, 16, 16>;
     testIndex2LevelDecoder<T>(NSAMPLES * 4, 256, "IVF1024,PQ16np");
 }
 
@@ -1178,110 +1178,110 @@ TEST(testCppcontribSaDecode, D64_Residual1x9_PQ8) {
     // It is acceptable to use COARSE_BITS=16 in this case,
     // because there's only one coarse quantizer element.
     // It won't work for "Residual2x9,PQ8".
-    using T = faiss::cppcontrib::Index2LevelDecoder<64, 64, 8, 16>;
+    using T = knowherefaiss::cppcontrib::Index2LevelDecoder<64, 64, 8, 16>;
     testIndex2LevelDecoder<T>(NSAMPLES * 2, 64, "Residual1x9,PQ8");
 }
 
 //
 TEST(testCppcontribSaDecode, D256_PQ16) {
-    using T = faiss::cppcontrib::IndexPQDecoder<256, 16>;
+    using T = knowherefaiss::cppcontrib::IndexPQDecoder<256, 16>;
     testIndexPQDecoder<T>(NSAMPLES, 256, "PQ16np");
 }
 
 //
 TEST(testCppcontribSaDecode, D160_PQ20) {
-    using T = faiss::cppcontrib::IndexPQDecoder<160, 8>;
+    using T = knowherefaiss::cppcontrib::IndexPQDecoder<160, 8>;
     testIndexPQDecoder<T>(NSAMPLES, 160, "PQ20np");
 }
 
 #if defined(__AVX2__)
 TEST(testCppcontribSaDecode, D40_PQ20) {
-    using T = faiss::cppcontrib::IndexPQDecoder<40, 2>;
+    using T = knowherefaiss::cppcontrib::IndexPQDecoder<40, 2>;
     testIndexPQDecoder<T>(NSAMPLES, 40, "PQ20np");
 }
 #endif
 
 // test IndexRowwiseMinMaxFP16
 TEST(testCppcontribSaDecode, D256_MINMAXFP16_IVF256_PQ16) {
-    using SubT = faiss::cppcontrib::Index2LevelDecoder<256, 256, 16>;
-    using T = faiss::cppcontrib::IndexMinMaxFP16Decoder<SubT>;
+    using SubT = knowherefaiss::cppcontrib::Index2LevelDecoder<256, 256, 16>;
+    using T = knowherefaiss::cppcontrib::IndexMinMaxFP16Decoder<SubT>;
     testMinMaxIndex2LevelDecoder<T>(NSAMPLES, 256, "MinMaxFP16,IVF256,PQ16np");
 }
 
 TEST(testCppcontribSaDecode, D256_MINMAXFP16_PQ16) {
-    using SubT = faiss::cppcontrib::IndexPQDecoder<256, 16>;
-    using T = faiss::cppcontrib::IndexMinMaxFP16Decoder<SubT>;
+    using SubT = knowherefaiss::cppcontrib::IndexPQDecoder<256, 16>;
+    using T = knowherefaiss::cppcontrib::IndexMinMaxFP16Decoder<SubT>;
     testMinMaxIndexPQDecoder<T>(NSAMPLES, 256, "MinMaxFP16,PQ16np");
 }
 
 // test IndexRowwiseMinMax
 TEST(testCppcontribSaDecode, D256_MINMAX_IVF256_PQ16) {
-    using SubT = faiss::cppcontrib::Index2LevelDecoder<256, 256, 16>;
-    using T = faiss::cppcontrib::IndexMinMaxDecoder<SubT>;
+    using SubT = knowherefaiss::cppcontrib::Index2LevelDecoder<256, 256, 16>;
+    using T = knowherefaiss::cppcontrib::IndexMinMaxDecoder<SubT>;
     testMinMaxIndex2LevelDecoder<T>(NSAMPLES, 256, "MinMax,IVF256,PQ16np");
 }
 
 TEST(testCppcontribSaDecode, D256_MINMAX_PQ16) {
-    using SubT = faiss::cppcontrib::IndexPQDecoder<256, 16>;
-    using T = faiss::cppcontrib::IndexMinMaxDecoder<SubT>;
+    using SubT = knowherefaiss::cppcontrib::IndexPQDecoder<256, 16>;
+    using T = knowherefaiss::cppcontrib::IndexMinMaxDecoder<SubT>;
     testMinMaxIndexPQDecoder<T>(NSAMPLES, 256, "MinMax,PQ16np");
 }
 
 // implemented for AVX2 and ARM so far
 #if defined(__AVX2__) || defined(__ARM_NEON)
 TEST(testCppcontribSaDecode, D256_PQ16x10) {
-    using T = faiss::cppcontrib::IndexPQDecoder<256, 16, 10>;
+    using T = knowherefaiss::cppcontrib::IndexPQDecoder<256, 16, 10>;
     testIndexPQDecoder<T>(NSAMPLES * 4, 256, "PQ16x10np");
 }
 
 TEST(testCppcontribSaDecode, D256_PQ16x12) {
-    using T = faiss::cppcontrib::IndexPQDecoder<256, 16, 12>;
+    using T = knowherefaiss::cppcontrib::IndexPQDecoder<256, 16, 12>;
     testIndexPQDecoder<T>(NSAMPLES * 16, 256, "PQ16x12np");
 }
 
 TEST(testCppcontribSaDecode, D160_PQ20x10) {
-    using T = faiss::cppcontrib::IndexPQDecoder<160, 8, 10>;
+    using T = knowherefaiss::cppcontrib::IndexPQDecoder<160, 8, 10>;
     testIndexPQDecoder<T>(NSAMPLES * 4, 160, "PQ20x10np");
 }
 
 TEST(testCppcontribSaDecode, D160_PQ20x12) {
-    using T = faiss::cppcontrib::IndexPQDecoder<160, 8, 12>;
+    using T = knowherefaiss::cppcontrib::IndexPQDecoder<160, 8, 12>;
     testIndexPQDecoder<T>(NSAMPLES * 16, 160, "PQ20x12np");
 }
 
 TEST(testCppcontribSaDecode, D256_IVF256_PQ16x10) {
-    using T = faiss::cppcontrib::Index2LevelDecoder<256, 256, 16, 8, 10>;
+    using T = knowherefaiss::cppcontrib::Index2LevelDecoder<256, 256, 16, 8, 10>;
     testIndex2LevelDecoder<T>(NSAMPLES * 4, 256, "IVF256,PQ16x10np");
 }
 
 TEST(testCppcontribSaDecode, D256_IVF256_PQ16x12) {
-    using T = faiss::cppcontrib::Index2LevelDecoder<256, 256, 16, 8, 12>;
+    using T = knowherefaiss::cppcontrib::Index2LevelDecoder<256, 256, 16, 8, 12>;
     testIndex2LevelDecoder<T>(NSAMPLES * 16, 256, "IVF256,PQ16x12np");
 }
 
 TEST(testCppcontribSaDecode, D256_MINMAXFP16_IVF256_PQ16x10) {
-    using SubT = faiss::cppcontrib::Index2LevelDecoder<256, 256, 16, 8, 10>;
-    using T = faiss::cppcontrib::IndexMinMaxFP16Decoder<SubT>;
+    using SubT = knowherefaiss::cppcontrib::Index2LevelDecoder<256, 256, 16, 8, 10>;
+    using T = knowherefaiss::cppcontrib::IndexMinMaxFP16Decoder<SubT>;
     testMinMaxIndex2LevelDecoder<T>(
             NSAMPLES * 4, 256, "MinMaxFP16,IVF256,PQ16x10np");
 }
 
 TEST(testCppcontribSaDecode, D256_MINMAXFP16_IVF1024_PQ16x10) {
-    using SubT = faiss::cppcontrib::Index2LevelDecoder<256, 256, 16, 10, 10>;
-    using T = faiss::cppcontrib::IndexMinMaxFP16Decoder<SubT>;
+    using SubT = knowherefaiss::cppcontrib::Index2LevelDecoder<256, 256, 16, 10, 10>;
+    using T = knowherefaiss::cppcontrib::IndexMinMaxFP16Decoder<SubT>;
     testMinMaxIndex2LevelDecoder<T>(
             NSAMPLES * 4, 256, "MinMaxFP16,IVF1024,PQ16x10np");
 }
 
 TEST(testCppcontribSaDecode, D256_MINMAXFP16_IVF1024_PQ16x10_ALTERNATIVE) {
-    using SubT = faiss::cppcontrib::Index2LevelDecoder<256, 256, 16, 16, 10>;
-    using T = faiss::cppcontrib::IndexMinMaxFP16Decoder<SubT>;
+    using SubT = knowherefaiss::cppcontrib::Index2LevelDecoder<256, 256, 16, 16, 10>;
+    using T = knowherefaiss::cppcontrib::IndexMinMaxFP16Decoder<SubT>;
     testMinMaxIndex2LevelDecoder<T>(
             NSAMPLES * 4, 256, "MinMaxFP16,IVF1024,PQ16x10np");
 }
 
 TEST(testCppcontribSaDecode, D160_Residual4x8_PQ8x10) {
-    using T = faiss::cppcontrib::Index2LevelDecoder<160, 40, 20, 8, 10>;
+    using T = knowherefaiss::cppcontrib::Index2LevelDecoder<160, 40, 20, 8, 10>;
     testIndex2LevelDecoder<T>(NSAMPLES * 4, 160, "Residual4x8,PQ8x10");
 }
 
@@ -1289,17 +1289,17 @@ TEST(testCppcontribSaDecode, D256_Residual1x9_PQ16x10) {
     // It is acceptable to use COARSE_BITS=16 in this case,
     // because there's only one coarse quantizer element.
     // It won't work for "Residual2x9,PQ16x10".
-    using T = faiss::cppcontrib::Index2LevelDecoder<256, 256, 16, 16, 10>;
+    using T = knowherefaiss::cppcontrib::Index2LevelDecoder<256, 256, 16, 16, 10>;
     testIndex2LevelDecoder<T>(NSAMPLES * 4, 256, "Residual1x9,PQ16x10");
 }
 
 TEST(testCppcontribSaDecode, D256_Residual4x10_PQ16x10) {
-    using T = faiss::cppcontrib::Index2LevelDecoder<256, 64, 16, 10, 10>;
+    using T = knowherefaiss::cppcontrib::Index2LevelDecoder<256, 64, 16, 10, 10>;
     testIndex2LevelDecoder<T>(NSAMPLES * 4, 256, "Residual4x10,PQ16x10");
 }
 
 TEST(testCppcontribSaDecode, D256_Residual4x12_PQ16x12) {
-    using T = faiss::cppcontrib::Index2LevelDecoder<256, 64, 16, 12, 12>;
+    using T = knowherefaiss::cppcontrib::Index2LevelDecoder<256, 64, 16, 12, 12>;
     testIndex2LevelDecoder<T>(NSAMPLES * 16, 256, "Residual4x12,PQ16x12");
 }
 
diff --git a/thirdparty/faiss/tests/test_cppcontrib_uintreader.cpp b/thirdparty/faiss/tests/test_cppcontrib_uintreader.cpp
index b6ecb261..68ccbeba 100644
--- a/thirdparty/faiss/tests/test_cppcontrib_uintreader.cpp
+++ b/thirdparty/faiss/tests/test_cppcontrib_uintreader.cpp
@@ -15,17 +15,17 @@
 #include <memory>
 #include <random>
 
-#include <faiss/utils/hamming.h>
+#include <knowherefaiss/utils/hamming.h>
 
-#include <faiss/cppcontrib/detail/UintReader.h>
+#include <knowherefaiss/cppcontrib/detail/UintReader.h>
 
 template <intptr_t N_ELEMENTS, intptr_t CODE_BITS, intptr_t CPOS>
 struct TestLoop {
     static void test(
             const uint8_t* const container,
-            faiss::BitstringReader& br) {
+            knowherefaiss::BitstringReader& br) {
         // validate
-        const intptr_t uintreader_data = faiss::cppcontrib::detail::
+        const intptr_t uintreader_data = knowherefaiss::cppcontrib::detail::
                 UintReaderRaw<N_ELEMENTS, CODE_BITS, CPOS>::get(container);
         const intptr_t bitstringreader_data = br.read(CODE_BITS);
 
@@ -44,7 +44,7 @@ template <intptr_t N_ELEMENTS, intptr_t CODE_BITS>
 struct TestLoop<N_ELEMENTS, CODE_BITS, N_ELEMENTS> {
     static void test(
             const uint8_t* const container,
-            faiss::BitstringReader& br) {}
+            knowherefaiss::BitstringReader& br) {}
 };
 
 template <intptr_t N_ELEMENTS, intptr_t CODE_BITS>
@@ -64,13 +64,13 @@ void TestUintReader() {
         }
 
         // populate it
-        faiss::BitstringWriter bw(container.get(), CODE_BYTES);
+        knowherefaiss::BitstringWriter bw(container.get(), CODE_BYTES);
         for (size_t i = 0; i < N_ELEMENTS; i++) {
             bw.write(u(rng), CODE_BITS);
         }
 
         // read it back and verify against bitreader
-        faiss::BitstringReader br(container.get(), CODE_BYTES);
+        knowherefaiss::BitstringReader br(container.get(), CODE_BYTES);
 
         TestLoop<N_ELEMENTS, CODE_BITS, 0>::test(container.get(), br);
     }
diff --git a/thirdparty/faiss/tests/test_dealloc_invlists.cpp b/thirdparty/faiss/tests/test_dealloc_invlists.cpp
index fb132087..e7dd74ab 100644
--- a/thirdparty/faiss/tests/test_dealloc_invlists.cpp
+++ b/thirdparty/faiss/tests/test_dealloc_invlists.cpp
@@ -14,13 +14,13 @@
 
 #include <gtest/gtest.h>
 
-#include <faiss/AutoTune.h>
-#include <faiss/IVFlib.h>
-#include <faiss/IndexIVF.h>
-#include <faiss/index_factory.h>
-#include <faiss/index_io.h>
+#include <knowherefaiss/AutoTune.h>
+#include <knowherefaiss/IVFlib.h>
+#include <knowherefaiss/IndexIVF.h>
+#include <knowherefaiss/index_factory.h>
+#include <knowherefaiss/index_io.h>
 
-using namespace faiss;
+using namespace knowherefaiss;
 
 namespace {
 
diff --git a/thirdparty/faiss/tests/test_disable_pq_sdc_tables.cpp b/thirdparty/faiss/tests/test_disable_pq_sdc_tables.cpp
index b211a5c4..011be437 100644
--- a/thirdparty/faiss/tests/test_disable_pq_sdc_tables.cpp
+++ b/thirdparty/faiss/tests/test_disable_pq_sdc_tables.cpp
@@ -9,10 +9,10 @@
 
 #include <random>
 
-#include "faiss/Index.h"
-#include "faiss/IndexHNSW.h"
-#include "faiss/index_factory.h"
-#include "faiss/index_io.h"
+#include "knowherefaiss/Index.h"
+#include "knowherefaiss/IndexHNSW.h"
+#include "knowherefaiss/index_factory.h"
+#include "knowherefaiss/index_io.h"
 #include "test_util.h"
 
 pthread_mutex_t temp_file_mutex = PTHREAD_MUTEX_INITIALIZER;
@@ -29,31 +29,31 @@ TEST(IO, TestReadHNSWPQ_whenSDCDisabledFlagPassed_thenDisableSDCTable) {
 
     // Build the index and write it to the temp file
     {
-        std::unique_ptr<faiss::Index> index_writer(
-                faiss::index_factory(d, "HNSW8,PQ4np", faiss::METRIC_L2));
+        std::unique_ptr<knowherefaiss::Index> index_writer(
+                knowherefaiss::index_factory(d, "HNSW8,PQ4np", knowherefaiss::METRIC_L2));
         index_writer->train(n, vectors.data());
         index_writer->add(n, vectors.data());
 
-        faiss::write_index(index_writer.get(), index_filename.c_str());
+        knowherefaiss::write_index(index_writer.get(), index_filename.c_str());
     }
 
     // Load index from disk. Confirm that the sdc table is equal to 0 when
     // disable sdc is set
     {
-        std::unique_ptr<faiss::IndexHNSWPQ> index_reader_read_write(
-                dynamic_cast<faiss::IndexHNSWPQ*>(
-                        faiss::read_index(index_filename.c_str())));
-        std::unique_ptr<faiss::IndexHNSWPQ> index_reader_sdc_disabled(
-                dynamic_cast<faiss::IndexHNSWPQ*>(faiss::read_index(
+        std::unique_ptr<knowherefaiss::IndexHNSWPQ> index_reader_read_write(
+                dynamic_cast<knowherefaiss::IndexHNSWPQ*>(
+                        knowherefaiss::read_index(index_filename.c_str())));
+        std::unique_ptr<knowherefaiss::IndexHNSWPQ> index_reader_sdc_disabled(
+                dynamic_cast<knowherefaiss::IndexHNSWPQ*>(knowherefaiss::read_index(
                         index_filename.c_str(),
-                        faiss::IO_FLAG_PQ_SKIP_SDC_TABLE)));
+                        knowherefaiss::IO_FLAG_PQ_SKIP_SDC_TABLE)));
 
         ASSERT_NE(
-                dynamic_cast<faiss::IndexPQ*>(index_reader_read_write->storage)
+                dynamic_cast<knowherefaiss::IndexPQ*>(index_reader_read_write->storage)
                         ->pq.sdc_table.size(),
                 0);
         ASSERT_EQ(
-                dynamic_cast<faiss::IndexPQ*>(
+                dynamic_cast<knowherefaiss::IndexPQ*>(
                         index_reader_sdc_disabled->storage)
                         ->pq.sdc_table.size(),
                 0);
diff --git a/thirdparty/faiss/tests/test_distances_if.cpp b/thirdparty/faiss/tests/test_distances_if.cpp
index f5bc5506..d8141e8e 100644
--- a/thirdparty/faiss/tests/test_distances_if.cpp
+++ b/thirdparty/faiss/tests/test_distances_if.cpp
@@ -6,9 +6,9 @@
 #include <random>
 #include <vector>
 
-#include <faiss/utils/distances.h>
+#include <knowherefaiss/utils/distances.h>
 
-#include <faiss/utils/distances_if.h>
+#include <knowherefaiss/utils/distances_if.h>
 
 /* compute the inner product between x and a subset y of ny vectors,
    whose indices are given by idy.  */
@@ -30,7 +30,7 @@ void fvec_inner_products_by_idx_ref(
         for (size_t i = 0; i < ny; i++) {
             if (idsj[i] < 0)
                 continue;
-            ipj[i] = faiss::fvec_inner_product(xj, y + d * idsj[i], d);
+            ipj[i] = knowherefaiss::fvec_inner_product(xj, y + d * idsj[i], d);
         }
     }
 }
@@ -55,7 +55,7 @@ void fvec_L2sqr_by_idx_ref(
         for (size_t i = 0; i < ny; i++) {
             if (idsj[i] < 0)
                 continue;
-            disj[i] = faiss::fvec_L2sqr(xj, y + d * idsj[i], d);
+            disj[i] = knowherefaiss::fvec_L2sqr(xj, y + d * idsj[i], d);
         }
     }
 }
@@ -105,7 +105,7 @@ TEST(TestDistancesIf, TestNyByIdx) {
                 nx,
                 ny);
 
-            faiss::fvec_inner_products_by_idx(
+            knowherefaiss::fvec_inner_products_by_idx(
                 dis_IP.data(), 
                 x.data(), 
                 y.data(),
@@ -126,7 +126,7 @@ TEST(TestDistancesIf, TestNyByIdx) {
                 nx,
                 ny);
 
-            faiss::fvec_L2sqr_by_idx(
+            knowherefaiss::fvec_L2sqr_by_idx(
                 dis_L2.data(), 
                 x.data(), 
                 y.data(),
diff --git a/thirdparty/faiss/tests/test_distances_simd.cpp b/thirdparty/faiss/tests/test_distances_simd.cpp
index 762d242b..c5bed78a 100644
--- a/thirdparty/faiss/tests/test_distances_simd.cpp
+++ b/thirdparty/faiss/tests/test_distances_simd.cpp
@@ -13,8 +13,8 @@
 #include <random>
 #include <vector>
 
-#include <faiss/FaissHook.h>
-#include <faiss/utils/distances.h>
+#include <knowherefaiss/FaissHook.h>
+#include <knowherefaiss/utils/distances.h>
 
 // reference implementations
 void fvec_inner_products_ny_ref(
@@ -24,7 +24,7 @@ void fvec_inner_products_ny_ref(
         size_t d,
         size_t ny) {
     for (size_t i = 0; i < ny; i++) {
-        ip[i] = faiss::fvec_inner_product(x, y, d);
+        ip[i] = knowherefaiss::fvec_inner_product(x, y, d);
         y += d;
     }
 }
@@ -36,7 +36,7 @@ void fvec_L2sqr_ny_ref(
         size_t d,
         size_t ny) {
     for (size_t i = 0; i < ny; i++) {
-        dis[i] = faiss::fvec_L2sqr(x, y, d);
+        dis[i] = knowherefaiss::fvec_L2sqr(x, y, d);
         y += d;
     }
 }
@@ -61,7 +61,7 @@ TEST(TestFvecL2sqrNy, D2) {
             }
 
             std::vector<float> distances(nrows, 0);
-            faiss::fvec_L2sqr_ny(
+            knowherefaiss::fvec_L2sqr_ny(
                     distances.data(), x.data(), y.data(), dim, nrows);
 
             std::vector<float> distances_ref(nrows, 0);
@@ -95,7 +95,7 @@ TEST(TestFvecInnerProductsNy, D2) {
             }
 
             std::vector<float> distances(nrows, 0);
-            faiss::fvec_inner_products_ny(
+            knowherefaiss::fvec_inner_products_ny(
                     distances.data(), x.data(), y.data(), dim, nrows);
 
             std::vector<float> distances_ref(nrows, 0);
diff --git a/thirdparty/faiss/tests/test_fastscan_perf.cpp b/thirdparty/faiss/tests/test_fastscan_perf.cpp
index f7d114d7..80286daa 100644
--- a/thirdparty/faiss/tests/test_fastscan_perf.cpp
+++ b/thirdparty/faiss/tests/test_fastscan_perf.cpp
@@ -15,9 +15,9 @@
 
 #include <omp.h>
 
-#include <faiss/IndexFlat.h>
-#include <faiss/IndexIVFPQFastScan.h>
-#include <faiss/impl/AuxIndexStructures.h>
+#include <knowherefaiss/IndexFlat.h>
+#include <knowherefaiss/IndexIVFPQFastScan.h>
+#include <knowherefaiss/impl/AuxIndexStructures.h>
 
 TEST(TestFastScan, knnVSrange) {
     // small vectors and database
@@ -40,21 +40,21 @@ TEST(TestFastScan, knnVSrange) {
     }
 
     // build index
-    faiss::IndexFlatL2 coarse_quantizer(d);
-    faiss::IndexIVFPQFastScan index(
-            &coarse_quantizer, d, nlist, d / 2, 4, faiss::METRIC_L2, 32);
+    knowherefaiss::IndexFlatL2 coarse_quantizer(d);
+    knowherefaiss::IndexIVFPQFastScan index(
+            &coarse_quantizer, d, nlist, d / 2, 4, knowherefaiss::METRIC_L2, 32);
     index.pq.cp.niter = 10; // speed up train
     index.nprobe = nlist;
     index.train(nb, database.data());
     index.add(nb, database.data());
 
     std::vector<float> distances(nb);
-    std::vector<faiss::idx_t> labels(nb);
+    std::vector<knowherefaiss::idx_t> labels(nb);
     auto t = std::chrono::high_resolution_clock::now();
     index.search(nb, database.data(), 1, distances.data(), labels.data());
     auto knn_time = std::chrono::high_resolution_clock::now() - t;
 
-    faiss::RangeSearchResult rsr(nb);
+    knowherefaiss::RangeSearchResult rsr(nb);
     t = std::chrono::high_resolution_clock::now();
     index.range_search(nb, database.data(), 1.0, &rsr);
     auto range_time = std::chrono::high_resolution_clock::now() - t;
diff --git a/thirdparty/faiss/tests/test_heap.cpp b/thirdparty/faiss/tests/test_heap.cpp
index 9481003d..de43b3e0 100644
--- a/thirdparty/faiss/tests/test_heap.cpp
+++ b/thirdparty/faiss/tests/test_heap.cpp
@@ -4,12 +4,12 @@
  * This source code is licensed under the MIT license found in the
  * LICENSE file in the root directory of this source tree.
  */
-#include <faiss/utils/Heap.h>
+#include <knowherefaiss/utils/Heap.h>
 #include <gtest/gtest.h>
 #include <algorithm>
 #include <numeric>
 
-using namespace faiss;
+using namespace knowherefaiss;
 
 TEST(Heap, addn_with_ids) {
     size_t n = 1000;
diff --git a/thirdparty/faiss/tests/test_hnsw.cpp b/thirdparty/faiss/tests/test_hnsw.cpp
index 9d90cf25..e7d83d7f 100644
--- a/thirdparty/faiss/tests/test_hnsw.cpp
+++ b/thirdparty/faiss/tests/test_hnsw.cpp
@@ -14,9 +14,9 @@
 #include <unordered_set>
 #include <vector>
 
-#include <faiss/impl/HNSW.h>
+#include <knowherefaiss/impl/HNSW.h>
 
-int reference_pop_min(faiss::HNSW::MinimaxHeap& heap, float* vmin_out) {
+int reference_pop_min(knowherefaiss::HNSW::MinimaxHeap& heap, float* vmin_out) {
     assert(heap.k > 0);
     // returns min. This is an O(n) operation
     int i = heap.k - 1;
@@ -48,9 +48,9 @@ int reference_pop_min(faiss::HNSW::MinimaxHeap& heap, float* vmin_out) {
 
 void test_popmin(int heap_size, int amount_to_put) {
     // create a heap
-    faiss::HNSW::MinimaxHeap mm_heap(heap_size);
+    knowherefaiss::HNSW::MinimaxHeap mm_heap(heap_size);
 
-    using storage_idx_t = faiss::HNSW::storage_idx_t;
+    using storage_idx_t = knowherefaiss::HNSW::storage_idx_t;
 
     std::default_random_engine rng(123 + heap_size * amount_to_put);
     std::uniform_int_distribution<storage_idx_t> u(0, 65536);
@@ -74,7 +74,7 @@ void test_popmin(int heap_size, int amount_to_put) {
     }
 
     // clone the heap
-    faiss::HNSW::MinimaxHeap cloned_mm_heap = mm_heap;
+    knowherefaiss::HNSW::MinimaxHeap cloned_mm_heap = mm_heap;
 
     // takes ones out one by one
     while (mm_heap.size() > 0) {
@@ -111,9 +111,9 @@ void test_popmin_identical_distances(
         int amount_to_put,
         const float distance) {
     // create a heap
-    faiss::HNSW::MinimaxHeap mm_heap(heap_size);
+    knowherefaiss::HNSW::MinimaxHeap mm_heap(heap_size);
 
-    using storage_idx_t = faiss::HNSW::storage_idx_t;
+    using storage_idx_t = knowherefaiss::HNSW::storage_idx_t;
 
     std::default_random_engine rng(123 + heap_size * amount_to_put);
     std::uniform_int_distribution<storage_idx_t> u(0, 65536);
@@ -131,7 +131,7 @@ void test_popmin_identical_distances(
     }
 
     // clone the heap
-    faiss::HNSW::MinimaxHeap cloned_mm_heap = mm_heap;
+    knowherefaiss::HNSW::MinimaxHeap cloned_mm_heap = mm_heap;
 
     // takes ones out one by one
     while (mm_heap.size() > 0) {
diff --git a/thirdparty/faiss/tests/test_ivf_index.cpp b/thirdparty/faiss/tests/test_ivf_index.cpp
index 21ed0abd..0b48efe7 100644
--- a/thirdparty/faiss/tests/test_ivf_index.cpp
+++ b/thirdparty/faiss/tests/test_ivf_index.cpp
@@ -17,10 +17,10 @@
 
 #include <gtest/gtest.h>
 
-#include <faiss/IndexFlat.h>
-#include <faiss/IndexIVFFlat.h>
-#include <faiss/impl/FaissAssert.h>
-#include <faiss/index_io.h>
+#include <knowherefaiss/IndexFlat.h>
+#include <knowherefaiss/IndexIVFFlat.h>
+#include <knowherefaiss/impl/FaissAssert.h>
+#include <knowherefaiss/index_io.h>
 
 namespace {
 
@@ -41,17 +41,17 @@ class TestContext {
     }
 
     // id to codes map
-    std::unordered_map<faiss::idx_t, std::vector<uint8_t>> codes;
+    std::unordered_map<knowherefaiss::idx_t, std::vector<uint8_t>> codes;
     // id to code norms map
-    std::unordered_map<faiss::idx_t, const float*> code_norms;
+    std::unordered_map<knowherefaiss::idx_t, const float*> code_norms;
     // id to list_no map
-    std::unordered_map<faiss::idx_t, size_t> list_nos;
-    faiss::idx_t id = 0;
+    std::unordered_map<knowherefaiss::idx_t, size_t> list_nos;
+    knowherefaiss::idx_t id = 0;
     std::set<size_t> lists_probed;
 };
 
 // the iterator that iterates over the codes stored in context object
-class TestInvertedListIterator : public faiss::InvertedListsIterator {
+class TestInvertedListIterator : public knowherefaiss::InvertedListsIterator {
    public:
     TestInvertedListIterator(size_t list_no, TestContext* context)
             : list_no{list_no}, context{context} {
@@ -77,7 +77,7 @@ class TestInvertedListIterator : public faiss::InvertedListsIterator {
         seek_next();
     }
 
-    virtual std::pair<faiss::idx_t, const uint8_t*> get_id_and_codes()
+    virtual std::pair<knowherefaiss::idx_t, const uint8_t*> get_id_and_codes()
             override {
         if (it == context->codes.cend()) {
             FAISS_THROW_MSG("invalid state");
@@ -91,10 +91,10 @@ class TestInvertedListIterator : public faiss::InvertedListsIterator {
     decltype(context->codes.cbegin()) it;
 };
 
-class TestInvertedLists : public faiss::InvertedLists {
+class TestInvertedLists : public knowherefaiss::InvertedLists {
    public:
     TestInvertedLists(size_t nlist, size_t code_size)
-            : faiss::InvertedLists(nlist, code_size) {
+            : knowherefaiss::InvertedLists(nlist, code_size) {
         use_iterator = true;
     }
 
@@ -103,7 +103,7 @@ class TestInvertedLists : public faiss::InvertedLists {
         FAISS_THROW_MSG("unexpected call");
     }
 
-    faiss::InvertedListsIterator* get_iterator(size_t list_no, void* context)
+    knowherefaiss::InvertedListsIterator* get_iterator(size_t list_no, void* context)
             const override {
         auto testContext = (TestContext*)context;
         testContext->lists_probed.insert(list_no);
@@ -114,14 +114,14 @@ class TestInvertedLists : public faiss::InvertedLists {
         FAISS_THROW_MSG("unexpected call");
     }
 
-    const faiss::idx_t* get_ids(size_t /* list_no */) const override {
+    const knowherefaiss::idx_t* get_ids(size_t /* list_no */) const override {
         FAISS_THROW_MSG("unexpected call");
     }
 
     // store the codes in context object
     size_t add_entry(
             size_t list_no,
-            faiss::idx_t /*theid*/,
+            knowherefaiss::idx_t /*theid*/,
             const uint8_t* code,
             const float* code_norm,
             void* context) override {
@@ -133,7 +133,7 @@ class TestInvertedLists : public faiss::InvertedLists {
     size_t add_entries(
             size_t /*list_no*/,
             size_t /*n_entry*/,
-            const faiss::idx_t* /*ids*/,
+            const knowherefaiss::idx_t* /*ids*/,
             const uint8_t* /*code*/,
             const float* /*code_norm*/) override {
         FAISS_THROW_MSG("unexpected call");
@@ -143,7 +143,7 @@ class TestInvertedLists : public faiss::InvertedLists {
             size_t /*list_no*/,
             size_t /*offset*/,
             size_t /*n_entry*/,
-            const faiss::idx_t* /*ids*/,
+            const knowherefaiss::idx_t* /*ids*/,
             const uint8_t* /*code*/) override {
         FAISS_THROW_MSG("unexpected call");
     }
@@ -172,8 +172,8 @@ TEST(IVF, list_context) {
     // thread-safe
     omp_set_num_threads(1);
 
-    faiss::IndexFlatL2 quantizer(d); // the other index
-    faiss::IndexIVFFlat index(&quantizer, d, nlist);
+    knowherefaiss::IndexFlatL2 quantizer(d); // the other index
+    knowherefaiss::IndexIVFFlat index(&quantizer, d, nlist);
     TestInvertedLists inverted_lists(nlist, index.code_size);
     index.replace_invlists(&inverted_lists);
     {
@@ -188,7 +188,7 @@ TEST(IVF, list_context) {
     }
     TestContext context;
     std::vector<float> query_vector;
-    constexpr faiss::idx_t query_vector_id = 100;
+    constexpr knowherefaiss::idx_t query_vector_id = 100;
     {
         // populating the database
         std::vector<float> database(nb * d);
@@ -199,10 +199,10 @@ TEST(IVF, list_context) {
                 query_vector.push_back(database[i]);
             }
         }
-        std::vector<faiss::idx_t> coarse_idx(nb);
+        std::vector<knowherefaiss::idx_t> coarse_idx(nb);
         index.quantizer->assign(nb, database.data(), coarse_idx.data());
         // pass dummy ids, the acutal ids are assigned in TextContext object
-        std::vector<faiss::idx_t> xids(nb, 42);
+        std::vector<knowherefaiss::idx_t> xids(nb, 42);
         // todo aguzhva: add a proper testing 
         const float* code_norms = nullptr;
         index.add_core(
@@ -216,11 +216,11 @@ TEST(IVF, list_context) {
                 << "should have correct number of list numbers";
     }
     {
-        constexpr faiss::idx_t k = 100;
+        constexpr knowherefaiss::idx_t k = 100;
         constexpr size_t nprobe = 10;
         std::vector<float> distances(k);
-        std::vector<faiss::idx_t> labels(k);
-        faiss::SearchParametersIVF params;
+        std::vector<knowherefaiss::idx_t> labels(k);
+        knowherefaiss::SearchParametersIVF params;
         params.inverted_list_context = &context;
         params.nprobe = nprobe;
         index.search(
diff --git a/thirdparty/faiss/tests/test_ivfpq_codec.cpp b/thirdparty/faiss/tests/test_ivfpq_codec.cpp
index 47757ba5..119f05d3 100644
--- a/thirdparty/faiss/tests/test_ivfpq_codec.cpp
+++ b/thirdparty/faiss/tests/test_ivfpq_codec.cpp
@@ -13,10 +13,10 @@
 
 #include <gtest/gtest.h>
 
-#include <faiss/IndexFlat.h>
-#include <faiss/IndexIVFPQ.h>
-#include <faiss/utils/distances.h>
-#include <faiss/utils/utils.h>
+#include <knowherefaiss/IndexFlat.h>
+#include <knowherefaiss/IndexIVFPQ.h>
+#include <knowherefaiss/utils/distances.h>
+#include <knowherefaiss/utils/utils.h>
 
 #include "simd/hook.h"
 
@@ -29,21 +29,21 @@ int d = 64;
 size_t nb = 8000;
 
 double eval_codec_error(long ncentroids, long m, const std::vector<float>& v) {
-    faiss::IndexFlatL2 coarse_quantizer(d);
-    faiss::IndexIVFPQ index(&coarse_quantizer, d, ncentroids, m, 8);
+    knowherefaiss::IndexFlatL2 coarse_quantizer(d);
+    knowherefaiss::IndexIVFPQ index(&coarse_quantizer, d, ncentroids, m, 8);
     index.pq.cp.niter = 10; // speed up train
     index.train(nb, v.data());
 
     // encode and decode to compute reconstruction error
 
-    std::vector<faiss::idx_t> keys(nb);
+    std::vector<knowherefaiss::idx_t> keys(nb);
     std::vector<uint8_t> codes(nb * m);
     index.encode_multiple(nb, keys.data(), v.data(), codes.data(), true);
 
     std::vector<float> v2(nb * d);
     index.decode_multiple(nb, keys.data(), codes.data(), v2.data());
 
-    return faiss::fvec_L2sqr(v.data(), v2.data(), nb * d);
+    return knowherefaiss::fvec_L2sqr(v.data(), v2.data(), nb * d);
 }
 
 } // namespace
diff --git a/thirdparty/faiss/tests/test_ivfpq_indexing.cpp b/thirdparty/faiss/tests/test_ivfpq_indexing.cpp
index 33425609..95b890b3 100644
--- a/thirdparty/faiss/tests/test_ivfpq_indexing.cpp
+++ b/thirdparty/faiss/tests/test_ivfpq_indexing.cpp
@@ -11,9 +11,9 @@
 
 #include <gtest/gtest.h>
 
-#include <faiss/IndexFlat.h>
-#include <faiss/IndexIVFPQ.h>
-#include <faiss/index_io.h>
+#include <knowherefaiss/IndexFlat.h>
+#include <knowherefaiss/IndexIVFPQ.h>
+#include <knowherefaiss/index_io.h>
 
 TEST(IVFPQ, accuracy) {
     // dimension of the vectors to index
@@ -27,15 +27,15 @@ TEST(IVFPQ, accuracy) {
     size_t nt = 1500;
 
     // make the index object and train it
-    faiss::IndexFlatL2 coarse_quantizer(d);
+    knowherefaiss::IndexFlatL2 coarse_quantizer(d);
 
     // a reasonable number of cetroids to index nb vectors
     int ncentroids = 25;
 
-    faiss::IndexIVFPQ index(&coarse_quantizer, d, ncentroids, 16, 8);
+    knowherefaiss::IndexIVFPQ index(&coarse_quantizer, d, ncentroids, 16, 8);
 
     // index that gives the ground-truth
-    faiss::IndexFlatL2 index_gt(d);
+    knowherefaiss::IndexFlatL2 index_gt(d);
 
     std::mt19937 rng;
     std::uniform_real_distribution<> distrib;
@@ -71,14 +71,14 @@ TEST(IVFPQ, accuracy) {
             queries[i] = distrib(rng);
         }
 
-        std::vector<faiss::idx_t> gt_nns(nq);
+        std::vector<knowherefaiss::idx_t> gt_nns(nq);
         std::vector<float> gt_dis(nq);
 
         index_gt.search(nq, queries.data(), 1, gt_dis.data(), gt_nns.data());
 
         index.nprobe = 5;
         int k = 5;
-        std::vector<faiss::idx_t> nns(k * nq);
+        std::vector<knowherefaiss::idx_t> nns(k * nq);
         std::vector<float> dis(k * nq);
 
         index.search(nq, queries.data(), k, dis.data(), nns.data());
diff --git a/thirdparty/faiss/tests/test_lowlevel_ivf.cpp b/thirdparty/faiss/tests/test_lowlevel_ivf.cpp
index 3734fca2..e8318b03 100644
--- a/thirdparty/faiss/tests/test_lowlevel_ivf.cpp
+++ b/thirdparty/faiss/tests/test_lowlevel_ivf.cpp
@@ -16,16 +16,16 @@
 
 #include <gtest/gtest.h>
 
-#include <faiss/AutoTune.h>
-#include <faiss/IVFlib.h>
-#include <faiss/IndexBinaryIVF.h>
-#include <faiss/IndexIVF.h>
-#include <faiss/IndexPreTransform.h>
-#include <faiss/VectorTransform.h>
-#include <faiss/index_factory.h>
-#include <faiss/index_io.h>
-
-using namespace faiss;
+#include <knowherefaiss/AutoTune.h>
+#include <knowherefaiss/IVFlib.h>
+#include <knowherefaiss/IndexBinaryIVF.h>
+#include <knowherefaiss/IndexIVF.h>
+#include <knowherefaiss/IndexPreTransform.h>
+#include <knowherefaiss/VectorTransform.h>
+#include <knowherefaiss/index_factory.h>
+#include <knowherefaiss/index_io.h>
+
+using namespace knowherefaiss;
 
 namespace {
 
diff --git a/thirdparty/faiss/tests/test_mem_leak.cpp b/thirdparty/faiss/tests/test_mem_leak.cpp
index 2a8e41b8..ab71a075 100644
--- a/thirdparty/faiss/tests/test_mem_leak.cpp
+++ b/thirdparty/faiss/tests/test_mem_leak.cpp
@@ -5,14 +5,14 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/IndexFlat.h>
-#include <faiss/IndexIVFFlat.h>
-#include <faiss/utils/random.h>
-#include <faiss/utils/utils.h>
+#include <knowherefaiss/IndexFlat.h>
+#include <knowherefaiss/IndexIVFFlat.h>
+#include <knowherefaiss/utils/random.h>
+#include <knowherefaiss/utils/utils.h>
 
 #include <gtest/gtest.h>
 
-using namespace faiss;
+using namespace knowherefaiss;
 
 TEST(MEM_LEAK, ivfflat) {
     size_t num_tfidf_faiss_cells = 20;
diff --git a/thirdparty/faiss/tests/test_merge.cpp b/thirdparty/faiss/tests/test_merge.cpp
index edbe2a03..cc9b8c46 100644
--- a/thirdparty/faiss/tests/test_merge.cpp
+++ b/thirdparty/faiss/tests/test_merge.cpp
@@ -10,12 +10,12 @@
 
 #include <gtest/gtest.h>
 
-#include <faiss/IVFlib.h>
-#include <faiss/IndexFlat.h>
-#include <faiss/IndexIVFFlat.h>
-#include <faiss/IndexPreTransform.h>
-#include <faiss/MetaIndexes.h>
-#include <faiss/invlists/OnDiskInvertedLists.h>
+#include <knowherefaiss/IVFlib.h>
+#include <knowherefaiss/IndexFlat.h>
+#include <knowherefaiss/IndexIVFFlat.h>
+#include <knowherefaiss/IndexPreTransform.h>
+#include <knowherefaiss/MetaIndexes.h>
+#include <knowherefaiss/invlists/OnDiskInvertedLists.h>
 
 #include "test_util.h"
 
@@ -23,7 +23,7 @@ namespace {
 
 pthread_mutex_t temp_file_mutex = PTHREAD_MUTEX_INITIALIZER;
 
-typedef faiss::idx_t idx_t;
+typedef knowherefaiss::idx_t idx_t;
 
 // parameters to use for the test
 int d = 64;
@@ -38,7 +38,7 @@ struct CommonData {
     std::vector<float> database;
     std::vector<float> queries;
     std::vector<idx_t> ids;
-    faiss::IndexFlatL2 quantizer;
+    knowherefaiss::IndexFlatL2 quantizer;
 
     CommonData() : database(nb * d), queries(nq * d), ids(nb), quantizer(d) {
         std::mt19937 rng;
@@ -53,7 +53,7 @@ struct CommonData {
             ids[i] = 123 + 456 * i;
         }
         { // just to train the quantizer
-            faiss::IndexIVFFlat iflat(&quantizer, d, nlist);
+            knowherefaiss::IndexIVFFlat iflat(&quantizer, d, nlist);
             iflat.train(nb, database.data());
         }
     }
@@ -64,7 +64,7 @@ CommonData cd;
 /// perform a search on shards, then merge and search again and
 /// compare results.
 int compare_merged(
-        faiss::IndexShards* index_shards,
+        knowherefaiss::IndexShards* index_shards,
         bool shift_ids,
         bool standard_merge = true) {
     std::vector<idx_t> refI(k * nq);
@@ -78,18 +78,18 @@ int compare_merged(
 
     if (standard_merge) {
         for (int i = 1; i < nindex; i++) {
-            faiss::ivflib::merge_into(
+            knowherefaiss::ivflib::merge_into(
                     index_shards->at(0), index_shards->at(i), shift_ids);
         }
 
         index_shards->syncWithSubIndexes();
     } else {
-        std::vector<const faiss::InvertedLists*> lists;
-        faiss::IndexIVF* index0 = nullptr;
+        std::vector<const knowherefaiss::InvertedLists*> lists;
+        knowherefaiss::IndexIVF* index0 = nullptr;
         size_t ntotal = 0;
         for (int i = 0; i < nindex; i++) {
             auto index_ivf =
-                    dynamic_cast<faiss::IndexIVF*>(index_shards->at(i));
+                    dynamic_cast<knowherefaiss::IndexIVF*>(index_shards->at(i));
             assert(index_ivf);
             if (i == 0) {
                 index0 = index_ivf;
@@ -98,7 +98,7 @@ int compare_merged(
             ntotal += index_ivf->ntotal;
         }
 
-        auto il = new faiss::OnDiskInvertedLists(
+        auto il = new knowherefaiss::OnDiskInvertedLists(
                 index0->nlist, index0->code_size, filename.c_str());
 
         il->merge_from_multiple(lists.data(), lists.size(), shift_ids);
@@ -126,11 +126,11 @@ int compare_merged(
 
 // test on IVFFlat with implicit numbering
 TEST(MERGE, merge_flat_no_ids) {
-    faiss::IndexShards index_shards(d);
+    knowherefaiss::IndexShards index_shards(d);
     index_shards.own_indices = true;
     for (int i = 0; i < nindex; i++) {
         index_shards.add_shard(
-                new faiss::IndexIVFFlat(&cd.quantizer, d, nlist));
+                new knowherefaiss::IndexIVFFlat(&cd.quantizer, d, nlist));
     }
     EXPECT_TRUE(index_shards.is_trained);
     index_shards.add(nb, cd.database.data());
@@ -142,12 +142,12 @@ TEST(MERGE, merge_flat_no_ids) {
 
 // test on IVFFlat, explicit ids
 TEST(MERGE, merge_flat) {
-    faiss::IndexShards index_shards(d, false, false);
+    knowherefaiss::IndexShards index_shards(d, false, false);
     index_shards.own_indices = true;
 
     for (int i = 0; i < nindex; i++) {
         index_shards.add_shard(
-                new faiss::IndexIVFFlat(&cd.quantizer, d, nlist));
+                new knowherefaiss::IndexIVFFlat(&cd.quantizer, d, nlist));
     }
 
     EXPECT_TRUE(index_shards.is_trained);
@@ -158,24 +158,24 @@ TEST(MERGE, merge_flat) {
 
 // test on IVFFlat and a VectorTransform
 TEST(MERGE, merge_flat_vt) {
-    faiss::IndexShards index_shards(d, false, false);
+    knowherefaiss::IndexShards index_shards(d, false, false);
     index_shards.own_indices = true;
 
     // here we have to retrain because of the vectorTransform
-    faiss::RandomRotationMatrix rot(d, d);
+    knowherefaiss::RandomRotationMatrix rot(d, d);
     rot.init(1234);
-    faiss::IndexFlatL2 quantizer(d);
+    knowherefaiss::IndexFlatL2 quantizer(d);
 
     { // just to train the quantizer
-        faiss::IndexIVFFlat iflat(&quantizer, d, nlist);
-        faiss::IndexPreTransform ipt(&rot, &iflat);
+        knowherefaiss::IndexIVFFlat iflat(&quantizer, d, nlist);
+        knowherefaiss::IndexPreTransform ipt(&rot, &iflat);
         ipt.train(nb, cd.database.data());
     }
 
     for (int i = 0; i < nindex; i++) {
-        faiss::IndexPreTransform* ipt = new faiss::IndexPreTransform(
-                new faiss::RandomRotationMatrix(rot),
-                new faiss::IndexIVFFlat(&quantizer, d, nlist));
+        knowherefaiss::IndexPreTransform* ipt = new knowherefaiss::IndexPreTransform(
+                new knowherefaiss::RandomRotationMatrix(rot),
+                new knowherefaiss::IndexIVFFlat(&quantizer, d, nlist));
         ipt->own_fields = true;
         index_shards.add_shard(ipt);
     }
@@ -189,14 +189,14 @@ TEST(MERGE, merge_flat_vt) {
 
 // put the merged invfile on disk
 TEST(MERGE, merge_flat_ondisk) {
-    faiss::IndexShards index_shards(d, false, false);
+    knowherefaiss::IndexShards index_shards(d, false, false);
     index_shards.own_indices = true;
     Tempfilename filename(&temp_file_mutex, "/tmp/faiss_tmp_XXXXXX");
 
     for (int i = 0; i < nindex; i++) {
-        auto ivf = new faiss::IndexIVFFlat(&cd.quantizer, d, nlist);
+        auto ivf = new knowherefaiss::IndexIVFFlat(&cd.quantizer, d, nlist);
         if (i == 0) {
-            auto il = new faiss::OnDiskInvertedLists(
+            auto il = new knowherefaiss::OnDiskInvertedLists(
                     ivf->nlist, ivf->code_size, filename.c_str());
             ivf->replace_invlists(il, true);
         }
@@ -212,12 +212,12 @@ TEST(MERGE, merge_flat_ondisk) {
 
 // now use ondisk specific merge
 TEST(MERGE, merge_flat_ondisk_2) {
-    faiss::IndexShards index_shards(d, false, false);
+    knowherefaiss::IndexShards index_shards(d, false, false);
     index_shards.own_indices = true;
 
     for (int i = 0; i < nindex; i++) {
         index_shards.add_shard(
-                new faiss::IndexIVFFlat(&cd.quantizer, d, nlist));
+                new knowherefaiss::IndexIVFFlat(&cd.quantizer, d, nlist));
     }
     EXPECT_TRUE(index_shards.is_trained);
     index_shards.add_with_ids(nb, cd.database.data(), cd.ids.data());
@@ -227,7 +227,7 @@ TEST(MERGE, merge_flat_ondisk_2) {
 
 // now use ondisk specific merge and use shift ids
 TEST(MERGE, merge_flat_ondisk_3) {
-    faiss::IndexShards index_shards(d, false, false);
+    knowherefaiss::IndexShards index_shards(d, false, false);
     index_shards.own_indices = true;
 
     std::vector<idx_t> ids;
@@ -237,7 +237,7 @@ TEST(MERGE, merge_flat_ondisk_3) {
     }
     for (int i = 0; i < nindex; i++) {
         index_shards.add_shard(
-                new faiss::IndexIVFFlat(&cd.quantizer, d, nlist));
+                new knowherefaiss::IndexIVFFlat(&cd.quantizer, d, nlist));
     }
     EXPECT_TRUE(index_shards.is_trained);
     index_shards.add_with_ids(nb, cd.database.data(), ids.data());
diff --git a/thirdparty/faiss/tests/test_omp_threads.cpp b/thirdparty/faiss/tests/test_omp_threads.cpp
index 0ba04eb3..3e574a56 100644
--- a/thirdparty/faiss/tests/test_omp_threads.cpp
+++ b/thirdparty/faiss/tests/test_omp_threads.cpp
@@ -7,8 +7,8 @@
 
 #include <gtest/gtest.h>
 
-#include <faiss/utils/utils.h>
+#include <knowherefaiss/utils/utils.h>
 
 TEST(Threading, openmp) {
-    EXPECT_TRUE(faiss::check_openmp());
+    EXPECT_TRUE(knowherefaiss::check_openmp());
 }
diff --git a/thirdparty/faiss/tests/test_ondisk_ivf.cpp b/thirdparty/faiss/tests/test_ondisk_ivf.cpp
index 7c41e082..fb77a5bd 100644
--- a/thirdparty/faiss/tests/test_ondisk_ivf.cpp
+++ b/thirdparty/faiss/tests/test_ondisk_ivf.cpp
@@ -17,11 +17,11 @@
 
 #include <gtest/gtest.h>
 
-#include <faiss/IndexFlat.h>
-#include <faiss/IndexIVFFlat.h>
-#include <faiss/index_io.h>
-#include <faiss/invlists/OnDiskInvertedLists.h>
-#include <faiss/utils/random.h>
+#include <knowherefaiss/IndexFlat.h>
+#include <knowherefaiss/IndexIVFFlat.h>
+#include <knowherefaiss/index_io.h>
+#include <knowherefaiss/invlists/OnDiskInvertedLists.h>
+#include <knowherefaiss/utils/random.h>
 
 namespace {
 
@@ -60,7 +60,7 @@ TEST(ONDISK, make_invlists) {
 
     Tempfilename filename;
 
-    faiss::OnDiskInvertedLists ivf(nlist, code_size, filename.c_str());
+    knowherefaiss::OnDiskInvertedLists ivf(nlist, code_size, filename.c_str());
 
     {
         std::vector<uint8_t> code(32);
@@ -80,10 +80,10 @@ TEST(ONDISK, make_invlists) {
     int ntot = 0;
     for (int i = 0; i < nlist; i++) {
         int size = ivf.list_size(i);
-        const faiss::idx_t* ids = ivf.get_ids(i);
+        const knowherefaiss::idx_t* ids = ivf.get_ids(i);
         const uint8_t* codes = ivf.get_codes(i);
         for (int j = 0; j < size; j++) {
-            faiss::idx_t id = ids[j];
+            knowherefaiss::idx_t id = ids[j];
             const int* ar = (const int*)&codes[code_size * j];
             EXPECT_EQ(ar[0], id);
             EXPECT_EQ(ar[1], i);
@@ -97,23 +97,23 @@ TEST(ONDISK, make_invlists) {
 TEST(ONDISK, test_add) {
     int d = 8;
     int nlist = 30, nq = 200, nb = 1500, k = 10;
-    faiss::IndexFlatL2 quantizer(d);
+    knowherefaiss::IndexFlatL2 quantizer(d);
     {
         std::vector<float> x(d * nlist);
-        faiss::float_rand(x.data(), d * nlist, 12345);
+        knowherefaiss::float_rand(x.data(), d * nlist, 12345);
         quantizer.add(nlist, x.data());
     }
     std::vector<float> xb(d * nb);
-    faiss::float_rand(xb.data(), d * nb, 23456);
+    knowherefaiss::float_rand(xb.data(), d * nb, 23456);
 
-    faiss::IndexIVFFlat index(&quantizer, d, nlist);
+    knowherefaiss::IndexIVFFlat index(&quantizer, d, nlist);
     index.add(nb, xb.data());
 
     std::vector<float> xq(d * nb);
-    faiss::float_rand(xq.data(), d * nq, 34567);
+    knowherefaiss::float_rand(xq.data(), d * nq, 34567);
 
     std::vector<float> ref_D(nq * k);
-    std::vector<faiss::idx_t> ref_I(nq * k);
+    std::vector<knowherefaiss::idx_t> ref_I(nq * k);
 
     index.search(nq, xq.data(), k, ref_D.data(), ref_I.data());
 
@@ -121,9 +121,9 @@ TEST(ONDISK, test_add) {
 
     // test add + search
     {
-        faiss::IndexIVFFlat index2(&quantizer, d, nlist);
+        knowherefaiss::IndexIVFFlat index2(&quantizer, d, nlist);
 
-        faiss::OnDiskInvertedLists ivf(
+        knowherefaiss::OnDiskInvertedLists ivf(
                 index.nlist, index.code_size, filename.c_str());
 
         index2.replace_invlists(&ivf);
@@ -131,7 +131,7 @@ TEST(ONDISK, test_add) {
         index2.add(nb, xb.data());
 
         std::vector<float> new_D(nq * k);
-        std::vector<faiss::idx_t> new_I(nq * k);
+        std::vector<knowherefaiss::idx_t> new_I(nq * k);
 
         index2.search(nq, xq.data(), k, new_D.data(), new_I.data());
 
@@ -143,10 +143,10 @@ TEST(ONDISK, test_add) {
 
     // test io
     {
-        faiss::Index* index3 = faiss::read_index(filename2.c_str());
+        knowherefaiss::Index* index3 = knowherefaiss::read_index(filename2.c_str());
 
         std::vector<float> new_D(nq * k);
-        std::vector<faiss::idx_t> new_I(nq * k);
+        std::vector<knowherefaiss::idx_t> new_I(nq * k);
 
         index3->search(nq, xq.data(), k, new_D.data(), new_I.data());
 
@@ -165,7 +165,7 @@ TEST(ONDISK, make_invlists_threaded) {
 
     Tempfilename filename;
 
-    faiss::OnDiskInvertedLists ivf(nlist, code_size, filename.c_str());
+    knowherefaiss::OnDiskInvertedLists ivf(nlist, code_size, filename.c_str());
 
     std::vector<int> list_nos(nadd);
 
@@ -192,10 +192,10 @@ TEST(ONDISK, make_invlists_threaded) {
     int ntot = 0;
     for (int i = 0; i < nlist; i++) {
         int size = ivf.list_size(i);
-        const faiss::idx_t* ids = ivf.get_ids(i);
+        const knowherefaiss::idx_t* ids = ivf.get_ids(i);
         const uint8_t* codes = ivf.get_codes(i);
         for (int j = 0; j < size; j++) {
-            faiss::idx_t id = ids[j];
+            knowherefaiss::idx_t id = ids[j];
             const int* ar = (const int*)&codes[code_size * j];
             EXPECT_EQ(ar[0], id);
             EXPECT_EQ(ar[1], i);
diff --git a/thirdparty/faiss/tests/test_pairs_decoding.cpp b/thirdparty/faiss/tests/test_pairs_decoding.cpp
index d21136cb..d66b4f49 100644
--- a/thirdparty/faiss/tests/test_pairs_decoding.cpp
+++ b/thirdparty/faiss/tests/test_pairs_decoding.cpp
@@ -14,14 +14,14 @@
 
 #include <gtest/gtest.h>
 
-#include <faiss/IVFlib.h>
-#include <faiss/IndexIVF.h>
-#include <faiss/VectorTransform.h>
-#include <faiss/index_factory.h>
+#include <knowherefaiss/IVFlib.h>
+#include <knowherefaiss/IndexIVF.h>
+#include <knowherefaiss/VectorTransform.h>
+#include <knowherefaiss/index_factory.h>
 
 namespace {
 
-typedef faiss::idx_t idx_t;
+typedef knowherefaiss::idx_t idx_t;
 
 /*************************************************************
  * Test utils
@@ -47,11 +47,11 @@ std::vector<float> make_data(size_t n) {
     return database;
 }
 
-std::unique_ptr<faiss::Index> make_index(
+std::unique_ptr<knowherefaiss::Index> make_index(
         const char* index_type,
         const std::vector<float>& x) {
     auto index =
-            std::unique_ptr<faiss::Index>(faiss::index_factory(d, index_type));
+            std::unique_ptr<knowherefaiss::Index>(knowherefaiss::index_factory(d, index_type));
     index->train(nb, x.data());
     index->add(nb, x.data());
     return index;
@@ -70,10 +70,10 @@ bool test_search_centroid(const char* index_key) {
        the inverted list corresponding to its centroid */
 
     std::vector<idx_t> centroid_ids(nb);
-    faiss::ivflib::search_centroid(
+    knowherefaiss::ivflib::search_centroid(
             index.get(), xb.data(), nb, centroid_ids.data());
 
-    const faiss::IndexIVF* ivf = faiss::ivflib::extract_index_ivf(index.get());
+    const knowherefaiss::IndexIVF* ivf = knowherefaiss::ivflib::extract_index_ivf(index.get());
 
     for (int i = 0; i < nb; i++) {
         bool found = false;
@@ -98,10 +98,10 @@ int test_search_and_return_centroids(const char* index_key) {
     auto index = make_index(index_key, xb);
 
     std::vector<idx_t> centroid_ids(nb);
-    faiss::ivflib::search_centroid(
+    knowherefaiss::ivflib::search_centroid(
             index.get(), xb.data(), nb, centroid_ids.data());
 
-    faiss::IndexIVF* ivf = faiss::ivflib::extract_index_ivf(index.get());
+    knowherefaiss::IndexIVF* ivf = knowherefaiss::ivflib::extract_index_ivf(index.get());
     ivf->nprobe = 4;
 
     std::vector<float> xq = make_data(nq); // database vectors
@@ -122,7 +122,7 @@ int test_search_and_return_centroids(const char* index_key) {
     std::vector<idx_t> query_centroid_ids(nq);
     std::vector<idx_t> result_centroid_ids(nq * k);
 
-    faiss::ivflib::search_and_return_centroids(
+    knowherefaiss::ivflib::search_and_return_centroids(
             index.get(),
             nq,
             xq.data(),
diff --git a/thirdparty/faiss/tests/test_params_override.cpp b/thirdparty/faiss/tests/test_params_override.cpp
index 8891d0e5..91d89625 100644
--- a/thirdparty/faiss/tests/test_params_override.cpp
+++ b/thirdparty/faiss/tests/test_params_override.cpp
@@ -14,16 +14,16 @@
 
 #include <gtest/gtest.h>
 
-#include <faiss/AutoTune.h>
-#include <faiss/IVFlib.h>
-#include <faiss/IndexBinaryIVF.h>
-#include <faiss/IndexIVF.h>
-#include <faiss/clone_index.h>
-#include <faiss/impl/AuxIndexStructures.h>
-#include <faiss/impl/IDSelector.h>
-#include <faiss/index_factory.h>
-
-using namespace faiss;
+#include <knowherefaiss/AutoTune.h>
+#include <knowherefaiss/IVFlib.h>
+#include <knowherefaiss/IndexBinaryIVF.h>
+#include <knowherefaiss/IndexIVF.h>
+#include <knowherefaiss/clone_index.h>
+#include <knowherefaiss/impl/AuxIndexStructures.h>
+#include <knowherefaiss/impl/IDSelector.h>
+#include <knowherefaiss/index_factory.h>
+
+using namespace knowherefaiss;
 
 namespace {
 
diff --git a/thirdparty/faiss/tests/test_partitioning.cpp b/thirdparty/faiss/tests/test_partitioning.cpp
index b719fcfe..aec22748 100644
--- a/thirdparty/faiss/tests/test_partitioning.cpp
+++ b/thirdparty/faiss/tests/test_partitioning.cpp
@@ -7,10 +7,10 @@
 
 #include <gtest/gtest.h>
 
-#include <faiss/utils/AlignedTable.h>
-#include <faiss/utils/partitioning.h>
+#include <knowherefaiss/utils/AlignedTable.h>
+#include <knowherefaiss/utils/partitioning.h>
 
-using namespace faiss;
+using namespace knowherefaiss;
 
 typedef AlignedTable<uint16_t> AlignedTableUint16;
 
diff --git a/thirdparty/faiss/tests/test_pq_encoding.cpp b/thirdparty/faiss/tests/test_pq_encoding.cpp
index be09ba23..109db91c 100644
--- a/thirdparty/faiss/tests/test_pq_encoding.cpp
+++ b/thirdparty/faiss/tests/test_pq_encoding.cpp
@@ -11,9 +11,9 @@
 
 #include <gtest/gtest.h>
 
-#include <faiss/IndexPQFastScan.h>
-#include <faiss/impl/ProductQuantizer.h>
-#include <faiss/impl/pq4_fast_scan.h>
+#include <knowherefaiss/IndexPQFastScan.h>
+#include <knowherefaiss/impl/ProductQuantizer.h>
+#include <knowherefaiss/impl/pq4_fast_scan.h>
 
 namespace {
 
@@ -53,13 +53,13 @@ TEST(PQEncoderGeneric, encode) {
         // NOTE(hoss): Necessary scope to ensure trailing bits are flushed to
         // mem.
         {
-            faiss::PQEncoderGeneric encoder(codes.get(), nbits);
+            knowherefaiss::PQEncoderGeneric encoder(codes.get(), nbits);
             for (const auto& v : values) {
                 encoder.encode(v & mask);
             }
         }
 
-        faiss::PQDecoderGeneric decoder(codes.get(), nbits);
+        knowherefaiss::PQDecoderGeneric decoder(codes.get(), nbits);
         for (int i = 0; i < nsubcodes; ++i) {
             uint64_t v = decoder.decode();
             EXPECT_EQ(values[i] & mask, v);
@@ -73,12 +73,12 @@ TEST(PQEncoder8, encode) {
     const uint64_t mask = 0xFF;
     std::unique_ptr<uint8_t[]> codes(new uint8_t[nsubcodes]);
 
-    faiss::PQEncoder8 encoder(codes.get(), 8);
+    knowherefaiss::PQEncoder8 encoder(codes.get(), 8);
     for (const auto& v : values) {
         encoder.encode(v & mask);
     }
 
-    faiss::PQDecoder8 decoder(codes.get(), 8);
+    knowherefaiss::PQDecoder8 decoder(codes.get(), 8);
     for (int i = 0; i < nsubcodes; ++i) {
         uint64_t v = decoder.decode();
         EXPECT_EQ(values[i] & mask, v);
@@ -91,12 +91,12 @@ TEST(PQEncoder16, encode) {
     const uint64_t mask = 0xFFFF;
     std::unique_ptr<uint8_t[]> codes(new uint8_t[2 * nsubcodes]);
 
-    faiss::PQEncoder16 encoder(codes.get(), 16);
+    knowherefaiss::PQEncoder16 encoder(codes.get(), 16);
     for (const auto& v : values) {
         encoder.encode(v & mask);
     }
 
-    faiss::PQDecoder16 decoder(codes.get(), 16);
+    knowherefaiss::PQDecoder16 decoder(codes.get(), 16);
     for (int i = 0; i < nsubcodes; ++i) {
         uint64_t v = decoder.decode();
         EXPECT_EQ(values[i] & mask, v);
@@ -106,7 +106,7 @@ TEST(PQEncoder16, encode) {
 TEST(PQFastScan, set_packed_element) {
     int d = 20, ntotal = 1000, M = 5, nbits = 4;
     const std::vector<float> ds = random_vector_float(ntotal * d);
-    faiss::IndexPQFastScan index(d, M, nbits);
+    knowherefaiss::IndexPQFastScan index(d, M, nbits);
     index.train(ntotal, ds.data());
     index.add(ntotal, ds.data());
 
@@ -116,12 +116,12 @@ TEST(PQFastScan, set_packed_element) {
         std::vector<uint8_t> code(M);
         for (int i = 0; i < ntotal; i++) {
             for (int sq = 0; sq < M; sq++) {
-                old[i * M + sq] = faiss::pq4_get_packed_element(
+                old[i * M + sq] = knowherefaiss::pq4_get_packed_element(
                         index.codes.data(), index.bbs, M, i, sq);
             }
         }
         for (int sq = 0; sq < M; sq++) {
-            faiss::pq4_set_packed_element(
+            knowherefaiss::pq4_set_packed_element(
                     index.codes.data(),
                     ((old[vector_id * M + sq] + 3) % 16),
                     index.bbs,
@@ -131,7 +131,7 @@ TEST(PQFastScan, set_packed_element) {
         }
         for (int i = 0; i < ntotal; i++) {
             for (int sq = 0; sq < M; sq++) {
-                uint8_t newcode = faiss::pq4_get_packed_element(
+                uint8_t newcode = knowherefaiss::pq4_get_packed_element(
                         index.codes.data(), index.bbs, M, i, sq);
                 uint8_t oldcode = old[i * M + sq];
                 if (i == vector_id) {
diff --git a/thirdparty/faiss/tests/test_simdlib.cpp b/thirdparty/faiss/tests/test_simdlib.cpp
index 58ebc858..ba1e1ce7 100644
--- a/thirdparty/faiss/tests/test_simdlib.cpp
+++ b/thirdparty/faiss/tests/test_simdlib.cpp
@@ -7,9 +7,9 @@
 
 #include <gtest/gtest.h>
 
-#include <faiss/utils/simdlib.h>
+#include <knowherefaiss/utils/simdlib.h>
 
-using namespace faiss;
+using namespace knowherefaiss;
 
 TEST(TestSIMDLib, TestCmpltAndBlendInplace) {
     simd8float32 lowestValues(0, 1, 2, 3, 4, 5, 6, 7);
diff --git a/thirdparty/faiss/tests/test_sliding_ivf.cpp b/thirdparty/faiss/tests/test_sliding_ivf.cpp
index ea9e53d6..c30e08dc 100644
--- a/thirdparty/faiss/tests/test_sliding_ivf.cpp
+++ b/thirdparty/faiss/tests/test_sliding_ivf.cpp
@@ -14,13 +14,13 @@
 
 #include <gtest/gtest.h>
 
-#include <faiss/AutoTune.h>
-#include <faiss/IVFlib.h>
-#include <faiss/IndexIVF.h>
-#include <faiss/clone_index.h>
-#include <faiss/index_factory.h>
+#include <knowherefaiss/AutoTune.h>
+#include <knowherefaiss/IVFlib.h>
+#include <knowherefaiss/IndexIVF.h>
+#include <knowherefaiss/clone_index.h>
+#include <knowherefaiss/index_factory.h>
 
-using namespace faiss;
+using namespace knowherefaiss;
 
 // dimension of the vectors to index
 int d = 32;
@@ -79,7 +79,7 @@ void make_index_slices(
         Index* index = sub_indexes.back().get();
 
         auto xb = make_data(nb * d);
-        std::vector<faiss::idx_t> ids(nb);
+        std::vector<knowherefaiss::idx_t> ids(nb);
         std::mt19937 rng;
         std::uniform_int_distribution<> distrib;
         for (int j = 0; j < nb; j++) {
diff --git a/thirdparty/faiss/tests/test_threaded_index.cpp b/thirdparty/faiss/tests/test_threaded_index.cpp
index 3dc2660d..246e569c 100644
--- a/thirdparty/faiss/tests/test_threaded_index.cpp
+++ b/thirdparty/faiss/tests/test_threaded_index.cpp
@@ -5,9 +5,9 @@
  * LICENSE file in the root directory of this source tree.
  */
 
-#include <faiss/IndexReplicas.h>
-#include <faiss/IndexShards.h>
-#include <faiss/impl/ThreadedIndex.h>
+#include <knowherefaiss/IndexReplicas.h>
+#include <knowherefaiss/IndexShards.h>
+#include <knowherefaiss/impl/ThreadedIndex.h>
 
 #include <gtest/gtest.h>
 #include <chrono>
@@ -19,10 +19,10 @@ namespace {
 
 struct TestException : public std::exception {};
 
-using idx_t = faiss::idx_t;
+using idx_t = knowherefaiss::idx_t;
 
-struct MockIndex : public faiss::Index {
-    explicit MockIndex(idx_t d) : faiss::Index(d) {
+struct MockIndex : public knowherefaiss::Index {
+    explicit MockIndex(idx_t d) : knowherefaiss::Index(d) {
         resetMock();
     }
 
@@ -46,7 +46,7 @@ struct MockIndex : public faiss::Index {
             idx_t k,
             float* distances,
             idx_t* labels,
-            const faiss::SearchParameters* params) const override {
+            const knowherefaiss::SearchParameters* params) const override {
         FAISS_THROW_IF_NOT(!params);
         nCalled = n;
         xCalled = x;
@@ -67,11 +67,11 @@ struct MockIndex : public faiss::Index {
 };
 
 template <typename IndexT>
-struct MockThreadedIndex : public faiss::ThreadedIndex<IndexT> {
-    using idx_t = faiss::idx_t;
+struct MockThreadedIndex : public knowherefaiss::ThreadedIndex<IndexT> {
+    using idx_t = knowherefaiss::idx_t;
 
     explicit MockThreadedIndex(bool threaded)
-            : faiss::ThreadedIndex<IndexT>(threaded) {}
+            : knowherefaiss::ThreadedIndex<IndexT>(threaded) {}
 
     void add(idx_t, const float*) override {}
     void search(
@@ -80,7 +80,7 @@ struct MockThreadedIndex : public faiss::ThreadedIndex<IndexT> {
             idx_t,
             float*,
             idx_t*,
-            const faiss::SearchParameters*) const override {}
+            const knowherefaiss::SearchParameters*) const override {}
     void reset() override {}
 };
 
@@ -155,7 +155,7 @@ TEST(ThreadedIndex, MultipleException) {
 
         // Multiple indices threw an exception that was aggregated into a
         // FaissException
-        EXPECT_THROW(ti.runOnIndex(fn), faiss::FaissException);
+        EXPECT_THROW(ti.runOnIndex(fn), knowherefaiss::FaissException);
 
         // Index 2 should have processed
         EXPECT_TRUE(idxs[2]->flag);
@@ -171,7 +171,7 @@ TEST(ThreadedIndex, TestReplica) {
     // Try with threading and without
     for ([[maybe_unused]] const bool threaded : {true, false}) {
         std::vector<std::unique_ptr<MockIndex>> idxs;
-        faiss::IndexReplicas replica(d);
+        knowherefaiss::IndexReplicas replica(d);
 
         for (int i = 0; i < numReplicas; ++i) {
             idxs.emplace_back(new MockIndex(d));
@@ -180,7 +180,7 @@ TEST(ThreadedIndex, TestReplica) {
 
         std::vector<float> x(n * d);
         std::vector<float> distances(n * k);
-        std::vector<faiss::idx_t> labels(n * k);
+        std::vector<knowherefaiss::idx_t> labels(n * k);
 
         replica.add(n, x.data());
 
@@ -220,7 +220,7 @@ TEST(ThreadedIndex, TestShards) {
     // Try with threading and without
     for (bool threaded : {true, false}) {
         std::vector<std::unique_ptr<MockIndex>> idxs;
-        faiss::IndexShards shards(d, threaded);
+        knowherefaiss::IndexShards shards(d, threaded);
 
         for (int i = 0; i < numShards; ++i) {
             idxs.emplace_back(new MockIndex(d));
@@ -229,7 +229,7 @@ TEST(ThreadedIndex, TestShards) {
 
         std::vector<float> x(n * d);
         std::vector<float> distances(n * k);
-        std::vector<faiss::idx_t> labels(n * k);
+        std::vector<knowherefaiss::idx_t> labels(n * k);
 
         shards.add(n, x.data());
 
diff --git a/thirdparty/faiss/tests/test_transfer_invlists.cpp b/thirdparty/faiss/tests/test_transfer_invlists.cpp
index 309a331d..687cb915 100644
--- a/thirdparty/faiss/tests/test_transfer_invlists.cpp
+++ b/thirdparty/faiss/tests/test_transfer_invlists.cpp
@@ -11,15 +11,15 @@
 
 #include <gtest/gtest.h>
 
-#include <faiss/AutoTune.h>
-#include <faiss/IVFlib.h>
-#include <faiss/IndexIVFFlat.h>
-#include <faiss/VectorTransform.h>
-#include <faiss/clone_index.h>
-#include <faiss/impl/io.h>
-#include <faiss/index_factory.h>
-#include <faiss/index_io.h>
-#include <faiss/utils/random.h>
+#include <knowherefaiss/AutoTune.h>
+#include <knowherefaiss/IVFlib.h>
+#include <knowherefaiss/IndexIVFFlat.h>
+#include <knowherefaiss/VectorTransform.h>
+#include <knowherefaiss/clone_index.h>
+#include <knowherefaiss/impl/io.h>
+#include <knowherefaiss/index_factory.h>
+#include <knowherefaiss/index_io.h>
+#include <knowherefaiss/utils/random.h>
 
 namespace {
 
@@ -31,9 +31,9 @@ size_t nt = 500;
 int k = 10;
 int nlist = 40;
 
-using namespace faiss;
+using namespace knowherefaiss;
 
-typedef faiss::idx_t idx_t;
+typedef knowherefaiss::idx_t idx_t;
 
 std::vector<float> get_data(size_t nb, int seed) {
     std::vector<float> x(nb * d);
diff --git a/thirdparty/faiss/tests/test_util.h b/thirdparty/faiss/tests/test_util.h
index 3be0e35c..ebc4588d 100644
--- a/thirdparty/faiss/tests/test_util.h
+++ b/thirdparty/faiss/tests/test_util.h
@@ -8,7 +8,7 @@
 #ifndef FAISS_TEST_UTIL_H
 #define FAISS_TEST_UTIL_H
 
-#include <faiss/IndexIVFPQ.h>
+#include <knowherefaiss/IndexIVFPQ.h>
 #include <unistd.h>
 #include <cstdlib>
 
diff --git a/thirdparty/faiss/tutorial/cpp/1-Flat.cpp b/thirdparty/faiss/tutorial/cpp/1-Flat.cpp
index 147fa89b..b7fab3e2 100644
--- a/thirdparty/faiss/tutorial/cpp/1-Flat.cpp
+++ b/thirdparty/faiss/tutorial/cpp/1-Flat.cpp
@@ -9,10 +9,10 @@
 #include <cstdlib>
 #include <random>
 
-#include <faiss/IndexFlat.h>
+#include <knowherefaiss/IndexFlat.h>
 
 // 64-bit int
-using idx_t = faiss::idx_t;
+using idx_t = knowherefaiss::idx_t;
 
 int main() {
     int d = 64;      // dimension
@@ -37,7 +37,7 @@ int main() {
         xq[d * i] += i / 1000.;
     }
 
-    faiss::IndexFlatL2 index(d); // call constructor
+    knowherefaiss::IndexFlatL2 index(d); // call constructor
     printf("is_trained = %s\n", index.is_trained ? "true" : "false");
     index.add(nb, xb); // add vectors to the index
     printf("ntotal = %zd\n", index.ntotal);
diff --git a/thirdparty/faiss/tutorial/cpp/2-IVFFlat.cpp b/thirdparty/faiss/tutorial/cpp/2-IVFFlat.cpp
index 86530ae9..60961a09 100644
--- a/thirdparty/faiss/tutorial/cpp/2-IVFFlat.cpp
+++ b/thirdparty/faiss/tutorial/cpp/2-IVFFlat.cpp
@@ -10,10 +10,10 @@
 #include <cstdlib>
 #include <random>
 
-#include <faiss/IndexFlat.h>
-#include <faiss/IndexIVFFlat.h>
+#include <knowherefaiss/IndexFlat.h>
+#include <knowherefaiss/IndexIVFFlat.h>
 
-using idx_t = faiss::idx_t;
+using idx_t = knowherefaiss::idx_t;
 
 int main() {
     int d = 64;      // dimension
@@ -41,8 +41,8 @@ int main() {
     int nlist = 100;
     int k = 4;
 
-    faiss::IndexFlatL2 quantizer(d); // the other index
-    faiss::IndexIVFFlat index(&quantizer, d, nlist);
+    knowherefaiss::IndexFlatL2 quantizer(d); // the other index
+    knowherefaiss::IndexIVFFlat index(&quantizer, d, nlist);
     assert(!index.is_trained);
     index.train(nb, xb);
     assert(index.is_trained);
diff --git a/thirdparty/faiss/tutorial/cpp/3-IVFPQ.cpp b/thirdparty/faiss/tutorial/cpp/3-IVFPQ.cpp
index c84e52e8..63e893a3 100644
--- a/thirdparty/faiss/tutorial/cpp/3-IVFPQ.cpp
+++ b/thirdparty/faiss/tutorial/cpp/3-IVFPQ.cpp
@@ -9,10 +9,10 @@
 #include <cstdlib>
 #include <random>
 
-#include <faiss/IndexFlat.h>
-#include <faiss/IndexIVFPQ.h>
+#include <knowherefaiss/IndexFlat.h>
+#include <knowherefaiss/IndexIVFPQ.h>
 
-using idx_t = faiss::idx_t;
+using idx_t = knowherefaiss::idx_t;
 
 int main() {
     int d = 64;      // dimension
@@ -40,8 +40,8 @@ int main() {
     int nlist = 100;
     int k = 4;
     int m = 8;                       // bytes per vector
-    faiss::IndexFlatL2 quantizer(d); // the other index
-    faiss::IndexIVFPQ index(&quantizer, d, nlist, m, 8);
+    knowherefaiss::IndexFlatL2 quantizer(d); // the other index
+    knowherefaiss::IndexIVFPQ index(&quantizer, d, nlist, m, 8);
 
     index.train(nb, xb);
     index.add(nb, xb);
diff --git a/thirdparty/faiss/tutorial/cpp/4-GPU.cpp b/thirdparty/faiss/tutorial/cpp/4-GPU.cpp
index 158aefb5..acbe6c01 100644
--- a/thirdparty/faiss/tutorial/cpp/4-GPU.cpp
+++ b/thirdparty/faiss/tutorial/cpp/4-GPU.cpp
@@ -10,10 +10,10 @@
 #include <cstdlib>
 #include <random>
 
-#include <faiss/IndexFlat.h>
-#include <faiss/gpu/GpuIndexFlat.h>
-#include <faiss/gpu/GpuIndexIVFFlat.h>
-#include <faiss/gpu/StandardGpuResources.h>
+#include <knowherefaiss/IndexFlat.h>
+#include <knowherefaiss/gpu/GpuIndexFlat.h>
+#include <knowherefaiss/gpu/GpuIndexIVFFlat.h>
+#include <knowherefaiss/gpu/StandardGpuResources.h>
 
 int main() {
     int d = 64;      // dimension
@@ -38,11 +38,11 @@ int main() {
         xq[d * i] += i / 1000.;
     }
 
-    faiss::gpu::StandardGpuResources res;
+    knowherefaiss::gpu::StandardGpuResources res;
 
     // Using a flat index
 
-    faiss::gpu::GpuIndexFlatL2 index_flat(&res, d);
+    knowherefaiss::gpu::GpuIndexFlatL2 index_flat(&res, d);
 
     printf("is_trained = %s\n", index_flat.is_trained ? "true" : "false");
     index_flat.add(nb, xb); // add vectors to the index
@@ -78,7 +78,7 @@ int main() {
     // Using an IVF index
 
     int nlist = 100;
-    faiss::gpu::GpuIndexIVFFlat index_ivf(&res, d, nlist, faiss::METRIC_L2);
+    knowherefaiss::gpu::GpuIndexIVFFlat index_ivf(&res, d, nlist, knowherefaiss::METRIC_L2);
 
     assert(!index_ivf.is_trained);
     index_ivf.train(nb, xb);
diff --git a/thirdparty/faiss/tutorial/cpp/5-Multiple-GPUs.cpp b/thirdparty/faiss/tutorial/cpp/5-Multiple-GPUs.cpp
index 0872e60a..831202c3 100644
--- a/thirdparty/faiss/tutorial/cpp/5-Multiple-GPUs.cpp
+++ b/thirdparty/faiss/tutorial/cpp/5-Multiple-GPUs.cpp
@@ -9,12 +9,12 @@
 #include <cstdlib>
 #include <random>
 
-#include <faiss/IndexFlat.h>
-#include <faiss/gpu/GpuAutoTune.h>
-#include <faiss/gpu/GpuCloner.h>
-#include <faiss/gpu/GpuIndexFlat.h>
-#include <faiss/gpu/StandardGpuResources.h>
-#include <faiss/gpu/utils/DeviceUtils.h>
+#include <knowherefaiss/IndexFlat.h>
+#include <knowherefaiss/gpu/GpuAutoTune.h>
+#include <knowherefaiss/gpu/GpuCloner.h>
+#include <knowherefaiss/gpu/GpuIndexFlat.h>
+#include <knowherefaiss/gpu/StandardGpuResources.h>
+#include <knowherefaiss/gpu/utils/DeviceUtils.h>
 
 int main() {
     int d = 64;      // dimension
@@ -39,21 +39,21 @@ int main() {
         xq[d * i] += i / 1000.;
     }
 
-    int ngpus = faiss::gpu::getNumDevices();
+    int ngpus = knowherefaiss::gpu::getNumDevices();
 
     printf("Number of GPUs: %d\n", ngpus);
 
-    std::vector<faiss::gpu::GpuResourcesProvider*> res;
+    std::vector<knowherefaiss::gpu::GpuResourcesProvider*> res;
     std::vector<int> devs;
     for (int i = 0; i < ngpus; i++) {
-        res.push_back(new faiss::gpu::StandardGpuResources);
+        res.push_back(new knowherefaiss::gpu::StandardGpuResources);
         devs.push_back(i);
     }
 
-    faiss::IndexFlatL2 cpu_index(d);
+    knowherefaiss::IndexFlatL2 cpu_index(d);
 
-    faiss::Index* gpu_index =
-            faiss::gpu::index_cpu_to_gpu_multiple(res, devs, &cpu_index);
+    knowherefaiss::Index* gpu_index =
+            knowherefaiss::gpu::index_cpu_to_gpu_multiple(res, devs, &cpu_index);
 
     printf("is_trained = %s\n", gpu_index->is_trained ? "true" : "false");
     gpu_index->add(nb, xb); // add vectors to the index
diff --git a/thirdparty/faiss/tutorial/cpp/6-HNSW.cpp b/thirdparty/faiss/tutorial/cpp/6-HNSW.cpp
index 9bd8cd3f..06c078c1 100644
--- a/thirdparty/faiss/tutorial/cpp/6-HNSW.cpp
+++ b/thirdparty/faiss/tutorial/cpp/6-HNSW.cpp
@@ -10,9 +10,9 @@
 #include <cstdlib>
 #include <random>
 
-#include <faiss/IndexHNSW.h>
+#include <knowherefaiss/IndexHNSW.h>
 
-using idx_t = faiss::idx_t;
+using idx_t = knowherefaiss::idx_t;
 
 int main() {
     int d = 64;      // dimension
@@ -39,7 +39,7 @@ int main() {
 
     int k = 4;
 
-    faiss::IndexHNSWFlat index(d, 32);
+    knowherefaiss::IndexHNSWFlat index(d, 32);
     index.add(nb, xb);
 
     { // search xq
diff --git a/thirdparty/faiss/tutorial/cpp/7-PQFastScan.cpp b/thirdparty/faiss/tutorial/cpp/7-PQFastScan.cpp
index 4cdfea05..586ebb08 100644
--- a/thirdparty/faiss/tutorial/cpp/7-PQFastScan.cpp
+++ b/thirdparty/faiss/tutorial/cpp/7-PQFastScan.cpp
@@ -10,9 +10,9 @@
 #include <cstdlib>
 #include <random>
 
-#include <faiss/IndexPQFastScan.h>
+#include <knowherefaiss/IndexPQFastScan.h>
 
-using idx_t = faiss::idx_t;
+using idx_t = knowherefaiss::idx_t;
 
 int main() {
     int d = 64;      // dimension
@@ -42,7 +42,7 @@ int main() {
     int m = 8;
     int n_bit = 4;
 
-    faiss::IndexPQFastScan index(d, m, n_bit);
+    knowherefaiss::IndexPQFastScan index(d, m, n_bit);
     printf("Index is trained? %s\n", index.is_trained ? "true" : "false");
     index.train(nb, xb);
     printf("Index is trained? %s\n", index.is_trained ? "true" : "false");
diff --git a/thirdparty/faiss/tutorial/cpp/8-PQFastScanRefine.cpp b/thirdparty/faiss/tutorial/cpp/8-PQFastScanRefine.cpp
index 2435d94d..a5dc9e05 100644
--- a/thirdparty/faiss/tutorial/cpp/8-PQFastScanRefine.cpp
+++ b/thirdparty/faiss/tutorial/cpp/8-PQFastScanRefine.cpp
@@ -10,10 +10,10 @@
 #include <cstdlib>
 #include <random>
 
-#include <faiss/IndexPQFastScan.h>
-#include <faiss/IndexRefine.h>
+#include <knowherefaiss/IndexPQFastScan.h>
+#include <knowherefaiss/IndexRefine.h>
 
-using idx_t = faiss::idx_t;
+using idx_t = knowherefaiss::idx_t;
 
 int main() {
     int d = 64;      // dimension
@@ -43,8 +43,8 @@ int main() {
     int m = 8;
     int n_bit = 4;
 
-    faiss::IndexPQFastScan index(d, m, n_bit);
-    faiss::IndexRefineFlat index_refine(&index);
+    knowherefaiss::IndexPQFastScan index(d, m, n_bit);
+    knowherefaiss::IndexRefineFlat index_refine(&index);
     // refine index after PQFastScan
 
     printf("Index is trained? %s\n",
@@ -59,8 +59,8 @@ int main() {
         idx_t* I = new idx_t[(int)(k * nq)];
         float* D = new float[(int)(k * nq)];
         float k_factor = 3;
-        faiss::IndexRefineSearchParameters* params =
-                new faiss::IndexRefineSearchParameters();
+        knowherefaiss::IndexRefineSearchParameters* params =
+                new knowherefaiss::IndexRefineSearchParameters();
         params->k_factor = k_factor;
         index_refine.search(nq, xq, k, D, I, params);
 
diff --git a/thirdparty/faiss/tutorial/cpp/9-RefineComparison.cpp b/thirdparty/faiss/tutorial/cpp/9-RefineComparison.cpp
index d7fbc90a..d68d72d0 100644
--- a/thirdparty/faiss/tutorial/cpp/9-RefineComparison.cpp
+++ b/thirdparty/faiss/tutorial/cpp/9-RefineComparison.cpp
@@ -10,10 +10,10 @@
 #include <cstdlib>
 #include <random>
 
-#include <faiss/IndexPQFastScan.h>
-#include <faiss/IndexRefine.h>
-#include <faiss/index_factory.h>
-using idx_t = faiss::idx_t;
+#include <knowherefaiss/IndexPQFastScan.h>
+#include <knowherefaiss/IndexRefine.h>
+#include <knowherefaiss/index_factory.h>
+using idx_t = knowherefaiss::idx_t;
 
 int main() {
     int d = 64;      // dimension
@@ -41,16 +41,16 @@ int main() {
     }
 
     // Constructing the refine PQ index with SQfp16 with index factory
-    faiss::Index* index_fp16;
-    index_fp16 = faiss::index_factory(
-            d, "PQ32x4fs,Refine(SQfp16)", faiss::METRIC_L2);
+    knowherefaiss::Index* index_fp16;
+    index_fp16 = knowherefaiss::index_factory(
+            d, "PQ32x4fs,Refine(SQfp16)", knowherefaiss::METRIC_L2);
     index_fp16->train(nb, xb);
     index_fp16->add(nb, xb);
 
     // Constructing the refine PQ index with SQ8
-    faiss::Index* index_sq8;
+    knowherefaiss::Index* index_sq8;
     index_sq8 =
-            faiss::index_factory(d, "PQ32x4fs,Refine(SQ8)", faiss::METRIC_L2);
+            knowherefaiss::index_factory(d, "PQ32x4fs,Refine(SQ8)", knowherefaiss::METRIC_L2);
     index_sq8->train(nb, xb);
     index_sq8->add(nb, xb);
 
@@ -63,8 +63,8 @@ int main() {
 
         // Parameterization on k factor while doing search for index refinement
         float k_factor = 3;
-        faiss::IndexRefineSearchParameters* params =
-                new faiss::IndexRefineSearchParameters();
+        knowherefaiss::IndexRefineSearchParameters* params =
+                new knowherefaiss::IndexRefineSearchParameters();
         params->k_factor = k_factor;
 
         // Perform index search using different index refinement
diff --git a/thirdparty/hnswlib/hnswlib/space_cosine.h b/thirdparty/hnswlib/hnswlib/space_cosine.h
index a3b35b3b..2dbfa32d 100644
--- a/thirdparty/hnswlib/hnswlib/space_cosine.h
+++ b/thirdparty/hnswlib/hnswlib/space_cosine.h
@@ -9,11 +9,11 @@ template <typename DataType, typename DistanceType>
 static DistanceType
 Cosine(const void* pVect1, const void* pVect2, const void* qty_ptr) {
     if constexpr (std::is_same_v<DataType, knowhere::fp32>) {
-        return faiss::fvec_inner_product((const DataType*)pVect1, (const DataType*)pVect2, *((size_t*)qty_ptr));
+        return knowherefaiss::fvec_inner_product((const DataType*)pVect1, (const DataType*)pVect2, *((size_t*)qty_ptr));
     } else if constexpr (std::is_same_v<DataType, knowhere::fp16>) {
-        return faiss::fp16_vec_inner_product((const DataType*)pVect1, (const DataType*)pVect2, *((size_t*)qty_ptr));
+        return knowherefaiss::fp16_vec_inner_product((const DataType*)pVect1, (const DataType*)pVect2, *((size_t*)qty_ptr));
     } else if constexpr (std::is_same_v<DataType, knowhere::bf16>) {
-        return faiss::bf16_vec_inner_product((const DataType*)pVect1, (const DataType*)pVect2, *((size_t*)qty_ptr));
+        return knowherefaiss::bf16_vec_inner_product((const DataType*)pVect1, (const DataType*)pVect2, *((size_t*)qty_ptr));
     } else {
         throw std::runtime_error("Unknown Datatype\n");
     }
@@ -27,7 +27,7 @@ CosineDistance(const void* pVect1, const void* pVect2, const void* qty_ptr) {
 
 static inline float
 CosineSQ8Distance(const void* pVect1, const void* pVect2, const void* qty_ptr) {
-    return -1.0f * faiss::ivec_inner_product((const int8_t*)pVect1, (const int8_t*)pVect2, *(size_t*)qty_ptr);
+    return -1.0f * knowherefaiss::ivec_inner_product((const int8_t*)pVect1, (const int8_t*)pVect2, *(size_t*)qty_ptr);
 }
 
 template <typename DataType, typename DistanceType>
diff --git a/thirdparty/hnswlib/hnswlib/space_hamming.h b/thirdparty/hnswlib/hnswlib/space_hamming.h
index 6fc490c2..f9cf78f3 100644
--- a/thirdparty/hnswlib/hnswlib/space_hamming.h
+++ b/thirdparty/hnswlib/hnswlib/space_hamming.h
@@ -1,6 +1,6 @@
 #pragma once
 
-#include <faiss/utils/binary_distances.h>
+#include <knowherefaiss/utils/binary_distances.h>
 
 #include "hnswlib.h"
 
@@ -8,7 +8,7 @@ namespace hnswlib {
 
 static float
 Hamming(const void* pVect1v, const void* pVect2v, const void* qty_ptr) {
-    return faiss::xor_popcnt((const uint8_t*)pVect1v, (const uint8_t*)pVect2v, *((size_t*)qty_ptr) / 8);
+    return knowherefaiss::xor_popcnt((const uint8_t*)pVect1v, (const uint8_t*)pVect2v, *((size_t*)qty_ptr) / 8);
 }
 
 class HammingSpace : public SpaceInterface<float> {
diff --git a/thirdparty/hnswlib/hnswlib/space_ip.h b/thirdparty/hnswlib/hnswlib/space_ip.h
index 0ce7f46c..c892e22e 100644
--- a/thirdparty/hnswlib/hnswlib/space_ip.h
+++ b/thirdparty/hnswlib/hnswlib/space_ip.h
@@ -9,11 +9,11 @@ template <typename DataType, typename DistanceType>
 static DistanceType
 InnerProduct(const void* pVect1, const void* pVect2, const void* qty_ptr) {
     if constexpr (std::is_same_v<DataType, knowhere::fp32>) {
-        return faiss::fvec_inner_product((const DataType*)pVect1, (const DataType*)pVect2, *((size_t*)qty_ptr));
+        return knowherefaiss::fvec_inner_product((const DataType*)pVect1, (const DataType*)pVect2, *((size_t*)qty_ptr));
     } else if constexpr (std::is_same_v<DataType, knowhere::fp16>) {
-        return faiss::fp16_vec_inner_product((const DataType*)pVect1, (const DataType*)pVect2, *((size_t*)qty_ptr));
+        return knowherefaiss::fp16_vec_inner_product((const DataType*)pVect1, (const DataType*)pVect2, *((size_t*)qty_ptr));
     } else if constexpr (std::is_same_v<DataType, knowhere::bf16>) {
-        return faiss::bf16_vec_inner_product((const DataType*)pVect1, (const DataType*)pVect2, *((size_t*)qty_ptr));
+        return knowherefaiss::bf16_vec_inner_product((const DataType*)pVect1, (const DataType*)pVect2, *((size_t*)qty_ptr));
     } else {
         throw std::runtime_error("Unknown Datatype\n");
     }
@@ -27,7 +27,7 @@ InnerProductDistance(const void* pVect1, const void* pVect2, const void* qty_ptr
 
 static inline float
 InnerProductSQ8Distance(const void* pVect1, const void* pVect2, const void* qty_ptr) {
-    return -1.0f * faiss::ivec_inner_product((const int8_t*)pVect1, (const int8_t*)pVect2, *(size_t*)qty_ptr);
+    return -1.0f * knowherefaiss::ivec_inner_product((const int8_t*)pVect1, (const int8_t*)pVect2, *(size_t*)qty_ptr);
 }
 
 #if defined(USE_AVX)
diff --git a/thirdparty/hnswlib/hnswlib/space_jaccard.h b/thirdparty/hnswlib/hnswlib/space_jaccard.h
index a0c3f12d..15ffdbad 100644
--- a/thirdparty/hnswlib/hnswlib/space_jaccard.h
+++ b/thirdparty/hnswlib/hnswlib/space_jaccard.h
@@ -1,6 +1,6 @@
 #pragma once
 
-#include <faiss/utils/binary_distances.h>
+#include <knowherefaiss/utils/binary_distances.h>
 
 #include "hnswlib.h"
 
@@ -8,7 +8,7 @@ namespace hnswlib {
 
 static float
 Jaccard(const void* pVect1v, const void* pVect2v, const void* qty_ptr) {
-    return faiss::bvec_jaccard((const uint8_t*)pVect1v, (const uint8_t*)pVect2v, *((size_t*)qty_ptr) / 8);
+    return knowherefaiss::bvec_jaccard((const uint8_t*)pVect1v, (const uint8_t*)pVect2v, *((size_t*)qty_ptr) / 8);
 }
 
 class JaccardSpace : public SpaceInterface<float> {
diff --git a/thirdparty/hnswlib/hnswlib/space_l2.h b/thirdparty/hnswlib/hnswlib/space_l2.h
index 6bac0ff1..665f6e43 100644
--- a/thirdparty/hnswlib/hnswlib/space_l2.h
+++ b/thirdparty/hnswlib/hnswlib/space_l2.h
@@ -9,11 +9,11 @@ template <typename DataType, typename DistanceType>
 static DistanceType
 NormSqr(const void* pVect1v, const void* qty_ptr) {
     if constexpr (std::is_same_v<DataType, knowhere::fp32>) {
-        return faiss::fvec_norm_L2sqr((const DataType*)pVect1v, *(size_t*)(qty_ptr));
+        return knowherefaiss::fvec_norm_L2sqr((const DataType*)pVect1v, *(size_t*)(qty_ptr));
     } else if constexpr (std::is_same_v<DataType, knowhere::fp16>) {
-        return faiss::fp16_vec_norm_L2sqr((const DataType*)pVect1v, *(size_t*)(qty_ptr));
+        return knowherefaiss::fp16_vec_norm_L2sqr((const DataType*)pVect1v, *(size_t*)(qty_ptr));
     } else if constexpr (std::is_same_v<DataType, knowhere::bf16>) {
-        return faiss::bf16_vec_norm_L2sqr((const DataType*)pVect1v, *(size_t*)(qty_ptr));
+        return knowherefaiss::bf16_vec_norm_L2sqr((const DataType*)pVect1v, *(size_t*)(qty_ptr));
     } else {
         throw std::runtime_error("Unknown Datatype\n");
     }
@@ -23,11 +23,11 @@ template <typename DataType, typename DistanceType>
 static DistanceType
 L2Sqr(const void* pVect1v, const void* pVect2v, const void* qty_ptr) {
     if constexpr (std::is_same_v<DataType, knowhere::fp32>) {
-        return faiss::fvec_L2sqr((const DataType*)pVect1v, (const DataType*)pVect2v, *((size_t*)qty_ptr));
+        return knowherefaiss::fvec_L2sqr((const DataType*)pVect1v, (const DataType*)pVect2v, *((size_t*)qty_ptr));
     } else if constexpr (std::is_same_v<DataType, knowhere::fp16>) {
-        return faiss::fp16_vec_L2sqr((const DataType*)pVect1v, (const DataType*)pVect2v, *((size_t*)qty_ptr));
+        return knowherefaiss::fp16_vec_L2sqr((const DataType*)pVect1v, (const DataType*)pVect2v, *((size_t*)qty_ptr));
     } else if constexpr (std::is_same_v<DataType, knowhere::bf16>) {
-        return faiss::bf16_vec_L2sqr((const DataType*)pVect1v, (const DataType*)pVect2v, *((size_t*)qty_ptr));
+        return knowherefaiss::bf16_vec_L2sqr((const DataType*)pVect1v, (const DataType*)pVect2v, *((size_t*)qty_ptr));
     } else {
         throw std::runtime_error("Unknown Datatype\n");
     }
@@ -35,7 +35,7 @@ L2Sqr(const void* pVect1v, const void* pVect2v, const void* qty_ptr) {
 
 static inline float
 L2SqrSQ8(const void* pVect1v, const void* pVect2v, const void* qty_ptr) {
-    return faiss::ivec_L2sqr((const int8_t*)pVect1v, (const int8_t*)pVect2v, *(size_t*)qty_ptr);
+    return knowherefaiss::ivec_L2sqr((const int8_t*)pVect1v, (const int8_t*)pVect2v, *(size_t*)qty_ptr);
 }
 
 #if defined(USE_AVX512)
-- 
2.45.1.windows.1


From 08fd961ff7638e7698336670e2700a3ccfd30284 Mon Sep 17 00:00:00 2001
From: qanly97 <maqianli20@h-partners.com>
Date: Thu, 6 Nov 2025 19:47:53 +0800
Subject: [PATCH 2/7] =?UTF-8?q?=E5=BA=94=E7=94=A8=20knowhere-v2.2.2-ascend?=
 =?UTF-8?q?=20=E7=9A=84=E4=BF=AE=E6=94=B9=E5=B9=B6=E5=BE=AE=E8=B0=83?=
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

---
 CMakeLists.txt                 |  6 ++++--
 conanfile.py                   |  2 +-
 readme.en.md                   |  3 +++
 readme.zh.md                   |  3 +++
 src/common/comp/brute_force.cc | 23 +++++++++++++++++++++++
 5 files changed, 34 insertions(+), 3 deletions(-)
 create mode 100644 readme.en.md
 create mode 100644 readme.zh.md

diff --git a/CMakeLists.txt b/CMakeLists.txt
index ca7cb909..c7d4f445 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -15,6 +15,7 @@
 cmake_minimum_required(VERSION 3.26.4 FATAL_ERROR)
 project(knowhere CXX C)
 set(CMAKE_EXPORT_COMPILE_COMMANDS ON)
+set(CMAKE_SKIP_BUILD_RPATH TRUE)
 list(APPEND CMAKE_MODULE_PATH "${CMAKE_CURRENT_SOURCE_DIR}/cmake/modules/")
 include(GNUInstallDirs)
 include(ExternalProject)
@@ -86,6 +87,7 @@ include(cmake/utils/platform_check.cmake)
 include(cmake/utils/compile_flags.cmake)
 include(cmake/libs/libfaiss.cmake)
 include(cmake/libs/libhnsw.cmake)
+include(cmake/libs/libascend.cmake)
 
 include_directories(thirdparty/faiss)
 
@@ -166,7 +168,7 @@ else()
 endif()
 
 knowhere_file_glob(GLOB_RECURSE KNOWHERE_GPU_SRCS src/index/gpu/flat_gpu/*.cc
-                   src/index/gpu/ivf_gpu/*.cc)
+                   src/index/gpu/ivf_gpu/*.cc src/common/ascend/*.cc)
 list(REMOVE_ITEM KNOWHERE_SRCS ${KNOWHERE_GPU_SRCS})
 
 if(NOT WITH_CUVS)
@@ -209,7 +211,7 @@ if(WITH_CUVS)
     CUDA::cusparse
     CUDA::cusolver)
 endif()
-target_link_libraries(knowhere PUBLIC ${KNOWHERE_LINKER_LIBS})
+target_link_libraries(knowhere PUBLIC ${KNOWHERE_LINKER_LIBS} ${ASCEND_LIBS})
 target_include_directories(knowhere PUBLIC ${CMAKE_CURRENT_SOURCE_DIR}/include)
 
 if(WITH_UT)
diff --git a/conanfile.py b/conanfile.py
index 456832f6..2a26c033 100644
--- a/conanfile.py
+++ b/conanfile.py
@@ -94,7 +94,7 @@ class KnowhereConan(ConanFile):
 
     def requirements(self):
         self.requires("boost/1.83.0")
-        self.requires("glog/0.6.0")
+        # self.requires("glog/0.6.0")
         self.requires("nlohmann_json/3.11.2")
         self.requires("openssl/1.1.1t")
         self.requires("prometheus-cpp/1.1.0")
diff --git a/readme.en.md b/readme.en.md
new file mode 100644
index 00000000..d3d2c6a0
--- /dev/null
+++ b/readme.en.md
@@ -0,0 +1,3 @@
+## Disclaimer
+
+The reference design is not a commercial release product and is only for the reference of users. If it is needed, users need to complete the productization by themselves and carry out security protection. Huawei does not assume security responsibility.
\ No newline at end of file
diff --git a/readme.zh.md b/readme.zh.md
new file mode 100644
index 00000000..70fc4ebc
--- /dev/null
+++ b/readme.zh.md
@@ -0,0 +1,3 @@
+## 
+
+
\ No newline at end of file
diff --git a/src/common/comp/brute_force.cc b/src/common/comp/brute_force.cc
index 7acc67a5..26a13f58 100644
--- a/src/common/comp/brute_force.cc
+++ b/src/common/comp/brute_force.cc
@@ -172,6 +172,8 @@ template <typename DataType>
 expected<DataSetPtr>
 BruteForce::Search(const DataSetPtr base_dataset, const DataSetPtr query_dataset, const Json& config,
                    const BitsetView& bitset_) {
+    LOG_KNOWHERE_INFO_ << __FILE__ << ":" << __LINE__ << ": BruteForce::Search "
+        << std::this_thread::get_id();
     BruteForceConfig cfg;
     std::string msg;
     auto status = Config::Load(cfg, config, knowhere::SEARCH, &msg);
@@ -197,14 +199,19 @@ template <typename DataType>
 Status
 BruteForce::SearchWithBuf(const DataSetPtr base_dataset, const DataSetPtr query_dataset, int64_t* ids, float* dis,
                           const Json& config, const BitsetView& bitset) {
+    double ts = GetMillisecs();
     auto xb = base_dataset->GetTensor();
     auto nb = base_dataset->GetRows();
     auto dim = base_dataset->GetDim();
     auto xb_id_offset = base_dataset->GetTensorBeginId();
+    auto ascend_index_type = base_dataset->GetAscendIndexType();
 
     auto xq = query_dataset->GetTensor();
     auto nq = query_dataset->GetRows();
 
+    auto funcLess = [](const float a, const float b) -> bool const { return a < b; };
+    auto funcGreater = [](const float a, const float b) -> bool const { return a > b; };
+
     BruteForceConfig cfg;
     RETURN_IF_ERROR(Config::Load(cfg, config, knowhere::SEARCH));
 
@@ -237,6 +244,10 @@ BruteForce::SearchWithBuf(const DataSetPtr base_dataset, const DataSetPtr query_
     int topk = cfg.k.value();
     auto labels = ids;
     auto distances = dis;
+
+    LOG_KNOWHERE_INFO_ << __FILE__ << ":" << __LINE__ << ": BruteForce::SearchWithBuf " << std::this_thread::get_id()
+        << " nb:" << nb << " nq:" << nq << " topk:" << topk;
+
     // some check for minhash metric
     if (faiss_metric_type == knowherefaiss::METRIC_MinHash_Jaccard) {
         auto labels = ids;
@@ -293,6 +304,10 @@ BruteForce::SearchWithBuf(const DataSetPtr base_dataset, const DataSetPtr query_
                             LOG_KNOWHERE_ERROR_ << "Metric L2 not supported for current vector type";
                             return Status::faiss_inner_error;
                         }
+                        if (ascend_index_type == "ASCEND_FLAT_INT8") {
+                            ReComputeTopKResult(topk, dim, static_cast<const float*>(xb), cur_query,
+                                                cur_labels, cur_distances, funcLess);
+                        }
                         break;
                     }
                     case knowherefaiss::METRIC_INNER_PRODUCT: {
@@ -322,6 +337,11 @@ BruteForce::SearchWithBuf(const DataSetPtr base_dataset, const DataSetPtr query_
                                 return Status::faiss_inner_error;
                             }
                         }
+                        // ascend indexscore
+                        if (ascend_index_type == "ASCEND_FLAT_INT8") {
+                            ReComputeTopKResult(topk, dim, static_cast<const float*>(xb), cur_query,
+                                                cur_labels, cur_distances, funcGreater);
+                        }
                         break;
                     }
                     case knowherefaiss::METRIC_Jaccard: {
@@ -355,6 +375,9 @@ BruteForce::SearchWithBuf(const DataSetPtr base_dataset, const DataSetPtr query_
                         return Status::invalid_metric_type;
                     }
                 }
+                double te = GetMillisecs();
+                LOG_KNOWHERE_INFO_ << __FILE__ << ":" << __LINE__ << ": BruteForce::SearchWithBuf " << std::this_thread::get_id()
+                    << " time:" << te - ts;
                 return Status::success;
             }));
         }
-- 
2.45.1.windows.1


From b30e86f57868739ebd4f92ae1cf2e706e77b1b56 Mon Sep 17 00:00:00 2001
From: qanly97 <maqianli20@h-partners.com>
Date: Thu, 6 Nov 2025 20:01:14 +0800
Subject: [PATCH 3/7] =?UTF-8?q?=E5=90=8D=E7=A7=B0=E4=BF=AE=E6=94=B9?=
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

---
 benchmark/hdf5/benchmark_simd_qps.cpp | 56 +++++++++++++--------------
 cmake/libs/libfaiss.cmake             |  2 +-
 2 files changed, 29 insertions(+), 29 deletions(-)

diff --git a/benchmark/hdf5/benchmark_simd_qps.cpp b/benchmark/hdf5/benchmark_simd_qps.cpp
index 19cfcaf5..9559f3d1 100644
--- a/benchmark/hdf5/benchmark_simd_qps.cpp
+++ b/benchmark/hdf5/benchmark_simd_qps.cpp
@@ -65,22 +65,22 @@ class Benchmark_simd_qps : public Benchmark_knowhere, public ::testing::Test {
             for (int32_t j = 0; j < nb; j++) {
                 const T* y = xb + j * dim;
                 if constexpr (std::is_same_v<T, knowhere::fp32>) {
-                    auto d = faiss::fvec_inner_product(x, y, dim);
+                    auto d = knowherefaiss::fvec_inner_product(x, y, dim);
                     if (dist) {
                         dist[(start + i) * nb + j] = d;
                     }
                 } else if constexpr (std::is_same_v<T, knowhere::fp16>) {
-                    auto d = faiss::fp16_vec_inner_product(x, y, dim);
+                    auto d = knowherefaiss::fp16_vec_inner_product(x, y, dim);
                     if (dist) {
                         dist[(start + i) * nb + j] = d;
                     }
                 } else if constexpr (std::is_same_v<T, knowhere::bf16>) {
-                    auto d = faiss::bf16_vec_inner_product(x, y, dim);
+                    auto d = knowherefaiss::bf16_vec_inner_product(x, y, dim);
                     if (dist) {
                         dist[(start + i) * nb + j] = d;
                     }
                 } else if constexpr (std::is_same_v<T, knowhere::int8>) {
-                    auto d = faiss::int8_vec_inner_product(x, y, dim);
+                    auto d = knowherefaiss::int8_vec_inner_product(x, y, dim);
                     if (dist) {
                         dist[(start + i) * nb + j] = d;
                     }
@@ -106,22 +106,22 @@ class Benchmark_simd_qps : public Benchmark_knowhere, public ::testing::Test {
             for (int32_t j = 0; j < nb; j++) {
                 const T* y = xb + j * dim;
                 if constexpr (std::is_same_v<T, knowhere::fp32>) {
-                    auto d = faiss::fvec_L2sqr(x, y, dim);
+                    auto d = knowherefaiss::fvec_L2sqr(x, y, dim);
                     if (dist) {
                         dist[(start + i) * nb + j] = d;
                     }
                 } else if constexpr (std::is_same_v<T, knowhere::fp16>) {
-                    auto d = faiss::fp16_vec_L2sqr(x, y, dim);
+                    auto d = knowherefaiss::fp16_vec_L2sqr(x, y, dim);
                     if (dist) {
                         dist[(start + i) * nb + j] = d;
                     }
                 } else if constexpr (std::is_same_v<T, knowhere::bf16>) {
-                    auto d = faiss::bf16_vec_L2sqr(x, y, dim);
+                    auto d = knowherefaiss::bf16_vec_L2sqr(x, y, dim);
                     if (dist) {
                         dist[(start + i) * nb + j] = d;
                     }
                 } else if constexpr (std::is_same_v<T, knowhere::int8>) {
-                    auto d = faiss::int8_vec_L2sqr(x, y, dim);
+                    auto d = knowherefaiss::int8_vec_L2sqr(x, y, dim);
                     if (dist) {
                         dist[(start + i) * nb + j] = d;
                     }
@@ -144,22 +144,22 @@ class Benchmark_simd_qps : public Benchmark_knowhere, public ::testing::Test {
             for (int32_t j = 0; j < nb; j++) {
                 const T* y = xb + j * dim;
                 if constexpr (std::is_same_v<T, knowhere::fp32>) {
-                    auto d = faiss::fvec_norm_L2sqr(y, dim);
+                    auto d = knowherefaiss::fvec_norm_L2sqr(y, dim);
                     if (dist) {
                         dist[(start + i) * nb + j] = d;
                     }
                 } else if constexpr (std::is_same_v<T, knowhere::fp16>) {
-                    auto d = faiss::fp16_vec_norm_L2sqr(y, dim);
+                    auto d = knowherefaiss::fp16_vec_norm_L2sqr(y, dim);
                     if (dist) {
                         dist[(start + i) * nb + j] = d;
                     }
                 } else if constexpr (std::is_same_v<T, knowhere::bf16>) {
-                    auto d = faiss::bf16_vec_norm_L2sqr(y, dim);
+                    auto d = knowherefaiss::bf16_vec_norm_L2sqr(y, dim);
                     if (dist) {
                         dist[(start + i) * nb + j] = d;
                     }
                 } else if constexpr (std::is_same_v<T, knowhere::int8>) {
-                    auto d = faiss::int8_vec_norm_L2sqr(y, dim);
+                    auto d = knowherefaiss::int8_vec_norm_L2sqr(y, dim);
                     if (dist) {
                         dist[(start + i) * nb + j] = d;
                     }
@@ -186,45 +186,45 @@ class Benchmark_simd_qps : public Benchmark_knowhere, public ::testing::Test {
                 const T* y = xb + j * dim;
                 if constexpr (std::is_same_v<T, knowhere::fp32>) {
                     if (dist) {
-                        faiss::fvec_inner_product_batch_4(x, y, y + dim, y + 2 * dim, y + 3 * dim, dim,
+                        knowherefaiss::fvec_inner_product_batch_4(x, y, y + dim, y + 2 * dim, y + 3 * dim, dim,
                                                           dist[(start + i) * nb + j], dist[(start + i) * nb + j + 1],
                                                           dist[(start + i) * nb + j + 2],
                                                           dist[(start + i) * nb + j + 3]);
                     } else {
                         float d0, d1, d2, d3;
-                        faiss::fvec_inner_product_batch_4(x, y, y + dim, y + 2 * dim, y + 3 * dim, dim, d0, d1, d2, d3);
+                        knowherefaiss::fvec_inner_product_batch_4(x, y, y + dim, y + 2 * dim, y + 3 * dim, dim, d0, d1, d2, d3);
                     }
                 } else if constexpr (std::is_same_v<T, knowhere::fp16>) {
                     if (dist) {
-                        faiss::fp16_vec_inner_product_batch_4(
+                        knowherefaiss::fp16_vec_inner_product_batch_4(
                             x, y, y + dim, y + 2 * dim, y + 3 * dim, dim, dist[(start + i) * nb + j],
                             dist[(start + i) * nb + j + 1], dist[(start + i) * nb + j + 2],
                             dist[(start + i) * nb + j + 3]);
                     } else {
                         float d0, d1, d2, d3;
-                        faiss::fp16_vec_inner_product_batch_4(x, y, y + dim, y + 2 * dim, y + 3 * dim, dim, d0, d1, d2,
+                        knowherefaiss::fp16_vec_inner_product_batch_4(x, y, y + dim, y + 2 * dim, y + 3 * dim, dim, d0, d1, d2,
                                                               d3);
                     }
                 } else if constexpr (std::is_same_v<T, knowhere::bf16>) {
                     if (dist) {
-                        faiss::bf16_vec_inner_product_batch_4(
+                        knowherefaiss::bf16_vec_inner_product_batch_4(
                             x, y, y + dim, y + 2 * dim, y + 3 * dim, dim, dist[(start + i) * nb + j],
                             dist[(start + i) * nb + j + 1], dist[(start + i) * nb + j + 2],
                             dist[(start + i) * nb + j + 3]);
                     } else {
                         float d0, d1, d2, d3;
-                        faiss::bf16_vec_inner_product_batch_4(x, y, y + dim, y + 2 * dim, y + 3 * dim, dim, d0, d1, d2,
+                        knowherefaiss::bf16_vec_inner_product_batch_4(x, y, y + dim, y + 2 * dim, y + 3 * dim, dim, d0, d1, d2,
                                                               d3);
                     }
                 } else if constexpr (std::is_same_v<T, knowhere::int8>) {
                     if (dist) {
-                        faiss::int8_vec_inner_product_batch_4(
+                        knowherefaiss::int8_vec_inner_product_batch_4(
                             x, y, y + dim, y + 2 * dim, y + 3 * dim, dim, dist[(start + i) * nb + j],
                             dist[(start + i) * nb + j + 1], dist[(start + i) * nb + j + 2],
                             dist[(start + i) * nb + j + 3]);
                     } else {
                         float d0, d1, d2, d3;
-                        faiss::int8_vec_inner_product_batch_4(x, y, y + dim, y + 2 * dim, y + 3 * dim, dim, d0, d1, d2,
+                        knowherefaiss::int8_vec_inner_product_batch_4(x, y, y + dim, y + 2 * dim, y + 3 * dim, dim, d0, d1, d2,
                                                               d3);
                     }
                 }
@@ -250,39 +250,39 @@ class Benchmark_simd_qps : public Benchmark_knowhere, public ::testing::Test {
                 const T* y = xb + j * dim;
                 if constexpr (std::is_same_v<T, knowhere::fp32>) {
                     if (dist) {
-                        faiss::fvec_L2sqr_batch_4(x, y, y + dim, y + 2 * dim, y + 3 * dim, dim,
+                        knowherefaiss::fvec_L2sqr_batch_4(x, y, y + dim, y + 2 * dim, y + 3 * dim, dim,
                                                   dist[(start + i) * nb + j], dist[(start + i) * nb + j + 1],
                                                   dist[(start + i) * nb + j + 2], dist[(start + i) * nb + j + 3]);
                     } else {
                         float d0, d1, d2, d3;
-                        faiss::fvec_L2sqr_batch_4(x, y, y + dim, y + 2 * dim, y + 3 * dim, dim, d0, d1, d2, d3);
+                        knowherefaiss::fvec_L2sqr_batch_4(x, y, y + dim, y + 2 * dim, y + 3 * dim, dim, d0, d1, d2, d3);
                     }
                 } else if constexpr (std::is_same_v<T, knowhere::fp16>) {
                     if (dist) {
-                        faiss::fp16_vec_L2sqr_batch_4(x, y, y + dim, y + 2 * dim, y + 3 * dim, dim,
+                        knowherefaiss::fp16_vec_L2sqr_batch_4(x, y, y + dim, y + 2 * dim, y + 3 * dim, dim,
                                                       dist[(start + i) * nb + j], dist[(start + i) * nb + j + 1],
                                                       dist[(start + i) * nb + j + 2], dist[(start + i) * nb + j + 3]);
                     } else {
                         float d0, d1, d2, d3;
-                        faiss::fp16_vec_L2sqr_batch_4(x, y, y + dim, y + 2 * dim, y + 3 * dim, dim, d0, d1, d2, d3);
+                        knowherefaiss::fp16_vec_L2sqr_batch_4(x, y, y + dim, y + 2 * dim, y + 3 * dim, dim, d0, d1, d2, d3);
                     }
                 } else if constexpr (std::is_same_v<T, knowhere::bf16>) {
                     if (dist) {
-                        faiss::bf16_vec_L2sqr_batch_4(x, y, y + dim, y + 2 * dim, y + 3 * dim, dim,
+                        knowherefaiss::bf16_vec_L2sqr_batch_4(x, y, y + dim, y + 2 * dim, y + 3 * dim, dim,
                                                       dist[(start + i) * nb + j], dist[(start + i) * nb + j + 1],
                                                       dist[(start + i) * nb + j + 2], dist[(start + i) * nb + j + 3]);
                     } else {
                         float d0, d1, d2, d3;
-                        faiss::bf16_vec_L2sqr_batch_4(x, y, y + dim, y + 2 * dim, y + 3 * dim, dim, d0, d1, d2, d3);
+                        knowherefaiss::bf16_vec_L2sqr_batch_4(x, y, y + dim, y + 2 * dim, y + 3 * dim, dim, d0, d1, d2, d3);
                     }
                 } else if constexpr (std::is_same_v<T, knowhere::int8>) {
                     if (dist) {
-                        faiss::int8_vec_L2sqr_batch_4(x, y, y + dim, y + 2 * dim, y + 3 * dim, dim,
+                        knowherefaiss::int8_vec_L2sqr_batch_4(x, y, y + dim, y + 2 * dim, y + 3 * dim, dim,
                                                       dist[(start + i) * nb + j], dist[(start + i) * nb + j + 1],
                                                       dist[(start + i) * nb + j + 2], dist[(start + i) * nb + j + 3]);
                     } else {
                         float d0, d1, d2, d3;
-                        faiss::int8_vec_L2sqr_batch_4(x, y, y + dim, y + 2 * dim, y + 3 * dim, dim, d0, d1, d2, d3);
+                        knowherefaiss::int8_vec_L2sqr_batch_4(x, y, y + dim, y + 2 * dim, y + 3 * dim, dim, d0, d1, d2, d3);
                     }
                 }
             }
diff --git a/cmake/libs/libfaiss.cmake b/cmake/libs/libfaiss.cmake
index 481d93a7..deeb290e 100644
--- a/cmake/libs/libfaiss.cmake
+++ b/cmake/libs/libfaiss.cmake
@@ -2,7 +2,7 @@ include(CheckCXXCompilerFlag)
 
 knowhere_file_glob(
   GLOB FAISS_SRCS thirdparty/faiss/knowherefaiss/*.cpp
-  thirdparty/faiss/knowherefaiss/impl/*.cpp thirdparty/faiss/faiss/invlists/*.cpp
+  thirdparty/faiss/knowherefaiss/impl/*.cpp thirdparty/faiss/knowherefaiss/invlists/*.cpp
   thirdparty/faiss/knowherefaiss/utils/*.cpp
   thirdparty/faiss/knowherefaiss/cppcontrib/knowhere/*.cpp)
 
-- 
2.45.1.windows.1


From c43d5cdbc0c52c7dc9677249276ca3e9892ccfc1 Mon Sep 17 00:00:00 2001
From: qanly97 <maqianli20@h-partners.com>
Date: Mon, 10 Nov 2025 15:03:12 +0800
Subject: [PATCH 4/7] compile bug fix

---
 CMakeLists.txt | 8 +++++---
 1 file changed, 5 insertions(+), 3 deletions(-)

diff --git a/CMakeLists.txt b/CMakeLists.txt
index c7d4f445..2dd92051 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -132,7 +132,8 @@ if(NOT WITH_LIGHT)
     src/io/*.cc
     src/common/*.cu
     src/index/*.cu
-    src/io/*.cu)
+    src/io/*.cu
+    src/common/ascend/*.cc)
 endif()
 
 if(WITH_LIGHT)
@@ -147,7 +148,8 @@ if(WITH_LIGHT)
     src/index/interrupt.cc
     src/index/sparse/*.cc
     src/io/*.cc
-    src/index/index_factory.cc)
+    src/index/index_factory.cc
+    src/common/ascend/*.cc)
   knowhere_file_glob(GLOB_RECURSE KNOWHERE_TRACER_SRCS src/common/tracer.cc)
   list(REMOVE_ITEM KNOWHERE_SRCS ${KNOWHERE_TRACER_SRCS})
 endif()
@@ -168,7 +170,7 @@ else()
 endif()
 
 knowhere_file_glob(GLOB_RECURSE KNOWHERE_GPU_SRCS src/index/gpu/flat_gpu/*.cc
-                   src/index/gpu/ivf_gpu/*.cc src/common/ascend/*.cc)
+                   src/index/gpu/ivf_gpu/*.cc)
 list(REMOVE_ITEM KNOWHERE_SRCS ${KNOWHERE_GPU_SRCS})
 
 if(NOT WITH_CUVS)
-- 
2.45.1.windows.1


From 7ddc9433cd9d251c066443bdf511c0d145f29d0f Mon Sep 17 00:00:00 2001
From: qanly97 <maqianli20@h-partners.com>
Date: Wed, 12 Nov 2025 15:29:24 +0800
Subject: [PATCH 5/7] =?UTF-8?q?=E4=B8=8D=E4=BD=BF=E7=94=A8=20SVE?=
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

---
 CMakeLists.txt            | 1 +
 cmake/libs/libfaiss.cmake | 2 +-
 2 files changed, 2 insertions(+), 1 deletion(-)

diff --git a/CMakeLists.txt b/CMakeLists.txt
index 2dd92051..3dea7600 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -83,6 +83,7 @@ if(WITH_LIGHT)
   add_definitions(-DKNOWHERE_WITH_LIGHT)
 endif()
 
+add_definitions(-U__ARM_FEATURE_SVE)
 include(cmake/utils/platform_check.cmake)
 include(cmake/utils/compile_flags.cmake)
 include(cmake/libs/libfaiss.cmake)
diff --git a/cmake/libs/libfaiss.cmake b/cmake/libs/libfaiss.cmake
index deeb290e..fe56ab9f 100644
--- a/cmake/libs/libfaiss.cmake
+++ b/cmake/libs/libfaiss.cmake
@@ -56,7 +56,7 @@ endif()
 if(__AARCH64)
 
   set(UTILS_SRC src/simd/distances_ref.cc src/simd/distances_neon.cc)
-  set(UTILS_SVE_SRC src/simd/hook.cc src/simd/distances_sve.cc)
+  set(UTILS_SVE_SRC src/simd/hook.cc)
   set(ALL_UTILS_SRC ${UTILS_SRC} ${UTILS_SVE_SRC})
 
   add_library(
-- 
2.45.1.windows.1


From 81c955773cac0fd7ba10be025f98f5e1bcb50d65 Mon Sep 17 00:00:00 2001
From: qanly97 <maqianli20@h-partners.com>
Date: Thu, 13 Nov 2025 15:10:03 +0800
Subject: [PATCH 6/7] =?UTF-8?q?=E4=BF=AE=E6=94=B9=E5=87=BD=E6=95=B0?=
 =?UTF-8?q?=E7=AD=BE=E5=90=8D=E5=92=8C=E5=8F=98=E9=87=8F=E7=B1=BB=E5=9E=8B?=
 =?UTF-8?q?=EF=BC=8C=E9=80=82=E9=85=8D=20milvus2.5?=
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

---
 src/common/comp/brute_force.cc |  6 ++--
 src/index/ascend/ascendflat.cc | 52 +++++++++++++++++++---------------
 src/index/ascend/flatint8.cc   | 51 ++++++++++++++++++---------------
 3 files changed, 61 insertions(+), 48 deletions(-)

diff --git a/src/common/comp/brute_force.cc b/src/common/comp/brute_force.cc
index 26a13f58..5ea72e10 100644
--- a/src/common/comp/brute_force.cc
+++ b/src/common/comp/brute_force.cc
@@ -305,7 +305,8 @@ BruteForce::SearchWithBuf(const DataSetPtr base_dataset, const DataSetPtr query_
                             return Status::faiss_inner_error;
                         }
                         if (ascend_index_type == "ASCEND_FLAT_INT8") {
-                            ReComputeTopKResult(topk, dim, static_cast<const float*>(xb), cur_query,
+                            auto cur_query_float = (const float*)xq + dim * index;
+                            ReComputeTopKResult(topk, dim, static_cast<const float*>(xb), cur_query_float,
                                                 cur_labels, cur_distances, funcLess);
                         }
                         break;
@@ -339,7 +340,8 @@ BruteForce::SearchWithBuf(const DataSetPtr base_dataset, const DataSetPtr query_
                         }
                         // ascend indexscore
                         if (ascend_index_type == "ASCEND_FLAT_INT8") {
-                            ReComputeTopKResult(topk, dim, static_cast<const float*>(xb), cur_query,
+                            auto cur_query_float = (const float*)xq + dim * index;
+                            ReComputeTopKResult(topk, dim, static_cast<const float*>(xb), cur_query_float,
                                                 cur_labels, cur_distances, funcGreater);
                         }
                         break;
diff --git a/src/index/ascend/ascendflat.cc b/src/index/ascend/ascendflat.cc
index b32a2e70..37d160c1 100644
--- a/src/index/ascend/ascendflat.cc
+++ b/src/index/ascend/ascendflat.cc
@@ -25,7 +25,7 @@
 #include "common/ascend/ascend_utils.h"
 #include "index/ascend/ascendflat_config.h"
 #include "knowhere/comp/thread_pool.h"
-#include "knowhere/factory.h"
+#include "knowhere/index/index_factory.h"
 
 namespace knowhere {
 namespace {
@@ -147,19 +147,19 @@ class AscnedFlatIndexNode : public IndexNode {
     }
 
     Status
-    Build(const DataSet& dataset, const Config& cfg) override {
+    Build(const DataSetPtr dataset, std::shared_ptr<Config> cfg, bool use_knowhere_build_pool = true) override {
         LOG_KNOWHERE_INFO_ << "ascend AscnedFlatIndexNode Build:"
             << std::this_thread::get_id() << " this:" << int64_t(this);
-        auto err = Train(dataset, cfg);
+        auto err = Train(dataset, cfg, use_knowhere_build_pool);
         if (err != Status::success) {
             return err;
         }
-        return Add(dataset, cfg);
+        return Add(dataset, std::move(cfg), use_knowhere_build_pool);
     }
 
     Status
-    Train(const DataSet& dataset, const Config& cfg) override {
-        const AscendFlatConfig& f_cfg = static_cast<const AscendFlatConfig&>(cfg);
+    Train(const DataSetPtr dataset, std::shared_ptr<Config> cfg, bool use_knowhere_build_pool = true) override {
+        const AscendFlatConfig& f_cfg = static_cast<const AscendFlatConfig&>(*cfg);
         faiss::MetricType metric;
         auto err = Str2FaissMetricType(f_cfg.metric_type.value(), metric);
         if (err != Status::success) {
@@ -168,7 +168,7 @@ class AscnedFlatIndexNode : public IndexNode {
         }
         LOG_KNOWHERE_INFO_ << "ascend AscnedFlatIndexNode Train:"
             << std::this_thread::get_id() << " this:" << int64_t(this)
-            << " dim: " << dataset.GetDim() << " metric type: " << f_cfg.metric_type.value();
+            << " dim: " << dataset->GetDim() << " metric type: " << f_cfg.metric_type.value();
 
         try {
             int32_t device_id = 0;
@@ -181,7 +181,7 @@ class AscnedFlatIndexNode : public IndexNode {
             LOG_KNOWHERE_INFO_ << "ascend AscnedFlatIndexNode Train on device:"
                 << device_id << ", thread-" << std::this_thread::get_id() << " this:" << int64_t(this);
             index_ = std::make_unique<faiss::ascend::AscendIndexFlat>(
-                static_cast<int>(dataset.GetDim()), metric, conf);
+                static_cast<int>(dataset->GetDim()), metric, conf);
         } catch (const std::exception& e) {
             LOG_KNOWHERE_ERROR_ << "error create ascend index, " << e.what();
             return Status::ascend_inner_error;
@@ -191,9 +191,9 @@ class AscnedFlatIndexNode : public IndexNode {
     }
 
     Status
-    Add(const DataSet& dataset, const Config& cfg) override {
-        auto x = dataset.GetTensor();
-        auto n = dataset.GetRows();
+    Add(const DataSetPtr dataset, std::shared_ptr<Config> cfg, bool use_knowhere_build_pool = true) override {
+        auto x = dataset->GetTensor();
+        auto n = dataset->GetRows();
         LOG_KNOWHERE_INFO_ << "ascend AscnedFlatIndexNode Add:"
             << std::this_thread::get_id() << " this:" << int64_t(this) << " n:" << n;
 
@@ -215,17 +215,17 @@ class AscnedFlatIndexNode : public IndexNode {
     }
 
     expected<DataSetPtr>
-    Search(const DataSet& dataset, const Config& cfg, const BitsetView& bitset) const override {
+    Search(const DataSetPtr dataset, std::unique_ptr<Config> cfg, const BitsetView& bitset) const override {
         if (index_ == nullptr) {
             LOG_KNOWHERE_ERROR_ << "search on empty index";
             expected<DataSetPtr>::Err(Status::empty_index, "index not loaded");
         }
 
         DataSetPtr results = std::make_shared<DataSet>();
-        const AscendFlatConfig& f_cfg = static_cast<const AscendFlatConfig&>(cfg);
+        const AscendFlatConfig& f_cfg = static_cast<const AscendFlatConfig&>(*cfg);
         auto k = f_cfg.k.value();
-        auto nq = dataset.GetRows();
-        auto x = dataset.GetTensor();
+        auto nq = dataset->GetRows();
+        auto x = dataset->GetTensor();
 
         auto len = k * nq;
         int64_t* ids = nullptr;
@@ -275,13 +275,13 @@ class AscnedFlatIndexNode : public IndexNode {
     }
 
     expected<DataSetPtr>
-    RangeSearch(const DataSet& dataset, const Config& cfg, const BitsetView& bitset) const override {
+    RangeSearch(const DataSetPtr dataset, std::unique_ptr<Config> cfg, const BitsetView& bitset) const override {
         LOG_KNOWHERE_ERROR_ << "ascend AscnedFlatIndexNode RangeSearch not implemented";
         return expected<DataSetPtr>::Err(Status::not_implemented, "RangeSearch not implemented");
     }
 
     expected<DataSetPtr>
-    GetVectorByIds(const DataSet& dataset) const override {
+    GetVectorByIds(const DataSetPtr dataset) const override {
         LOG_KNOWHERE_ERROR_ << "ascend AscnedFlatIndexNode GetVectorByIds not implemented";
         return expected<DataSetPtr>::Err(Status::not_implemented, "GetVectorByIds not implemented");
     }
@@ -293,7 +293,7 @@ class AscnedFlatIndexNode : public IndexNode {
     }
 
     expected<DataSetPtr>
-    GetIndexMeta(const Config& cfg) const override {
+    GetIndexMeta(std::unique_ptr<Config> cfg) const override {
         LOG_KNOWHERE_ERROR_ << "ascend AscnedFlatIndexNode GetIndexMeta not implemented";
         return expected<DataSetPtr>::Err(Status::not_implemented, "GetIndexMeta not implemented");
     }
@@ -326,7 +326,7 @@ class AscnedFlatIndexNode : public IndexNode {
     }
 
     Status
-    Deserialize(const BinarySet& binset, const Config& config) override {
+    Deserialize(const BinarySet& binset, std::shared_ptr<Config> config) override {
         std::string name = Type();
         auto binary = binset.GetByName(name);
         MyMemoryIOReader reader;
@@ -361,7 +361,7 @@ class AscnedFlatIndexNode : public IndexNode {
     }
 
     Status
-    DeserializeFromFile(const std::string& filename, const Config& config) override {
+    DeserializeFromFile(const std::string& filename, std::shared_ptr<Config> config) override {
         LOG_KNOWHERE_ERROR_ << "ascend AscnedFlatIndexNode DeserializeFromFile not implemented";
         return Status::not_implemented;
     }
@@ -444,8 +444,14 @@ class AscnedFlatIndexNode : public IndexNode {
     size_t load_ = 0;
 };
 
-KNOWHERE_REGISTER_GLOBAL(ASCEND_FLAT, [](const int32_t& version, const Object& object) { 
-    return Index<AscnedFlatIndexNode>::Create(version, object);
-});
+KNOWHERE_REGISTER_GLOBAL(
+    ASCEND_FLAT,
+    [](const int32_t& version, const Object& object) { 
+        return Index<AscnedFlatIndexNode>::Create(version, object);
+    },
+    fp32,
+    typeCheck<fp32>(knowhere::feature::FLOAT32),
+    knowhere::feature::FLOAT32
+);
 
 }  // namespace knowhere
diff --git a/src/index/ascend/flatint8.cc b/src/index/ascend/flatint8.cc
index c5239435..d60bd2ca 100644
--- a/src/index/ascend/flatint8.cc
+++ b/src/index/ascend/flatint8.cc
@@ -25,7 +25,7 @@
 #include "common/ascend/ascend_utils.h"
 #include "index/ascend/flatint8_config.h"
 #include "knowhere/comp/thread_pool.h"
-#include "knowhere/factory.h"
+#include "knowhere/index/index_factory.h"
 
 namespace knowhere {
 namespace {
@@ -147,20 +147,20 @@ class FlatInt8IndexNode : public IndexNode {
     }
 
     Status
-    Build(const DataSet& dataset, const Config& cfg) override {
+    Build(const DataSetPtr dataset, std::shared_ptr<Config> cfg, bool use_knowhere_build_pool = true) override {
         LOG_KNOWHERE_INFO_ << "ascend FlatInt8IndexNode Build:"
             << std::this_thread::get_id() << " this:" << int64_t(this);
-        auto err = Train(dataset, cfg);
+        auto err = Train(dataset, cfg, use_knowhere_build_pool);
         if (err != Status::success) {
             return err;
         }
-        return Add(dataset, cfg);
+        return Add(dataset, std::move(cfg), use_knowhere_build_pool);
     }
 
     Status
-    Train(const DataSet& dataset, const Config& cfg) override {
-        const FlatInt8Config& f_cfg = static_cast<const FlatInt8Config&>(cfg);
-        DataSet& newdataset = const_cast<DataSet&>(dataset);
+    Train(const DataSetPtr dataset, std::shared_ptr<Config> cfg, bool use_knowhere_build_pool = true) override {
+        const FlatInt8Config& f_cfg = static_cast<const FlatInt8Config&>(*cfg);
+        DataSet& newdataset = const_cast<DataSet&>(*dataset);
         newdataset.SetAscendIndexType(ascend_index_type);
         faiss::MetricType metric;
         auto err = Str2FaissMetricType(f_cfg.metric_type.value(), metric);
@@ -193,9 +193,9 @@ class FlatInt8IndexNode : public IndexNode {
     }
 
     Status
-    Add(const DataSet& dataset, const Config& cfg) override {
-        auto x = dataset.GetTensor();
-        auto n = dataset.GetRows();
+    Add(const DataSetPtr dataset, std::shared_ptr<Config> cfg, bool use_knowhere_build_pool = true) override {
+        auto x = dataset->GetTensor();
+        auto n = dataset->GetRows();
         LOG_KNOWHERE_INFO_ << "ascend FlatInt8IndexNode Add:"
             << std::this_thread::get_id() << " this:" << int64_t(this) << " n:" << n;
 
@@ -217,17 +217,17 @@ class FlatInt8IndexNode : public IndexNode {
     }
 
     expected<DataSetPtr>
-    Search(const DataSet& dataset, const Config& cfg, const BitsetView& bitset) const override {
+    Search(const DataSetPtr dataset, std::unique_ptr<Config> cfg, const BitsetView& bitset) const override {
         if (index_ == nullptr) {
             LOG_KNOWHERE_ERROR_ << "search on empty index";
             expected<DataSetPtr>::Err(Status::empty_index, "index not loaded");
         }
 
         DataSetPtr results = std::make_shared<DataSet>();
-        const FlatInt8Config& f_cfg = static_cast<const FlatInt8Config&>(cfg);
+        const FlatInt8Config& f_cfg = static_cast<const FlatInt8Config&>(*cfg);
         auto k = f_cfg.k.value();
-        auto nq = dataset.GetRows();
-        auto x = dataset.GetTensor();
+        auto nq = dataset->GetRows();
+        auto x = dataset->GetTensor();
 
         auto len = k * nq;
         int64_t* ids = nullptr;
@@ -276,13 +276,13 @@ class FlatInt8IndexNode : public IndexNode {
     }
 
     expected<DataSetPtr>
-    RangeSearch(const DataSet& dataset, const Config& cfg, const BitsetView& bitset) const override {
+    RangeSearch(const DataSetPtr dataset, std::unique_ptr<Config> cfg, const BitsetView& bitset) const override {
         LOG_KNOWHERE_ERROR_ << "ascend FlatInt8IndexNode RangeSearch not implemented";
         return expected<DataSetPtr>::Err(Status::not_implemented, "RangeSearch not implemented");
     }
 
     expected<DataSetPtr>
-    GetVectorByIds(const DataSet& dataset) const override {
+    GetVectorByIds(const DataSetPtr dataset) const override {
         LOG_KNOWHERE_ERROR_ << "ascend FlatInt8IndexNode GetVectorByIds not implemented";
         return expected<DataSetPtr>::Err(Status::not_implemented, "GetVectorByIds not implemented");
     }
@@ -294,7 +294,7 @@ class FlatInt8IndexNode : public IndexNode {
     }
 
     expected<DataSetPtr>
-    GetIndexMeta(const Config& cfg) const override {
+    GetIndexMeta(std::unique_ptr<Config> cfg) const override {
         LOG_KNOWHERE_ERROR_ << "ascend FlatInt8IndexNode GetIndexMeta not implemented";
         return expected<DataSetPtr>::Err(Status::not_implemented, "GetIndexMeta not implemented");
     }
@@ -327,7 +327,7 @@ class FlatInt8IndexNode : public IndexNode {
     }
 
     Status
-    Deserialize(const BinarySet& binset, const Config& config) override {
+    Deserialize(const BinarySet& binset, std::shared_ptr<Config> config) override {
         std::string name = Type();
         auto binary = binset.GetByName(name);
         MyMemoryIOReader reader;
@@ -362,7 +362,7 @@ class FlatInt8IndexNode : public IndexNode {
     }
 
     Status
-    DeserializeFromFile(const std::string& filename, const Config& config) override {
+    DeserializeFromFile(const std::string& filename, std::shared_ptr<Config> config) override {
         LOG_KNOWHERE_ERROR_ << "ascend FlatInt8IndexNode DeserializeFromFile not implemented";
         return Status::not_implemented;
     }
@@ -448,9 +448,14 @@ class FlatInt8IndexNode : public IndexNode {
     size_t load_ = 0;
 };
 
-KNOWHERE_REGISTER_GLOBAL(ASCEND_FLAT_INT8,
-                         [](const int32_t& version, const Object& object) { 
-    return Index<FlatInt8IndexNode>::Create(version, object);
-});
+KNOWHERE_REGISTER_GLOBAL(
+    ASCEND_FLAT_INT8,
+    [](const int32_t& version, const Object& object) {
+        return Index<FlatInt8IndexNode>::Create(version, object);
+    },
+    int8,
+    typeCheck<int8>(knowhere::feature::INT8),
+    knowhere::feature::INT8
+);
 
 }  // namespace knowhere
-- 
2.45.1.windows.1


From 261e710b0dbf413ae11a3c0ddc8f4f991c302ae7 Mon Sep 17 00:00:00 2001
From: m30074752 <maqianli20@h-partners.com>
Date: Wed, 26 Nov 2025 09:58:12 +0800
Subject: [PATCH 7/7] =?UTF-8?q?=E5=A2=9E=E5=8A=A0=20ascend=20=E6=A3=80?=
 =?UTF-8?q?=E7=B4=A2=E7=B1=BB=E5=9E=8B=E6=B3=A8=E5=86=8C=E9=80=BB=E8=BE=91?=
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

---
 include/knowhere/index/index_table.h | 5 +++++
 src/index/ascend/flatint8.cc         | 6 +++---
 2 files changed, 8 insertions(+), 3 deletions(-)

diff --git a/include/knowhere/index/index_table.h b/include/knowhere/index/index_table.h
index fdce22a7..0470928b 100644
--- a/include/knowhere/index/index_table.h
+++ b/include/knowhere/index/index_table.h
@@ -107,6 +107,11 @@ static std::set<std::pair<std::string, VecType>> legal_knowhere_index = {
     {IndexEnum::INDEX_SPARSE_WAND, VecType::VECTOR_SPARSE_FLOAT},
     //  minhash index
     {IndexEnum::INDEX_MINHASH_LSH, VecType::VECTOR_BINARY},
+
+    // ascend index
+    {IndexEnum::INDEX_ASCEND_FLAT, VecType::VECTOR_FLOAT},
+    {IndexEnum::INDEX_ASCEND_FLAT_INT8, VecType::VECTOR_FLOAT},
+    {IndexEnum::INDEX_ASCEND_FLAT_INT8, VecType::VECTOR_INT8},
 };
 
 static std::set<std::string> legal_support_mmap_knowhere_index = {
diff --git a/src/index/ascend/flatint8.cc b/src/index/ascend/flatint8.cc
index d60bd2ca..4f35bbdf 100644
--- a/src/index/ascend/flatint8.cc
+++ b/src/index/ascend/flatint8.cc
@@ -453,9 +453,9 @@ KNOWHERE_REGISTER_GLOBAL(
     [](const int32_t& version, const Object& object) {
         return Index<FlatInt8IndexNode>::Create(version, object);
     },
-    int8,
-    typeCheck<int8>(knowhere::feature::INT8),
-    knowhere::feature::INT8
+    fp32,
+    typeCheck<fp32>(knowhere::feature::FLOAT32),
+    knowhere::feature::FLOAT32
 );
 
 }  // namespace knowhere
-- 
2.45.1.windows.1

